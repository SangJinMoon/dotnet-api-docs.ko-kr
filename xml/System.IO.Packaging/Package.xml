<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e633ba759596ecfd98d51e13ceacad970601b282" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37759520" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a container that can store multiple data objects.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> 단일 엔터티로 이식성과 효율적인 액세스에 대 한 실제 정의 된 형식의 개체를 구성 하는 추상 클래스입니다.  
  
 ZIP 파일은 기본 실제 형식에 대 한는 <xref:System.IO.Packaging.Package>합니다.  다른 <xref:System.IO.Packaging.Package> 구현 XML 문서, 데이터베이스 등의 다른 실제 형식을 사용 하 여 또는 웹 서비스 수 있습니다.  
  
 같은 파일 시스템에 포함 된 항목을 <xref:System.IO.Packaging.Package> 파일과 폴더의 계층 구조에서 참조 됩니다.  
  
 하지만 <xref:System.IO.Packaging.Package> 자체는 추상 클래스는 <xref:System.IO.Packaging.ZipPackage> 파생된 클래스에서 기본적으로 사용 됩니다는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 A <xref:System.IO.Packaging.PackagePart> ("파트")에 저장 된 개체를 나타내는 추상 클래스는를 <xref:System.IO.Packaging.Package>입니다.  
  
 A <xref:System.IO.Packaging.PackageRelationship> ("관계")을 원본 간의 연결을 정의 <xref:System.IO.Packaging.Package> 또는 <xref:System.IO.Packaging.PackagePart> 와 대상 개체입니다.  <xref:System.IO.Packaging.PackageRelationship> 두 가지 형식 중 하나일 수 있습니다 각 두 형식 중 하나일 수 있습니다.  
  
-   패키지 수준 관계를 (만든 합니다 <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> 메서드) 연결을 <xref:System.IO.Packaging.Package> 를:  
  
    -   패키지의 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
-   파트 수준 관계 (만든 합니다 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> 메서드) 원본 관련 <xref:System.IO.Packaging.PackagePart> 에:  
  
    -   패키지의 다른 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
 관계의 원본 <xref:System.IO.Packaging.Package> 또는 원본 <xref:System.IO.Packaging.PackagePart> 관계의 "소유자"로 간주 됩니다.  원본 개체를 삭제 하는 경우 원본 개체를 소유한 모든 관계도 삭제 됩니다.  만들기 또는 관계를 삭제 하면 프로세스는 어떤 방식으로 원본 또는 대상 개체를 물리적으로 변경 되지 않습니다.  
  
 A <xref:System.IO.Packaging.PackageDigitalSignature> ("디지털 시그니처")가 파트 및 관계에 포함 된 디지털 서명을 나타내는 결합을 <xref:System.IO.Packaging.Package>입니다.  디지털 서명은 송신자를 식별 하 고 서명 된 파트 및 관계에 포함 되도록의 유효성을 검사 합니다 <xref:System.IO.Packaging.Package> 수정 되지 않은 합니다.  
  
 패키지에도 관리 DRM (디지털 권한)의 콘텐츠 요소는 지원를 <xref:System.IO.Packaging.Package> 권한 있는 사용자에 게 부여 하는 특정 액세스 권한을 사용 하 여 암호화 되도록 합니다.  
  
 기반으로 합니다 <xref:System.IO.Packaging.Package> 아키텍처는 <xref:System.Windows.Xps.Packaging.XpsDocument> 열기를 기반으로 문서를 저장 하기 위한 패키지 형식인 [사양 XPS (XML Paper)](http://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework에서는 패키지 콘텐츠, 리소스 및 페이지 및 기본적으로 표준 ZIP 파일을 사용 하 여 문서에 대 한 관계를 저장 합니다. 모든 ZIP 파일을 사용 하 여 응용 프로그램 사용할 수는 <xref:System.IO.Packaging> 저장 하 고 필요에 따라 액세스를 효율적으로 하나의 컨테이너에 데이터 파일의 여러 또는 모든 형식을 보호 하는 클래스입니다.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 만드는 기본 단계는 <xref:System.IO.Packaging.Package>합니다.  이 예제에서는 문서의 일부로 표시 되는 그래픽 이미지와 함께 문서를 포함 하는 패키지가 만들어집니다.  (이 HTML 파일에 지정 된 경우 비슷합니다는 \<i m G > 외부 이미지 파일을 참조 하는 태그입니다.)  두 <xref:System.IO.Packaging.PackageRelationship> 요소 패키지에도 포함 됩니다.  첫 번째 "패키지 수준" 관계를 패키지의 루트 요소로 문서 파트를 정의합니다.  두 번째, "파트 수준" 관계 문서 파트 (파트 수준 관계의 "원본") 및 이미지 파트 (파트 수준 관계의 "대상")의 사용 간의 연결을 정의 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 protected 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <param name="streaming">
          <see langword="true" /> to open the package for streaming; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" /> and streaming option.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 protected 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves and closes the package plus all underlying part streams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Close%2A> 하 고 <xref:System.IO.Packaging.Package.Dispose%2A> 동일한 작업을 수행-호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대로 합니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
> [!NOTE]
>  `using` 문 (다릅니다 합니다 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다.  [패키지 예제 추가 정보를 작성](http://go.microsoft.com/fwlink/?LinkID=160055) 및 [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여는 `using` 문.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new package part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 파트에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 파트와 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 실제로 파트를 만드는 메서드를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <summary>Creates a new uncompressed part with a given URI and content type.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 파트에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 파트와 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 파트 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 는 <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>합니다.  
  
 패키지 파트에 대 한 자세한 내용은 1.1 OPC Open Packaging Conventions () 사양의 섹션 다운로드할 수 있는 참조 하세요 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 실제로 파트를 만드는 메서드를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> or <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> compression.</param>
        <summary>Creates a new part with a given URI, content type, and compression option.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePart%2A> 메서드는 지원 두 `compressionOption` 값을 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 의 값 <xref:System.IO.Packaging.CompressionOption.Maximum>를 <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 하 여 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 만듭니다 <xref:System.IO.Stream> 새 파트에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 파트와 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="compressionOption" /> value is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 실제로 파트를 만드는 메서드를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] for the part being created.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream.</param>
        <summary>When overridden in a derived class, creates a new part in the package.</summary>
        <returns>The created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드를 호출 합니다 <xref:System.IO.Packaging.Package.CreatePart%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 파트를 만드는 방법.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.CreatePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에 새 파트를 만드는 클래스입니다.  
  
 기본 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드는 지원 두 `compressionOption` 값을 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 의 값 <xref:System.IO.Packaging.CompressionOption.Maximum>를 <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 하 여 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a package-level relationship to a given part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간의 <xref:System.IO.Packaging.Package> 대상 <xref:System.IO.Packaging.PackagePart> 패키지에 포함 합니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트 또는 어떤 방식으로 리소스 만들기 또는 관계를 삭제 프로세스를 물리적으로 변경 되지 않습니다.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 및 루트 문서 파트입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, and relationship type.</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 실제로 변경 하지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스입니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 으로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 여야 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI로 시작 하는 슬래시 ("/") 문자 같은 중 하나는 절대 경로 수 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")에서 기본 URI로 확인 하는 합니다.  
  
 하는 경우 `targetMode` 로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 하거나 절대 또는 상대 URI에 따라 구성 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  "http://www.microsoft.com/page2.xml"은 "page2.xml" 외부 대상 리소스를 참조 하는 절대 URI의 예입니다.  "images/picture1.jpg"은 예를 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해 참조 되는 상대 URI입니다.  
  
 `relationshipType` 이어야 합니다는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형성 된 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` OPC Open Packaging Conventions () 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/코어-속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 패키징 및 패키지 관계에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려면를 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 및 루트 문서 파트입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <param name="id">A unique XML identifier.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, relationship type, and [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 실제로 변경 하지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스입니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 `id` 올바른 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며 XML Schema Part 2에 설명 된 명명 규칙을 준수 해야 합니다: 데이터 형식 지정 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 하는 경우 `id` 으로 지정 된 `null` 고유 ID가 자동으로 생성 됩니다.  `id` 빈으로 지정 된 문자열이 올바르지 않습니다.  
  
 경우 `targetMode` 으로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 여야 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI로 시작 하는 슬래시 ("/") 문자 같은 중 하나는 절대 경로 수 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")에서 기본 URI로 확인 하는 합니다.  
  
 하는 경우 `targetMode` 로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 하거나 절대 또는 상대 URI에 따라 구성 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  "http://www.microsoft.com/page2.xml"은 "page2.xml" 외부 대상 리소스를 참조 하는 절대 URI의 예입니다.  "images/picture1.jpg"은 예를 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해 참조 되는 상대 URI입니다.  
  
 `relationshipType` 에 따라 구성 되는 URI 여야 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` OPC Open Packaging Conventions () 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/코어-속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3을 참조 하세요 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려면를 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 및 루트 문서 파트입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier; or a part with the specified <paramref name="id" /> already occurs in the package.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the part to delete.</param>
        <summary>Deletes a part with a given URI from the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 ("/") 문자로 시작 되는 절대 경로로 구성 된 상대 URI 여야 합니다.  패키지 루트에 상대적인 이며에 따라 형식이 절대 경로 [RFC 3986](http://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  "/ page1.xaml" 및 "/ images/picture4.jpg"은 유효한 파트 Uri의 예입니다.  
  
 예외가 발생 하는 경우 지정 된 일부 `partUri` 패키지가 아닙니다.  (사용할 수는 <xref:System.IO.Packaging.Package.PartExists%2A> 하는지 여부 지정된 된 부분을 결정 하는 방법 `partUri` 패키지에 있습니다.)  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 파트를 삭제 하는 방법입니다.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="P:System.IO.Packaging.PackagePart.Uri" /> of the <see cref="T:System.IO.Packaging.PackagePart" /> to delete.</param>
        <summary>When overridden in a derived class, deletes a part with a given URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.DeletePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.DeletePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> 실제 수행 하는 클래스 파생된 클래스에서 구현 된 실제 형식에 따라 작업을 삭제 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 구현을 호출 합니다 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 메서드는 지정 된 파트를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.  파생 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the <see cref="T:System.IO.Packaging.PackageRelationship" /> to delete.</param>
        <summary>Deletes a package-level relationship.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 예외가 발생 하는 경우 지정 된 관계 `id` 패키지가 아닙니다.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> 실제로 어떤 방식으로든에서 대상 파트를 변경 하지 않습니다.  
  
 패키지 관계에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Flushes and saves the content of all parts and relationships, closes the package, and releases all resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 변경 내용이 올바르게 저장는 되도록 <xref:System.IO.Packaging.Package.Dispose%2A> 도 종료, 플러시, 및 모든 파트 및 패키지에 포함 된 관계를 닫습니다.  
  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Dispose%2A> 하 고 <xref:System.IO.Packaging.Package.Close%2A> 같은 작업을 수행할-호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대로 합니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
 할당 및 메모리 내 리소스를 관리 하는 파생된 클래스에서 리소스를 해제 하려면이 메서드를 재정의 하는 경우 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 합니다. 파생 클래스 재정의 호출 해야 <xref:System.IO.Packaging.Package.Flush%2A> 기본 클래스 및 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드는 항상 해당 기본 클래스 정리를 수행 해야 합니다.  
  
> [!NOTE]
>  `using` 문 (다릅니다 합니다 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다. [패키지 예제 추가 정보를 작성](http://go.microsoft.com/fwlink/?LinkID=160055) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여 줍니다는 `using` 문입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the file access setting for the package.</summary>
        <value>중 하나는 <see cref="T:System.IO.FileAccess" /> 값: <see cref="F:System.IO.FileAccess.Read" />를 <see cref="F:System.IO.FileAccess.Write" />, 또는 <see cref="F:System.IO.FileAccess.ReadWrite" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FileOpenAccess%2A> 속성에는 기본값이 없습니다.  에 지정 된 파일 액세스 설정을 <xref:System.IO.Packaging.Package.%23ctor%2A> 새 패키지를 만들 때 또는 생성자 호출을 <xref:System.IO.Packaging.Package.Open%2A> 기존 패키지를 열 때 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves the contents of all parts and relationships that are contained in the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스의 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> 실제 형식에 따른 플러시 작업을 수행 하려면 구현 합니다.  파생된 클래스의 <xref:System.IO.Packaging.Package.FlushCore%2A> 메서드는 실제로 특정 파생된 클래스에서 실제 구현에 파트 및 관계 콘텐츠를 저장 하는 일을 담당 합니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다. 기본 작업에 <xref:System.IO.Packaging.Package.Flush%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> ZIP 파일 패키지에 파트 및 관계를 저장 합니다.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> 자동으로 호출 되는 <xref:System.IO.Packaging.Package.Close%2A> 고 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드.  때 <xref:System.IO.Packaging.Package.Close%2A> 나 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Flush%2A> 개별적으로 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only and cannot be modified.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 파트를 플러시합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, saves the content of all parts and relationships to the derived class store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> 호출한는 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 실제 플러시 작업을 수행 하는 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 구현에는 주문 또는 수행한 작업에 대 한 어떠한가 정도 사용 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.Flush" /> 메서드를 호출 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to return.</param>
        <summary>Returns the part with a given URI.</summary>
        <returns>The part with the specified <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> 없으면 지정 된 일부 예외가 `partUri` 존재 하지 않습니다.  
  
 합니다 <xref:System.IO.Packaging.Package.PartExists%2A> 메서드를 결정할 수 있는지 여부를 `partUri` 기존 파트를 참조 합니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 요청 된 일부를 반환 하는 클래스입니다.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 찾기, 검색 및 패키지에 포함 된 부분을 읽는 방법을 보여 줍니다.  전체 샘플을 참조 하세요 [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 파트를 플러시합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to retrieve.</param>
        <summary>When overridden in a derived class, returns the part addressed by a given URI.</summary>
        <returns>The requested part; or <see langword="null" />, if a part with the specified <paramref name="partUri" /> is not in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 파트를 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 구현을 호출 합니다 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 액세스 하 고 지정 된 부분을 반환 합니다.  파생 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the parts in the package.</summary>
        <returns>A collection of all the <see cref="T:System.IO.Packaging.PackagePart" /> elements that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> 포함 하는 패키지에 포함 된 모든 파트의 컬렉션을 반환 <xref:System.IO.Packaging.PackageRelationship> 부분입니다.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> 반환 하지 것입니다 `null`있지만 반환된 된 컬렉션 패키지 파트가 없는 경우 요소가 포함 됩니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetParts%2A> 호출을 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 메서드는 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 부분을 반환 하는 클래스입니다.  
  
 패키지와 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 합니다 <xref:System.IO.Packaging.Package.GetParts%2A> 에 포함 된 파트의 컬렉션을 가져옵니다 메서드를 <xref:System.IO.Packaging.Package>입니다.  완성 된 프로그램 소스 코드를 참조 하세요 [디지털 서명 샘플을 사용 하 여 패키지를 만드는](http://go.microsoft.com/fwlink/?LinkID=159966)합니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 파트를 플러시합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns an array of all the parts in the package.</summary>
        <returns>An array of all the parts that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 구현을 호출 합니다 <xref:System.IO.Packaging.Package.GetParts%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 액세스 하 고 파트의 배열을 반환 합니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetParts%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 파트를 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.GetParts" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to return.</param>
        <summary>Returns the package-level relationship with a given identifier.</summary>
        <returns>The package-level relationship with the specified <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 올바른 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며 XML Schema Part 2에 설명 된 명명 규칙을 준수 해야 합니다: 데이터 형식 지정 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3을 참조 하세요 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.InvalidOperationException">A relationship with the specified <paramref name="id" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the package-level relationships.</summary>
        <returns>A collection of all the package-level relationships that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 반환 하지 것입니다 `null`그러나 반환된 된 컬렉션 패키지에 패키지 수준 관계가 없는 경우 요소가 포함 될 수 있습니다.  
  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트 또는 어떤 방식으로 리소스 만들기 또는 관계를 삭제 프로세스를 물리적으로 변경 되지 않습니다.  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3을 참조 하세요 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">The <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> to match and return in the collection.</param>
        <summary>Returns a collection of all the package-level relationships that match a given <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>A collection of package-level relationships that match the specified <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 반환 하지 것입니다 `null`그러나 반환 된 컬렉션에 지정 된 일치 하는 패키지 수준 관계가 없는 경우 요소가 포함 될 수 있습니다 `relationshipType`합니다.  
  
 다음 표에서 패키지 수준 `relationshipType` OPC Open Packaging Conventions () 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/코어-속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 패키지에 대해 정의 된 관계를 검색 하는 방법을 보여 줍니다.  전체 샘플을 참조 하세요 [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> is an empty string.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <summary>Opens a package on a given IO stream.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <summary>Opens a package at a given path and file name.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 사용 하 여 패키지를 엽니다 <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, 및 <xref:System.IO.FileShare.None> (되도록 서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나).  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package with a given IO stream and file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> value is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이렇게 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 사용 하 여 패키지를 엽니다 <xref:System.IO.FileAccess.ReadWrite> 및 <xref:System.IO.FileShare.None> (서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나를 지정) 하 합니다.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package with a given IO stream, file mode, and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본값을 사용 하 여 패키지를 엽니다 <xref:System.IO.FileShare.None> 특성 (다른 특성 사용법을 지정 하는 <xref:System.IO.Packaging.Package.Open%2A> 메서드 오버 로드).  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 열고 읽는 방법을 <xref:System.IO.Packaging.Package> 포함 된 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <param name="packageShare">The file sharing mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode, file access, and file share setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" />, <paramref name="packageAccess" />, or <paramref name="packageShare" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the core properties of the package.</summary>
        <value>패키지의 핵심 속성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핵심 패키지 속성에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양 단원 3.1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="T:System.Uri" /> of the part to check for.</param>
        <summary>Indicates whether a part with a given URI is in the package.</summary>
        <returns>
          <see langword="true" /> if a part with the specified <paramref name="partUri" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 문자로 시작 해야 "/" 및 패키지의 루트에서 절대 경로 여야 합니다.  
  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only (information cannot be read).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to check for.</param>
        <summary>Indicates whether a package-level relationship with a given ID is contained in the package.</summary>
        <returns>
          <see langword="true" /> if a package-level relationship with the specified <paramref name="id" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended for application use.  Use the type-safe <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> method instead.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>