<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="26e89d81152bf959a5f5d5e7816e69f656353584" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683148" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>여러 데이터 개체를 저장할 수 있는 컨테이너를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> 개체의 이식성 및 효율적인 액세스에 대 한 정의 된 실제 형식 단일 엔터티를 구성 하는 데 사용할 수 있는 추상 클래스가입니다.  
  
 ZIP 파일은 기본 실제 형식에 대 한는 <xref:System.IO.Packaging.Package>합니다.  다른 <xref:System.IO.Packaging.Package> 구현 수 있는 XML 문서를 데이터베이스와 같은 다른 물리적 형식을 사용 하 여 또는 웹 서비스입니다.  
  
 같은 파일 시스템에 포함 된 항목은 <xref:System.IO.Packaging.Package> 파일과 폴더의 계층적 구성에서 참조 됩니다.  
  
 하지만 <xref:System.IO.Packaging.Package> 자체 클래스는 추상 클래스는 <xref:System.IO.Packaging.ZipPackage> 파생된 클래스에서 기본적으로 사용 됩니다는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 A <xref:System.IO.Packaging.PackagePart> ("파트")에 저장 된 개체를 나타내는 추상 클래스는는 <xref:System.IO.Packaging.Package>합니다.  
  
 A <xref:System.IO.Packaging.PackageRelationship> ("관계")을 원본 간의 연결을 정의 <xref:System.IO.Packaging.Package> 또는 <xref:System.IO.Packaging.PackagePart> 와 대상 개체입니다.  A <xref:System.IO.Packaging.PackageRelationship> 두 형식 중 하나일 수 있으며 각 두 형식 중 하나일 수 있습니다.  
  
-   패키지 수준 관계 (에서 만든는 <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> 메서드)와 관련 한 <xref:System.IO.Packaging.Package> 로:  
  
    -   패키지의 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
-   파트 수준 관계 (에서 만든는 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> 메서드)는 소스와 관련 된 <xref:System.IO.Packaging.PackagePart> 로:  
  
    -   패키지의 다른 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
 관계의 소스 <xref:System.IO.Packaging.Package> 또는 소스 <xref:System.IO.Packaging.PackagePart> 관계의 "소유자"로 간주 됩니다.  소스 개체가 삭제 된 원본 개체가 소유 하는 모든 관계가 삭제 됩니다.  만들기 또는 관계를 삭제 하는 과정은 어떤 방식으로든에서 원본 또는 대상 개체를 물리적으로 변경 되지 않습니다.  
  
 A <xref:System.IO.Packaging.PackageDigitalSignature> ("디지털 서명")에 포함 된 디지털 서명이 나타내는 관계와 파트의 컴퍼지션은는 <xref:System.IO.Packaging.Package>합니다.  디지털 서명은 출처를 식별 하 고 서명 된 파트 및 관계에 포함 하는 유효성을 검사는 <xref:System.IO.Packaging.Package> 수정 되지 않은 합니다.  
  
 패키지에는 또한 관리 DRM (디지털 권한)의 콘텐츠 요소는 지원는 <xref:System.IO.Packaging.Package> 권한 있는 사용자에 게 부여 하는 특정 액세스 권한을 가진 암호화 되도록 합니다.  
  
 에 따라는 <xref:System.IO.Packaging.Package> 아키텍처는 <xref:System.Windows.Xps.Packaging.XpsDocument> 열기에 따라 문서를 저장 하기 위한 패키지 형식이 [XPS XML Paper Specification ()](http://go.microsoft.com/fwlink/?LinkID=65761)합니다.  
  
 .NET Framework에서는 패키지를 콘텐츠, 리소스 및 페이지와 기본적으로 표준 ZIP 파일을 사용 하 여 문서에 대 한 관계를 저장 합니다. 다른 ZIP 파일과 응용 프로그램 사용 하 여 수는 <xref:System.IO.Packaging> 클래스를 저장 하 고 필요에 따라에 임의의 유형 또는 단일 효율적으로 액세스 컨테이너의 데이터 파일 수를 보호 합니다.  
  
 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 만드는 기본 단계는 <xref:System.IO.Packaging.Package>합니다.  이 예제에서는 문서의 일부로 표시 되는 그래픽 이미지와 함께 문서를 포함 하는 패키지가 생성 됩니다.  (이 HTML 파일에 있는 경우와 비슷하며는 \<IMG > 외부 이미지 파일을 참조 하는 태그입니다.)  두 개의 <xref:System.IO.Packaging.PackageRelationship> 요소 패키지에 포함 됩니다.  첫 번째, "패키지 수준" 관계는 패키지의 루트 요소와 문서 부분을 정의합니다.  두 번째, "파트 수준" 관계 이미지 파트 (파트 수준 관계의 "대상")를 사용 하는 문서 파트 (파트 수준 관계의 "원본")와 연결을 정의합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.IO.Packaging.Package" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">패키지의 파일 IO 권한입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Packaging.Package" />를 사용하는 <see cref="T:System.IO.FileAccess" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 보호 된 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="openFileAccess" />의 값이 올바르지 않은 경우</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">패키지의 파일 IO 권한입니다.</param>
        <param name="streaming">
          스트리밍을 위해 패키지를 여는 경우 <see langword="true" />, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Packaging.Package" /> 및 스트리밍 옵션을 사용하는 <see cref="T:System.IO.FileAccess" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 보호 된 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="openFileAccess" />의 값이 올바르지 않은 경우</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>패키지 및 모든 내부 파트 스트림을 저장하고 닫습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 동일한 작업을 수행-호출 하는 이유가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대입니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
> [!NOTE]
>  `using` 문 (다른는 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다.  [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055) 및 [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여는 `using` 문.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 패키지 파트를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 부분에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 부분과 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 패키지 파트에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.1을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 부분을 만들려면 방법을 합니다.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">새 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="contentType">데이터 스트림의 콘텐츠 형식입니다.</param>
        <summary>지정된 URI 및 콘텐츠 형식으로 압축되지 않은 새 파트를 만듭니다.</summary>
        <returns>새로 만들어진 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 부분에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 부분과 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 파트 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 은 <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>합니다.  
  
 패키지 파트에 대 한 자세한 내용은 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양에 1.1 섹션을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> 또는 <paramref name="contentType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="partUri" />의 파트가 이미 패키지에 있는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 파트를 추가할 수 없습니다.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 부분을 만들려면 방법을 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">새 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="contentType">데이터 스트림의 콘텐츠 형식입니다.</param>
        <param name="compressionOption">데이터 스트림의 압축 옵션으로 <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> 또는 <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> 압축입니다.</param>
        <summary>지정된 URI, 콘텐츠 형식 및 압축 옵션으로 새 파트를 만듭니다.</summary>
        <returns>새로 만들어진 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본값에 대 한 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePart%2A> 메서드는 지원 두 `compressionOption` 값 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 값 <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 만듭니다 <xref:System.IO.Stream> 새 부분에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 부분과 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> 또는 <paramref name="contentType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="partUri" />의 파트가 이미 패키지에 있는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="compressionOption" /> 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 파트를 추가할 수 없습니다.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 부분을 만들려면 방법을 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">만들 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="contentType">데이터 스트림의 콘텐츠 형식입니다.</param>
        <param name="compressionOption">데이터 스트림의 압축 옵션입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 패키지에서 새 파트를 만듭니다.</summary>
        <returns>만들어진 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드는 <xref:System.IO.Packaging.Package.CreatePart%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 파트를 만드는 방법을 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.CreatePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에 새 파트를 만드는 클래스입니다.  
  
 기본값에 대 한 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드는 지원 두 `compressionOption` 값 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 값 <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 파트에 대한 패키지 수준 관계를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 <xref:System.IO.Packaging.PackagePart> 패키지 합니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트나 리소스 어떤 방식으로든에서 만들거나 관계 삭제 프로세스 물리적으로 변경 하지 않습니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 와 문서 루트 파트.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">대상 파트가 패키지에 <see cref="F:System.IO.Packaging.TargetMode.Internal" />인지 또는 <see cref="F:System.IO.Packaging.TargetMode.External" />인지를 나타냅니다.</param>
        <param name="relationshipType">관계의 역할을 고유하게 정의하는 URI입니다.</param>
        <summary>지정된 URI, 대상 모드 및 관계 형식을 가진 파트에 대한 패키지 수준 관계를 만듭니다.</summary>
        <returns>지정된 파트에 대한 패키지 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 물리적으로 바뀌지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI 수는 절대 경로일 수로 시작 하는 슬래시 ("/") 문자와 같은 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")로 기본 URI를 확인 합니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 에 따라 만든 상대 URI 또는 절대 중 하나가 될 수 있습니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  "http://www.microsoft.com/page2.xml"는 대상 외부 리소스 "page2.xml"를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"는는 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해를 참조 하는 상대 URI의 예시입니다.  
  
 `relationshipType` 있어야는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형식이 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` 열기 패키징 규칙 (OPC) 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/핵심 속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 와 문서 루트 파트.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetUri" /> 파트가 <see cref="T:System.IO.Packaging.PackageRelationship" />이거나 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />이고 <paramref name="targetUri" />가 절대 URI인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="targetMode" />의 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">대상 파트가 패키지에 <see cref="F:System.IO.Packaging.TargetMode.Internal" />인지 또는 <see cref="F:System.IO.Packaging.TargetMode.External" />인지를 나타냅니다.</param>
        <param name="relationshipType">관계의 역할을 고유하게 정의하는 URI입니다.</param>
        <param name="id">고유 XML 식별자입니다.</param>
        <summary>지정된 URI, 대상 모드, 관계 형식 및 [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)]를 가진 파트에 대한 패키지 수준 관계를 만듭니다.</summary>
        <returns>지정된 파트에 대한 패키지 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 물리적으로 바뀌지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며 XML 스키마 2 부에에서 설명 된 명명 규칙을 따라야: 데이터 형식 지정 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 경우 `id` 로 지정 된 `null` 고유 ID를 자동으로 생성 됩니다.  `id` 빈으로 지정 된 문자열이 잘못 되었습니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI 수는 절대 경로일 수로 시작 하는 슬래시 ("/") 문자와 같은 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")로 기본 URI를 확인 합니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 에 따라 만든 상대 URI 또는 절대 중 하나가 될 수 있습니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  "http://www.microsoft.com/page2.xml"는 대상 외부 리소스 "page2.xml"를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"는는 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해를 참조 하는 상대 URI의 예시입니다.  
  
 `relationshipType` 에 따라 구성 되는 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` 열기 패키징 규칙 (OPC) 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/핵심 속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 와 문서 루트 파트.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetUri" /> 파트가 <see cref="T:System.IO.Packaging.PackageRelationship" />이거나 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />이고 <paramref name="targetUri" />가 절대 URI인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="targetMode" />의 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아니거나 지정된 <paramref name="id" />의 파트가 이미 패키지에 있는 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">삭제할 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <summary>패키지에서 지정된 URI의 파트를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 ("/") 문자로 시작 되는 절대 경로로 구성 하는 상대 URI 여야 합니다.  절대 경로 패키지 루트에 상대적인 및에 따라 형성 되는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  "/ page1.xaml" 및 "/ images/picture4.jpg"은 유효한 파트 Uri의 예입니다.  
  
 예외가 발생 하는 경우 지정 된 일부 `partUri` 는 패키지에 없습니다.  (사용할 수 있습니다는 <xref:System.IO.Packaging.Package.PartExists%2A> 여부를 지정 된 부분을 확인할 수 있는 방법은 `partUri` 패키지에 있습니다.)  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 파트를 삭제 하는 방법을 합니다.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">삭제할 <see cref="P:System.IO.Packaging.PackagePart.Uri" />의 <see cref="T:System.IO.Packaging.PackagePart" />입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 URI의 파트를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.DeletePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.DeletePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> 실제 수행 하도록 클래스 파생된 클래스에서 구현 된 실제 형식에 따라 작업을 삭제 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 의해 호출 됩니다는 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 지정된 된 부분입니다.  
  
 파생 된 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">삭제할 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />의 <see cref="T:System.IO.Packaging.PackageRelationship" />입니다.</param>
        <summary>패키지 수준 관계를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 예외가 발생 하는 경우 지정 된 관계 `id` 는 패키지에 없습니다.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> 실제로 어떤 방식으로든에서 대상 파트를 변경 하지 않습니다.  
  
 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>모든 파트 및 관계의 콘텐츠를 플러시 및 저장하고, 패키지를 닫고, 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 변경 내용을 올바르게 저장 되 고 있는지 확인 하려면 <xref:System.IO.Packaging.Package.Dispose%2A> 도 종료, 플러시, 및 모든 파트 및 패키지에 포함 된 관계를 닫습니다.  
  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Dispose%2A> 및 <xref:System.IO.Packaging.Package.Close%2A> 동일한 작업을 수행-호출 하는 이유가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대입니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
 할당 및 비 메모리 리소스를 관리 하는 파생된 클래스는 리소스를 해제 하려면이 메서드를 재정의 하는 경우 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 합니다. 파생 클래스 재정의 호출 또한 해야 <xref:System.IO.Packaging.Package.Flush%2A> 및 기본 클래스 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드는 항상 기본 클래스 정리를 수행 되도록 합니다.  
  
> [!NOTE]
>  `using` 문 (다른는 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여 줍니다는 `using` 문.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>패키지의 파일 액세스 설정을 가져옵니다.</summary>
        <value>
          <see cref="T:System.IO.FileAccess" />의 <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, 또는 <see cref="F:System.IO.FileAccess.ReadWrite" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FileOpenAccess%2A> 속성에는 기본값이 없습니다.  파일 액세스 설정에 지정 된는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자를 새 패키지를 만들 때 또는 호출의 <xref:System.IO.Packaging.Package.Open%2A> 기존 패키지를 열 때 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>패키지에 포함된 모든 파트 및 관계의 콘텐츠를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스의 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> 실제 형식에 따른 플러시 작업을 수행 하려면 구현 합니다.  파생된 클래스의 <xref:System.IO.Packaging.Package.FlushCore%2A> 메서드는 실제로 특정 파생된 클래스에서 물리적 구현에 파트 및 관계 콘텐츠를 저장 해야 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다. 기본 동작에서 <xref:System.IO.Packaging.Package.Flush%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> ZIP 파일 패키지에 파트 및 관계를 저장 합니다.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> 자동으로 호출 되는 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드.  때 <xref:System.IO.Packaging.Package.Close%2A> 또는 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Flush%2A> 별도로 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용이며 수정할 수 없는 경우</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 파트를 플러시합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에 재정의되는 경우 모든 파트 및 관계의 콘텐츠를 파생 클래스 저장소에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> 에 의해 호출 됩니다는 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 실제 플러시 작업을 수행 하는 방법을 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 구현에서 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 않아야는 <see cref="M:System.IO.Packaging.Package.Flush" /> 메서드를 호출 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">반환할 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <summary>지정된 URI의 파트를 반환합니다.</summary>
        <returns>지정된 <paramref name="partUri" />의 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> 없으면 지정 된 일부 예외가 `partUri` 존재 하지 않습니다.  
  
 <xref:System.IO.Packaging.Package.PartExists%2A> 확인 하려면 메서드를 사용할 수 있는지 여부를 `partUri` 기존 부분을 참조 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> 클래스 ZIP 파일에서 요청 된 부분을 반환 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 찾을, 검색 및 패키지에 포함 된 파트를 읽는 방법을 보여 줍니다.  전체 샘플을 참조 하십시오. [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="partUri" />의 파트가 패키지에 없는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 파트를 플러시합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">검색할 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 URI로 확인되는 파트를 반환합니다.</summary>
        <returns>요청된 파트, 또는 지정된 <paramref name="partUri" />의 파트가 패키지에 있지 않은 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 일부를 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 의해 호출 됩니다는 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 액세스 하 고 지정된 된 부분을 반환 합니다.  
  
 파생 된 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>패키지에 있는 모든 파트의 컬렉션을 반환합니다.</summary>
        <returns>패키지에 포함된 모든 <see cref="T:System.IO.Packaging.PackagePart" /> 요소의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> 포함 하는 패키지에 포함 된 모든 파트의 컬렉션을 반환 <xref:System.IO.Packaging.PackageRelationship> 부분입니다.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> 반환 하지 것입니다 `null`있지만 반환된 된 컬렉션 패키지 파트가 없습니다 경우 요소가 포함 됩니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetParts%2A> 호출은 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 의 메서드는 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 부분을 반환 하는 클래스입니다.  
  
 패키지 및 패키지 파트에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.1을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.IO.Packaging.Package.GetParts%2A> 에 포함 된 파트의 컬렉션을 가져옵니다 메서드는 <xref:System.IO.Packaging.Package>합니다.  완성 된 프로그램 소스 코드에 대 한 참조 [디지털 서명 샘플을 사용 하 여 패키지 만들기](http://go.microsoft.com/fwlink/?LinkID=159966)합니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 파트를 플러시합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 패키지에 있는 모든 파트의 배열을 반환합니다.</summary>
        <returns>패키지에 포함된 모든 파트의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 의해 호출 됩니다는 <xref:System.IO.Packaging.Package.GetParts%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 액세스 하 고 파트의 배열을 반환 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetParts%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 부분을 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="M:System.IO.Packaging.Package.GetParts" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">반환할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 식별자를 가진 패키지 수준 관계를 반환합니다.</summary>
        <returns>지정된 <paramref name="id" />의 패키지 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며 XML 스키마 2 부에에서 설명 된 명명 규칙을 따라야: 데이터 형식 지정 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 관계가 패키지에 없는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 패키지 수준 관계의 컬렉션을 반환합니다.</summary>
        <returns>패키지에 포함된 모든 패키지 수준 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 반환 하지 것입니다 `null`; 있지만 반환된 된 컬렉션 패키지에 있는 경우 패키지 수준 관계가 없는 요소가 포함 될 수 있습니다.  
  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트나 리소스 어떤 방식으로든에서 만들거나 관계 삭제 프로세스 물리적으로 변경 하지 않습니다.  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">컬렉션에서 일치하고 반환할 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />에 일치하는 모든 패키지 수준 관계의 컬렉션을 반환합니다.</summary>
        <returns>지정된 <paramref name="relationshipType" />에 일치하는 패키지 수준 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 하지만 반환 하지 것입니다 `null`지정 된 일치 하는 패키지 수준 관계가 없는 경우 반환된 된 컬렉션 요소가 포함 될 수 있습니다; `relationshipType`합니다.  
  
 다음 표에서 패키지 수준 `relationshipType` 열기 패키징 규칙 (OPC) 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/핵심 속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예에서는 패키지에 대해 정의 된 관계를 검색 하는 방법을 보여 줍니다.  전체 샘플을 참조 하십시오. [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>패키지를 엽니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">패키지를 열 IO 스트림입니다.</param>
        <summary>지정된 IO 스트림에서 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">열려는 패키지에 읽기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우 또는 열려는 패키지에 쓰기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <summary>지정된 경로 및 파일 이름에서 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 통해 패키지를 엽니다 <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, 및 <xref:System.IO.FileShare.None> (서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나를 지정) 하 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">패키지를 열 IO 스트림입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <summary>지정된 IO 스트림 및 파일 모드를 사용하여 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> 값이 잘못된 경우</exception>
        <exception cref="T:System.IO.IOException">열려는 패키지에 읽기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우 또는 열려는 패키지에 쓰기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <summary>지정된 경로의 패키지를 지정된 파일 모드를 사용하여 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 통해 패키지를 엽니다 <xref:System.IO.FileAccess.ReadWrite> 및 <xref:System.IO.FileShare.None> (서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나를 지정) 하 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" />의 값이 올바르지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">패키지를 열 IO 스트림입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <param name="packageAccess">패키지를 열 때 사용할 파일 액세스 권한입니다.</param>
        <summary>지정된 IO 스트림, 파일 모드 및 파일 액세스 설정을 사용하여 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> 또는 <paramref name="packageAccess" />의 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.IO.IOException">열려는 패키지에 읽기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우 또는 열려는 패키지에 쓰기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <param name="packageAccess">패키지를 열 때 사용할 파일 액세스 권한입니다.</param>
        <summary>지정된 경로의 패키지를 지정된 파일 모드 및 파일 액세스 설정을 사용하여 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 패키지를 엽니다 <xref:System.IO.FileShare.None> 특성 (서로 다른 특성 사용법을 지정 하는 <xref:System.IO.Packaging.Package.Open%2A> 메서드 오버 로드).  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 열고 읽기 위해는 <xref:System.IO.Packaging.Package> 포함 된 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> 또는 <paramref name="packageAccess" />의 값이 올바르지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <param name="packageAccess">패키지를 열 때 사용할 파일 액세스 권한입니다.</param>
        <param name="packageShare">패키지를 열 때 사용할 파일 공유 모드입니다.</param>
        <summary>지정된 경로의 패키지를 지정된 파일 모드, 파일 액세스 및 파일 공유 설정을 사용하여 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" />, <paramref name="packageAccess" /> 또는 <paramref name="packageShare" />의 값이 올바르지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>패키지의 핵심 속성을 가져옵니다.</summary>
        <value>패키지의 핵심 속성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 코어 패키지 속성에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양에 섹션 3.1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">확인할 파트의 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 URI의 파트가 패키지에 있는지 여부를 나타냅니다.</summary>
        <returns>
          지정된 <paramref name="partUri" />의 파트가 패키지에 있으면 <see langword="true" />, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 문자로 시작 해야 "/" 및 패키지의 루트에서 절대 경로 여야 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 정보를 읽을 수 없습니다.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">확인할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 ID의 패키지 수준 관계가 패키지에 포함되어 있는지 여부를 나타냅니다.</summary>
        <returns>
          지정된 <paramref name="id" />의 패키지 수준 관계가 패키지에 있으면 <see langword="true" />, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 인프라를 지원하는 것으로 응용 프로그램에서는 사용하지 않는 것이 좋습니다.  형식이 안전한 <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 메서드를 대신 사용하세요.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>