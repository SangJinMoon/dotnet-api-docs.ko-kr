<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f0fb9c3519c8854c5993cc79789391da05972e70" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36485658" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a container that can store multiple data objects.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> 개체의 이식성 및 효율적인 액세스에 대 한 정의 된 실제 형식 단일 엔터티를 구성 하는 데 사용할 수 있는 추상 클래스가입니다.  
  
 ZIP 파일은 기본 실제 형식에 대 한는 <xref:System.IO.Packaging.Package>합니다.  다른 <xref:System.IO.Packaging.Package> 구현 수 있는 XML 문서를 데이터베이스와 같은 다른 물리적 형식을 사용 하 여 또는 웹 서비스입니다.  
  
 같은 파일 시스템에 포함 된 항목은 <xref:System.IO.Packaging.Package> 파일과 폴더의 계층적 구성에서 참조 됩니다.  
  
 하지만 <xref:System.IO.Packaging.Package> 자체 클래스는 추상 클래스는 <xref:System.IO.Packaging.ZipPackage> 파생된 클래스에서 기본적으로 사용 됩니다는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 A <xref:System.IO.Packaging.PackagePart> ("파트")에 저장 된 개체를 나타내는 추상 클래스는는 <xref:System.IO.Packaging.Package>합니다.  
  
 A <xref:System.IO.Packaging.PackageRelationship> ("관계")을 원본 간의 연결을 정의 <xref:System.IO.Packaging.Package> 또는 <xref:System.IO.Packaging.PackagePart> 와 대상 개체입니다.  A <xref:System.IO.Packaging.PackageRelationship> 두 형식 중 하나일 수 있으며 각 두 형식 중 하나일 수 있습니다.  
  
-   패키지 수준 관계 (에서 만든는 <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> 메서드)와 관련 한 <xref:System.IO.Packaging.Package> 로:  
  
    -   패키지의 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
-   파트 수준 관계 (에서 만든는 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> 메서드)는 소스와 관련 된 <xref:System.IO.Packaging.PackagePart> 로:  
  
    -   패키지의 다른 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
 관계의 소스 <xref:System.IO.Packaging.Package> 또는 소스 <xref:System.IO.Packaging.PackagePart> 관계의 "소유자"로 간주 됩니다.  소스 개체가 삭제 된 원본 개체가 소유 하는 모든 관계가 삭제 됩니다.  만들기 또는 관계를 삭제 하는 과정은 어떤 방식으로든에서 원본 또는 대상 개체를 물리적으로 변경 되지 않습니다.  
  
 A <xref:System.IO.Packaging.PackageDigitalSignature> ("디지털 서명")에 포함 된 디지털 서명이 나타내는 관계와 파트의 컴퍼지션은는 <xref:System.IO.Packaging.Package>합니다.  디지털 서명은 출처를 식별 하 고 서명 된 파트 및 관계에 포함 하는 유효성을 검사는 <xref:System.IO.Packaging.Package> 수정 되지 않은 합니다.  
  
 패키지에는 또한 관리 DRM (디지털 권한)의 콘텐츠 요소는 지원는 <xref:System.IO.Packaging.Package> 권한 있는 사용자에 게 부여 하는 특정 액세스 권한을 가진 암호화 되도록 합니다.  
  
 에 따라는 <xref:System.IO.Packaging.Package> 아키텍처는 <xref:System.Windows.Xps.Packaging.XpsDocument> 열기에 따라 문서를 저장 하기 위한 패키지 형식이 [XPS XML Paper Specification ()](http://go.microsoft.com/fwlink/?LinkID=65761)합니다.  
  
 .NET Framework에서는 패키지를 콘텐츠, 리소스 및 페이지와 기본적으로 표준 ZIP 파일을 사용 하 여 문서에 대 한 관계를 저장 합니다. 다른 ZIP 파일과 응용 프로그램 사용 하 여 수는 <xref:System.IO.Packaging> 클래스를 저장 하 고 필요에 따라에 임의의 유형 또는 단일 효율적으로 액세스 컨테이너의 데이터 파일 수를 보호 합니다.  
  
 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 만드는 기본 단계는 <xref:System.IO.Packaging.Package>합니다.  이 예제에서는 문서의 일부로 표시 되는 그래픽 이미지와 함께 문서를 포함 하는 패키지가 생성 됩니다.  (이 HTML 파일에 있는 경우와 비슷하며는 \<IMG > 외부 이미지 파일을 참조 하는 태그입니다.)  두 개의 <xref:System.IO.Packaging.PackageRelationship> 요소 패키지에 포함 됩니다.  첫 번째, "패키지 수준" 관계는 패키지의 루트 요소와 문서 부분을 정의합니다.  두 번째, "파트 수준" 관계 이미지 파트 (파트 수준 관계의 "대상")를 사용 하는 문서 파트 (파트 수준 관계의 "원본")와 연결을 정의합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 보호 된 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <param name="streaming">
          <see langword="true" /> to open the package for streaming; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" /> and streaming option.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 보호 된 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves and closes the package plus all underlying part streams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 동일한 작업을 수행-호출 하는 이유가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대입니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
> [!NOTE]
>  `using` 문 (다른는 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다.  [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055) 및 [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여는 `using` 문.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new package part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 부분에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 부분과 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 패키지 파트에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.1을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 부분을 만들려면 방법을 합니다.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <summary>Creates a new uncompressed part with a given URI and content type.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 부분에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 부분과 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 파트 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 은 <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>합니다.  
  
 패키지 파트에 대 한 자세한 내용은 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양에 1.1 섹션을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 부분을 만들려면 방법을 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> or <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> compression.</param>
        <summary>Creates a new part with a given URI, content type, and compression option.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본값에 대 한 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePart%2A> 메서드는 지원 두 `compressionOption` 값 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 값 <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 만듭니다 <xref:System.IO.Stream> 새 부분에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 부분과 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="compressionOption" /> value is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 부분을 만들려면 방법을 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] for the part being created.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream.</param>
        <summary>When overridden in a derived class, creates a new part in the package.</summary>
        <returns>The created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드는 <xref:System.IO.Packaging.Package.CreatePart%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 파트를 만드는 방법을 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.CreatePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에 새 파트를 만드는 클래스입니다.  
  
 기본값에 대 한 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드는 지원 두 `compressionOption` 값 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 값 <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a package-level relationship to a given part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 <xref:System.IO.Packaging.PackagePart> 패키지 합니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트나 리소스 어떤 방식으로든에서 만들거나 관계 삭제 프로세스 물리적으로 변경 하지 않습니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 와 문서 루트 파트.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, and relationship type.</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 물리적으로 바뀌지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI 수는 절대 경로일 수로 시작 하는 슬래시 ("/") 문자와 같은 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")로 기본 URI를 확인 합니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 에 따라 만든 상대 URI 또는 절대 중 하나가 될 수 있습니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  "http://www.microsoft.com/page2.xml"는 대상 외부 리소스 "page2.xml"를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"는는 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해를 참조 하는 상대 URI의 예시입니다.  
  
 `relationshipType` 있어야는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형식이 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` 열기 패키징 규칙 (OPC) 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/핵심 속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 와 문서 루트 파트.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <param name="id">A unique XML identifier.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, relationship type, and [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 물리적으로 바뀌지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며 XML 스키마 2 부에에서 설명 된 명명 규칙을 따라야: 데이터 형식 지정 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 경우 `id` 로 지정 된 `null` 고유 ID를 자동으로 생성 됩니다.  `id` 빈으로 지정 된 문자열이 잘못 되었습니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI 수는 절대 경로일 수로 시작 하는 슬래시 ("/") 문자와 같은 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")로 기본 URI를 확인 합니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 에 따라 만든 상대 URI 또는 절대 중 하나가 될 수 있습니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  "http://www.microsoft.com/page2.xml"는 대상 외부 리소스 "page2.xml"를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"는는 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해를 참조 하는 상대 URI의 예시입니다.  
  
 `relationshipType` 에 따라 구성 되는 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` 열기 패키징 규칙 (OPC) 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/핵심 속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 와 문서 루트 파트.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier; or a part with the specified <paramref name="id" /> already occurs in the package.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the part to delete.</param>
        <summary>Deletes a part with a given URI from the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 ("/") 문자로 시작 되는 절대 경로로 구성 하는 상대 URI 여야 합니다.  절대 경로 패키지 루트에 상대적인 및에 따라 형성 되는 [RFC 3986](http://tools.ietf.org/html/rfc3986) 일반 구문 식별자 URI (Uniform Resource) 사양입니다.  "/ page1.xaml" 및 "/ images/picture4.jpg"은 유효한 파트 Uri의 예입니다.  
  
 예외가 발생 하는 경우 지정 된 일부 `partUri` 는 패키지에 없습니다.  (사용할 수 있습니다는 <xref:System.IO.Packaging.Package.PartExists%2A> 여부를 지정 된 부분을 확인할 수 있는 방법은 `partUri` 패키지에 있습니다.)  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 파트를 삭제 하는 방법을 합니다.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="P:System.IO.Packaging.PackagePart.Uri" /> of the <see cref="T:System.IO.Packaging.PackagePart" /> to delete.</param>
        <summary>When overridden in a derived class, deletes a part with a given URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.DeletePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.DeletePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> 실제 수행 하도록 클래스 파생된 클래스에서 구현 된 실제 형식에 따라 작업을 삭제 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 의해 호출 됩니다는 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 지정된 된 부분입니다.  파생 된 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the <see cref="T:System.IO.Packaging.PackageRelationship" /> to delete.</param>
        <summary>Deletes a package-level relationship.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 예외가 발생 하는 경우 지정 된 관계 `id` 는 패키지에 없습니다.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> 실제로 어떤 방식으로든에서 대상 파트를 변경 하지 않습니다.  
  
 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Flushes and saves the content of all parts and relationships, closes the package, and releases all resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 변경 내용을 올바르게 저장 되 고 있는지 확인 하려면 <xref:System.IO.Packaging.Package.Dispose%2A> 도 종료, 플러시, 및 모든 파트 및 패키지에 포함 된 관계를 닫습니다.  
  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Dispose%2A> 및 <xref:System.IO.Packaging.Package.Close%2A> 동일한 작업을 수행-호출 하는 이유가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대입니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
 할당 및 비 메모리 리소스를 관리 하는 파생된 클래스는 리소스를 해제 하려면이 메서드를 재정의 하는 경우 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 합니다. 파생 클래스 재정의 호출 또한 해야 <xref:System.IO.Packaging.Package.Flush%2A> 및 기본 클래스 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드는 항상 기본 클래스 정리를 수행 되도록 합니다.  
  
> [!NOTE]
>  `using` 문 (다른는 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여 줍니다는 `using` 문.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the file access setting for the package.</summary>
        <value>중 하나는 <see cref="T:System.IO.FileAccess" /> 값: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, 또는 <see cref="F:System.IO.FileAccess.ReadWrite" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FileOpenAccess%2A> 속성에는 기본값이 없습니다.  파일 액세스 설정에 지정 된는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자를 새 패키지를 만들 때 또는 호출의 <xref:System.IO.Packaging.Package.Open%2A> 기존 패키지를 열 때 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves the contents of all parts and relationships that are contained in the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스의 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> 실제 형식에 따른 플러시 작업을 수행 하려면 구현 합니다.  파생된 클래스의 <xref:System.IO.Packaging.Package.FlushCore%2A> 메서드는 실제로 특정 파생된 클래스에서 물리적 구현에 파트 및 관계 콘텐츠를 저장 해야 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다. 기본 동작에서 <xref:System.IO.Packaging.Package.Flush%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> ZIP 파일 패키지에 파트 및 관계를 저장 합니다.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> 자동으로 호출 되는 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드.  때 <xref:System.IO.Packaging.Package.Close%2A> 또는 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Flush%2A> 별도로 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only and cannot be modified.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 파트를 플러시합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, saves the content of all parts and relationships to the derived class store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> 에 의해 호출 됩니다는 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 실제 플러시 작업을 수행 하는 방법을 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 구현에서 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 않아야는 <see cref="M:System.IO.Packaging.Package.Flush" /> 메서드를 호출 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to return.</param>
        <summary>Returns the part with a given URI.</summary>
        <returns>The part with the specified <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> 없으면 지정 된 일부 예외가 `partUri` 존재 하지 않습니다.  
  
 <xref:System.IO.Packaging.Package.PartExists%2A> 확인 하려면 메서드를 사용할 수 있는지 여부를 `partUri` 기존 부분을 참조 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> 클래스 ZIP 파일에서 요청 된 부분을 반환 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 찾을, 검색 및 패키지에 포함 된 파트를 읽는 방법을 보여 줍니다.  전체 샘플을 참조 하십시오. [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 파트를 플러시합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to retrieve.</param>
        <summary>When overridden in a derived class, returns the part addressed by a given URI.</summary>
        <returns>The requested part; or <see langword="null" />, if a part with the specified <paramref name="partUri" /> is not in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 일부를 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 의해 호출 됩니다는 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 액세스 하 고 지정된 된 부분을 반환 합니다.  파생 된 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the parts in the package.</summary>
        <returns>A collection of all the <see cref="T:System.IO.Packaging.PackagePart" /> elements that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> 포함 하는 패키지에 포함 된 모든 파트의 컬렉션을 반환 <xref:System.IO.Packaging.PackageRelationship> 부분입니다.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> 반환 하지 것입니다 `null`있지만 반환된 된 컬렉션 패키지 파트가 없습니다 경우 요소가 포함 됩니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetParts%2A> 호출은 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 의 메서드는 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 부분을 반환 하는 클래스입니다.  
  
 패키지 및 패키지 파트에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.1을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.IO.Packaging.Package.GetParts%2A> 에 포함 된 파트의 컬렉션을 가져옵니다 메서드는 <xref:System.IO.Packaging.Package>합니다.  완성 된 프로그램 소스 코드에 대 한 참조 [디지털 서명 샘플을 사용 하 여 패키지 만들기](http://go.microsoft.com/fwlink/?LinkID=159966)합니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 파트를 플러시합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns an array of all the parts in the package.</summary>
        <returns>An array of all the parts that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 의해 호출 됩니다는 <xref:System.IO.Packaging.Package.GetParts%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 액세스 하 고 파트의 배열을 반환 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.ZipPackage> 추상의 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <xref:System.IO.Packaging.Package.GetParts%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 부분을 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 Chapter 1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="M:System.IO.Packaging.Package.GetParts" /> 메서드를 호출 합니다.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to return.</param>
        <summary>Returns the package-level relationship with a given identifier.</summary>
        <returns>The package-level relationship with the specified <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며 XML 스키마 2 부에에서 설명 된 명명 규칙을 따라야: 데이터 형식 지정 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.InvalidOperationException">A relationship with the specified <paramref name="id" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the package-level relationships.</summary>
        <returns>A collection of all the package-level relationships that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 반환 하지 것입니다 `null`; 있지만 반환된 된 컬렉션 패키지에 있는 경우 패키지 수준 관계가 없는 요소가 포함 될 수 있습니다.  
  
 패키지 수준 관계 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 대상 부분 패키지에 있습니다.  
  
-   사이 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스입니다.  
  
 패키지 관계 패키지 관계의 "소유자"로 간주 됩니다.  패키지를 삭제 하는 경우 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트나 리소스 어떤 방식으로든에서 만들거나 관계 삭제 프로세스 물리적으로 변경 하지 않습니다.  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양의 섹션 1.3을 참조 하십시오. [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">The <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> to match and return in the collection.</param>
        <summary>Returns a collection of all the package-level relationships that match a given <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>A collection of package-level relationships that match the specified <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 하지만 반환 하지 것입니다 `null`지정 된 일치 하는 패키지 수준 관계가 없는 경우 반환된 된 컬렉션 요소가 포함 될 수 있습니다; `relationshipType`합니다.  
  
 다음 표에서 패키지 수준 `relationshipType` 열기 패키징 규칙 (OPC) 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/핵심 속성|  
|디지털 서명|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/서명|  
|디지털 서명 인증서|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/인증서|  
|디지털 서명 원본|http://schemas.openxmlformats.org/package/2006/relationships/digit al-서명/원본|  
|미리 보기|http://schemas.openxmlformats.org/package/2006/relationships/meta 데이터/미리 보기|  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예에서는 패키지에 대해 정의 된 관계를 검색 하는 방법을 보여 줍니다.  전체 샘플을 참조 하십시오. [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> is an empty string.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <summary>Opens a package on a given IO stream.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <summary>Opens a package at a given path and file name.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 통해 패키지를 엽니다 <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, 및 <xref:System.IO.FileShare.None> (서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나를 지정) 하 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package with a given IO stream and file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> value is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 통해 패키지를 엽니다 <xref:System.IO.FileAccess.ReadWrite> 및 <xref:System.IO.FileShare.None> (서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나를 지정) 하 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package with a given IO stream, file mode, and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 패키지를 엽니다 <xref:System.IO.FileShare.None> 특성 (서로 다른 특성 사용법을 지정 하는 <xref:System.IO.Packaging.Package.Open%2A> 메서드 오버 로드).  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에서는 열고 읽기 위해는 <xref:System.IO.Packaging.Package> 포함 된 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [는 패키지 예제 추가 정보를 읽는](http://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <param name="packageShare">The file sharing mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode, file access, and file share setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 기본 형식인 패키지에서 사용 되는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
   
  
## Examples  
 다음 예제에는 새 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 요소에 저장 된 데이터와 함께 합니다.  전체 샘플을 참조 하십시오. [패키지 작성 샘플](http://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" />, <paramref name="packageAccess" />, or <paramref name="packageShare" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the core properties of the package.</summary>
        <value>패키지의 핵심 속성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 코어 패키지 속성에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 열린 패키징 규칙 (OPC) 사양에 섹션 3.1 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="T:System.Uri" /> of the part to check for.</param>
        <summary>Indicates whether a part with a given URI is in the package.</summary>
        <returns>
          <see langword="true" /> if a part with the specified <paramref name="partUri" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 문자로 시작 해야 "/" 및 패키지의 루트에서 절대 경로 여야 합니다.  
  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only (information cannot be read).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to check for.</param>
        <summary>Indicates whether a package-level relationship with a given ID is contained in the package.</summary>
        <returns>
          <see langword="true" /> if a package-level relationship with the specified <paramref name="id" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은에서 다운로드할 수 열려 패키징 규칙 (OPC) 사양을 참조 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended for application use.  Use the type-safe <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> method instead.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>