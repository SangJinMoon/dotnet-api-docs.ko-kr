<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e736f111054396eb8c10c409622d4163d4c6e42f" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36299118" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>다시 사용 및 버전 지정이 가능한, 공용 언어 런타임 응용 프로그램의 자체 설명 빌딩 블록인 어셈블리를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Reflection.Assembly> 클래스의 어셈블리를 어셈블리에 포함 된 형식을 검색 하 고 이러한 형식의 인스턴스를 만들 메타 데이터 및 구성 요소를 탐색 하려면 어셈블리를 로드 합니다.  
  
 배열에 가져오려는 <xref:System.Reflection.Assembly> 현재 어셈블리를 나타내는에 로드 된 응용 프로그램 도메인 (예를 들어 응용 프로그램의 기본 도메인 간단한 프로젝트)를 사용 하 여 개체는 <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> 메서드.  
  
 어셈블리를 동적으로 로드 된 <xref:System.Reflection.Assembly> 정적 메서드를 제공 하는 클래스 (`Shared` Visual Basic의 메서드). 어셈블리 로드 작업이 발생 하는 응용 프로그램 도메인에 로드 됩니다.  
  
-   사용 하는 어셈블리를 로드 하는 권장된 방법은 <xref:System.AppDomain.Load%2A> 어셈블리의 표시 이름으로 로드할 수를 식별 하는 메서드 (예를 들어 "System.Windows.Forms, 버전 2.0.0.0, Culture = neutral, PublicKeyToken = = b77a5c561934e089"). 어셈블리에 대 한 검색에 설명 된 규칙을 따르는 [런타임에서 어셈블리를 찾는 방법을](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)합니다.  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드를 사용 하면 반사 하지만 실행에 대 한 어셈블리 로드 합니다. 예를 들어, 64 비트 플랫폼을 대상으로 하는 어셈블리를 검사 하 여 32 비트 플랫폼에서 실행 되는 코드입니다.  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A> 및 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 어셈블리 경로 의해 식별 해야 하는 드문 경우를 위해 제공 됩니다.  
  
 가져오려는 <xref:System.Reflection.Assembly> 현재 실행 중인 어셈블리 사용에 대 한 개체는 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 메서드.  
  
 대부분의 멤버는 <xref:System.Reflection.Assembly> 클래스는 어셈블리에 대 한 정보를 제공 합니다. 예:  
  
-   <xref:System.Reflection.Assembly.GetName%2A> 메서드가 반환 되는 <xref:System.Reflection.AssemblyName> 어셈블리 표시 이름 부분에 대 한 액세스를 제공 하는 개체입니다.  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A> 메서드는 어셈블리에 적용 되는 특성을 나열 합니다.  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A> 메서드를 어셈블리 매니페스트에 파일에 대 한 액세스를 제공 합니다.  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> 메서드를 어셈블리 매니페스트에 있는 리소스의 이름을 제공 합니다.  
  
 <xref:System.Reflection.Assembly.GetTypes%2A> 메서드는 어셈블리의 모든 형식 목록을 나열 합니다. <xref:System.Reflection.Assembly.GetExportedTypes%2A> 메서드 어셈블리 외부에 호출자에 게 표시 되는 형식을 나열 합니다. <xref:System.Reflection.Assembly.GetType%2A> 어셈블리에 있는 특정 형식의 검색할 메서드를 사용할 수 있습니다. <xref:System.Reflection.Assembly.CreateInstance%2A> 메서드를 검색 하 고 어셈블리에서 형식의 인스턴스를 만들거나 사용할 수 있습니다.  
  
 어셈블리에 대 한 자세한 내용은의 "응용 프로그램 도메인 및 어셈블리" 섹션을 참조 하십시오.는 [응용 프로그램 도메인](~/docs/framework/app-domains/application-domains.md) 항목입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 현재 실행 중인 어셈블리를 가져올, 해당 어셈블리에 포함 된 형식의 인스턴스를 만들고, 런타임에 바인딩과 함께 형식의 메서드 중 하나를 호출 하는 방법을 보여 줍니다. 코드 예제에서는이 위해 라는 클래스를 정의 `Example`, 라는 메서드가 있는 `SampleMethod`합니다. 클래스의 생성자는 메서드의 반환 값을 계산 하는 데 사용 되는 정수를 허용 합니다.  
  
 코드 예제에서는 또한의 사용법을 보여줍니다는 <xref:System.Reflection.Assembly.GetName%2A> 를 얻는 메서드를 한 <xref:System.Reflection.AssemblyName> 어셈블리의 전체 이름을 구문 분석을 사용할 수 있는 개체입니다. 어셈블리의 버전 번호를 표시 하는 예제는 <xref:System.Reflection.Assembly.CodeBase%2A> 속성 및 <xref:System.Reflection.Assembly.EntryPoint%2A> 속성.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">상속자에 대 한 완전 신뢰 합니다. 부분적으로 신뢰할 수 있는 코드에서이 클래스는 상속 될 수 없습니다.</permission>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성 하는 동안이 생성자는 파생된 클래스에서 호출 <xref:System.Reflection.Assembly> 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>예를 들어 <see cref="T:System.Reflection.AssemblyName" /> 개체에 원래 지정된 어셈블리 위치를 가져옵니다.</summary>
        <value>원래 지정된 어셈블리 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로드 된 매니페스트가 들어 있는 파일에 절대 경로 가져오려면는 <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> 속성 대신 합니다.  
  
 오버 로드를 사용 하 여 어셈블리를 바이트 배열로 로드 된 경우는 <xref:System.Reflection.Assembly.Load%2A> 바이트의 배열을 사용 하는 메서드를이 속성 로드 된 어셈블리의 위치가 아닌 메서드의 호출자의 위치를 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.Assembly.CodeBase%2A> 속성입니다.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리에서 형식을 찾은 다음 시스템 활성기를 사용하여 해당 형식의 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</param>
        <summary>대/소문자 구분 검색 기능을 사용하여 이 어셈블리에서 지정된 형식을 찾은 다음 시스템 활성기를 사용하여 해당 형식의 인스턴스를 만듭니다.</summary>
        <returns>
          <see langword="null" />을 찾을 수 있는 경우 기본 생성자로 만든 지정된 형식의 인스턴스이며, 그렇지 않은 경우는 <paramref name="typeName" />입니다. 형식은 문화권 또는 활성화 특성을 지정하지 않고 <see cref="T:System.Reflection.BindingFlags" />를 <see langword="Public" /> 또는 <see langword="Instance" />로 설정하여 기본 바인더를 사용하여 확인됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 런타임에서 찾을 수 없는 경우 `typeName` 에 <xref:System.Reflection.Assembly> 인스턴스를 반환 `null` 예외를 throw 하는 대신 합니다. 이 때문에 발생할 수 있습니다.  
  
-   형식의 정규화 된 이름을 지정 하지 않았습니다.  
  
-   정규화 된 형식 이름을 지정한 있지만 대 소문자 형식의 소문자가 일치 하지 않는 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성입니다. 대/소문자 비구분 비교 `typeName` 형식의 전체 이름 호출는 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 오버 로드 하 고 지정 `true` 에 대 한는 `ignoreCase` 인수입니다.  
  
-   형식을 현재에 존재 하지 않는 <xref:System.Reflection.Assembly> 인스턴스.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Person` 클래스 및 호출 된 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 메서드를 인스턴스화해야 합니다.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</param>
        <param name="ignoreCase">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자 구분 검색 기능을 선택적으로 사용하여, 지정된 형식을 이 어셈블리에서 찾은 다음 시스템 활성기를 사용하여 해당 인스턴스를 만듭니다.</summary>
        <returns>
          <see langword="null" />을 찾을 수 있는 경우 기본 생성자로 만든 지정된 형식의 인스턴스이며, 그렇지 않은 경우는 <paramref name="typeName" />입니다. 형식은 문화권 또는 활성화 특성을 지정하지 않고 <see cref="T:System.Reflection.BindingFlags" />를 <see langword="Public" /> 또는 <see langword="Instance" />로 설정하여 기본 바인더를 사용하여 확인됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 런타임에서 찾을 수 없는 경우 `typeName` 에 <xref:System.Reflection.Assembly> 인스턴스를 반환 `null` 예외를 throw 하는 대신 합니다. 이 때문에 발생할 수 있습니다.  
  
-   형식의 정규화 된 이름을 지정 하지 않았습니다.  
  
-   형식을 현재에 존재 하지 않는 <xref:System.Reflection.Assembly> 인스턴스.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Person` 클래스입니다. 그런 다음 호출 하는 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 메서드를 인스턴스화할 수 있지만 때문에의 대/소문자는 `typeName` 인수는 형식의 일치 하지 않는 <xref:System.Type.FullName%2A> 속성, 메서드는 반환 `null`합니다. 이 예제에서는 동일한 문자열을 전달 하는 경우는 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 오버 로드 하 고 비교는 대/소문자 구분, 이어야 함을 지정는 `Person` 클래스를 찾을 수 및 `Person` 개체가 인스턴스화될 성공적으로 합니다.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</param>
        <param name="ignoreCase">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="bindingAttr">검색 수행 방법에 영향을 주는 비트 마스크입니다. 이 값은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그 조합입니다.</param>
        <param name="binder">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see langword="MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다. <c>바인더</c>가 <see langword="null" />이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달되는 인수를 포함하는 배열입니다. 이 인수 배열은 실행될 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 <see langword="null" />이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see langword="CultureInfo" />의 인스턴스입니다. 이 매개 변수가 <see langword="null" />이면 현재 스레드에 대한 <see langword="CultureInfo" />가 사용됩니다. 예를 들어 1,000은 각 문화권마다 다르게 표현되므로 1,000을 나타내는 <see langword="String" />을 <see langword="Double" /> 값으로 변환하기 위해 이 매개 변수가 필요합니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>대/소문자 구분 검색 기능을 선택적으로 사용하고 지정된 문화권, 인수, 바인딩 및 활성화 특성을 사용하여, 지정된 형식을 이 어셈블리에서 찾은 다음 시스템 활성기를 사용하여 해당 인스턴스를 만듭니다.</summary>
        <returns>지정된 형식의 인스턴스 또는 <see langword="null" />이 없으면 <paramref name="typeName" />입니다. 제공된 인수는 형식을 확인하고 인스턴스를 만드는 데 사용된 생성자를 바인딩하는 데 사용됩니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">비어 있지 않은 활성화 특성 배열이 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 형식에 전달됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">대리자의 인스턴스를 만들려고 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다.</param>
        <param name="typeName">형식의 전체 이름입니다.</param>
        <summary>어셈블리의 표시 이름에 의해 정규화된 형식의 이름을 만듭니다.</summary>
        <returns>어셈블리의 표시 이름으로 정규화된 이 형식의 전체 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 문자열의 형식은 다음과 같습니다.  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 참조 <xref:System.Reflection.AssemblyName> 에 대 한 설명은 형식의 어셈블리의 표시 이름입니다.  
  
 공용 언어 런타임의 버전에서 변경 내용에 맞추는, 직접 정규화 된 이름을 생성 하는 대신이 메서드를 사용 합니다.  정규화 된 어셈블리 이름에 대 한 정보를 참조 하십시오. <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 사용자 지정 특성을 포함하는 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리의 사용자 지정 특성을 포함하는 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리에 정의된 형식의 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리에 정의된 형식의 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A> 속성은 크기를 비교할는 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 메서드와 비슷하지만 <xref:System.Reflection.Assembly.DefinedTypes%2A> 속성의 컬렉션을 반환 <xref:System.Reflection.TypeInfo> 개체 및 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 메서드 배열을 반환 <xref:System.Type> 개체입니다.  
  
 반환된 된 배열에는 중첩 된 유형을 포함합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 진입점을 가져옵니다.</summary>
        <value>이 어셈블리의 진입점을 나타내는 개체입니다. 예를 들어 어셈블리가 DLL이어서 진입점을 찾을 수 없는 경우에는 <see langword="null" />이 반환됩니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">이 인스턴스와 비교할 개체입니다.</param>
        <summary>이 어셈블리와 지정된 개체가 서로 같은지 확인합니다.</summary>
        <returns>
          <see langword="true" />가 이 인스턴스와 같으면 <paramref name="o" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A> 메서드를 결정 하는 참조 같음 테스트를 수행 하는지 여부를 현재 인스턴스 및 `o` 같은지 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>코드베이스를 나타내는 URI를 가져옵니다(이스케이프 문자 포함).</summary>
        <value>이스케이프 문자를 포함하는 URI입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 증명을 가져옵니다.</summary>
        <value>이 어셈블리에 대한 증명 정보입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 증명 정보는 코드에 부여할 수 있는 권한 같이 보안 정책을 결정하기 위해 입력하는 정보 집합입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식의 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식의 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리의 표시 이름을 가져옵니다.</summary>
        <value>어셈블리의 표시 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 <xref:System.Reflection.AssemblyName> 에 대 한 설명은 형식의 어셈블리의 표시 이름입니다.  
  
> [!NOTE]
>  표시 이름을 구문 분석 하는 사용자 고유의 코드 작성 권장 되지 않습니다. 대신, 표시 이름에 전달 된 <xref:System.Reflection.AssemblyName.%23ctor%2A> 생성자를 구문 분석 하 고 새의 해당 필드를 채웁니다 <xref:System.Reflection.AssemblyName>합니다.  
  
 .NET Framework 버전 2.0의에서 프로세서 아키텍처 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 그러나 반환 하는 문자열에 포함 되지 됩니다는 <xref:System.Reflection.Assembly.FullName%2A> 호환성을 위해 속성입니다. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
   
  
## Examples  
 다음 예에서는 현재 실행 중인 어셈블리의 표시 이름 및 포함 된 어셈블리의 표시 이름을 검색는 <xref:System.Int32> 유형 (`int` C#에서는 `Integer` Visual basic에서).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">어셈블리에서 반환될 형식을 나타내는 개체입니다.</param>
        <summary>지정된 형식이 정의되어 있는 현재 로드된 어셈블리를 가져옵니다.</summary>
        <returns>지정된 형식이 정의되어 있는 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 호출의 값을 검색 하는 것은 <xref:System.Type.Assembly?displayProperty=nameWithType> 속성입니다. 그러나는 <xref:System.Type.Assembly?displayProperty=nameWithType> 속성에는 일반적으로 우수한 성능을 제공 합니다.  
  
 이 메서드를 호출 하려면 있어야는 <xref:System.Type> 개체 클래스 정의 되어 있는 어셈블리 이미 로드 되어 있어야 함을 의미 합니다.  
  
   
  
## Examples  
 포함 된 어셈블리를 검색 하는 다음 예제는 <xref:System.Int32> 입력 하 고 해당 이름 및 파일 위치를 표시 합니다.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 실행 중인 메서드를 호출한 메서드의 <see cref="T:System.Reflection.Assembly" />를 반환합니다.</summary>
        <returns>현재 실행 중인 메서드를 호출하는 메서드의 <see langword="Assembly" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 메서드는 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 메서드 타임 (JIT) 컴파일러에 의해 확장 된 인라인 하거나 호출자 인라인으로 확장 된 경우 어셈블리에서 반환 된 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 예기치 않게 다를 수 있습니다. 예를 들어, 다음 메서드 및 어셈블리 살펴보겠습니다.  
  
-   메서드 `M1` 어셈블리에 `A1` 호출 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>합니다.  
  
-   메서드 `M2` 어셈블리에 `A2` 호출 `M1`합니다.  
  
-   메서드 `M3` 어셈블리에 `A3` 호출 `M2`합니다.  
  
 때 `M1` 인라이닝 되지 않으면 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A2`합니다. 때 `M1` 인라인 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A3`합니다. 마찬가지로, `M2` 인라이닝 되지 않으면 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A2`합니다. 때 `M2` 인라인 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A3`합니다.  
  
 이 효과도 발생 때 `M1` 의 마무리 호출으로 실행 `M2`, 되거나 `M2` 의 마무리 호출으로 실행 `M3`합니다. JIT 컴파일러를 방지할 수 있습니다 인라인 호출 하는 메서드 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>를 적용 하 여는 <xref:System.Runtime.CompilerServices.MethodImplAttribute> 특성이 <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> 플래그를 마무리 호출을 방지 하는 비슷한 메커니즘이 있지만 합니다.  
  
   
  
## Examples  
 다음 예제에서는 현재 메서드의 호출 하는 어셈블리를 가져옵니다.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리에 대한 사용자 지정 특성을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">이 인수는 <see cref="T:System.Reflection.Assembly" /> 형식의 개체에 대해 무시됩니다.</param>
        <summary>이 어셈블리에 대한 사용자 지정 특성을 모두 가져옵니다.</summary>
        <returns>이 어셈블리에 대한 사용자 지정 특성이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 구현 하는 해당 <xref:System.Reflection.ICustomAttributeProvider> 인터페이스 메서드. 따라서는 `inherit` 매개 변수는 무시 하는 경우에 지정 해야 합니다.  
  
 의사 (pseudo) 특성의 특성이 있는 경우 설정 해야 하는 코어 메타 데이터의 비트를 나타냅니다. 유형에 대 한 메타 데이터를 확장 하 고는 형식과 함께 저장 하는 사용자 지정 특성을 달리 의사 (pseudo) 특성 유형에 대 한 메타 데이터를 변경 하 고 삭제 됩니다. 결과 비트는 일부 기존 리플렉션 Api를 사용 하 여 액세스할 수 없습니다.  
  
 다음 표에서 다른 의사 (pseudo) 속성 및 접근자 리플렉션에 사용할 수 있는 비트를 요약 합니다.  
  
|의사 (pseudo) 특성|메타 데이터 비트|리플렉션 접근자|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 이름|접근자가 없습니다 PInvokeMap 일반 메서드/전역 메서드 특성에 대 한 합니다.<br /><br /> DLL 이름에 대 한 접근자가 없습니다.|  
|GuidAttribute|실제 사용자 지정 특성으로 저장 합니다.|실제 사용자 지정 특성으로 액세스 합니다.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|다양 한 비트입니다.|접근자가 없습니다.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 클래스 압축 합니다.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 접근자가 없습니다.|  
|FieldOffsetAttribute|필드의 오프셋입니다.|접근자가 없습니다.|  
|AssemblyLoadAttribute|CorAssemblyFlags|접근자 또는 열거자입니다.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">사용자 지정 특성이 반환될 형식입니다.</param>
        <param name="inherit">이 인수는 <see cref="T:System.Reflection.Assembly" /> 형식의 개체에 대해 무시됩니다.</param>
        <summary>형식에 의해 지정된 대로, 이 어셈블리에 대한 사용자 지정 특성을 가져옵니다.</summary>
        <returns>
          <paramref name="attributeType" />에 의해 지정된 대로 이 어셈블리에 대한 사용자 지정 특성이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 구현 하는 해당 <xref:System.Reflection.ICustomAttributeProvider> 인터페이스 메서드. 따라서는 `inherit` 매개 변수는 무시 하는 경우에 지정 해야 합니다.  
  
 의사 (pseudo) 특성의 특성이 있는 경우 설정 해야 하는 코어 메타 데이터의 비트를 나타냅니다. 유형에 대 한 메타 데이터를 확장 하 고는 형식과 함께 저장 하는 사용자 지정 특성을 달리 의사 (pseudo) 특성 유형에 대 한 메타 데이터를 변경 하 고 삭제 됩니다. 결과 비트는 일부 기존 리플렉션 Api를 사용 하 여 액세스할 수 없습니다.  
  
 다음 표에서 다른 의사 (pseudo) 속성 및 접근자 리플렉션에 사용할 수 있는 비트를 요약 합니다.  
  
|의사 (pseudo) 특성|메타 데이터 비트|리플렉션 접근자|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 이름|접근자가 없습니다 PInvokeMap 일반 메서드/전역 메서드 특성에 대 한 합니다.<br /><br /> DLL 이름에 대 한 접근자가 없습니다.|  
|GuidAttribute|실제 사용자 지정 특성으로 저장 합니다.|실제 사용자 지정 특성으로 액세스 합니다.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|다양 한 비트입니다.|접근자가 없습니다.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 클래스 압축 합니다.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 접근자가 없습니다.|  
|FieldOffsetAttribute|필드의 오프셋입니다.|접근자가 없습니다.|  
|AssemblyLoadAttribute|CorAssemblyFlags|접근자 또는 열거자입니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />이 런타임 형식이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> 개체로 표현되는, 현재 <see cref="T:System.Reflection.CustomAttributeData" />에 적용된 특성 관련 정보를 반환합니다.</summary>
        <returns>현재 어셈블리에 적용된 특성에 대한 데이터를 나타내는 <see cref="T:System.Reflection.CustomAttributeData" /> 개체의 제네릭 목록입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리플렉션 전용 컨텍스트에 사용자 지정 특성 자체 리플렉션 전용 컨텍스트로 로드 된 코드에 정의 되어 있는 경우 코드의 한 사용자 지정 특성을 검사 하려면이 메서드를 사용 합니다. 와 같은 메서드 <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> 특성의 인스턴스를 만들기 때문에 이러한 경우에 사용할 수 없습니다. 리플렉션 전용 컨텍스트에서 코드를 실행할 수 없습니다. 자세한 내용 및 예를 들어 코드를 실행 하는 것에 대 한 참조는 <xref:System.Reflection.CustomAttributeData> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 응용 프로그램 도메인에 있는 프로세스 실행 파일을 가져옵니다. 이 실행 파일은 다른 응용 프로그램 도메인에서 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />에 의해 실행된 첫 번째 실행 파일입니다.</summary>
        <returns>어셈블리는 기본 응용 프로그램 도메인에 있는 프로세스 실행 파일이거나 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />에 의해 실행된 첫 번째 실행 파일입니다. 비관리 코드에서 호출한 경우에는 <see langword="null" />이 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 메서드가 반환할 수 `null` 때 관리 되는 어셈블리는 관리 되지 않는 응용 프로그램에서 로드 되었습니다. 예를 들어, 관리 되지 않는 응용 프로그램의 C#에 대 한 호출에서 작성 된 COM 구성 요소 인스턴스를 만드는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 프로세스에 대 한 진입점 관리 되는 어셈블리 보다는 비관리 코드 때문에 C# 구성 요소에 있는 메서드의 null을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 실행 중인 코드가 포함된 어셈블리를 가져옵니다.</summary>
        <returns>현재 실행 중인 코드가 포함된 어셈블리를 가져옵니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 성능상의 이유로 모르는 디자인 타임에는 어셈블리는 현재 실행 하는 경우에이 메서드를 호출 해야 합니다. 검색 하는 것이 좋습니다는 <xref:System.Reflection.Assembly> 현재 어셈블리를 나타내는 개체를 사용 하는 것은 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 다음 예제와 같이, 어셈블리에서 발견 되는 형식의 속성입니다.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 현재 실행 중인 코드 라고 하는 메서드를 포함 하는 어셈블리를 가져오려면 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 해당 어셈블리에 포함 된 형식에 따라 현재 실행 중인 어셈블리를 가져올 속성입니다. 호출 또한는 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 반환 하는 것을 표시 하는 <xref:System.Reflection.Assembly> 동일한 어셈블리를 나타내는 개체입니다.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식을 가져옵니다.</summary>
        <returns>이 어셈블리에 정의되어 있고 어셈블리 외부에서 볼 수 있는 형식을 나타내는 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리 외부에 표시 되는 유일한 형식 public 형식 및 다른 공용 형식에 중첩 된 public 형식이 됩니다.  
  
   
  
## Examples  
 다양 한 액세스 수준 및 호출을 사용 하 여 클래스의 수를 정의 하는 다음 코드 샘플 <xref:System.Reflection.Assembly.GetExportedTypes%2A> 어셈블리 외부에 표시 되는 것을 표시 합니다.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">어셈블리가 동적 어셈블리입니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">종속 어셈블리를 로드할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">지정된 파일의 이름입니다. 파일 경로는 포함하지 않습니다.</param>
        <summary>이 어셈블리의 매니페스트 파일 테이블에서 지정된 파일에 대한 <see cref="T:System.IO.FileStream" />을 가져옵니다.</summary>
        <returns>파일이 없는 경우 지정된 파일 또는 <see langword="null" />을 포함하는 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 및 개인 리소스 파일을 모두에서 작동합니다.  
  
 `name` 파일 경로가 포함 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 지정된 된 파일 읽기에 대 한 액세스 권한입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리 매니페스트의 파일 테이블에 있는 파일을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>어셈블리 매니페스트의 파일 테이블에 있는 파일을 가져옵니다.</summary>
        <returns>파일을 포함하는 스트림의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 공용 및 개인 리소스 파일에 적용 합니다.  
  
 이 오버 로드는 호출에 해당 하는 <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> 오버 로드를 지정 하 고 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">파일이 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>리소스 모듈의 포함 여부를 지정하여 어셈블리 매니페스트의 파일 테이블에서 파일을 가져옵니다.</summary>
        <returns>파일을 포함하는 스트림의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 공용 및 개인 리소스 파일에 적용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">파일이 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리의 일부인 로드된 모듈을 모두 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리의 일부인 로드된 모듈을 모두 가져옵니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>이 어셈블리의 일부인 로드된 모듈을 모두 가져오며 리소스 모듈의 포함 여부를 지정합니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">리소스의 이름(대/소문자 구분)입니다.</param>
        <summary>지정된 리소스가 지속되는 방법에 대한 정보를 반환합니다.</summary>
        <returns>리소스의 토폴로지에 대한 정보로 채워진 개체이거나, 리소스를 찾을 수 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출자에 게 표시 되는 리소스 또는 호출자에 게 하는 경우에 리소스 정보가 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 있는 모든 리소스의 이름을 반환합니다.</summary>
        <returns>모든 리소스의 이름이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음과 같이이 메서드에서 반환 된 배열에 있는 각 리소스 이름을 사용할 수 있습니다.  
  
-   리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> 메서드는 리소스에 대 한 추가 정보를 가져옵니다.  
  
-   .Resources 파일 확장명을 제거 하 고에 전달 이름의 이진.resources 파일로으로 식별 한 경우는 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> 를 리소스 관리자를 인스턴스화하는 생성자입니다.  
  
-   리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 를 검색할 메서드는 <xref:System.IO.Stream> 에 전달할 수 있는 개체는 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 생성자입니다.  
  
-   리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 를 검색할 메서드는 <xref:System.IO.Stream> 에 전달할 수 있는 개체는 <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 생성자입니다.  
  
 호출자에 게 표시 되는 리소스 또는 호출자에 게 하는 경우에 리소스 정보가 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">요청된 매니페스트 리소스의 이름(대/소문자 구분)입니다.</param>
        <summary>지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</summary>
        <returns>매니페스트 리소스이거나 컴파일하는 동안 리소스가 지정되지 않은 경우 또는 호출자가 리소스를 볼 수 없는 경우에는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매니페스트 리소스는 컴파일 타임에 어셈블리에 포함 된 리소스 (예: 이미지 파일). 매니페스트 리소스에 대 한 자세한 내용은 참조 [Microsoft.NET Framework 리소스 기본 사항](http://go.microsoft.com/fwlink/?LinkId=204554) MSDN 라이브러리에서.  
  
 호출자에 게 표시 되는 리소스 또는 호출자에 게 하는 경우에 리소스 정보가 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
> [!NOTE]
>  이 메서드가 반환 `null` 다른 어셈블리의 개인 리소스에 액세스 하 고 호출자에 게 없는 경우 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.  
  
 어셈블리 매니페스트 리소스 파일을 나열 하는 경우 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 반환는 <xref:System.IO.Stream> 시간에 디스크에 리소스 파일을 찾을 수 없는 경우에 개체입니다. 리소스 파일을 찾을 수 없습니다, 전달 하는 경우 결과 <xref:System.IO.Stream> 개체는 <xref:System.Resources.ResourceReader> 생성자에 의해는 <xref:System.ArgumentException>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>[Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 대신 catch합니다.  </para>
          </block>  찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
        <exception cref="T:System.NotImplementedException">리소스 길이는 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">해당 네임스페이스가 매니페스트 리소스 이름의 범위를 지정하는 데 사용된 형식입니다.</param>
        <param name="name">요청된 매니페스트 리소스의 이름(대/소문자 구분)입니다.</param>
        <summary>지정된 형식의 네임스페이스에 의해 범위가 지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</summary>
        <returns>매니페스트 리소스이거나 컴파일하는 동안 리소스가 지정되지 않은 경우 또는 호출자가 리소스를 볼 수 없는 경우에는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 전체 이름을 지정 하는 경우 등 `type` "MyNameSpace.MyClasses"은 및 `name` 는 "Net",이 메서드 검색 "MyNameSpace.Net" 라는 리소스에 대 한 오버 로드 합니다.  
  
 매니페스트 리소스는 컴파일 타임에 어셈블리에 포함 된 리소스 (예: 이미지 파일). 매니페스트 리소스에 대 한 자세한 내용은 참조 [Microsoft.NET Framework 리소스 기본 사항](http://go.microsoft.com/fwlink/?LinkId=204554) MSDN 라이브러리에서.  
  
 호출자에 게 표시 되는 리소스 또는 호출자에 게 하는 경우에 리소스 정보가 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
> [!NOTE]
>  이 메서드가 반환 `null` 다른 어셈블리의 개인 리소스에 액세스 하 고 호출자에 게 없는 경우 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.  
  
 어셈블리 매니페스트 리소스 파일을 나열 하는 경우 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 반환는 <xref:System.IO.Stream> 시간에 디스크에 리소스 파일을 찾을 수 없는 경우에 개체입니다. 리소스 파일을 찾을 수 없습니다, 전달 하는 경우 결과 <xref:System.IO.Stream> 개체는 <xref:System.Resources.ResourceReader> 생성자에 의해는 <xref:System.ArgumentException>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
        <exception cref="T:System.NotImplementedException">리소스 길이는 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">요청되는 모듈의 이름입니다.</param>
        <summary>이 어셈블리에 있는 지정된 모듈을 가져옵니다.</summary>
        <returns>요청되는 모듈 또는 모듈이 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 파일 이름에 적용 합니다.  
  
 에 있는 클래스는 `Reflection.Emit` 네임 스페이스 범위 이름을 동적 모듈에 대 한를 내보냅니다. 범위 이름으로 확인할 수 있습니다는 <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> 속성입니다. 종류를 모듈의 전달 `Assembly.GetModule`합니다. 예를 들어 어셈블리 매니페스트가 포함 된 모듈을 사용 하도록 하려는 경우 모듈의 범위 이름을 전달 `GetModule`합니다. 그렇지 않은 경우 모듈의 파일 이름을 전달 합니다. 중 하나에 의해 로드 된 어셈블리는 `Load` byte 매개 변수를 가진 메서드를 하나만 모듈 있고 매니페스트 모듈입니다. 항상 범위 이름을 사용 하 여 이러한 모듈을 검색 합니다.  
  
 형식을 사용 하 여 특정 모듈에서 검색할 수 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>합니다. 호출 `Module.GetType` 모듈 매니페스트를 포함 하는 시작 하지 전체 어셈블리에 대해 검색 합니다. 어떤 있는 모듈을이 어셈블리에서 형식을 검색 하려면 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리의 일부인 모듈을 모두 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리의 일부인 모듈을 모두 가져옵니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 공용 및 개인 리소스 파일에 적용 합니다.  
  
> [!NOTE]
>  모듈 파일 이름 확장명을 가진 내보내야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 어셈블리 매니페스트가 포함 된 반환된 된 배열에는 모듈의 이름을 표시 합니다.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">로드할 모듈은 파일 이름 확장명을 지정하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>이 어셈블리의 일부인 모듈을 모두 가져오며 리소스 모듈의 포함 여부를 지정합니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 공용 및 개인 리소스 파일에 적용 합니다.  
  
> [!NOTE]
>  모듈 파일 이름 확장명을 가진 내보내야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져옵니다.</summary>
        <returns>이 어셈블리에 대해 완전히 구문 분석된 표시 이름을 포함하는 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">어셈블리의 경로에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">어셈블리를 섀도 복사한 후 <see langword="true" />를 어셈블리 위치로 설정하려면 <see cref="P:System.Reflection.Assembly.CodeBase" />이고, <see langword="false" />를 원래 위치로 설정하려면 <see cref="P:System.Reflection.Assembly.CodeBase" />입니다.</param>
        <summary>이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져오며 <paramref name="copiedName" />에 의해 지정된 대로 코드베이스를 설정합니다.</summary>
        <returns>이 어셈블리에 대해 완전히 구문 분석된 표시 이름을 포함하는 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">어셈블리의 경로에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">serialization 정보로 채울 개체입니다.</param>
        <param name="context">serialization의 대상 컨텍스트입니다.</param>
        <summary>이 어셈블리를 다시 인스턴스화하는 데 필요한 데이터가 모두 포함된 serialization 정보를 가져옵니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리가 참조하는 모든 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" /> 개체를 가져옵니다.</summary>
        <returns>이 어셈블리가 참조하는 모든 어셈블리의 완전 구문 분석된 표시 이름이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 속성은 <xref:System.Reflection.AssemblyName> 이 메서드에 의해 반환 되는 개체는 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> 참조 된 어셈블리에 대 한 해시 알고리즘이 없는 또는 참조 된 어셈블리의 해시 알고리즘 없는 경우 로 식별 되는 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> 열거형입니다. 이전 버전의.NET Framework에는 <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 반환 된 속성 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> 이 상황에서.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출은 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> 메서드. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Assembly> 클래스입니다.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>위성 어셈블리를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">지정된 문화권입니다.</param>
        <summary>지정된 문화권에 대한 위성 어셈블리를 가져옵니다.</summary>
        <returns>지정된 위성 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위성 어셈블리는 기본 문화권 이나 중립 문화권으로 사용 되는 단일 문화권에 대 한 리소스와 지역화할 수 없는 실행 코드가 포함 되어 있는 기본 응용 프로그램 어셈블리와 구별 하 여 지역화 된 리소스를 포함 합니다.  
  
 현재 어셈블리 버전을 사용 하려면이 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">일치하는 파일 이름을 가진 위성 어셈블리는 있지만 <see langword="CultureInfo" />가 지정된 어셈블리와 일치하지 않는 경우</exception>
        <exception cref="T:System.BadImageFormatException">위성 어셈블리가 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">지정된 문화권입니다.</param>
        <param name="version">위성 어셈블리의 버전입니다.</param>
        <summary>지정된 문화권에 대한 지정된 버전의 위성 어셈블리를 가져옵니다.</summary>
        <returns>지정된 위성 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위성 어셈블리는 기본 문화권 이나 중립 문화권으로 사용 되는 단일 문화권에 대 한 리소스와 지역화할 수 없는 실행 코드가 포함 되어 있는 기본 응용 프로그램 어셈블리와 구별 하 여 지역화 된 리소스를 포함 합니다.  
  
 호출 된 <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> 현재 어셈블리 버전을 사용 하는 오버 로드 합니다.  
  
 경우 `version` 은 `null`, 리소스와 주 어셈블리 서명 된 경우에 현재 어셈블리 버전이 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileLoadException">일치하는 파일 이름을 가진 위성 어셈블리는 있지만 <see langword="CultureInfo" /> 또는 버전이 지정된 어셈블리와 일치하지 않는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">위성 어셈블리가 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">형식의 전체 이름입니다.</param>
        <summary>어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
        <returns>지정된 클래스를 나타내는 개체이며 클래스가 없는 경우 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 어셈블리 인스턴스만을 검색합니다. `name` 네임 스페이스만 어셈블리가 아니라 매개 변수를 포함 합니다. 유형에 대 한 다른 어셈블리를 검색 하려면 사용 하 여는 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 포함 될 수 있습니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리에 전달 되었습니다, 하더라도이 메서드에 의해 반환 됩니다. 형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 추상 `MeansOfTransportation` 클래스에 `Transportation` 네임 스페이스입니다. 호출의 <xref:System.Reflection.Assembly.GetType%28System.String%29> 를 검색할 메서드 해당 <xref:System.Type> 개체, 호출은 <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> 배열을 가져올 메서드를 <xref:System.Reflection.PropertyInfo> 형식의에 정보를 표시 한 다음 형식의 속성을 나타내는 개체 속성을 추상화 합니다. 에 대 한 호출에서 <xref:System.Reflection.Assembly.GetType%28System.String%29> 메서드는 형식의 정규화 된 이름 (즉, 해당 네임 스페이스의 형식 이름과 함께)을 사용 합니다.  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>[Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 대신 catch합니다. </para>
          </block>
          <paramref name="name" />이 종속 어셈블리를 찾았지만 로드할 수 없습니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">형식의 전체 이름입니다.</param>
        <param name="throwOnError">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</param>
        <summary>어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져오고, 형식을 찾을 수 없는 경우 선택적으로 예외를 throw합니다.</summary>
        <returns>지정된 클래스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 어셈블리 인스턴스만을 검색합니다. `name` 네임 스페이스만 어셈블리가 아니라 매개 변수를 포함 합니다. 유형에 대 한 다른 어셈블리를 검색 하려면 사용 하 여는 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 포함 될 수 있습니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리에 전달 되었습니다, 하더라도이 메서드에 의해 반환 됩니다. 형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
 `throwOnError` 매개 변수 형식의 찾을 수 없을 때 어떤 일이 생기만 적용 됩니다. 다른 모든 예외가 throw 될 수 있는 영향을 주지 않습니다. 특히, 형식을 찾았지만 로드할 수 없으면 <xref:System.TypeLoadException> throw 될 수 있는 경우에 `throwOnError` 은 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 잘못되었습니다.  -또는-  <paramref name="name" />의 길이가 1024자를 초과합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">형식의 전체 이름입니다.</param>
        <param name="throwOnError">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</param>
        <param name="ignoreCase">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 무시할지 여부와 형식이 없으면 예외를 throw할지를 선택적으로 지정하여 어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
        <returns>지정된 클래스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 어셈블리 인스턴스만을 검색합니다. `name` 네임 스페이스만 어셈블리가 아니라 매개 변수를 포함 합니다. 유형에 대 한 다른 어셈블리를 검색 하려면 사용 하 여는 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 포함 될 수 있습니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리에 전달 되었습니다, 하더라도이 메서드에 의해 반환 됩니다. 형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
 `throwOnError` 매개 변수 형식의 찾을 수 없을 때 어떤 일이 생기만 적용 됩니다. 다른 모든 예외가 throw 될 수 있는 영향을 주지 않습니다. 특히, 형식을 찾았지만 로드할 수 없으면 <xref:System.TypeLoadException> throw 될 수 있는 경우에 `throwOnError` 은 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 잘못되었습니다.  -또는-  <paramref name="name" />의 길이가 1024자를 초과합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  -또는-  현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 정의되어 있는 형식을 가져옵니다.</summary>
        <returns>이 어셈블리에 정의되어 있는 모든 형식이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 배열에는 중첩 된 유형을 포함합니다.  
  
 경우는 <xref:System.Reflection.Assembly.GetTypes%2A> 메서드는 어셈블리 및 형식에 어셈블리가 로드 되지 않은 (예를 들어 경우 두 번째 어셈블리의 형식에서 파생), 어셈블리의 유형에 따라 달라 한다는 점에서 <xref:System.Reflection.ReflectionTypeLoadException> throw 됩니다. 예를 들어 이러한 경우 첫 번째 어셈블리와 함께 로드 하는 데는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 또는 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드 및 두 번째 어셈블리를 로드 하지 못했습니다. 발생할 수도 있습니다. 사용 하 여 로드 된 어셈블리는 <xref:System.Reflection.Assembly.Load%2A> 및 <xref:System.Reflection.Assembly.LoadFile%2A> 두 번째 어셈블리를 찾을 수 없으면 경우 메서드는 <xref:System.Reflection.Assembly.GetTypes%2A> 메서드를 호출 합니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리에 전달 되었습니다, 반환된 된 배열에 포함 되지 않습니다. 형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
 컬렉션을 검색 하려면 <xref:System.Reflection.TypeInfo> 개체의 배열 하는 대신 <xref:System.Type> 개체를 사용 하 여는 <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 어셈블리의 형식에에서 대 한 메서드의 매개 변수를 표시합니다.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">어셈블리에 로드할 수 없는 하나 이상의 형식이 포함되어 있습니다. <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 속성에는 로드할 수 없는 각 형식에 대한 예외가 포함되어 있으나, 이 예외의 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 속성에 의해 반환된 배열에는 로드된 각 형식에 대한 <see cref="T:System.Type" /> 개체 및 로드할 수 없는 각 형식에 대한 <see langword="null" /> 개체가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리를 전역 어셈블리 캐시에서 로드했는지를 나타내는 값을 가져옵니다.</summary>
        <value>어셈블리를 전역 어셈블리 캐시에서 로드했으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리를 로드하는 데 사용된 호스트 컨텍스트를 가져옵니다.</summary>
        <value>어셈블리를 로드하는 데 사용된 호스트 컨텍스트가 있을 경우 호스트 컨텍스트를 나타내는 <see cref="T:System.Int64" /> 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>매니페스트가 포함된 파일에 저장된 CLR(공용 언어 런타임) 버전을 나타내는 문자열을 가져옵니다.</summary>
        <value>CLR 버전 폴더 이름입니다. 이 값은 전체 경로가 아닙니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어.NET Framework 버전 1.1에 대 한 값 v1.1.4322 것입니다. 해당 버전에 대 한 이진 파일 경로 %windir%\Microsoft.NET\Framework\v1.1.4322 있을 것입니다.  
  
 기본적으로 <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> 어셈블리를 빌드하는 데 사용 하는 CLR의 버전으로 설정 합니다. 그러나이 설정 되어 다른 값으로 컴파일 타임에 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">이 어셈블리에 대해 확인할 특성의 형식입니다.</param>
        <param name="inherit">이 인수는 이 형식의 개체에 대해 무시됩니다.</param>
        <summary>지정된 특성이 어셈블리에 적용되었는지를 나타냅니다.</summary>
        <returns>특성이 어셈블리에 적용되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 적용는 <xref:System.Reflection.AssemblyTitleAttribute> 특성을 어셈블리 및 사용 하 여 <xref:System.Reflection.Assembly.IsDefined%2A> 적용 되었는지 여부를 나타냅니다. 또한 적용 되지 않은 특성을 테스트 합니다.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />에 잘못된 형식이 사용된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리가 현재 프로세스에서 리플렉션 내보내기를 사용하여 동적으로 생성되었는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 어셈블리가 현재 프로세스에서 동적으로 생성되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리는 파생된 클래스에 의해 표현 됩니다 <xref:System.Reflection.Emit.AssemblyBuilder>합니다.  
  
 동적 어셈블리를 디스크에 저장된 된 어셈블리에 저장 될 때 동적입니다. 저장 된 어셈블리는 다른 응용 프로그램 도메인 또는 프로세스에 로드 하는 경우는 <xref:System.Reflection.Assembly.IsDynamic%2A> 속성에서 반환 `false`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리가 완전히 신뢰되어 로드되는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 어셈블리가 완전히 신뢰되어 로드되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리를 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <summary>내보낸 어셈블리가 포함된 COFF(Common Object File Format) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 호출 어셈블리의 신뢰 수준을와 같습니다. 사용 하 여 응용 프로그램 도메인의 신뢰 수준으로 바이트 배열에서 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 메서드 오버 로드 합니다. 오버 로드를 통해 증명 정보를 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 방법을 참조는 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 메서드 오버 로드 합니다.  
  
 C + + 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.BadImageFormatException>합니다. 이 주로 발생 재배치 주소는 c + + 컴파일러가 또는 `.reloc` 실행 파일에서 섹션. 유지 하기 위해는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 이 메서드 오버 로드 항상 생성 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">로드될 어셈블리를 설명하는 개체입니다.</param>
        <summary>해당 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 이 throw 됩니다 `assemblyRef` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 단순한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.  
  
> [!NOTE]
>  사용 하지 않는 <xref:System.Reflection.AssemblyName> 으로 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 집합입니다. <xref:System.Reflection.AssemblyName.CodeBase%2A> 요소를 모두 제공 하지 않는 어셈블리 id는 (예: 이름 또는 버전)의 로드가 발생 하지 않습니다 부하 id 별 규칙에 따라에서 예상한 대로 <xref:System.Reflection.Assembly.Load%2A> 메서드. 대신, 어셈블리에서 로드 한 규칙을 사용 하 여 로드 됩니다. 로드 컨텍스트를 사용 하 여의 단점에 대 한 정보를 참조 하십시오.는 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드 오버 로드 또는 [어셈블리 로드에 대 한 유용한](~/docs/framework/deployment/best-practices-for-assembly-loading.md)합니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 없이 <xref:System.Security.Policy.Evidence> 매개 변수를이 어셈블리는 로더가 제공 하는 증거와 함께 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 공용 개체 파일 형식 (COFF) 이미지에 대 한 증명 정보를 로드 하는 매개 변수는 호출 하는 어셈블리에서 상속 됩니다. 이.NET Framework 버전 1.1에 적용 됩니다 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 s p 1 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 결합 되어 매개 변수를 증명 COFF 이미지를 로드 합니다. `Zone``Url` 및 `Site` 호출 하는 어셈블리에서 상속 된 및 `Hash` 및 `StrongName` COFF 어셈블리에서 가져옵니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 하는 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.BadImageFormatException>합니다. 이 주로 발생 재배치 주소는 c + + 컴파일러가 또는 `.reloc` 실행 파일에서 섹션. 유지 하기 위해는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
> [!NOTE]
>  모두는 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 속성이 설정 되어, 어셈블리를 로드할 첫 번째 시도 표시 이름을 사용 하 여 (에서 반환 된 버전, 문화권 및 등을 포함 하는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성). 파일이 없는 경우 <xref:System.Reflection.AssemblyName.CodeBase%2A> 어셈블리를 검색 하는 데 사용 됩니다. 사용 하는 어셈블리가 있는 경우 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름은 어셈블리와 일치 합니다. 일치가 실패 하면는 <xref:System.IO.FileLoadException> throw 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Reflection.AssemblyName> 개체를 사용 하 여 로드 하는 `sysglobal.dll` 어셈블리입니다. 그런 다음 어셈블리의 공용 형식의 전체 이름을 표시 합니다.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" />가 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>[Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 대신 catch합니다.  </para>
          </block>  찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다. -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />가 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">긴 형식의 어셈블리 이름입니다.</param>
        <summary>긴 형식의 이름으로 지정된 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 형식의 어셈블리 이름 (예: "System" System.dll 어셈블리에 대 한)의 버전, culture, 공개 키 토큰 및 선택적으로 프로세서 아키텍처와 함께 간단한 이름은 이루어져 있습니다. 에 어셈블리의 해당 <xref:System.Reflection.Assembly.FullName%2A> 속성입니다. 다음 예제에서는.NET Framework 4에 대 한 System.dll 어셈블리를 로드 하는 긴 이름 사용을 예를 보여줍니다.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> 이 throw 됩니다 `assemblyString` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 단순한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 없이 <xref:System.Security.Policy.Evidence> 매개 변수를이 어셈블리는 로더가 제공 하는 증거와 함께 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 공용 개체 파일 형식 (COFF) 이미지에 대 한 증명 정보를 로드 하는 매개 변수는 호출 하는 어셈블리에서 상속 됩니다. 이.NET Framework 버전 1.1에 적용 됩니다 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 s p 1 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 결합 되어 매개 변수를 증명 COFF 이미지를 로드 합니다. `Zone``Url` 및 `Site` 호출 하는 어셈블리에서 상속 된 및 `Hash` 및 `StrongName` COFF 어셈블리에서 가져옵니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 하는 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.BadImageFormatException>합니다. 이 주로 발생 재배치 주소는 c + + 컴파일러가 또는 `.reloc` 실행 파일에서 섹션. 유지 하기 위해는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 .NET Framework 버전 2.0의에서 프로세서 아키텍처 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어 "ProcessorArchitecture = msil"입니다. 그러나 어셈블리 이름을 지정 하는 권장된 방법은 만드는 것는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 정규화 된 이름, 어셈블리를 로드 하 고 지정된 된 어셈블리에 포함 된 모든 형식을 나열 합니다. 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />이 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</param>
        <summary>생성된 어셈블리가 들어 있고 경우에 따라 어셈블리에 대한 기호도 포함하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 호출 어셈블리의 신뢰 수준을와 같습니다. 사용 하 여 응용 프로그램 도메인의 신뢰 수준으로 바이트 배열에서 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 메서드 오버 로드 합니다. 오버 로드를 통해 증명 정보를 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 방법을 참조는 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 메서드 오버 로드 합니다.  
  
 C + + 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.BadImageFormatException>합니다. 이 주로 발생 재배치 주소는 c + + 컴파일러가 또는 `.reloc` 실행 파일에서 섹션. 유지 하기 위해는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 이 메서드 오버 로드 항상 생성 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">로드될 어셈블리를 설명하는 개체입니다.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>해당 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 로드합니다. 어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 이 throw 됩니다 `assemblyRef` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 단순한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.  
  
> [!NOTE]
>  사용 하지 않는 <xref:System.Reflection.AssemblyName> 으로 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 집합입니다. <xref:System.Reflection.AssemblyName.CodeBase%2A> 요소를 모두 제공 하지 않는 어셈블리 id는 (예: 이름 또는 버전)의 로드가 발생 하지 않습니다 부하 id 별 규칙에 따라에서 예상한 대로 <xref:System.Reflection.Assembly.Load%2A> 메서드. 대신, 어셈블리에서 로드 한 규칙을 사용 하 여 로드 됩니다. 로드 컨텍스트를 사용 하 여의 단점에 대 한 정보를 참조 하십시오.는 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드 오버 로드 또는 [어셈블리 로드에 대 한 유용한](~/docs/framework/deployment/best-practices-for-assembly-loading.md)합니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 없이 <xref:System.Security.Policy.Evidence> 매개 변수를이 어셈블리는 로더가 제공 하는 증거와 함께 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 공용 개체 파일 형식 (COFF) 이미지에 대 한 증명 정보를 로드 하는 매개 변수는 호출 하는 어셈블리에서 상속 됩니다. 이.NET Framework 버전 1.1에 적용 됩니다 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 s p 1 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 결합 되어 매개 변수를 증명 COFF 이미지를 로드 합니다. `Zone``Url` 및 `Site` 호출 하는 어셈블리에서 상속 된 및 `Hash` 및 `StrongName` COFF 어셈블리에서 가져옵니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 하는 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.BadImageFormatException>합니다. 이 주로 발생 재배치 주소는 c + + 컴파일러가 또는 `.reloc` 실행 파일에서 섹션. 유지 하기 위해는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
> [!NOTE]
>  모두는 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 속성이 설정 되어, 어셈블리를 로드할 첫 번째 시도 표시 이름을 사용 하 여 (에서 반환 된 버전, 문화권 및 등을 포함 하는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성). 파일이 없는 경우 <xref:System.Reflection.AssemblyName.CodeBase%2A> 어셈블리를 검색 하는 데 사용 됩니다. 사용 하는 어셈블리가 있는 경우 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름은 어셈블리와 일치 합니다. 일치가 실패 하면는 <xref:System.IO.FileLoadException> throw 됩니다.  
  
 호출 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 한 번만 같은 어셈블리에 있지만 지정 된 다른 증명 공용 언어 런타임에서 throw 하지 않는 이상는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성 수 없기 때문에 확인 했습니다. 처음에 성공 하는 증명 정보에 사용 되는 증명 정보가입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">어셈블리의 표시 이름입니다.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>해당 표시 이름이 지정된 어셈블리를 로드한 다음 제공된 증명을 사용하여 이 어셈블리를 호출자의 도메인에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 이 throw 됩니다 `assemblyString` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 단순한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 없이 <xref:System.Security.Policy.Evidence> 매개 변수를이 어셈블리는 로더가 제공 하는 증거와 함께 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 공용 개체 파일 형식 (COFF) 이미지에 대 한 증명 정보를 로드 하는 매개 변수는 호출 하는 어셈블리에서 상속 됩니다. 이.NET Framework 버전 1.1에 적용 됩니다 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 s p 1 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 결합 되어 매개 변수를 증명 COFF 이미지를 로드 합니다. `Zone``Url` 및 `Site` 호출 하는 어셈블리에서 상속 된 및 `Hash` 및 `StrongName` COFF 어셈블리에서 가져옵니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 하는 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.BadImageFormatException>합니다. 이 주로 발생 재배치 주소는 c + + 컴파일러가 또는 `.reloc` 실행 파일에서 섹션. 유지 하기 위해는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 이 메서드를 호출 하면 두 번 이상 지정 된 다른 증명 하지만 동일한 어셈블리에서 공용 언어 런타임에서 throw 하지 않는 한 <xref:System.IO.FileLoadException> 같음와 다른 증명 사양의 무결성을 확인할 수 없습니다. 처음에 성공 하는 증명 정보에 사용 되는 증명 정보가입니다.  
  
 .NET Framework 버전 2.0의에서 프로세서 아키텍처 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어 "ProcessorArchitecture = msil"입니다. 그러나 어셈블리 이름을 지정 하는 권장된 방법은 만드는 것는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.  -또는-  어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>생성된 어셈블리가 들어 있고 경우에 따라 어셈블리에 대한 기호 및 증명 정보도 포함하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다. 어셈블리의 기호를 나타내는 원시 바이트도 로드 됩니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 없이 <xref:System.Security.Policy.Evidence> 매개 변수를이 어셈블리는 로더가 제공 하는 증거와 함께 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 매개 변수 증거 COFF 이미지를 로드를 호출 하는 어셈블리에서 상속 됩니다. 이.NET Framework 버전 1.1에 적용 됩니다 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 s p 1 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드와는 `Byte[]` 결합 되어 매개 변수를 증명 COFF 이미지를 로드 합니다. `Zone``Url` 및 `Site` 호출 하는 어셈블리에서 상속 된 및 `Hash` 및 `StrongName` COFF 어셈블리에서 가져옵니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 하는 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.BadImageFormatException>합니다. 이 주로 발생 재배치 주소는 c + + 컴파일러가 또는 `.reloc` 실행 파일에서 섹션. 유지 하기 위해는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 호출 하는 경우는 [\], 바이트\<xref:System.Reflection.Assembly.Load%2A > 메서드를 한 번만 같은 어셈블리에 있지만 지정 된 다른 증명 공용 언어 런타임에서 throw 하지 않는 이상는 <xref:System.IO.FileLoadException> 때문에 같음 및 다른 증명 사양의 무결성을 확인할 수 없습니다. 처음에 성공 하는 증명 정보에 사용 되는 증명 정보가입니다.  
  
 이 메서드 오버 로드 항상 생성 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다.  기본적으로 레거시 CAS 정책은 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 활성화되지 않습니다. 활성화되지 않은 경우 <paramref name="securityEvidence" />는 <see langword="null" />이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공할 수 있습니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</param>
        <param name="securityContextSource">보안 컨텍스트의 소스입니다.</param>
        <summary>생성된 어셈블리가 들어 있고 경우에 따라 기호도 포함하고 보안 컨텍스트의 소스도 지정하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리 보안 컨텍스트에 대 한 지정된 된 소스를 사용 하 여 호출자의 응용 프로그램 도메인에 로드 됩니다. 경우 `rawSymbolStore` 지정는 어셈블리에 대 한 기호를 나타내는 원시 바이트도 로드 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="rawAssembly" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" />의 값이 열거형 값 중 하나가 아닌 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리 파일의 내용을 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">로드할 파일의 정규화된 경로입니다.</param>
        <summary>지정된 경로에 있는 어셈블리 파일의 내용을 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드 로드 하 고 id가 동일 하지만 다른 경로에 있는 어셈블리를 검사 합니다.<xref:System.Reflection.Assembly.LoadFile%2A> 로드 컨텍스트로 파일 로드 되지 않으며으로 로드 경로 사용 하 여 종속성을 해결 되지 않으면는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드 수행 하지 않습니다. <xref:System.Reflection.Assembly.LoadFile%2A> 이 제한 된 시나리오에서 유용 하기 때문에 <xref:System.Reflection.Assembly.LoadFrom%2A> 어셈블리를 로드 하는 데 사용 될 수 없습니다 서로 다른 경로 다르지만 동일한 id를 첫 번째 로드를 이러한 어셈블리입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 인수는 절대 경로가 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 매개 변수가 빈 문자열("")이거나 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="path" />가 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">어셈블리 파일의 정규화된 경로입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>경로가 지정된 어셈블리를 로드한 다음 제공된 증명 정보를 사용하여 이 어셈블리를 호출자의 도메인에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드 로드 하 고 id가 동일 하지만 다른 경로에 있는 어셈블리를 검사 합니다. <xref:System.Reflection.Assembly.LoadFile%2A> 파일을 로드 하지 않습니다는 <xref:System.Reflection.Assembly.LoadFrom%2A> 컨텍스트에으로 로드 경로 사용 하 여 종속성을 확인 하지 않습니다는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드 수행 하지 않습니다. <xref:System.Reflection.Assembly.LoadFile%2A> 이 제한 된 시나리오에서 유용 하기 때문에 <xref:System.Reflection.Assembly.LoadFrom%2A> 어셈블리를 로드 하는 데 사용 될 수 없습니다 서로 다른 경로 다르지만 동일한 id를 첫 번째 로드를 이러한 어셈블리입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 인수는 절대 경로가 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 매개 변수가 빈 문자열("")이거나 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="path" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다. 기본적으로 레거시 CAS 정책은 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 활성화되지 않습니다. 활성화되지 않은 경우 <paramref name="securityEvidence" />는 <see langword="null" />이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리를 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 이스케이프 문자 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자에 대 한 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 대 한 상대 또는 절대 수 있고 어셈블리는 호출자의 도메인에 로드 됩니다.  
  
 어셈블리 세 가지 컨텍스트 중 하나에 로드 하거나 컨텍스트 없이 로드할 수 있습니다.  
  
-   검색을 통해 발견 된 어셈블리를 포함 하는 로드 컨텍스트: gac에서 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장는 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인의 합니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트 사용자 검색을 통해 검색 된 디렉터리에 없는 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.  
  
-   리플렉션 전용 컨텍스트에 포함 된 로드 된 어셈블리는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 코드에서 이러한 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 경우 모든 컨텍스트에서 않습니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트를 검색에 포함 되지 경로에서 로드 되도록 어셈블리를 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 수 있도록 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, 한 어셈블리 로드 컨텍스트를 표시 이름으로 같은 어셈블리를 로드 하려고 하는 나중에 로드 하려고 하면 작업이 실패 합니다. 이 어셈블리가 deserialize 될 때 발생할 수 있습니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   에 대 한 네이티브 이미지 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리가는 도메인 중립적으로 로드할 수 없습니다.  
  
-   .NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 해당 파일 이름이 나 경로가 지정 된 어셈블리를 로드 합니다.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 확장명을 지정하지 않는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작되지 않는 코드베이스에 필요한 <see cref="T:System.Net.WebPermission" />이 지정되지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI 읽기 위해입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리를 로드하고 보안 증명을 제공합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 이스케이프 문자 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자에 대 한 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 대 한 상대 또는 절대 수 있고 어셈블리는 호출자의 도메인에 로드 됩니다.  
  
 어셈블리 세 가지 컨텍스트 중 하나에 로드 하거나 컨텍스트 없이 로드할 수 있습니다.  
  
-   검색을 통해 발견 된 어셈블리를 포함 하는 로드 컨텍스트: gac에서 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장는 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인의 합니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트 사용자 검색을 통해 검색 된 디렉터리에 없는 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.  
  
-   리플렉션 전용 컨텍스트에 포함 된 로드 된 어셈블리는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 코드에서 이러한 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 경우 모든 컨텍스트에서 않습니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트를 검색에 포함 되지 경로에서 로드 되도록 어셈블리를 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 수 있도록 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, 한 어셈블리 로드 컨텍스트를 표시 이름으로 같은 어셈블리를 로드 하려고 하는 나중에 로드 하려고 하면 작업이 실패 합니다. 어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   에 대 한 네이티브 이미지 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리가는 도메인 중립적으로 로드할 수 없습니다.  
  
-   .NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드 없이 <xref:System.Security.Policy.Evidence> 매개 변수를이 어셈블리는 로더가 제공 하는 증거와 함께 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   이 메서드를 호출 하면 두 번 이상 지정 된 다른 증명 하지만 동일한 어셈블리에서 공용 언어 런타임에서 throw 하지 않는 한 <xref:System.IO.FileLoadException> 같음와 다른 증명 사양의 무결성을 확인할 수 없습니다. 처음에 성공 하는 증명 정보에 사용 되는 증명 정보가입니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 공용 개체 파일 형식 (COFF) 이미지에 대 한 증명 정보를 로드 하는 매개 변수를 결합 합니다. `Zone``Url` 및 `Site` 호출 하는 어셈블리에서 상속 된 및 `Hash` 및 `StrongName` COFF 어셈블리에서 가져옵니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 하는 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 확장명을 지정하지 않는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.  -또는-  <paramref name="securityEvidence" />가 모호하지 않으며 올바르지 않은 것으로 확인되었습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작되지 않는 코드베이스에 필요한 <see cref="T:System.Net.WebPermission" />이 지정되지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI 읽기 위해입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <param name="hashValue">계산된 해시 코드의 값입니다.</param>
        <param name="hashAlgorithm">파일을 해시하고 강력한 이름을 생성하는 데 사용된 해시 알고리즘입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리, 해시 값 및 해시 알고리즘을 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 이스케이프 문자 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자에 대 한 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 대 한 상대 또는 절대 수 있고 어셈블리는 호출자의 도메인에 로드 됩니다.  
  
 어셈블리 세 가지 컨텍스트 중 하나에 로드 하거나 컨텍스트 없이 로드할 수 있습니다.  
  
-   검색 하 여 찾은 어셈블리를 포함 하는 로드 컨텍스트: 전역 어셈블리 캐시에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인의 합니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트 사용자를 검색에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.  
  
-   리플렉션 전용 컨텍스트에 포함 된 로드 된 어셈블리는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 코드에서 이러한 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 경우 모든 컨텍스트에서 않습니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트를 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리를 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 아직 수 있도록 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, 한 어셈블리 로드 컨텍스트를 표시 이름으로 같은 어셈블리를 로드 하려고 하는 나중에 로드 하려고 하면 작업이 실패 합니다. 어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   에 대 한 네이티브 이미지 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리는 도메인 중립적으로 로드될 수 없습니다.  
  
 어셈블리 로더를 제공 하는 증거와 함께 로드 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 이름 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">발견된 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  -또는-  <paramref name="assemblyFile" />이 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작되지 않는 코드베이스에 필요한 <see cref="T:System.Net.WebPermission" />이 지정되지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI 읽기 위해입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <param name="hashValue">계산된 해시 코드의 값입니다.</param>
        <param name="hashAlgorithm">파일을 해시하고 강력한 이름을 생성하는 데 사용된 해시 알고리즘입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리, 보안 증명 정보, 해시 값 및 해시 알고리즘을 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 이스케이프 문자 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자에 대 한 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 대 한 상대 또는 절대 수 있고 어셈블리는 호출자의 도메인에 로드 됩니다.  
  
 어셈블리 세 가지 컨텍스트 중 하나에 로드 하거나 컨텍스트 없이 로드할 수 있습니다.  
  
-   검색을 통해 발견 된 어셈블리를 포함 하는 로드 컨텍스트: gac에서 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장는 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인의 합니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트 사용자 검색을 통해 검색 된 디렉터리에 없는 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.  
  
-   리플렉션 전용 컨텍스트에 포함 된 로드 된 어셈블리는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 코드에서 이러한 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 경우 모든 컨텍스트에서 않습니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트를 검색에 포함 되지 경로에서 로드 되도록 어셈블리를 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 수 있도록 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, 한 어셈블리 로드 컨텍스트를 표시 이름으로 같은 어셈블리를 로드 하려고 하는 나중에 로드 하려고 하면 작업이 실패 합니다. 어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.  
  
-   어셈블리를 로드 되 면 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   에 대 한 네이티브 이미지 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리가는 도메인 중립적으로 로드할 수 없습니다.  
  
-   .NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드 없이 <xref:System.Security.Policy.Evidence> 매개 변수를이 어셈블리는 로더가 제공 하는 증거와 함께 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   이 메서드를 호출 하면 두 번 이상 지정 된 다른 증명 하지만 동일한 어셈블리에서 공용 언어 런타임에서 throw 하지 않는 한 <xref:System.IO.FileLoadException> 같음와 다른 증명 사양의 무결성을 확인할 수 없습니다. 처음에 성공 하는 증명 정보에 사용 되는 증명 정보가입니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 공용 개체 파일 형식 (COFF) 이미지에 대 한 증명 정보를 로드 하는 매개 변수를 결합 합니다. `Zone``Url` 및 `Site` 호출 하는 어셈블리에서 상속 된 및 `Hash` 및 `StrongName` COFF 어셈블리에서 가져옵니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 하는 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 확장명을 지정하지 않는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.  -또는-  <paramref name="securityEvidence" />가 모호하지 않으며 올바르지 않은 것으로 확인되었습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작되지 않는 코드베이스에 필요한 <see cref="T:System.Net.WebPermission" />이 지정되지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI 읽기 위해입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리의 내부 모듈을 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">모듈의 이름입니다. 이 문자열은 어셈블리 매니페스트에 있는 파일 이름과 일치해야 합니다.</param>
        <param name="rawModule">내보낸 모듈 또는 리소스가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <summary>내보낸 모듈인 리소스 파일이 포함된 COFF(Common Object File Format) 기반 이미지가 포함된 이 어셈블리의 내부 모듈을 로드합니다.</summary>
        <returns>로드된 모듈입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 또는 <paramref name="rawModule" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" />이 이 어셈블리 매니페스트에 있는 파일 항목과 일치하지 않은 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" />이 올바른 모듈이 아닌 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">모듈의 이름입니다. 이 문자열은 어셈블리 매니페스트에 있는 파일 이름과 일치해야 합니다.</param>
        <param name="rawModule">내보낸 모듈 또는 리소스가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">모듈의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다. 이 배열이 리소스 파일이면 <see langword="null" />이어야 합니다.</param>
        <summary>내보낸 모듈인 리소스 파일이 포함된 COFF(Common Object File Format) 기반 이미지가 포함된 이 어셈블리의 내부 모듈을 로드합니다. 모듈의 기호를 나타내는 원시 바이트도 로드됩니다.</summary>
        <returns>로드된 모듈입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 또는 <paramref name="rawModule" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" />이 이 어셈블리 매니페스트에 있는 파일 항목과 일치하지 않은 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" />이 올바른 모듈이 아닌 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  오버 로드는 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 메서드 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다. 사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">어셈블리의 표시 이름입니다.</param>
        <summary>부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다. <paramref name="partialName" />이 없으면 이 메서드에서 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> 메서드 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다. 사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.  
  
 이 메서드에서 어셈블리를 로드 하는 응용 프로그램은 해당 어셈블리가 업그레이드의 영향을 받습니다. 따라서,이 메서드를 사용 하지 마십시오 사용 하도록 응용 프로그램을 다시 디자인 된 <xref:System.Reflection.Assembly.Load%28System.String%29> 메서드 오버 로드 또는 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 메서드 오버 로드 합니다.  
  
 이 메서드는 먼저 호출 <xref:System.Reflection.Assembly.Load%2A>합니다. 어셈블리를 찾을 수 없습니다,이 메서드는 단순한 동일 이름 및 가장 높은 버전 번호를 포함 하는 전역 어셈블리 캐시에서 어셈블리를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="partialName" />이 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">어셈블리의 표시 이름입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다. 어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다. <paramref name="partialName" />이 없으면 이 메서드에서 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> 메서드 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다. 사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.  
  
 증명 정보는 코드에 부여할 수 있는 권한 같이 보안 정책을 결정하기 위해 입력하는 정보 집합입니다.  
  
 이 메서드에서 어셈블리를 로드 하는 응용 프로그램은 해당 어셈블리가 업그레이드의 영향을 받습니다. 따라서,이 메서드를 사용 하지 마십시오 사용 하도록 응용 프로그램을 다시 디자인 된 <xref:System.Reflection.Assembly.Load%2A> 메서드 또는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드.  
  
 이 메서드는 먼저 호출 <xref:System.Reflection.Assembly.Load%2A>합니다. 어셈블리를 찾을 수 없습니다,이 메서드는 단순한 동일 이름 및 가장 높은 버전 번호를 포함 하는 전역 어셈블리 캐시에서 어셈블리를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보 집합으로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="partialName" />이 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드 호출 및 증명 정보로 어셈블리를 로드 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>매니페스트가 포함된 로드된 파일의 전체 경로나 UNC 위치를 가져옵니다.</summary>
        <value>매니페스트가 포함된 로드된 파일의 위치입니다. 로드된 파일이 섀도 복사된 경우 위치는 해당 파일이 섀도 복사된 후의 위치입니다. <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 메서드 오버로드를 사용한 경우처럼 어셈블리가 바이트 배열에서 로드되면 빈 문자열("")이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위치를 가져오려면 파일이 섀도 복사 되기 전에 <xref:System.Reflection.Assembly.CodeBase%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 매니페스트가 포함 된 로드 된 파일의 위치를 표시 합니다.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">현재 어셈블리가 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 개체로 표현되는 동적 어셈블리입니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리의 매니페스트가 포함된 모듈을 가져옵니다.</summary>
        <value>어셈블리의 매니페스트가 포함된 모듈입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>공용 언어 런타임 클래스 로더가 일반적인 방법으로 어셈블리의 내부 모듈에 대한 참조를 확인할 수 없는 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 콜백 기회를 찾아 자체 모듈을 로드 한 반환을 제공 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 모듈을 포함하는 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리의 모듈을 포함하는 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <c>오른쪽</c>과 비교할 어셈블리입니다.</param>
        <param name="right">
          <c>왼쪽</c>과 비교할 어셈블리입니다.</param>
        <summary>두 <see cref="T:System.Reflection.Assembly" /> 개체가 같은지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <c>오른쪽</c>과 비교할 어셈블리입니다.</param>
        <param name="right">
          <c>왼쪽</c>과 비교할 어셈블리입니다.</param>
        <summary>두 <see cref="T:System.Reflection.Assembly" /> 개체가 같지 않은지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리의 권한 부여 집합을 가져옵니다.</summary>
        <value>현재 어셈블리의 권한 부여 집합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 개체는 경로 같은 중요 한 정보를 포함할 수 있습니다. 따라서 이러한 개체에 액세스 하려면 완전 신뢰가 필요 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리가 리플렉션 전용 컨텍스트에 로드되었는지를 나타내는 <see cref="T:System.Boolean" /> 값을 가져옵니다.</summary>
        <value>어셈블리가 실행 컨텍스트가 아니라 리플렉션 전용 컨텍스트에 로드되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 어셈블리를 리플렉션 전용 컨텍스트에 로드 되었으면는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 메서드를 어셈블리에서 코드를 실행할 수 없습니다. 어셈블리 코드를 실행 하려면 실행 컨텍스트에 로드 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리를 검사할 수 있지만 실행할 수는 없는 리플렉션 전용 컨텍스트에 어셈블리를 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <summary>내보낸 어셈블리가 포함된 COFF(Common Object File Format) 기반 이미지에서 어셈블리를 로드합니다. 어셈블리는 호출자 응용 프로그램 도메인의 리플렉션 전용 컨텍스트에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다. 코드를 실행 하려면 어셈블리에 로드 해야도 실행 컨텍스트를 사용 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
 리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다. 컨텍스트에 로드 되는 어셈블리를 응용 프로그램 도메인을 언로드하는 유일한 언로드해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" />를 로드할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <see cref="P:System.Reflection.AssemblyName.FullName" /> 속성에서 반환된 어셈블리의 표시 이름입니다.</param>
        <summary>지정된 표시 이름을 사용하여 어셈블리를 리플렉션 전용 컨텍스트에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성은 리플렉션 전용 컨텍스트에 자동으로 로드 되지 않습니다.  
  
 리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다. 코드를 실행 하려면 어셈블리에 로드 해야도 실행 컨텍스트를 사용 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙은 다음과 같습니다.  
  
> [!NOTE]
>  C + +에서 컴파일된 실행 파일을 반영할 때 throw 될 수 있습니다는 <xref:System.IO.FileLoadException>합니다. C + + 컴파일러가 실행 파일에서.reloc 섹션 이나 재배치 주소 원인인 것 같습니다. C +, 하려면 지정 `/fixed:no` 링크할 때.  
  
 리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다. 컨텍스트에 로드 되는 어셈블리를 응용 프로그램 도메인을 언로드하는 유일한 언로드해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" />을 찾았지만 로드할 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />이 이후 버전으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 경로입니다.</param>
        <summary>지정된 경로를 사용하여 어셈블리를 리플렉션 전용 컨텍스트에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성은 리플렉션 전용 컨텍스트에 자동으로 로드 되지 않습니다. 종속성을 자동으로 로드 하려면 처리는 <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> 이벤트 및 이벤트 처리기에 종속성을 로드 합니다.  
  
 리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다. 코드를 실행 하려면 사용 하 여 어셈블리를 로드는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 `assemblyFile` 이스케이프 문자 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자에 대 한 이스케이프 문자를 제공합니다.  
  
 에 지정 된 경로 `assemblyFile` 현재 디렉터리에 상대적입니다. 어셈블리는 호출자의 도메인에 로드 됩니다.  
  
 리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다. 컨텍스트에 로드 되는 어셈블리를 응용 프로그램 도메인을 언로드하는 유일한 언로드해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 이름 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" />을 찾았지만 로드할 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  -또는-  버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작되지 않는 코드베이스에 필요한 <see cref="T:System.Net.WebPermission" />이 지정되지 않은 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" />가 빈 문자열("")인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI 읽기 위해입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>CLR(공용 언어 런타임)가 이 어셈블리에 대해 적용해야 하는 보안 규칙 집합을 나타내는 값을 가져옵니다.</summary>
        <value>CLR가 이 어셈블리에 대해 적용하는 보안 규칙 집합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 사용 하 여 컴파일하는 어셈블리는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 투명도 필요 하지만 대신에 명시적으로 만들 수 있습니다. .NET Framework의 이전 버전으로 컴파일된 어셈블리에는 수준 1 투명도 있습니다.  
  
 [보안 변경 내용](~/docs/framework/security/security-changes.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 형식을 반환합니다.</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 형식을 나타내는 개체입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>표시 이름이라고도 하는 어셈블리의 전체 이름을 반환합니다.</summary>
        <returns>어셈블리의 전체 이름입니다. 어셈블리의 전체 이름을 확인할 수 없는 경우에는 클래스 이름입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <summary>일부 보안 검사를 무시하고 로드 소스 컨텍스트로 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 운영 체제 (예를 들어 임시 파일을 인터넷 또는 인트라넷에서 다운로드 한)는 웹에서 로드 되었음을 표시 하는 로컬 어셈블리를 로드 합니다. 전에 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 이러한 어셈블리를 샌드 박싱된 응용 프로그램 도메인으로 자동으로 로드 되었습니다. 부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 완전 신뢰 수준으로 로드 됩니다.  
  
 이 메서드를 사용 하는 대신,으로 적용할 수 있습니다는 [ &lt;NetFx40_LegacySecurityPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) 응용 프로그램 구성 파일에 있습니다. 이 인해의 보안 정책으로 되돌리려면 공용 언어 런타임에서 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.  
  
> [!CAUTION]
>  이러한 솔루션 중 하나를 사용 하는 경우 확인 해야 로드할 안전 하다 `assemblyFile` 완전 신뢰 수준으로 됩니다.  
  
 로드 컨텍스트를 포함 하 여 로드 컨텍스트의 참조는 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 확장명을 지정하지 않는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">발견된 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  -또는-  <paramref name="assemblyFile" />이 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작되지 않는 코드베이스에 필요한 <see cref="T:System.Net.WebPermission" />이 지정되지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
  </Members>
</Type>