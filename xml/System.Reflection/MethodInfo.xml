<Type Name="MethodInfo" FullName="System.Reflection.MethodInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="54ef50301741e290eb8cfdd7bae7838f5b8e6e1a" /><Meta Name="ms.sourcegitcommit" Value="e3904cb57bb8e1854a7de1615afac7a569a2064b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/14/2019" /><Meta Name="ms.locfileid" Value="54252972" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodInfo : System.Reflection.MethodBase, System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodInfo extends System.Reflection.MethodBase implements class System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodInfo&#xA;Inherits MethodBase&#xA;Implements _MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodInfo abstract : System::Reflection::MethodBase, System::Runtime::InteropServices::_MethodInfo" />
  <TypeSignature Language="F#" Value="type MethodInfo = class&#xA;    inherit MethodBase&#xA;    interface _MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodInfo))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3a170-101">메서드의 특성을 검색하고 메서드 메타데이터에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-101">Discovers the attributes of a method and provides access to method metadata.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-102"><xref:System.Reflection.MethodInfo> 클래스 형식의 메서드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-102">The <xref:System.Reflection.MethodInfo> class represents a method of a type.</span></span> <span data-ttu-id="3a170-103">사용할 수는 <xref:System.Reflection.MethodInfo> 개체가 나타내는 메서드에 대 한 정보를 가져오는 메서드를 호출 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-103">You can use a <xref:System.Reflection.MethodInfo> object to obtain information about the method that the object represents and to invoke the method.</span></span> <span data-ttu-id="3a170-104">예:</span><span class="sxs-lookup"><span data-stu-id="3a170-104">For example:</span></span>  
  
-   <span data-ttu-id="3a170-105">값을 검색 하 여 메서드의 표시 여부를 확인할 수 있습니다 합니다 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>를 <xref:System.Reflection.MethodBase.IsPrivate%2A>, 및 <xref:System.Reflection.MethodBase.IsPublic%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-105">You can determine the method's visibility by retrieving the values of the <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, <xref:System.Reflection.MethodBase.IsPrivate%2A>, and <xref:System.Reflection.MethodBase.IsPublic%2A> properties.</span></span>  
  
-   <span data-ttu-id="3a170-106">특성은 메서드에 적용 된 값을 검색 하 여 검색할 수 있습니다 합니다 <xref:System.Reflection.MethodBase.Attributes%2A> 속성 또는 호출 된 <xref:System.Reflection.Assembly.GetCustomAttributes%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-106">You can discover what attributes are applied to the method by retrieving the value of the <xref:System.Reflection.MethodBase.Attributes%2A> property or calling the <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method.</span></span>  
  
-   <span data-ttu-id="3a170-107">메서드가 제네릭 메서드인지, 개방적이 고 생성 된 제네릭 메서드, 또는 닫힌 생성 된 제네릭 메서드의 값을 검색 하 여 확인할 수는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 고 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-107">You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> properties.</span></span>  
  
-   <span data-ttu-id="3a170-108">메서드의 매개 변수에 대 한 정보를 반환 형식에서의 <xref:System.Reflection.MethodBase.GetParameters%2A> 메서드 및 <xref:System.Reflection.MethodInfo.ReturnParameter%2A>를 <xref:System.Reflection.MethodInfo.ReturnType%2A>, 및 <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-108">You can get information about the method's parameters and return type from the <xref:System.Reflection.MethodBase.GetParameters%2A> method and the <xref:System.Reflection.MethodInfo.ReturnParameter%2A>, <xref:System.Reflection.MethodInfo.ReturnType%2A>, and <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> properties.</span></span>  
  
-   <span data-ttu-id="3a170-109">클래스 인스턴스에서 호출 하 여 메서드를 실행할 수는 <xref:System.Reflection.MethodBase.Invoke%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-109">You can execute a method on a class instance by calling the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span>  
  
-   <span data-ttu-id="3a170-110">인스턴스화할 수 있습니다는 <xref:System.Reflection.MethodInfo> 를 호출 하 여 제네릭 메서드 정의 나타내는 하나에서 생성된 된 제네릭 메서드를 나타내는 개체를 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-110">You can instantiate a <xref:System.Reflection.MethodInfo> object that represents a constructed generic method from one that represents a generic method definition by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 <span data-ttu-id="3a170-111">인스턴스화할 수 있습니다는 <xref:System.Reflection.MethodInfo> 를 호출 하 여 인스턴스를 <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> 또는 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> 메서드를 호출 하 여를 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 메서드의 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-111">You can instantiate a <xref:System.Reflection.MethodInfo> instances by calling the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> or <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> method, or by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
 <span data-ttu-id="3a170-112">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-112">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="3a170-113">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-113">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="3a170-114">상속자에 대 한 완전 신뢰 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-114">for full trust for inheritors.</span></span> <span data-ttu-id="3a170-115">부분적으로 신뢰할 수 있는 코드에서이 클래스를 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-115">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="3a170-116">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-116">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="3a170-117">상속 하는 경우 <see cref="T:System.Reflection.MethodInfo" />를 재정의 해야 합니다 <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />를 <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />를 <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />를 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />합니다 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, 및 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-117">When you inherit from <see cref="T:System.Reflection.MethodInfo" />, you must override <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para></block>
    <altmember cref="Overload:System.Type.GetMethods" />
    <altmember cref="Overload:System.Type.GetMethod" />
    <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a170-118"><see cref="T:System.Reflection.MethodInfo" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-118">Initializes a new instance of the <see cref="T:System.Reflection.MethodInfo" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodInfo.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a170-119">제네릭 메서드에 할당되지 않은 제네릭 형식 매개 변수가 포함되어 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-119">Gets a value indicating whether a generic method contains unassigned generic type parameters.</span></span></summary>
        <value><span data-ttu-id="3a170-120">현재 <see cref="T:System.Reflection.MethodInfo" />에 할당되지 않은 제네릭 형식 매개 변수가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-120"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodInfo" /> contains unassigned generic type parameters; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="3a170-121">제네릭 메서드를 호출 하려면 제네릭 형식 정의가 없거나 개방형 생성된 형식 자체 메서드의 형식 인수 또는 바깥쪽 형식에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-121">To invoke a generic method, there must be no generic type definitions or open constructed types in the type arguments of the method itself, or in any enclosing types.</span></span> <span data-ttu-id="3a170-122">이러한 재귀를 결정 하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-122">Making this recursive determination can be difficult.</span></span> <span data-ttu-id="3a170-123">편의 위해 및 오류의 가능성을 줄이기 위해는 `ContainsGenericParameters` 속성을 호출할 수 있는 닫힌된 생성 된 메서드를 구분 하기 위한 표준 방법이 제공 및 개방형 생성 메서드 일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-123">For convenience, and to reduce the chance of error, the `ContainsGenericParameters` property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="3a170-124">경우는 `ContainsGenericParameters` 속성이 true를 반환, 메서드를 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-124">If the `ContainsGenericParameters` property returns true, the method cannot be invoked.</span></span>

<span data-ttu-id="3a170-125">`ContainsGenericParameters` 속성 형식 매개 변수를 재귀적으로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-125">The `ContainsGenericParameters` property searches recursively for type parameters.</span></span> <span data-ttu-id="3a170-126">예를 들어 반환 `true` 개방형 형식에서 모든 메서드에 대 한 `A<T>` (`A(Of T)` Visual Basic의) 경우에 자체 메서드는 제네릭이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-126">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="3a170-127">동작을 사용 하 여이 대조해 보세요 합니다 <xref:System.Reflection.MethodInfo.IsGenericMethod> 반환 하는 속성 `false` 이러한 메서드에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-127">Contrast this with the behavior of the <xref:System.Reflection.MethodInfo.IsGenericMethod> property, which returns `false` for such a method.</span></span>

<span data-ttu-id="3a170-128">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodInfo.IsGenericMethod> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-128">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod> property.</span></span> <span data-ttu-id="3a170-129">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-129">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType> property.</span></span>

## Examples  
<span data-ttu-id="3a170-130">다음 코드 예제에서는 합니다 `ContainsGenericParameters` 속성을 나타내는 메시지를 표시 하는지 여부를 <xref:System.Reflection.MethodInfo> (즉, 바인딩되지 않은 형식 매개 변수)는 열려 있는 제네릭 메서드는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-130">The following code example uses the `ContainsGenericParameters` property to display a message indicating whether a <xref:System.Reflection.MethodInfo> is an open generic method (that is, whether it has unbound type parameters).</span></span>

<span data-ttu-id="3a170-131">이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-131">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>

```vb
Console.WriteLine(vbTab _
    & "Does it have unassigned generic parameters? {0}", _
    mi.ContainsGenericParameters)
```

```csharp
Console.WriteLine("\tDoes it have unassigned generic parameters? {0}", 
    mi.ContainsGenericParameters);
```

```cpp
Console::WriteLine("\tDoes it have unassigned generic parameters? {0}", 
    mi->ContainsGenericParameters);
```

]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <altmember cref="P:System.Reflection.MethodInfo.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodInfo.IsGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="3a170-132">리플렉션 및 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="3a170-132">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="3a170-133">제네릭 소개(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="3a170-133">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3a170-134">이 메서드로부터 대리자를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-134">Creates a delegate from this method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type -&gt; Delegate&#xA;override this.CreateDelegate : Type -&gt; Delegate" Usage="methodInfo.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="3a170-135">만들 대리자의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-135">The type of the delegate to create.</span></span></param>
        <summary><span data-ttu-id="3a170-136">이 메서드로부터 지정된 형식의 대리자를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-136">Creates a delegate of the specified type from this method.</span></span></summary>
        <returns><span data-ttu-id="3a170-137">이 메서드의 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-137">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type * obj -&gt; Delegate&#xA;override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="methodInfo.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="3a170-138">만들 대리자의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-138">The type of the delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="3a170-139">대리자의 대상이 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-139">The object targeted by the delegate.</span></span></param>
        <summary><span data-ttu-id="3a170-140">이 메서드로부터 지정된 대상으로 지정된 형식의 대리자를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-140">Creates a delegate of the specified type with the specified target from this method.</span></span></summary>
        <returns><span data-ttu-id="3a170-141">이 메서드의 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-141">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="3a170-142">이 인스턴스와 비교할 개체 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-142">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3a170-143">이 인스턴스가 지정된 개체와 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-143">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="3a170-144"><see langword="true" />가 이 인스턴스의 형식 및 값과 같으면 <paramref name="obj" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-144"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetBaseDefinition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a170-145">파생 클래스에서 재정의되는 경우 이 인스턴스가 나타내는 메서드가 처음 선언된 직접 또는 간접 기본 클래스의 메서드에 대해 <see cref="T:System.Reflection.MethodInfo" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-145">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</span></span></summary>
        <returns><span data-ttu-id="3a170-146">이 메서드의 첫 번째 구현에 대한 <see cref="T:System.Reflection.MethodInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-146">A <see cref="T:System.Reflection.MethodInfo" /> object for the first implementation of this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-147"><xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드 클래스 계층 구조에 지정 된 메서드의 첫 번째 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-147">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the first definition of the specified method in the class hierarchy.</span></span> <span data-ttu-id="3a170-148">메서드의 첫 번째 정의의 값을 검색 하 여 발견 되는 형식을 확인할 수 있습니다 합니다 <xref:System.Reflection.MemberInfo.DeclaringType%2A> 속성에서 반환 된 <xref:System.Reflection.MethodInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-148">You can determine the type on which the first definition of the method is found by retrieving the value of the <xref:System.Reflection.MemberInfo.DeclaringType%2A> property on the returned <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="3a170-149"><xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드는 다음과 같이 동작 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-149">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method behaves as follows:</span></span>  
  
-   <span data-ttu-id="3a170-150">경우 현재 <xref:System.Reflection.MethodInfo> 개체는 인터페이스 구현을 나타냅니다는 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드는 현재 <xref:System.Reflection.MethodInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-150">If the current <xref:System.Reflection.MethodInfo> object represents an interface implementation, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="3a170-151">경우 현재 <xref:System.Reflection.MethodInfo> 개체를 가상 기본 클래스 정의 재정의 하는 메서드를 나타냅니다는 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드가 반환 되는 <xref:System.Reflection.MethodInfo> 가상 정의 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-151">If the current <xref:System.Reflection.MethodInfo> object represents a method that overrides a virtual definition in a base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the virtual definition.</span></span>  
  
-   <span data-ttu-id="3a170-152">하는 경우 현재 <xref:System.Reflection.MethodInfo> 개체와 지정 된 메서드를 나타냅니다는 `new` C#의 키워드 또는 `Shadows` Visual basic에서 키워드 (에서처럼 `newslot`에 설명 된 대로 [Common Type System](~/docs/standard/base-types/common-type-system.md)), 합니다 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드는 현재 <xref:System.Reflection.MethodInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-152">If the current <xref:System.Reflection.MethodInfo> object represents a method that is specified with the `new` keyword in C# or the `Shadows` keyword in Visual Basic (as in `newslot`, as described in [Common Type System](~/docs/standard/base-types/common-type-system.md)), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="3a170-153">경우 현재 <xref:System.Reflection.MethodInfo> 개체 상속 된 메서드를 나타냅니다 (즉, 현재 메서드의 구현을 제공 하지 않습니다 자체)는 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드가 반환 되는 <xref:System.Reflection.MethodInfo> 클래스 계층 구조에서 가장 낮은 메서드를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-153">If the current <xref:System.Reflection.MethodInfo> object represents an inherited method (that is, the current method does not provide its own implementation), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the lowest method in the class hierarchy.</span></span> <span data-ttu-id="3a170-154">예를 들어 경우 `Base.ToString` 재정의 `Object.ToString`, 및 `Derived.ToString` 재정의 `Base.ToString`를 호출 합니다 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드를를 <xref:System.Reflection.MethodInfo> 나타내는 개체입니다 `Derived.ToString` 반환를 <xref:System.Reflection.MethodInfo> 나타내는 개체입니다 `Object.ToString`.</span><span class="sxs-lookup"><span data-stu-id="3a170-154">For example, if `Base.ToString` overrides `Object.ToString`, and `Derived.ToString` overrides `Base.ToString`, calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method on a <xref:System.Reflection.MethodInfo> object that represents `Derived.ToString` returns a <xref:System.Reflection.MethodInfo> object that represents `Object.ToString`.</span></span>  
  
-   <span data-ttu-id="3a170-155">경우 현재 <xref:System.Reflection.MethodInfo> 개체가 모든 기본 클래스에 존재 하지 않는 메서드를 나타내는지 합니다 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드는 현재 <xref:System.Reflection.MethodInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-155">If the current <xref:System.Reflection.MethodInfo> object represents a method that is not present in any base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="3a170-156">현재 메서드를 호출 하 여 기본 클래스의 메서드를 재정의 하는지 여부를 확인할 수 있습니다는 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-156">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span> <span data-ttu-id="3a170-157">다음 예제에서는 구현 하는 `IsOverride` 이 작업을 수행 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-157">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
 <span data-ttu-id="3a170-158">호출 하 여 `GetBaseDefinition` 메서드:</span><span class="sxs-lookup"><span data-stu-id="3a170-158">To call the `GetBaseDefinition` method:</span></span>  
  
1.  <span data-ttu-id="3a170-159">가져오기는 <xref:System.Type> 속성이 포함 된 형식 (클래스 또는 구조체)를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-159">Get a <xref:System.Type> object that represents the type (the class or structure) that contains the property.</span></span> <span data-ttu-id="3a170-160">호출할 수 있습니다 (형식의 인스턴스) 개체를 사용 하 여 작업 하는 경우 해당 <xref:System.Object.GetType%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-160">If you are working with an object (an instance of a type), you can call its <xref:System.Object.GetType%2A> method.</span></span> <span data-ttu-id="3a170-161">그렇지 않으면 C# 연산자를 사용 하 여 또는 Visual Basic 연산자를 예로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-161">Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</span></span>  
  
2.  <span data-ttu-id="3a170-162">가져오기는 <xref:System.Reflection.MethodInfo> 관심이 있는 메서드를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-162">Get a <xref:System.Reflection.MethodInfo> object that represents the method in which you're interested.</span></span> <span data-ttu-id="3a170-163">모든 메서드에서 배열을 가져와서이 수행할 수 있습니다는 <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> 메서드 다음 배열에 요소를 반복 하 고 검색할 수 있습니다는 <xref:System.Reflection.MethodInfo> 호출 하 여 직접 메서드를 나타내는 개체를 <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> 메서드 및 지정 하는 메서드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-163">You can do this by getting an array of all methods from the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> method and then iterating the elements in the array, or you can retrieve the <xref:System.Reflection.MethodInfo> object that represents the method directly by calling the <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> method and specifying the method name.</span></span>  
  
3.  <span data-ttu-id="3a170-164">호출 된 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 의 값을 가져오는 방법의 <xref:System.Reflection.MethodInfo> 기본 메서드 정의 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-164">Call the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method to get the value of the <xref:System.Reflection.MethodInfo> object that represents the base method definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a170-165">다음 예제에서는 동작을 보여 줍니다.는 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-165">The following example demonstrates the behavior of the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/getbasedefinition1.cs#1)]
 [!code-vb[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/getbasedefinition1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/53c57c96-83e1-4ee3-9543-9ac832671a89"><span data-ttu-id="3a170-166">공용 형식 시스템</span><span class="sxs-lookup"><span data-stu-id="3a170-166">Common Type System</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodInfo.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a170-167">제네릭 메서드의 형식 인수나 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-167">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="3a170-168">제네릭 메서드의 형식 인수나 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-168">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="3a170-169">현재 메서드가 제네릭 메서드가 아니면 빈 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-169">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-170">반환된 된 배열 요소의 제네릭 메서드의 형식 매개 변수 목록에 나타나는 순서는입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-170">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="3a170-171">현재 메서드는 폐쇄형된 생성된 메서드 경우 (즉, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성에서 반환 `false`)를 반환 하는 배열을 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> 메서드는 제네릭 메서드의 제네릭 형식 매개 변수에 할당 된 형식을 포함 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-171">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="3a170-172">현재 메서드가 제네릭 메서드 정의 인 경우 배열 형식 매개 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-172">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="3a170-173">현재 메서드가 개방형 생성된 메서드 이면 (즉, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성이 반환 `true`) 일부 형식 매개 변수 및 형식에는 특정 형식이 할당 된 바깥쪽 제네릭 형식의 매개 변수 할당 된 형식으로 매개 변수 배열 포함 형식 및 형식 모두 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-173">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="3a170-174">사용 된 <xref:System.Type.IsGenericParameter%2A> 구분 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-174">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="3a170-175">이 시나리오를 보여 주는 코드 예를 참조 하세요.를 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-175">For a demonstration of this scenario, see the code example for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="3a170-176">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-176">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="3a170-177">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-177">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
## Examples  
 <span data-ttu-id="3a170-178">다음 코드 예제에서는 제네릭 메서드의 형식 인수를 가져오고 표시 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-178">The following code example shows how to get the type arguments of a generic method and display them.</span></span>  
  
 <span data-ttu-id="3a170-179">이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-179">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#8](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#8)]
 [!code-csharp[MethodInfo.Generics#8](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#8)]
 [!code-vb[MethodInfo.Generics#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a170-180">이 메서드는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-180">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="3a170-181">리플렉션 및 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="3a170-181">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="3a170-182">제네릭 소개(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="3a170-182">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a170-183">현재 메서드를 생성하는 데 사용할 수 있는 제네릭 메서드 정의를 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-183">Returns a <see cref="T:System.Reflection.MethodInfo" /> object that represents a generic method definition from which the current method can be constructed.</span></span></summary>
        <returns><span data-ttu-id="3a170-184">현재 메서드를 생성하는 데 사용할 수 있는 제네릭 메서드 정의를 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-184">A <see cref="T:System.Reflection.MethodInfo" /> object representing a generic method definition from which the current method can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-185">제네릭 메서드 정의 메서드 생성 하는 데 사용 될 수 있는 템플릿입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-185">A generic method definition is a template from which methods can be constructed.</span></span> <span data-ttu-id="3a170-186">예를 들어 제네릭 메서드 정의에서 `T M<T>(T t)` (C# 구문;으로 표현 합니다. `Function M(Of T)(ByVal tVal As T) As T` Visual basic에서) 생성 하 고 메서드를 호출할 수 있습니다 `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="3a170-186">For example, from the generic method definition `T M<T>(T t)` (expressed in C# syntax; `Function M(Of T)(ByVal tVal As T) As T` in Visual Basic) you can construct and invoke the method `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` in Visual Basic).</span></span> <span data-ttu-id="3a170-187">지정 된를 <xref:System.Reflection.MethodInfo> 생성 된 메서드,이 나타내는 개체를 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> 메서드가 제네릭 메서드 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-187">Given a <xref:System.Reflection.MethodInfo> object representing this constructed method, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the generic method definition.</span></span>  
  
 <span data-ttu-id="3a170-188">생성 된 메서드와 동일한 제네릭 메서드 정의에서 만들어지는 경우에 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> 메서드를 반환 하는 동일한 <xref:System.Reflection.MethodInfo> 두 메서드 모두에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-188">If two constructed methods are created from the same generic method definition, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the same <xref:System.Reflection.MethodInfo> object for both methods.</span></span>  
  
 <span data-ttu-id="3a170-189">호출 하는 경우 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> 에 <xref:System.Reflection.MethodInfo> 이미 제네릭 메서드 정의 나타내는 반환 되 고 현재 <xref:System.Reflection.MethodInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-189">If you call <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> on a <xref:System.Reflection.MethodInfo> that already represents a generic method definition, it returns the current <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="3a170-190">제네릭 메서드 정의 선언 형식의 제네릭 매개 변수를 포함 하는 경우 있습니다 됩니다 제네릭 메서드 정의 생성 된 각 형식에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-190">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="3a170-191">예를 들어 다음 C#, Visual Basic 및 c + + 코드를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-191">For example, consider the following C#, Visual Basic, and C++ code:</span></span>  
  
```  
class B<U,V> {}  
class C<T> { public B<T,S> M<S>() {...}}  
  
Class B(Of U, V)  
End Class  
Class C(Of T)  
    Public Function M(Of S)() As B(Of T, S)  
        ...  
    End Function  
End Class   
  
generic <typename U, typename V> ref class B {};  
generic <typename T> ref class C  
{  
public:  
    generic <typename S> B<T,S>^ M() {...};  
};  
```  
  
 <span data-ttu-id="3a170-192">생성 된 형식에서 `C<int>` (`C(Of Integer)` Visual basic에서), 제네릭 메서드 `M` 반환 `B<int, S>`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-192">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method `M` returns `B<int, S>`.</span></span> <span data-ttu-id="3a170-193">개방형 형식에서 `C<T>`하십시오 `M` 반환 `B<T, S>`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-193">In the open type `C<T>`, `M` returns `B<T, S>`.</span></span> <span data-ttu-id="3a170-194">두 경우 모두를 <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> 속성이 반환 `true` 에 대 한 합니다 <xref:System.Reflection.MethodInfo> 나타내는 `M`이므로 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 둘 다에서 호출할 수 있습니다 <xref:System.Reflection.MethodInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-194">In both cases, the <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `true` for the <xref:System.Reflection.MethodInfo> that represents `M`, so <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> can be called on both <xref:System.Reflection.MethodInfo> objects.</span></span> <span data-ttu-id="3a170-195">생성된 된 형식을 호출 하는 결과 경우 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 되는 <xref:System.Reflection.MethodInfo> 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-195">In the case of the constructed type, the result of calling <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> is a <xref:System.Reflection.MethodInfo> that can be invoked.</span></span> <span data-ttu-id="3a170-196">개방형 형식의 경우 합니다 <xref:System.Reflection.MethodInfo> 반환한 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-196">In the case of the open type, the <xref:System.Reflection.MethodInfo> returned by <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> cannot be invoked.</span></span>  
  
 <span data-ttu-id="3a170-197">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-197">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="3a170-198">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-198">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a170-199">다음 코드 예제에서는 제네릭 메서드를 얻는 데 필요한 코드와 클래스를 보여 줍니다.는 <xref:System.Reflection.MethodInfo> 메서드의 경우 메서드 형식 인수를 바인딩하고 bound 메서드를 다시 원래 제네릭 형식 정의 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-199">The following code example shows a class with a generic method and the code required to obtain a <xref:System.Reflection.MethodInfo> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</span></span>  
  
 <span data-ttu-id="3a170-200">이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-200">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#2](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#2)]
 [!code-csharp[MethodInfo.Generics#2](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#2)]
 [!code-vb[MethodInfo.Generics#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#2)]  
[!code-cpp[MethodInfo.Generics#3](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#3)]
[!code-csharp[MethodInfo.Generics#3](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#3)]
[!code-vb[MethodInfo.Generics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#3)]  
[!code-cpp[MethodInfo.Generics#4](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#4)]
[!code-csharp[MethodInfo.Generics#4](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#4)]
[!code-vb[MethodInfo.Generics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a170-201">현재 메서드는 제네릭 메서드가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-201">The current method is not a generic method.</span></span> <span data-ttu-id="3a170-202">즉, <see cref="P:System.Reflection.MethodBase.IsGenericMethod" />이 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-202">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a170-203">이 메서드는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-203">This method is not supported.</span></span></exception>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="3a170-204">리플렉션 및 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="3a170-204">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="3a170-205">제네릭 소개(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="3a170-205">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a170-206">이 인스턴스의 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-206">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="3a170-207">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-207">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * obj[] -&gt; obj" Usage="methodInfo.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="parameters">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a170-208">현재 메서드가 제네릭 메서드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-208">Gets a value indicating whether the current method is a generic method.</span></span></summary>
        <value><span data-ttu-id="3a170-209">현재 메서드가 제네릭 메서드; 이면 true를 그렇지 않으면 false입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-209">true if the current method is a generic method; otherwise, false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a170-210">현재 <see cref="T:System.Reflection.MethodInfo" />가 제네릭 메서드 정의를 나타내는지 여부를 표시하는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-210">Gets a value indicating whether the current <see cref="T:System.Reflection.MethodInfo" /> represents the definition of a generic method.</span></span></summary>
        <value><span data-ttu-id="3a170-211"><see cref="T:System.Reflection.MethodInfo" /> 개체가 제네릭 메서드 정의를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-211"><see langword="true" /> if the <see cref="T:System.Reflection.MethodInfo" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="3a170-212">하는 경우 현재 <xref:System.Reflection.MethodInfo> 는 제네릭 메서드 정의 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-212">If the current <xref:System.Reflection.MethodInfo> represents a generic method definition, then:</span></span>

  - <span data-ttu-id="3a170-213">`IsGenericMethodDefinition`가 `true`를 반환하는 경우</span><span class="sxs-lookup"><span data-stu-id="3a170-213">`IsGenericMethodDefinition` returns `true`.</span></span>

  - <span data-ttu-id="3a170-214">각 <xref:System.Type> 에서 반환 된 배열에 있는 개체는 <xref:System.Reflection.MethodInfo.GetGenericArguments> 메서드:</span><span class="sxs-lookup"><span data-stu-id="3a170-214">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments> method:</span></span>

      - <span data-ttu-id="3a170-215"><xref:System.Type.IsGenericParameter?displayProperty=nameWithType> 속성이 `true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-215">The <xref:System.Type.IsGenericParameter?displayProperty=nameWithType> property returns `true`.</span></span>

      - <span data-ttu-id="3a170-216">합니다 <xref:System.Type.DeclaringMethod?displayProperty=nameWithType> 현재 반환 <xref:System.Reflection.MethodInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-216">The <xref:System.Type.DeclaringMethod?displayProperty=nameWithType> returns the current <xref:System.Reflection.MethodInfo>.</span></span>

      - <span data-ttu-id="3a170-217"><xref:System.Type.GenericParameterPosition?displayProperty=nameWithType> 속성의 위치와 동일 합니다 <xref:System.Type> 배열에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-217">The <xref:System.Type.GenericParameterPosition?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>

<span data-ttu-id="3a170-218">사용 된 `IsGenericMethodDefinition` 형식 인수가 제네릭 메서드의 형식 매개 변수에 할당 된 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-218">Use the `IsGenericMethodDefinition` property to determine whether type arguments have been assigned to the type parameters of a generic method.</span></span> <span data-ttu-id="3a170-219">형식 인수에 할당 된 경우는 `IsGenericMethodDefinition` 속성이 false를 반환 형식 인수 중 일부는 경우에 <xref:System.Type> 바깥쪽 형식의 형식 매개 변수를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-219">If type arguments have been assigned, the `IsGenericMethodDefinition` property returns false even if some of the type arguments are <xref:System.Type> objects that represent type parameters of enclosing types.</span></span> <span data-ttu-id="3a170-220">예를 들어 다음 C\#, Visual Basic 및 c + + 코드:</span><span class="sxs-lookup"><span data-stu-id="3a170-220">For example, consider the following C\#, Visual Basic, and C++ code:</span></span>

    ```cs
    class C
    {
        T N<T,U>(T t, U u) {...}
        public V M<V>(V v)
        {
            return N<V,int>(v, 42);
        }
    }
    ```

    ```vb
    Class C
        Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T
            ...
        End Function
        Public Function M(Of V)(ByVal va As V ) As V
            Return N(Of V, Integer)(va, 42)
        End Function
    End Class
    ```

    ```cpp
    ref class C
    {
    private:
        generic <typename T, typename U> T N(T t, U u) {...}
    public:
        generic <typename V> V M(V v)
        {
            return N<V, int>(v, 42);
        }
    };
    ```

<span data-ttu-id="3a170-221">N, M 및 형식이 형식 매개 변수를 지정 메서드에 대 한 호출을 포함 하는 M 메서드 본문 <xref:System.Int32>합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-221">The method body of M contains a call to method N, specifying the type parameter of M and the type <xref:System.Int32>.</span></span> <span data-ttu-id="3a170-222">합니다 `IsGenericMethodDefinition` 메서드에 대 한 속성은 `N<V,int>`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-222">The `IsGenericMethodDefinition` property returns false for method `N<V,int>`.</span></span>

> [!NOTE]
> <span data-ttu-id="3a170-223">Open 메서드를 생성 하지만 `N<V,int>` 는 클래스 C 리플렉션할 때 없던를 반드시 생성 되어야를 사용 하 여 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 동적 클래스 C를 내보내기 위해.</span><span class="sxs-lookup"><span data-stu-id="3a170-223">Although the open constructed method `N<V,int>` is not encountered when reflecting over class C, it must be generated using <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> in order to emit C as a dynamic class.</span></span>


<span data-ttu-id="3a170-224">제네릭 메서드 정의 선언 형식의 제네릭 매개 변수를 포함 하는 경우 있습니다 됩니다 제네릭 메서드 정의 생성 된 각 형식에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-224">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="3a170-225">예를 들어 다음 C\# 및 Visual Basic 코드:</span><span class="sxs-lookup"><span data-stu-id="3a170-225">For example, consider the following C\# and Visual Basic code:</span></span>

    ```csharp
    class B<U,V> {}
    class C<T> { public B<T,S> M<S>() {...}}
    ```

    ```vb
    Class B(Of U, V)
    End Class
    Class C(Of T)
        Public Function M(Of S)() As B(Of T, S)
            ...
        End Function
    End Class
    ```

    ```cpp
    generic <typename U, typename V> ref class B {};
    generic <typename T> ref class C
    {
    public:
        generic <typename S> B<T,S>^ M() {...};
    };
    ```

<span data-ttu-id="3a170-226">생성 된 형식에서 `C<int>` (`C(Of Integer)` Visual basic에서), 제네릭 메서드 M 반환 `B<int, S>`.</span><span class="sxs-lookup"><span data-stu-id="3a170-226">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method M returns `B<int, S>`.</span></span> <span data-ttu-id="3a170-227">개방형 형식에서 `C<T>`, M 반환 `B<T, S>`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-227">In the open type `C<T>`, M returns `B<T, S>`.</span></span> <span data-ttu-id="3a170-228">두 경우 모두를 `IsGenericMethodDefinition` 속성이 반환 `true` 에 대 한는 <xref:System.Reflection.MethodInfo> M을 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-228">In both cases, the `IsGenericMethodDefinition` property returns `true` for the <xref:System.Reflection.MethodInfo> that represents M.</span></span>

<span data-ttu-id="3a170-229">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodInfo.IsGenericMethod> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-229">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod> property.</span></span> <span data-ttu-id="3a170-230">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-230">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType> property.</span></span>

## Examples  
<span data-ttu-id="3a170-231">다음 코드 예제에서는 합니다 `IsGenericMethodDefinition` 속성을 나타내는 메시지를 표시 하는지 여부를 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-231">The following code example uses the `IsGenericMethodDefinition` property to display a message indicating whether a <xref:System.Reflection.MethodInfo> represents a generic method definition.</span></span>

<span data-ttu-id="3a170-232">이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3a170-232">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>

```vb
Console.WriteLine(vbTab _
    & "Is this a generic method definition? {0}", _
    mi.IsGenericMethodDefinition)
```

```csharp
Console.WriteLine("\tIs this a generic method definition? {0}", 
    mi.IsGenericMethodDefinition);
```

```cpp
Console::WriteLine("\tIs this a generic method definition? {0}", 
    mi->IsGenericMethodDefinition);
```

]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="3a170-233">리플렉션 및 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="3a170-233">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="3a170-234">제네릭 소개(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="3a170-234">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodInfo.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="3a170-235">현재 제네릭 메서드 정의의 형식 매개 변수를 대체할 형식 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-235">An array of types to be substituted for the type parameters of the current generic method definition.</span></span></param>
        <summary><span data-ttu-id="3a170-236">현재 제네릭 메서드 정의의 형식 매개 변수를 형식 배열의 요소로 대체하고, 결과로 생성된 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-236">Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <see cref="T:System.Reflection.MethodInfo" /> object representing the resulting constructed method.</span></span></summary>
        <returns><span data-ttu-id="3a170-237">현재 제네릭 메서드 정의의 형식 매개 변수를 <paramref name="typeArguments" />의 요소로 대체하여 생성된 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-237">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the constructed method formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic method definition.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-238">합니다 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드를 사용 하면 특정 형식을 만들어 제네릭 메서드 정의의 형식 매개 변수에 할당 하는 코드를 작성할 수 있습니다는 <xref:System.Reflection.MethodInfo> 생성된 된 특정 메서드를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-238">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <xref:System.Reflection.MethodInfo> object that represents a particular constructed method.</span></span> <span data-ttu-id="3a170-239">경우는 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성의 <xref:System.Reflection.MethodInfo> 개체를 반환 합니다 `true`, 메서드를 호출 하거나 메서드를 호출 하는 대리자를 만드는 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-239">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property of this <xref:System.Reflection.MethodInfo> object returns `true`, you can use it to invoke the method or to create a delegate to invoke the method.</span></span>  
  
 <span data-ttu-id="3a170-240">사용 하 여 생성 된 메서드는 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드는 열 수, 즉, 해당 형식 인수 중 일부 바깥쪽 제네릭 형식의 형식 매개 변수를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-240">Methods constructed with the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</span></span> <span data-ttu-id="3a170-241">동적 어셈블리를 생성 하는 경우 이러한 개방형 생성된 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-241">You might use such open constructed methods when you generate dynamic assemblies.</span></span> <span data-ttu-id="3a170-242">예를 들어 다음 C#, Visual Basic 및 c + + 코드를 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="3a170-242">For example, consider the following C#, Visual Basic, and C++ code.</span></span>  
  
```  
class C  
{  
    T N<T,U>(T t, U u) {...}  
    public V M<V>(V v)  
    {  
        return N<V,int>(v, 42);  
    }  
}  
  
Class C  
    Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T  
        ...  
    End Function  
    Public Function M(Of V)(ByVal va As V ) As V  
        Return N(Of V, Integer)(va, 42)  
    End Function  
End Class  
  
ref class C  
{  
private:  
    generic <typename T, typename U> T N(T t, U u) {...}  
public:  
    generic <typename V> V M(V v)  
    {  
        return N<V, int>(v, 42);  
    }  
};  
```  
  
 <span data-ttu-id="3a170-243">메서드 본문 `M` 메서드 호출이 포함 되어 `N`, 형식 매개 변수에 지정 `M` 형식과 <xref:System.Int32>합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-243">The method body of `M` contains a call to method `N`, specifying the type parameter of `M` and the type <xref:System.Int32>.</span></span> <span data-ttu-id="3a170-244">합니다 <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> 속성이 반환 `false` 메서드에 대 한 `N<V,int>`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-244">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `false` for method `N<V,int>`.</span></span> <span data-ttu-id="3a170-245">합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성이 반환 `true`, 따라서 메서드 `N<V,int>` 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-245">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, so method `N<V,int>` cannot be invoked.</span></span>  
  
 <span data-ttu-id="3a170-246">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-246">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="3a170-247">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-247">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a170-248">다음 코드 예제는 속성과 메서드를 보여 줍니다. <xref:System.Reflection.MethodInfo> 는 제네릭 메서드 검사를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-248">The following code example demonstrates the properties and methods of <xref:System.Reflection.MethodInfo> that support the examination of generic methods.</span></span> <span data-ttu-id="3a170-249">이 예제에서는 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-249">The example does the following:</span></span>  
  
-   <span data-ttu-id="3a170-250">제네릭 메서드가 있는 클래스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-250">Defines a class that has a generic method.</span></span>  
  
-   <span data-ttu-id="3a170-251">만듭니다는 <xref:System.Reflection.MethodInfo> 제네릭 메서드를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-251">Creates a <xref:System.Reflection.MethodInfo> that represents the generic method.</span></span>  
  
-   <span data-ttu-id="3a170-252">제네릭 메서드 정의의 속성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-252">Displays properties of the generic method definition.</span></span>  
  
-   <span data-ttu-id="3a170-253">형식 인수 형식 매개 변수를 할당 합니다 <xref:System.Reflection.MethodInfo>, 생성된 된 제네릭 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-253">Assigns type arguments to the type parameters of the <xref:System.Reflection.MethodInfo>, and invokes the resulting constructed generic method.</span></span>  
  
-   <span data-ttu-id="3a170-254">생성 된 제네릭 메서드의 속성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-254">Displays properties of the constructed generic method.</span></span>  
  
-   <span data-ttu-id="3a170-255">생성 된 메서드에서 제네릭 메서드 정의 검색 하 고 원래 정의를 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-255">Retrieves the generic method definition from the constructed method and compares it to the original definition.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3a170-256">현재 <see cref="T:System.Reflection.MethodInfo" />가 제네릭 메서드 정의를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-256">The current <see cref="T:System.Reflection.MethodInfo" /> does not represent a generic method definition.</span></span> <span data-ttu-id="3a170-257">즉, <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />이 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-257">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3a170-258"><paramref name="typeArguments" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="3a170-258"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3a170-259">또는</span><span class="sxs-lookup"><span data-stu-id="3a170-259">-or-</span></span> 
<span data-ttu-id="3a170-260"><paramref name="typeArguments" />의 요소가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-260">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3a170-261"><paramref name="typeArguments" />의 요소 수가 현재 제네릭 메서드 정의의 형식 매개 변수 수와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-261">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters of the current generic method definition.</span></span>  
  
<span data-ttu-id="3a170-262">또는</span><span class="sxs-lookup"><span data-stu-id="3a170-262">-or-</span></span> 
<span data-ttu-id="3a170-263"><paramref name="typeArguments" />의 요소가 현재 제네릭 메서드 정의의 해당 형식 매개 변수에 대해 지정된 제약 조건을 충족하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-263">An element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3a170-264">이 메서드는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-264">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="3a170-265">리플렉션 및 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="3a170-265">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="3a170-266">제네릭 소개(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="3a170-266">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.MethodInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a170-267">이 멤버가 메서드임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-267">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></summary>
        <value><span data-ttu-id="3a170-268">이 멤버가 메서드임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-268">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-269">이 속성을 재정의 <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-269">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a170-270">따라서 집합을 조사할 때 <xref:System.Reflection.MemberInfo> 개체에서 반환 된 배열에 예를 들어 <xref:System.Type.GetMembers%2A> - <xref:System.Reflection.MemberInfo.MemberType%2A> 속성에서 반환 <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> 지정된 된 멤버 메서드를가 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-270">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> only when a given member is a method.</span></span>  
  
 <span data-ttu-id="3a170-271">가져오려는 합니다 `MemberType` 속성을 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-271">To get the `MemberType` property, first get the class `Type`.</span></span> <span data-ttu-id="3a170-272">`Type`, 가져오기는 `MethodInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-272">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="3a170-273">`MethodInfo`, 가져오기는 `MemberType`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-273">From the `MethodInfo`, get the `MemberType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a170-274">다음 예제에서는 지정된 된 멤버의 유형을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-274">The following example displays the type of the specified member.</span></span>  
  
 [!code-cpp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="3a170-275">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-275">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="3a170-276">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-276">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="3a170-277">두 <see cref="T:System.Reflection.MethodInfo" /> 개체가 같은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-277">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="3a170-278"><see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-278"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="System.Reflection.MethodInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="3a170-279">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-279">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="3a170-280">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-280">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="3a170-281">두 <see cref="T:System.Reflection.MethodInfo" /> 개체가 같지 않은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-281">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="3a170-282"><see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-282"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.MethodInfo.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a170-283">메서드의 반환 형식에 대한 정보(예: 반환 형식에 사용자 지정 한정자가 포함되는지 여부)가 포함된 <see cref="T:System.Reflection.ParameterInfo" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-283">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span></span></summary>
        <value><span data-ttu-id="3a170-284">반환 형식에 대한 정보가 포함된 <see cref="T:System.Reflection.ParameterInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-284">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-285">컴파일러 디자이너에서 사용할 수는 <xref:System.Reflection.ParameterInfo> 사용자 지정 하는지 여부를 검색 하려면이 속성에서 반환 된 개체 한정자와 같은 <xref:Microsoft.VisualC.IsConstModifier>, 반환 형식에 적용 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-285">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3a170-286">이 메서드가 구현되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-286">This method is not implemented.</span></span></exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public virtual Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.MethodInfo.ReturnType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a170-287">이 메서드의 반환 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-287">Gets the return type of this method.</span></span></summary>
        <value><span data-ttu-id="3a170-288">이 메서드의 반환 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-288">The return type of this method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-289">반환 형식 속성을 가져오려면 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-289">To get the return type property, first get the class `Type`.</span></span> <span data-ttu-id="3a170-290">`Type`, 가져오기는 `MethodInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-290">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="3a170-291">`MethodInfo`, 가져오기는 `ReturnType`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-291">From the `MethodInfo`, get the `ReturnType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a170-292">다음 예제에서는 지정 된 메서드의 반환 형식을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-292">The following example displays the return type of the specified method.</span></span>  
  
 [!code-cpp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnTypeCustomAttributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3a170-293">반환 형식에 대한 사용자 지정 특성을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-293">Gets the custom attributes for the return type.</span></span></summary>
        <value><span data-ttu-id="3a170-294">반환 형식에 대한 사용자 지정 특성을 나타내는 <see langword="ICustomAttributeProvider" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-294">An <see langword="ICustomAttributeProvider" /> object representing the custom attributes for the return type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="3a170-295">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-295">Reserved for future use.</span></span> <span data-ttu-id="3a170-296">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-296">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="3a170-297">매핑할 전달된 이름의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-297">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="3a170-298">매핑할 이름의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-298">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="3a170-299">이름을 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-299">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="3a170-300">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-300">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="3a170-301">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-301">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-302">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-302">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3a170-303">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-303">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3a170-304">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-304">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetType">
      <MemberSignature Language="C#" Value="Type _MethodInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodInfo.GetType() = System::Runtime::InteropServices::_MethodInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3a170-305">COM에서 <see cref="M:System.Object.GetType" /> 메서드에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-305">Provides access to the <see cref="M:System.Object.GetType" /> method from COM.</span></span></summary>
        <returns><span data-ttu-id="3a170-306"><see cref="T:System.Type" /> 형식을 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-306">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.MethodInfo" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="3a170-307">반환할 형식 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-307">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="3a170-308">형식 정보의 로캘 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-308">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="3a170-309">요청된 형식 정보 개체에 대한 포인터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-309">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="3a170-310">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-310">Retrieves the type information for an object, which can be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-311">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-311">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3a170-312">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-312">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3a170-313">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-313">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="3a170-314">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-314">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="3a170-315">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span><span class="sxs-lookup"><span data-stu-id="3a170-315">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-316">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-316">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3a170-317">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-317">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3a170-318">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-318">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.Invoke">
      <MemberSignature Language="C#" Value="void _MethodInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="3a170-319">멤버를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-319">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="3a170-320">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-320">Reserved for future use.</span></span> <span data-ttu-id="3a170-321">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-321">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="3a170-322">인수를 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-322">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="3a170-323">호출의 컨텍스트를 설명하는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-323">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="3a170-324">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-324">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="3a170-325">결과를 저장할 위치에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-325">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="3a170-326">예외 정보가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-326">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="3a170-327">오류가 있는 첫 번째 인수의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-327">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="3a170-328">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-328">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a170-329">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-329">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3a170-330">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-330">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3a170-331">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a170-331">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>