<Type Name="Control" FullName="System.Windows.Controls.Control">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1c6f29ab671c8f7d13a9d4339b98cf6f7044ef12" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30620467" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Control : System.Windows.FrameworkElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.Windows.FrameworkElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits FrameworkElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::Windows::FrameworkElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Windows.Controls.ControlTemplate" />을 사용하여 모양을 정의하는 UI(사용자 인터페이스) 요소에 대한 기본 클래스를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Control> 클래스는 다양 한 응용 프로그램에 추가 하는 컨트롤에 대 한 기본 클래스입니다. <xref:System.Windows.Controls.Control> 추가할 수 있지만 클래스 정의 동작을 거의;는 <xref:System.Windows.Controls.Control> 응용 프로그램에 훨씬 더 일반적에서 상속 되는 컨트롤을 추가 하는 <xref:System.Windows.Controls.Control>와 같은 한 <xref:System.Windows.Controls.Button> 또는 <xref:System.Windows.Controls.ListBox>합니다.  
  
 <xref:System.Windows.Controls.Control.Template%2A> 속성, 즉 한 <xref:System.Windows.Controls.ControlTemplate>의 모양을 지정는 <xref:System.Windows.Controls.Control>합니다. 컨트롤의 모양을 변경 하지만 해당 기능을 유지 하려는 경우 새 고려해 야 <xref:System.Windows.Controls.ControlTemplate> 새 클래스를 만드는 대신 합니다. 자세한 내용은 [스타일 지정 및 템플릿](~/docs/framework/wpf/controls/styling-and-templating.md)을 참조하세요.  
  
 컨트롤에서 상속할 수 컨트롤 사용자 지정 동작을 만들 수 있을 뿐만 아니라 다른 모양을 사용자 지정할 수 있도록 하려는 경우는 <xref:System.Windows.Controls.Control> 클래스 및 정의 <xref:System.Windows.Controls.ControlTemplate>합니다.  상속 된 클래스에서 상속할 수는 기존 컨트롤의 동작을 확장 하려면 <xref:System.Windows.Controls.Control>합니다.  
  
 A <xref:System.Windows.Controls.Control> 가지고 있지 않은 한 <xref:System.Windows.Controls.ControlTemplate> 는 다음과 같은 속성이 효과가 설정과 응용 프로그램에 표시 되지 않으면는 <xref:System.Windows.Controls.ControlTemplate> 명시적으로 참조:  
  
-   <xref:System.Windows.Controls.Control.Background%2A>  
  
-   <xref:System.Windows.Controls.Control.BorderBrush%2A>  
  
-   <xref:System.Windows.Controls.Control.BorderThickness%2A>  
  
-   <xref:System.Windows.Controls.Control.FontFamily%2A>  
  
-   <xref:System.Windows.Controls.Control.FontSize%2A>  
  
-   <xref:System.Windows.Controls.Control.FontStretch%2A>  
  
-   <xref:System.Windows.Controls.Control.FontWeight%2A>  
  
-   <xref:System.Windows.Controls.Control.Foreground%2A>  
  
-   <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A>  
  
-   <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A>  
  
 일반적으로 이러한 속성을 사용 하는 요소에 바인딩하는 <xref:System.Windows.Controls.ControlTemplate> 속성에 있습니다.  예를 들어, 값에 따라 색을 변경 하려면 제어 하려는 경우는 <xref:System.Windows.Controls.Control.Background%2A> 속성에 있는 요소의 일부 속성을 바인딩할 수 있습니다는 <xref:System.Windows.Controls.ControlTemplate> 에 <xref:System.Windows.Controls.Control.Background%2A>합니다. 사용 하 여는 [TemplateBinding 태그 확장](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) 컨트롤에 속성 요소에 바인딩하는 <xref:System.Windows.Controls.ControlTemplate>합니다.  
  
 <xref:System.Windows.Controls.Control> 메타 데이터 재정의 <xref:System.Windows.UIElement.Focusable%2A> 속성 해당 기본값을 설정 하 고 `true`합니다. 자세한 내용은 참조 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Controls.Control" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">콘텐츠를 정렬하는 데 사용되는 계산된 크기입니다.</param>
        <summary>
          <see cref="T:System.Windows.Controls.Control" /> 개체의 콘텐츠를 정렬하고 크기를 조정하도록 호출됩니다.</summary>
        <returns>컨트롤의 크기입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 컨트롤 정렬 시각적 첫 번째 자식만을 정렬합니다. 변환은 없습니다 적용 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 배경을 설명하는 브러시를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 배경을 채우는 데 사용되는 브러시입니다. 기본값은 <see cref="P:System.Windows.Media.Brushes.Transparent" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Control.Background%2A> 속성은 컨트롤의 저장 상태에만 적용 됩니다.  컨트롤의 상태가 변경 될 때의 모양을 지정 하는 컨트롤의 기본 스타일입니다. 예를 들어, 설정 하는 경우는 <xref:System.Windows.Controls.Control.Background%2A> 속성에는 <xref:System.Windows.Controls.Button>, 단추 누름 또는 수행 되지 않습니다는 경우에 값이 있습니다. 백그라운드의 고급 사용자 지정 하는 컨트롤을 만들려는 경우 컨트롤의 스타일을 정의 해야 합니다.  
  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.Background%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.BackgroundProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 배경 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#11)]  
  
 [!code-csharp[ControlProps#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[ControlProps#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#1)]  
  
 다음 예제를 누를 때 단추의 배경색을 변경 하는 트리거를 사용 하는 템플릿을 보여 줍니다.  
  
 [!code-xaml[BackgroundProp_snip#ButtonTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/BackgroundProp_snip/CS/page1.xaml#buttontemplate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Background" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush BorderBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush BorderBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.BorderBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ BorderBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 테두리 배경을 설명하는 브러시를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 테두리를 채우는 데 사용되는 브러시이며 기본값은 <see cref="P:System.Windows.Media.Brushes.Transparent" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.BorderBrush%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_BorderBrush"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.BorderBrushProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 테두리 브러시 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#17](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#17)]  
  
 [!code-csharp[ControlProps#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#7)]
 [!code-vb[ControlProps#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BorderBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderBrushProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.BorderBrush" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThickness">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness BorderThickness { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness BorderThickness" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.BorderThickness" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderThickness As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness BorderThickness { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 테두리 두께를 가져오거나 설정합니다.</summary>
        <value>두께 값이며 기본 값은 네 면 모두 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.BorderThickness%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_BorderThickness"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.BorderThicknessProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 테두리 두께 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops11)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops1)]
 [!code-vb[ControlProps_snip#AdditionalControlProps1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThicknessProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderThicknessProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderThicknessProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BorderThicknessProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderThicknessProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderThicknessProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.BorderThickness" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 글꼴 패밀리를 가져오거나 설정합니다.</summary>
        <value>글꼴 패밀리입니다. 기본값은 시스템 대화 상자 글꼴입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.FontFamily%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.FontFamilyProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 글꼴 패밀리 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#13](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#13)]  
  
 [!code-csharp[ControlProps#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#3)]
 [!code-vb[ControlProps#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontFamily" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>글꼴 크기를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Controls.Control" />의 텍스트 크기입니다. 기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontSize" />입니다. 글꼴 크기는 양수여야 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.FontSize%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.FontSizeProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object FontSize="double"/>  
- or –  
<object FontSize ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현을 <xref:System.Double> 값입니다. 이 값으로 해석 되는 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열은 소수점이 하를 명시적으로 포함 하지 않아야 합니다. 예를 들어 값 `1` 허용 됩니다.  
  
 동일한 <xref:System.Double> 여기 속성 값 섹션에서 설명 하는 제한 된 범위에 적용 합니다.  
  
 *qualifiedDouble*  
 A *double* 앞에서 설명한 대로 즉 값 다음에 단위 선언 문자열 중 하나: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값)은 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
 **참고** 대부분의 경우 double "Auto"로 설정할 수 있습니다 하지만 <xref:System.Windows.Controls.Control.FontSize%2A?displayProperty=nameWithType> 경우 렌더링 되지 않는 "자동"으로 설정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 글꼴 크기 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#14](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#14)]  
  
 [!code-csharp[ControlProps#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#4)]
 [!code-vb[ControlProps#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontSize" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>글꼴의 너비 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.FontStretch" /> 값입니다. 기본값은 <see cref="P:System.Windows.FontStretches.Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.FontStretch%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.FontStretchProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 글꼴 스트레치 속성을 설정 하는 방법을 보여 줍니다. 가능한 스트레치 값에 대 한 참조 <xref:System.Windows.FontStretches>합니다.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops12)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops2)]
 [!code-vb[ControlProps_snip#AdditionalControlProps2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontStretch" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>글꼴 스타일 속성을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.FontStyle" /> 값입니다. 기본값은 <see cref="P:System.Windows.FontStyles.Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.FontStyle%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.FontStyleProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 글꼴 스타일 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#15](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#15)]  
  
 [!code-csharp[ControlProps#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#5)]
 [!code-vb[ControlProps#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정한 글꼴의 두께 속성을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.FontWeight" /> 값입니다. 기본값은 <see cref="P:System.Windows.FontWeights.Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.FontWeight%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다. 목록은 미리 정의 된 <xref:System.Windows.FontWeight> 값, 참조는 <xref:System.Windows.FontWeights> 클래스입니다.  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.FontWeightProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 설정 하는 방법을 보여 주는 다음 예제는 <xref:System.Windows.Controls.Control.FontWeight%2A> 컨트롤의 속성입니다.  
  
 [!code-xaml[ControlProps#16](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#16)]  
  
 [!code-csharp[ControlProps#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#6)]
 [!code-vb[ControlProps#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.FontWeight" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>전경색을 설명하는 브러시를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 전경을 칠하는 브러시입니다. 기본값은 시스템 대화 상자 글꼴 색입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.Foreground%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.ForegroundProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 글꼴 스타일 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#12)]  
  
 [!code-csharp[ControlProps#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ControlProps#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Foreground" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandlesScrolling">
      <MemberSignature Language="C#" Value="protected internal virtual bool HandlesScrolling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HandlesScrolling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.HandlesScrolling" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property HandlesScrolling As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HandlesScrolling { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 스크롤을 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤의 스타일에 <see cref="T:System.Windows.Controls.ScrollViewer" />가 있고 사용자 지정 키보드 스크롤 동작이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalContentAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalContentAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalContentAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.HorizontalContentAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalContentAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalContentAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 콘텐츠의 가로 맞춤을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.HorizontalAlignment" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.HorizontalAlignment.Left" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 외에 <xref:System.Windows.HorizontalAlignment.Left>, <xref:System.Windows.HorizontalAlignment.Right>, 및 <xref:System.Windows.HorizontalAlignment.Center>, 설정할 수 있습니다는 <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> 속성을 <xref:System.Windows.HorizontalAlignment.Stretch>, 부모 요소에 할당 된 공간에 자식 요소가 늘어나입니다. 자세한 내용은 참조 [맞춤, 여백 및 안쪽 여백 개요](~/docs/framework/wpf/advanced/alignment-margins-and-padding-overview.md)합니다.  
  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_HorizontalContentAlignment"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.HorizontalContentAlignmentProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 가로 내용 맞춤 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#18](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#18)]  
  
 [!code-csharp[ControlProps#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#8)]
 [!code-vb[ControlProps#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalContentAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalContentAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalContentAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.HorizontalContentAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalContentAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalContentAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.HorizontalContentAlignment" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTabStop">
      <MemberSignature Language="C#" Value="public bool IsTabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.IsTabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTabStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 탭 탐색에 포함되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤이 탭 탐색에 포함되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Windows.Controls.Control.IsTabStop%2A> 은 `false`, 컨트롤은 탭 탐색에서 제외 합니다.  
  
<a name="dependencyPropertyInfo_IsTabStop"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.IsTabStopProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 설정 하는 방법을 보여 주는 다음 예제는 <xref:System.Windows.Controls.Control.IsTabStop%2A> 속성 및 컨트롤에 포함 되어 있는지 여부를 테스트 하는 방법에 대 한 탭 탐색 합니다.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps15](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops15)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops4)]
 [!code-vb[ControlProps_snip#AdditionalControlProps4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTabStopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTabStopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTabStopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.IsTabStopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTabStopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTabStopProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.IsTabStop" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">메서드에서 반환할 수 있는 최대 크기입니다.</param>
        <summary>컨트롤을 다시 측정하기 위해 호출됩니다.</summary>
        <returns>컨트롤의 크기이며, 최대값은 <paramref name="constraint" />로 지정됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 컨트롤 측정만 첫 번째 시각적 자식을 측정합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDoubleClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 단추를 두 번 이상 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 라우트된 이벤트가 요소 트리를 통해 버블링 경로 따르는 것 처럼 보이지만, 실제로 각 요소 트리를 따라 발생 하는 직접 라우트된 이벤트 <xref:System.Windows.UIElement>합니다. 설정 하는 경우는 <xref:System.Windows.RoutedEventArgs.Handled%2A> 속성을 `true` 에 <xref:System.Windows.Controls.Control.MouseDoubleClick> 이벤트 처리기의 경우 이후의 <xref:System.Windows.Controls.Control.MouseDoubleClick> 경로 따라 이벤트 발생 합니다 <xref:System.Windows.RoutedEventArgs.Handled%2A> 로 설정 `false`합니다. 응용 프로그램에서 이벤트를 처리 하 고 컨트롤을 두 번 클릭할 때 알림을 받으려면 하려는 컨트롤 소비자에 대 한 상위 수준의 이벤트입니다.  
  
 마우스 두 번 클릭을 처리 하려면 컨트롤 작성자 사용할지는 <xref:System.Windows.UIElement.MouseLeftButtonDown> 이벤트 때 <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> 2 일입니다.  이렇게 하면 상태의 <xref:System.Windows.RoutedEventArgs.Handled%2A> 요소 트리에 있는 다른 요소는 이벤트를 처리 하는 경우에 적절 하 게 전파 합니다.  
  
 <xref:System.Windows.Controls.Control> 클래스 정의 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> 및 <xref:System.Windows.Controls.Control.MouseDoubleClick> 이벤트 하지만 단일 클릭 이벤트를 해당 되지 않습니다.  사용자가 컨트롤을 두 번 클릭 하는 경우를 확인 하려면 처리는 <xref:System.Windows.UIElement.MouseDown> 이벤트 (또는 한) 확인 하 고 여부는 <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> 속성 값은 1입니다.  
  
<a name="routedEventInfo_MouseDoubleClick"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.MouseDoubleClickEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 이벤트 처리기를 연결 하는 방법을 보여 줍니다는 <xref:System.Windows.Controls.Control.MouseDoubleClick> 이벤트입니다.  
  
 [!code-xaml[ControlProps_snip#ControlEvents11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#controlevents11)]  
  
 다음 예제에서는 이벤트 처리기는 <xref:System.Windows.Controls.Control.MouseDoubleClick> 이벤트입니다.  
  
 [!code-csharp[ControlProps_snip#ControlEvents1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#controlevents1)]
 [!code-vb[ControlProps_snip#ControlEvents1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#controlevents1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDoubleClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDoubleClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.MouseDoubleClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDoubleClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDoubleClickEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.Controls.Control.MouseDoubleClick" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary>
          <see cref="E:System.Windows.Controls.Control.MouseDoubleClick" /> 라우트된 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 <xref:System.Windows.Controls.Control.MouseDoubleClick> 호출 하 여 이벤트는 <xref:System.Windows.UIElement.RaiseEvent%2A> 메서드. 자세한 내용은 참조 [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDoubleClick (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDoubleClick(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseDoubleClick (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseDoubleClick(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary>
          <see cref="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" /> 라우트된 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> 호출 하 여 이벤트는 <xref:System.Windows.UIElement.RaiseEvent%2A> 메서드.  자세한 내용은 참조 [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">이전 템플릿입니다.</param>
        <param name="newTemplate">새 템플릿입니다.</param>
        <summary>컨트롤의 템플릿이 변경될 때마다 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서식 파일을 변경 하는 것에 대 한 타이밍은 다음과 같습니다.  
  
1.  서식 파일에 의해 변경 되는 <xref:System.Windows.DependencyObject.SetValue%2A> 메서드 호출, 스타일 트리거 또는 다른 방법입니다.  
  
2.  속성 값을 변경 합니다. 속성 변경 콜백이 호출 됩니다.  
  
3.  이전 시각적 트리 제거 됩니다.  
  
4.  내부 메서드는 호출 될는 <xref:System.Windows.Controls.Control.OnTemplateChanged%2A> 메서드.  
  
5.  나중에 측정값을 하는 동안 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> 라고 새 시각적 트리 첨부 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 안쪽 여백 속성을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Controls.Control" />의 콘텐츠와 해당 <see cref="P:System.Windows.FrameworkElement.Margin" /> 또는 <see cref="T:System.Windows.Controls.Border" /> 사이의 간격입니다.  두께의 기본값은 네 면 모두 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 안쪽 여백 순서 왼쪽, 위쪽, 오른쪽 및 아래쪽에 지정 됩니다. 자세한 내용은 참조 <xref:System.Windows.Thickness> 및 [맞춤, 여백 및 안쪽 여백 개요](~/docs/framework/wpf/advanced/alignment-margins-and-padding-overview.md)합니다.  
  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.Padding%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.PaddingProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤의 안쪽 여백 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps13](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops13)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops3)]
 [!code-vb[ControlProps_snip#AdditionalControlProps3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Padding" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDoubleClick As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDoubleClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 마우스 단추를 두 번 이상 클릭하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 라우트된 이벤트가 요소 트리를 통해 터널링 경로 따르는 것 처럼 보이지만, 실제로 각 요소 트리를 따라 발생 하는 직접 라우트된 이벤트 <xref:System.Windows.UIElement>합니다. 설정 하는 경우는 <xref:System.Windows.RoutedEventArgs.Handled%2A> 속성을 `true` 에 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> 이벤트 처리기의 경우 이후의 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> 경로 따라 이벤트 발생 합니다 <xref:System.Windows.RoutedEventArgs.Handled%2A> 로 설정 `false`, 하지만 <xref:System.Windows.Controls.Control.MouseDoubleClick> 이벤트발생합니다<xref:System.Windows.RoutedEventArgs.Handled%2A>로 설정 `true`합니다. 응용 프로그램에서 이벤트를 처리 하 고 컨트롤을 두 번 클릭할 때 알림을 받으려면 하려는 컨트롤 소비자에 대 한 상위 수준의 이벤트입니다.  
  
 마우스 두 번 클릭을 처리 하려면 컨트롤 작성자 사용할지는 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 이벤트 때 <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> 2 일입니다.  이렇게 하면 상태의 <xref:System.Windows.RoutedEventArgs.Handled%2A> 요소 트리에 있는 다른 요소는 이벤트를 처리 하는 경우에 적절 하 게 전파 합니다.  
  
 <xref:System.Windows.Controls.Control> 클래스 정의 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> 및 <xref:System.Windows.Controls.Control.MouseDoubleClick> 이벤트 하지만 단일 클릭 이벤트를 해당 되지 않습니다.  사용자가 컨트롤을 두 번 클릭 하는 경우를 확인 하려면 처리는 <xref:System.Windows.UIElement.MouseDown> 이벤트 (또는 한) 확인 하 고 여부는 <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> 속성 값은 1입니다.  
  
<a name="routedEventInfo_PreviewMouseDoubleClick"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.PreviewMouseDoubleClickEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 이벤트 처리기를 연결 하는 방법을 보여 줍니다.는 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> 이벤트입니다.  
  
 [!code-xaml[ControlProps_snip#ControlEvents12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#controlevents12)]  
  
 다음 예제에서는 이벤트 처리기는 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> 이벤트입니다.  
  
 [!code-csharp[ControlProps_snip#ControlEvents2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#controlevents2)]
 [!code-vb[ControlProps_snip#ControlEvents2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#controlevents2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDoubleClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDoubleClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDoubleClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.PreviewMouseDoubleClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDoubleClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDoubleClickEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 Tab 키를 사용하여 컨트롤을 탐색할 때 요소가 포커스를 받는 순서를 결정하는 값을 가져오거나 설정합니다.</summary>
        <value>장치의 논리적 탐색 순서를 결정하는 값입니다. 기본값은 <see cref="F:System.Int32.MaxValue" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탭 인덱스가 낮은 포커스를 받을 인덱스가 높은 컨트롤 앞입니다.  
  
<a name="dependencyPropertyInfo_TabIndex"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.TabIndexProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 세 개의 단추가의 탭 인덱스를 설정합니다.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps17](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TabIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TabIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.TabIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TabIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TabIndexProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.TabIndex" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 템플릿을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Controls.Control" />의 모양을 정의하는 템플릿입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ControlTemplate> 의 모양을 지정는 <xref:System.Windows.Controls.Control>경우는 <xref:System.Windows.Controls.Control> 없는 <xref:System.Windows.Controls.ControlTemplate>, <xref:System.Windows.Controls.Control> 응용 프로그램에 표시 되지 것입니다. 제어 작성자는 기본 컨트롤 템플릿을 정의 하 고 응용 프로그램 작성자는 <xref:System.Windows.Controls.ControlTemplate> 컨트롤의 시각적 트리를 다시 정의 해야 합니다. 참조 [컨트롤 스타일 및 템플릿](~/docs/framework/wpf/controls/control-styles-and-templates.md) 내용 및 예제는 기존 컨트롤의 시각적 트리를 변경 하는 방법에 대 한 합니다.  
  
 A <xref:System.Windows.Controls.ControlTemplate> 사용자와 개체를 포함 하 여 외부에 표시 되지 않는 구현 정보의 자체 포함된 단위 수 <xref:System.Windows.Style> 개체입니다. 컨트롤의 콘텐츠를 조작 하기 위한 유일한 방법은 동일한 컨트롤 템플릿 내에서입니다.  
  
<a name="dependencyPropertyInfo_Template"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.TemplateProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Windows.Controls.ControlTemplate> 에 대 한는 <xref:System.Windows.Controls.Button>합니다.  이 리소스 응용 프로그램에 추가 하는 경우 응용 프로그램의 모든 단추는 타원으로 표시 되지만 단추 기능은 유지 됩니다.  
  
 [!code-xaml[StylingIntroSample_snippet#ButtonCT](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#buttonct)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.Template" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Controls.Control" /> 개체의 문자열 표현을 반환합니다.</summary>
        <returns>컨트롤을 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤 작성자는 컨트롤의 소비자에 게 유용한 정보를 포함 하는 문자열을 반환 하려면이 메서드를 재정의 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalContentAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalContentAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalContentAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.VerticalContentAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalContentAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalContentAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 콘텐츠의 세로 맞춤을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.VerticalAlignment" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.VerticalAlignment.Top" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 외에 <xref:System.Windows.VerticalAlignment.Top>, <xref:System.Windows.VerticalAlignment.Bottom>, 및 <xref:System.Windows.VerticalAlignment.Center>를 설정할 수 있습니다는 <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> 속성을 <xref:System.Windows.VerticalAlignment.Stretch>, 자식 요소가 부모 요소 레이아웃 할당 된 공간을 채우기 위해 늘여입니다. 자세한 내용은 참조 [맞춤, 여백 및 안쪽 여백 개요](~/docs/framework/wpf/advanced/alignment-margins-and-padding-overview.md)합니다.  
  
 이 속성에만 해당 템플릿을 사용 하 여 컨트롤 적용는 <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> 속성을 매개 변수로 합니다. 다른 컨트롤에 대해이 속성이 아무런 영향이 없습니다.  
  
<a name="dependencyPropertyInfo_VerticalContentAlignment"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Control.VerticalContentAlignmentProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 컨트롤에서 콘텐츠 세로 맞춤 속성을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ControlProps#19](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#19)]  
  
 [!code-csharp[ControlProps#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#9)]
 [!code-vb[ControlProps#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalContentAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalContentAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalContentAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.VerticalContentAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalContentAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalContentAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Controls.Control.VerticalContentAlignment" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>