<Type Name="RouteCollection" FullName="System.Web.Routing.RouteCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cf5ff60b46deeeccf60512f17fb902ace47c66d5" />
    <Meta Name="ms.sourcegitcommit" Value="1b899505ed6d42225f2b3c9150bfdc080d0d1f9b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/28/2018" />
    <Meta Name="ms.locfileid" Value="32089310" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RouteCollection : System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RouteCollection extends System.Collections.ObjectModel.Collection`1&lt;class System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Web.Routing.RouteCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class RouteCollection&#xA;Inherits Collection(Of RouteBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RouteCollection : System::Collections::ObjectModel::Collection&lt;System::Web::Routing::RouteBase ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Web.Routing.RouteBase</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ASP.NET 라우팅에 대한 경로 컬렉션을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection> 클래스에서 파생 된 개체의 컬렉션을 관리할 수 있도록 하는 메서드를 제공는 <xref:System.Web.Routing.RouteBase> 클래스입니다.  
  
 일반적으로 사용 됩니다는 `static` <xref:System.Web.Routing.RouteTable.Routes%2A> 의 속성은 <xref:System.Web.Routing.RouteTable> 검색할 클래스는 <xref:System.Web.Routing.RouteCollection> 개체입니다. <xref:System.Web.Routing.RouteTable.Routes%2A> 속성 ASP.NET 응용 프로그램에 대 한 모든 경로 저장 합니다. ASP.NET 라우팅에서의 경로를 반복 하는 <xref:System.Web.Routing.RouteTable.Routes%2A> URL과 일치 하는 경로 찾기 위해 속성입니다.  
  
 URL을 구성을 호출 하면는 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> 메서드 및 값 컬렉션을 전달 합니다. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> 메서드를 전달 하 고 반환 하는 값과 일치 하는 매개 변수는 첫 번째 경로 찾습니다는 <xref:System.Web.Routing.VirtualPathData> 일치 하는 경로 대 한 정보를 포함 하는 개체입니다. 통해 URL을 검색할는 <xref:System.Web.Routing.VirtualPathData.VirtualPath%2A> 의 속성은 <xref:System.Web.Routing.VirtualPathData> 개체입니다.  
  
 이름이 나 이름 없이 경로 추가할 수 있습니다. 이름을 포함 하면 Url이 생성 될 때 비슷한 경로 구분할 수 있습니다. 이름을 지정 하지 않는 경우 컬렉션의 첫 번째 일치 하는 경로 사용 하 여 URL을 구성을 ASP.NET 라우팅에서 합니다.  
  
 명명 되지 않은 경로를 추가 하는 경우는 <xref:System.Web.Routing.RouteCollection> 개체를 컬렉션에 이미 있는 경로 추가할 수 없습니다. 명명된 된 경로 추가 하면 이미 컬렉션에 대 한 경로 식별 하는 이름을 사용할 수 없습니다.  
  
 사용 된 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 및 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드를 다른 프로세스에서 충돌 없이 컬렉션과 상호 작용 하는 있는지 확인 합니다.  
  
 경로 컬렉션에 대 한 경로 추가 하는 방법에 대 한 자세한 내용은 참조 [ASP.NET 라우팅에서](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)합니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">가상 파일 시스템에서 리소스를 검색하기 위한 공급자입니다.</param>
        <summary>지정된 가상 경로 공급자를 사용하여 <see cref="T:System.Web.Routing.RouteCollection" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string name, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string name, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Add(System.String,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (name As String, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ name, System::Web::Routing::RouteBase ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="name">경로를 식별하는 값입니다. 값이 <see langword="null" /> 또는 빈 문자열일 수 있습니다.</param>
        <param name="item">컬렉션 끝에 추가할 경로입니다.</param>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> 개체의 끝에 경로를 추가하고 경로에 지정된 이름을 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection.Add%2A> 메서드를 사용 하면 경로 컬렉션에 추가할 때 경로 대 한 이름을 정의할 수 있습니다. 경로 대 한 이름을 정의 하 여 라우팅을 사용 하 여 URL을 생성할 때 사용할 특정 경로 지정할 수 있습니다. 특정 경로 지정 하는 둘 이상의 경로가 전달 하는 값과 일치 하는 경우 중요는 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> 메서드. 명명된 된 경로 지정 하지 않으면 경우 ASP.NET 라우팅이 값과 일치 하는 컬렉션의 첫 번째 경로 사용 합니다. 자세한 내용은 참조 [하는 방법: 경로에서 Url 생성](http://msdn.microsoft.com/library/1ffd4085-71f6-4822-be8f-f682ca638650)합니다.  
  
 이름에 한 번만 사용할 수는 <xref:System.Web.Routing.RouteCollection> 개체입니다.  
  
 경로 대 한 이름을 지정 해야 하는 경우 호출 하 여 경로 추가할 수 있습니다는 <xref:System.Collections.ObjectModel.Collection%601.Add%2A> 메서드.  
  
 사용 하 여는 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 및 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드를 다른 프로세스에서 충돌 없이 컬렉션과 상호 작용 하는 있는지 확인 합니다.  
  
   
  
## Examples  
 다음 예제에 대 한 경로 추가 하는 방법을 보여 줍니다는 <xref:System.Web.Routing.RouteCollection> 개체를 경로에 이름을 할당 합니다.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#1)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 이미 컬렉션에서 사용되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendTrailingSlash">
      <MemberSignature Language="C#" Value="public bool AppendTrailingSlash { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AppendTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public Property AppendTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AppendTrailingSlash { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>가상 경로가 정규화된 경우 후행 슬래시를 추가하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          후행 슬래시를 추가하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> 개체에서 요소를 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 및 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드를 다른 프로세스에서 충돌 없이 컬렉션과 상호 작용 하는 있는지 확인 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReadLock">
      <MemberSignature Language="C#" Value="public IDisposable GetReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReadLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션에서 개체를 검색할 때 스레드 보안을 관리하기 위한 개체를 제공합니다.</summary>
        <returns>스레드 보안을 관리하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection> 개체는 응용 프로그램에서 여러 프로세스에 사용할 수 있습니다. 따라서 응용 프로그램이 실행 중인 때 경로 검색 해야 할 경우 사용 된 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 스레드로부터 안전을 보장 하려면 메서드. 경로 컬렉션에 대 한 읽기 잠금이 가져와서 수 있도록 하는 동안에 검색할 컬렉션이 수정 되지 것입니다.  
  
 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 잠금을 수행할 수 있을 때까지 계속에서 스레드를 중지 합니다. 쓰기 잠금이 있으면 업데이트가 완료 되 고 쓰기 잠금이 해제 될 때까지 스레드가 대기 합니다. 경로 컬렉션에 대 한 읽기 잠금이 해제 될 때는 <xref:System.IDisposable> 이 메서드에 의해 반환 되는 개체는 삭제 되었습니다.  
  
 사용 하지 않는 경우 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>를 읽을 때 오류가 발생할 수 있습니다는 <xref:System.Web.Routing.RouteCollection> 컬렉션입니다. 예를 들어,의 개체를 통해 루프는 <xref:System.Web.Routing.RouteCollection> 호출 하지 않고, 읽을 컬렉션 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>합니다. 다른 요청에서 다른 스레드에서 호출할 수 있는 수행 하는 동안 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 컬렉션에 대 한 경로 추가 합니다. 첫 번째 스레드가 오류가 발생 하 여 다음 실패 합니다.  
  
 두 가지 시나리오는 않아도 호출 하 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>:  
  
-   공용 메서드는 <xref:System.Web.Routing.RouteCollection> 같은 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> 및 <xref:System.Web.Routing.RouteCollection.GetRouteData%2A> 호출 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 내부적으로 합니다. 명시적으로 호출할 필요가 없습니다 따라서 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 의 공용 메서드를 호출 하는 경우는 <xref:System.Web.Routing.RouteCollection> 클래스 컬렉션에서 데이터를 검색 합니다.  
  
-   응용 프로그램 시작 되 고 아직을 처리 하지 않은 요청을 등의 경우는 `Application_Start` 이벤트 처리기를 하나만 스레드가 실행 중입니다. 읽는 동안 컬렉션을 업데이트 해야 할 수 있는 다른 스레드가 있으므로 호출 필요가 없습니다 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>합니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 응용 프로그램이 실행 되는 경로 검색 하는 경우. `Using` 문을 통해를 읽을 때 컬렉션에서 (코드가 정상적으로 완료 되거나 예외가 throw 됩니다) 여부는 런타임 시 수행 되는 작업에 관계 없이 잠금 안전 하 게 해제 됩니다의 끝에는 `Using` 코드 블록입니다.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData GetRouteData (System.Web.HttpContextBase httpContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.RouteData GetRouteData(class System.Web.HttpContextBase httpContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetRouteData(System.Web.HttpContextBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteData (httpContext As HttpContextBase) As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::RouteData ^ GetRouteData(System::Web::HttpContextBase ^ httpContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpContext" Type="System.Web.HttpContextBase" />
      </Parameters>
      <Docs>
        <param name="httpContext">HTTP 요청에 대한 정보를 캡슐화하는 개체입니다.</param>
        <summary>지정된 값과 일치하는 컬렉션의 경로에 관한 정보를 반환합니다.</summary>
        <returns>경로 정의의 값이 포함된 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="context" /> 매개 변수에서 개체의 <see cref="P:System.Web.HttpContextBase.Request" /> 속성이 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetVirtualPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>경로와 연결되는 URL 경로에 대한 정보를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">요청된 경로에 대한 정보를 캡슐화하는 개체입니다.</param>
        <param name="values">경로에 대한 매개 변수를 포함하는 개체입니다.</param>
        <summary>지정된 컨텍스트 및 매개 변수 값을 기준으로 경로와 연결된 URL 경로에 대한 정보를 반환합니다.</summary>
        <returns>경로와 연결된 URL 경로에 대한 정보를 포함하는 개체입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, string name, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, string name, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::String ^ name, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">요청된 경로에 대한 정보를 캡슐화하는 개체입니다.</param>
        <param name="name">URL 경로에 대한 정보를 검색할 때 사용할 경로의 이름입니다.</param>
        <param name="values">경로에 대한 매개 변수를 포함하는 개체입니다.</param>
        <summary>지정된 컨텍스트, 경로 이름 및 매개 변수 값을 기반으로 하여 명명된 경로와 연결된 URL 경로에 대한 정보를 반환합니다.</summary>
        <returns>경로와 연결된 URL 경로에 대한 정보를 포함하는 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수에 지정된 이름을 갖는 경로를 찾을 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWriteLock">
      <MemberSignature Language="C#" Value="public IDisposable GetWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWriteLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션에서 요소를 추가하거나 제거할 때 스레드 보안을 관리하기 위한 개체를 제공합니다.</summary>
        <returns>스레드 보안을 관리하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 권장 되는 ASP.NET 응용 프로그램에서 경로 정의 하는 방법에 대 한 경로 추가 하는 것은 <xref:System.Web.Routing.RouteTable.Routes%2A> 속성에 대 한 이벤트 처리기에는 `Application_Start` Global.asax 파일에는 이벤트입니다. 자세한 내용은 <xref:System.Web.Routing.RouteCollection>을 참조하세요.  
  
 사용 하는 응용 프로그램을 실행 하는 경우 경로 추가 해야 할 경우는 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 스레드로부터 안전을 보장 하려면 메서드. 경로 컬렉션에 쓰기 잠금이 해제 될 때는 <xref:System.IDisposable> 이 메서드에 의해 반환 되는 개체는 삭제 되었습니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드는 응용 프로그램을 실행 하는 동안 경로 추가할 때.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ignore">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>경로에 대해 일치 여부를 확인하지 않아야 하는 URL 패턴을 정의합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 만드는 경로에 매핑되는 <xref:System.Web.Routing.StopRoutingHandler> 경로 처리기입니다. 이 메서드를 호출 하면 지정된 된 URL 패턴 일치 하는 요청 경로 요청으로 처리 되지 않습니다.  
  
 ASP.NET 라우팅에서 URL이 이미지 파일 등의 물리적 파일와 일치 하는 경우 요청 자동으로 무시 합니다. 경우에 따라 수도 있습니다 라우팅 물리적 파일이 있는 경우 요청을 무시 하도록 합니다. 예를 들어 ASP.NET.axd 파일에 대 한 자동으로 확인 하는 요청 처리 되어서는 안 경로 요청으로.axd 파일 이름 확장명에 해당 하는 실제 파일이 없는 경우에 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">무시할 URL 패턴입니다.</param>
        <summary>경로에 대해 일치 여부를 확인하지 않아야 하는 URL 패턴을 정의합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 만드는 경로에 매핑되는 <xref:System.Web.Routing.StopRoutingHandler> 경로 처리기입니다. 이 메서드를 호출 하면 지정된 된 URL 패턴 일치 하는 요청 경로 요청으로 처리 되지 않습니다.  
  
 ASP.NET 라우팅에서 URL이 이미지 파일 등의 물리적 파일와 일치 하는 경우 요청 자동으로 무시 합니다. 경우에 따라 수도 있습니다 라우팅 물리적 파일이 있는 경우 요청을 무시 하도록 합니다. 예를 들어 ASP.NET.axd 파일에 대 한 자동으로 확인 하는 요청 처리 되어서는 안 경로 요청으로.axd 파일 이름 확장명에 해당 하는 실제 파일이 없는 경우에 합니다.  
  
   
  
## Examples  
 다음 예제와 같이, 라우팅에서.axd 파일을 제외 하려면이 메서드를 사용 하는 MVC 프로젝트에 대 한 기본 서식 파일:  
  
 [!code-csharp[MvcDefaultApp#2](~/samples/snippets/csharp/VS_Snippets_WebNet/mvcdefaultapp/cs/global.asax.cs#2)]
 [!code-vb[MvcDefaultApp#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/mvcdefaultapp/vb/global.asax.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url, object constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url, object constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String, constraints As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url, System::Object ^ constraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="constraints" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="url">무시할 URL 패턴입니다.</param>
        <param name="constraints">URL 패턴과 일치하는 요청을 무시할지 여부를 결정하는 추가 조건입니다.</param>
        <summary>요청 URL이 지정된 제약 조건을 충족하는 경우 경로에 대한 일치 여부를 확인하지 않아야 하는 URL 패턴을 정의합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 만드는 경로에 매핑되는 <xref:System.Web.Routing.StopRoutingHandler> 경로 처리기입니다. 이 메서드를 호출 하면 지정된 된 URL 패턴 일치 하는 요청 경로 요청으로 처리 되지 않습니다.  
  
 ASP.NET 라우팅에서 URL이 이미지 파일 등의 물리적 파일와 일치 하는 경우 요청 자동으로 무시 합니다. 경우에 따라 수도 있습니다 라우팅 물리적 파일이 있는 경우 요청을 무시 하도록 합니다. 예를 들어 ASP.NET.axd 파일에 대 한 자동으로 확인 하는 요청 처리 되어서는 안 경로 요청으로.axd 파일 이름 확장명에 해당 하는 실제 파일이 없는 경우에 합니다.  
  
   
  
## Examples  
 다음 예제에서는 모든 Url을 확장명이.aspx 무시 하려면이 메서드를 사용 하는 방법을 보여 줍니다. ".Aspx" 확장명을 가진 파일에 대 한 모든 Url을 처리 하는 사용자 지정 HTTP 처리기를 등록 하는 경우이 작업을 수행 수 있습니다. 단일 URL 패턴 일치 하는 모든.aspx 요청 해야 포괄적인 두 개의 매개 변수가 같은 `{*path}.aspx/{*pathinfo}`합니다. (이 패턴 일치 하는.aspx, 쿼리 문자열 매개 변수를 포함 하 여로 끝나는 모든 URL.) 그러나 라우팅에서 끝에 캐치 올 매개 변수는 하나만 허용 합니다. 대신 모든 Url과 일치 하는 포괄적인 단일 매개 변수가 있는 URL 패턴을 지정 하 고 다음 예제와 같이.aspx 확장명이 없는 모든 항목을 제외 하는 제약 조건을 수 있습니다.:  
  
```vb  
routes.Ignore("{*allaspx}", new With {.allaspx = ".*\.aspx(/.*)?"})  
```  
  
```csharp  
routes.Ignore("{*allaspx}", new {allaspx=@".*\.aspx(/.*)?"});  
```  
  
 일반적으로 코드의 이전 줄에서 호출 되는 메서드를에 추가 되는 `Application_Start` 의 예제에 나와 있는 것 처럼 global.asax는 <xref:System.Web.Routing.RouteCollection.Ignore%28System.String%29> 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.InsertItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">
          <c>item</c>을 삽입할 인덱스(0부터 시작)입니다.</param>
        <param name="item">삽입할 경로입니다.</param>
        <summary>지정한 인덱스에 있는 <see cref="T:System.Web.Routing.RouteCollection" /> 개체에 지정된 경로를 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 되지 않은 경로를 추가 하는 경우는 <xref:System.Web.Routing.RouteCollection> 개체를 컬렉션에 이미 있는 경로 추가할 수 없습니다.  
  
 사용 하 여는 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 및 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드를 다른 프로세스에서 충돌 없이 컬렉션과 상호 작용 하는 있는지 확인 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />이 컬렉션에 이미 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteBase this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteBase Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(name As String) As RouteBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteBase ^ default[System::String ^] { System::Web::Routing::RouteBase ^ get(System::String ^ name); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 경로를 식별하는 값입니다.</param>
        <summary>컬렉션에서 지정된 이름을 가진 경로를 가져옵니다.</summary>
        <value>지정된 이름을 가진 개체 또는 <paramref name="name" />이 <see langword="null" />이거나 빈 문자열이거나 컬렉션의 경로와 일치하지 않을 경우 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 및 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드를 다른 프로세스에서 충돌 없이 컬렉션과 상호 작용 하는 있는지 확인 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowercaseUrls">
      <MemberSignature Language="C#" Value="public bool LowercaseUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LowercaseUrls" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property LowercaseUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LowercaseUrls { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>가상 경로가 정규화된 경우 URL이 소문자로 변환되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          URL을 소문자로 변환하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쿼리 문자열은 URL를 포함 하는 경우 URL의 해당 부분을 소문자로 변환 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPageRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Web Forms 응용 프로그램의 경로를 정의하는 방법을 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 같습니다는 <xref:System.Web.Routing.RouteCollection.Add%2A> 메서드와 전달은 <xref:System.Web.Routing.Route> 를 사용 하 여 만든 개체는 <xref:System.Web.Routing.PageRouteHandler> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는이 방법을 사용 하 여 Web Forms 응용 프로그램에 대 한 경로 정의 하는 방법을 보여 줍니다. 이 예제에서는 명명 된 메서드를 보여 줍니다. `RegisterRoutes` 에서 호출 되는 `Application_Start` Global.asax 파일에 있습니다. 메서드에서 사용의 각 오버 로드 <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> 응용 프로그램에 경로 추가 합니다. Web Forms 응용 프로그램에 대 한 경로 정의 하는 방법에 대 한 자세한 내용은 참조 [하는 방법: Web Forms 응용 프로그램에 대 한 경로 정의](http://msdn.microsoft.com/library/200fe812-d0a6-4531-b9b4-cfc4ee83a678)합니다.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#122)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#122)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeUrl">경로에 대한 URL 패턴입니다.</param>
        <param name="physicalFile">경로의 실제 URL입니다.</param>
        <summary>Web Forms 응용 프로그램의 경로를 정의하는 방법을 제공합니다.</summary>
        <returns>경로 컬렉션에 추가되는 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 같습니다는 <xref:System.Web.Routing.RouteCollection.Add%2A> 메서드와 전달은 <xref:System.Web.Routing.Route> 를 사용 하 여 만든 개체는 <xref:System.Web.Routing.PageRouteHandler> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는이 방법을 사용 하 여 경로 정의 하는 방법을 보여 줍니다. 첫 번째 문은 이름을 없는 경로 정의 합니다. 두 번째 문은 명명된 된 경로 정의합니다. 이 예제는에서 사용할 수 있는 보다 큰 예제의 일부는 <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> 메서드 개요입니다.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#140)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#140)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeUrl">경로에 대한 URL 패턴입니다.</param>
        <param name="physicalFile">경로의 실제 URL입니다.</param>
        <param name="checkPhysicalUrlAccess">ASP.NET에서 사용자가 실제 URL에 액세스할 수 있는 권한을 가지고 있는지를 확인해야 할지(경로 URL이 항상 검사되는지) 여부를 나타내는 값입니다. 이 매개 변수는 <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> 속성을 설정합니다.</param>
        <summary>Web Forms 응용 프로그램의 경로를 정의하는 방법을 제공합니다.</summary>
        <returns>경로 컬렉션에 추가되는 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 같습니다는 <xref:System.Web.Routing.RouteCollection.Add%2A> 메서드와 전달은 <xref:System.Web.Routing.Route> 를 사용 하 여 만든 개체는 <xref:System.Web.Routing.PageRouteHandler> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는이 방법을 사용 하 여 경로 정의 하는 방법을 보여 줍니다. 이 예제는에서 사용할 수 있는 보다 큰 예제의 일부는 <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> 메서드 개요입니다.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#145)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#145)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeUrl">경로에 대한 URL 패턴입니다.</param>
        <param name="physicalFile">경로의 실제 URL입니다.</param>
        <param name="checkPhysicalUrlAccess">ASP.NET에서 사용자가 실제 URL에 액세스할 수 있는 권한을 가지고 있는지를 확인해야 할지(경로 URL이 항상 검사되는지) 여부를 나타내는 값입니다. 이 매개 변수는 <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> 속성을 설정합니다.</param>
        <param name="defaults">경로 매개 변수의 기본값입니다.</param>
        <summary>Web Forms 응용 프로그램의 경로를 정의하는 방법을 제공합니다.</summary>
        <returns>경로 컬렉션에 추가되는 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 같습니다는 <xref:System.Web.Routing.RouteCollection.Add%2A> 메서드와 전달은 <xref:System.Web.Routing.Route> 를 사용 하 여 만든 개체는 <xref:System.Web.Routing.PageRouteHandler> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는이 방법을 사용 하 여 경로 정의 하는 방법을 보여 줍니다. 이 예제는에서 사용할 수 있는 보다 큰 예제의 일부는 <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> 메서드 개요입니다.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#150)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeUrl">경로에 대한 URL 패턴입니다.</param>
        <param name="physicalFile">경로의 실제 URL입니다.</param>
        <param name="checkPhysicalUrlAccess">ASP.NET에서 사용자가 실제 URL에 액세스할 수 있는 권한을 가지고 있는지를 확인해야 할지(경로 URL이 항상 검사되는지) 여부를 나타내는 값입니다. 이 매개 변수는 <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> 속성을 설정합니다.</param>
        <param name="defaults">경로의 기본값입니다.</param>
        <param name="constraints">URL 요청이 이 경로로 처리되기 위해 충족해야 할 제약 조건입니다.</param>
        <summary>Web Forms 응용 프로그램의 경로를 정의하는 방법을 제공합니다.</summary>
        <returns>경로 컬렉션에 추가되는 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 같습니다는 <xref:System.Web.Routing.RouteCollection.Add%2A> 메서드와 전달은 <xref:System.Web.Routing.Route> 를 사용 하 여 만든 개체는 <xref:System.Web.Routing.PageRouteHandler> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는이 방법을 사용 하 여 경로 정의 하는 방법을 보여 줍니다. 이 예제는에서 사용할 수 있는 보다 큰 예제의 일부는 <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> 메서드 개요입니다.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#155)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints, System.Web.Routing.RouteValueDictionary dataTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints, class System.Web.Routing.RouteValueDictionary dataTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints, System::Web::Routing::RouteValueDictionary ^ dataTokens);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="dataTokens" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeUrl">경로에 대한 URL 패턴입니다.</param>
        <param name="physicalFile">경로의 실제 URL입니다.</param>
        <param name="checkPhysicalUrlAccess">ASP.NET에서 사용자가 실제 URL에 액세스할 수 있는 권한을 가지고 있는지를 확인해야 할지(경로 URL이 항상 검사되는지) 여부를 나타내는 값입니다. 이 매개 변수는 <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> 속성을 설정합니다.</param>
        <param name="defaults">경로 매개 변수의 기본값입니다.</param>
        <param name="constraints">URL 요청이 이 경로로 처리되기 위해 충족해야 할 제약 조건입니다.</param>
        <param name="dataTokens">경로와 연결되지만 경로가 URL 패턴과 일치하는지 여부를 결정하는 데 사용되지 않는 값입니다.</param>
        <summary>Web Forms 응용 프로그램의 경로를 정의하는 방법을 제공합니다.</summary>
        <returns>경로 컬렉션에 추가되는 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 같습니다는 <xref:System.Web.Routing.RouteCollection.Add%2A> 메서드와 전달은 <xref:System.Web.Routing.Route> 를 사용 하 여 만든 개체는 <xref:System.Web.Routing.PageRouteHandler> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는이 방법을 사용 하 여 경로 정의 하는 방법을 보여 줍니다. 이 예제는에서 사용할 수 있는 보다 큰 예제의 일부는 <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> 메서드 개요입니다.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#160)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#160)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="routeUrl" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">제거할 경로의 인덱스(0부터 시작)입니다.</param>
        <summary>지정한 인덱스에 있는 <see cref="T:System.Web.Routing.RouteCollection" /> 개체에서 경로를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 및 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드를 다른 프로세스에서 충돌 없이 컬렉션과 상호 작용 하는 있는지 확인 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteExistingFiles">
      <MemberSignature Language="C#" Value="public bool RouteExistingFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteExistingFiles" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteExistingFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteExistingFiles { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 라우팅에서 기존 파일과 일치하는 URL을 처리할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          기존 파일과 일치하는 요청을 비롯한 모든 요청을 ASP.NET 라우팅이 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 값이 동적으로 변경할 수 있지만 변경 하는 서비스를 활성화 한 후 ASP.NET 라우팅 통합을 사용 하는 경우 무시 됩니다. 자세한 내용은 참조 [ASP.NET 라우팅 통합](http://go.microsoft.com/fwlink/?LinkId=195235)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.SetItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">바꿀 경로의 인덱스(0부터 시작)입니다.</param>
        <param name="item">지정된 인덱스에 추가할 경로입니다.</param>
        <summary>지정한 인덱스에 있는 경로를 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 되지 않은 경로를 추가 하는 경우는 <xref:System.Web.Routing.RouteCollection> 개체를 컬렉션에 이미 있는 경로 추가할 수 없습니다.  
  
 사용 하 여는 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> 메서드 및 <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> 메서드를 다른 프로세스에서 충돌 없이 컬렉션과 상호 작용 하는 있는지 확인 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />이 컬렉션에 이미 있는 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>