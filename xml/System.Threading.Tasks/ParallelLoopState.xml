<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ParallelLoopState.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53e4244160069333f5d930b81c7b54173c2ad6d6a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e4244160069333f5d930b81c7b54173c2ad6d6a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Enables iterations of parallel loops to interact with other iterations.</source>
          <target state="translated">병렬 루프의 반복이 다른 반복과 상호 작용하도록 합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>An instance of this class is provided by the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Parallel" /&gt;</ph> class to each loop; you can not create instances in your code.</source>
          <target state="translated">이 클래스의 인스턴스는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Parallel" /&gt;</ph> 클래스에 의해 각 루프에 제공됩니다. 사용자 코드에 인스턴스를 만들 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Note that you cannot instantiate an instance of this class.</source>
          <target state="translated">참고가이 클래스의 인스턴스를 인스턴스화할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>It is automatically generated by the compiler as an argument in a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">에 대 한 호출에서 인수로 컴파일러에서 자동으로 생성 되는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>The example provides an illustration.</source>
          <target state="translated">예제에서는 그림을 제공합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Constructs such as <ph id="ph1">`for`</ph> and <ph id="ph2">`foreach`</ph> (in C#) and <ph id="ph3">`For`</ph> and <ph id="ph4">`For Each`</ph> (in Visual Basic) execute sequentially from the lowest index to the highest or from the first object in a set to the last.</source>
          <target state="translated">와 같은 생성 <ph id="ph1">`for`</ph> 및 <ph id="ph2">`foreach`</ph> (C#의) 및 <ph id="ph3">`For`</ph> 및 <ph id="ph4">`For Each`</ph> (Visual Basic)에서는 순차적으로 또는 집합에 있는 첫 번째 개체에서 가장 높은 최저 인덱스에서 마지막까지 실행 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> methods do not.</source>
          <target state="translated">반면,는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> 메서드는 그렇지 않습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Because individual iterations of the loop run in parallel, they can begin and end in any order.</source>
          <target state="translated">루프의 각 반복을 병렬로 실행할 때문에 시작 하 고 순서에 관계 없이 종료 수 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState&gt;</ph> class allows individual iterations of parallel loops to interact with one another.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState&gt;</ph> 서로 상호 작용 하 여 병렬 루프의 반복이 개별 클래스를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState&gt;</ph> class allows you to:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState&gt;</ph> 클래스 수 있습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Exit the current iteration and prevent any additional iterations from starting by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method.</source>
          <target state="translated">현재 반복을 종료 하 고 호출 하 여 처음부터 모든 추가 반복을 방지는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>This does not affect iterations that have already begun execution.</source>
          <target state="translated">이미 실행을 시작 하는 반복에는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Prevent any iterations with an index greater than the current index from executing by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">현재 인덱스 보다 큰 인덱스를 포함 하는 반복 호출 하 여 실행할 수 없도록 방지는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>This does not affect iterations that have already begun execution.</source>
          <target state="translated">이미 실행을 시작 하는 반복에는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Determine whether an exception has occurred in any loop iteration by retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A&gt;</ph> property.</source>
          <target state="translated">값을 검색 하 여 루프 반복에서 예외가 발생 했는지 확인는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Determine whether any iteration of the loop has called the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method by retrieving the value of the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> property.</source>
          <target state="translated">루프의 반복이 호출 하는지 여부를 결정는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 값을 검색 하 여 메서드에 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>You can use this property to return from iterations of the loop that started before the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method but are still executing.</source>
          <target state="translated">이 속성을 사용 하 여 호출 하기 전에 시작 된 루프의 반복에서 반환할 수는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드 하지만 계속 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Determine whether any iteration of the loop has called the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method or has thrown an exception by retrieving the value of the <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> property.</source>
          <target state="translated">루프의 반복이 호출 하는지 여부를 결정은 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드 값을 검색 하 여 예외를 throw 또는 <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Exit from a long-running iteration whose index is greater than the index of an iteration in which Break was called by retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property.</source>
          <target state="translated">인덱스의 값을 검색 하 여 Break가 호출 하는 반복의 인덱스 보다 큽니다. 장기 실행 반복에서 종료는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>The following example executes up to 100 iterations of a loop in parallel.</source>
          <target state="translated">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</source>
          <target state="translated">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>A randomly generated value determines on which iteration of the loop the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method is called.</source>
          <target state="translated">루프의 반복에 결정 하는 임의로 생성 된 값은 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>As the output from the example shows, no iterations whose index is greater than the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property value start after the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">인덱스 보다 크면 반복 하는 예제에서 출력으로의 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 를 호출한 후 시작 하는 속성 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>Because iterations of the loop are still likely to be executing when the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method is called, each iteration calls the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> property to check whether another iteration has called the <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">루프의 반복은 여전히 때 실행할 수 있기 때문에 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드가 호출 되 면 각 반복 호출는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 다른 반복이 호출 되어 있는지 여부를 확인 하는 속성의 <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>If  the property value is <ph id="ph1">`true`</ph>, the iteration checks the value of the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property and, if it is greater than the current iteration's index value, returns immediately.</source>
          <target state="translated">속성 값이 <ph id="ph1">`true`</ph>, 반복의 값을 검사는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.ParallelLoopState" /&gt;</ph> instance is meant to be used only within the body of the loop to which an instance was provided.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.ParallelLoopState" /&gt;</ph> 인스턴스는 인스턴스가 제공 된 루프의 본문 내 에서만 사용 될 것입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>It is not safe to use a provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.ParallelLoopState" /&gt;</ph> instance after the associated loop ends, nor is it safe to explicitly hand it off to other threads and have those threads access it at any time.</source>
          <target state="translated">제공 된 사용 하 여 안전 하지 않습니다 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.ParallelLoopState" /&gt;</ph> 관련된 루프 후 인스턴스 종료 나 명시적으로 다른 스레드에서에 전달할 안전성 고 언제 든 지 액세스할 이러한 스레드에 있습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.ParallelLoopState">
          <source>A different <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.ParallelLoopState" /&gt;</ph> instance will be provided to each thread involved in a loop.</source>
          <target state="translated">다른 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.ParallelLoopState" /&gt;</ph> 인스턴스 루프에 관련 된 각 스레드에 제공 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>Communicates that the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Parallel" /&gt;</ph> loop should cease execution of iterations beyond the current iteration at the system's earliest convenience.</source>
          <target state="translated">현재 반복 이외에 시스템에서 편의상 빨리 수행하는 반복에서 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Parallel" /&gt;</ph> 루프의 반복 실행이 중단되도록 통신합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> indicates that no iterations after the current iteration should be run.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 현재 반복 후 반복을 실행 해야 함을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>It effectively cancels any additional iterations of the loop.</source>
          <target state="translated">효과적으로 루프의 모든 추가 반복을 취소합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>However, it does not stop any iterations that have already begun execution.</source>
          <target state="translated">그러나 모든 반복 실행을 이미 시작을 중지 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>For example, if <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> is called from the 100th iteration of a parallel loop iterating from 0 to 1,000, all iterations less than 100 should still be run, but the iterations from 101 through to 1000 that have not yet started are not executed.</source>
          <target state="translated">예를 들어 경우 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 반복 0에서 1, 000, 모든 반복을 100 보다 작은 해야 계속 실행 되지만 적용 되지 않은 아직 시작 되지 않습니다 1000 통해는 101부터 반복 실행 되어 병렬 루프의 100 번째 반복에서 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>For long-running iterations that may already be executing, <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> sets the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property to the current iteration's index if the current index is less than the current value of <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph>.</source>
          <target state="translated">장기 실행 반복 실행 이미 수에 대 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 설정는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성을 현재 인덱스의 현재 값 보다 작은 경우 현재 반복 인덱스 <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>To stop iterations whose index is greater than the lowest break iteration from competing execution, you should do the following:</source>
          <target state="translated">인덱스 경쟁 실행에서 가장 낮은 중단 반복 보다 크면 반복을 중지 하려면 다음을 수행 해야 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>Check whether the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">확인 여부는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 속성은 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>Exit from the iteration if its index is greater than the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property value.</source>
          <target state="translated">해당 항목이 있는 인덱스 보다 큰 경우 반복에서 종료는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>The example provides an illustration.</source>
          <target state="translated">예제에서는 그림을 제공합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> is typically employed in search-based algorithms where an ordering is present in the data source.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 일반적으로 순서는 데이터 원본에는 검색 기반 알고리즘에서 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>The following example executes up to 100 iterations of a loop in parallel.</source>
          <target state="translated">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</source>
          <target state="translated">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>A randomly generated value determines on which iteration of the loop the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method is called.</source>
          <target state="translated">루프의 반복에 결정 하는 임의로 생성 된 값은 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>As the output from the example shows, no iterations whose index is greater than the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property value start after the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">인덱스 보다 크면 반복 하는 예제에서 출력으로의 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 를 호출한 후 시작 하는 속성 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>Because iterations of the loop are still likely to be executing when the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method is called, each iteration calls the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> property to check whether another iteration has called the <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">루프의 반복은 여전히 때 실행할 수 있기 때문에 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드가 호출 되 면 각 반복 호출는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 다른 반복이 호출 되어 있는지 여부를 확인 하는 속성의 <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>If  the property value is <ph id="ph1">`true`</ph>, the iteration checks the value of the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property and, if it is greater than the current iteration's index value, returns immediately.</source>
          <target state="translated">속성 값이 <ph id="ph1">`true`</ph>, 반복의 값을 검사는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> method was previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> 메서드가 이미 호출된 경우</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.ParallelLoopState.Break">
          <source><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> may not be used in combination by iterations of the same loop.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph>은 동일한 루프의 반복을 조합하여 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.ParallelLoopState.IsExceptional">
          <source>Gets whether any iteration of the loop has thrown an exception that went unhandled by that iteration.</source>
          <target state="translated">루프 반복이 해당 반복에서 처리되지 않은 예외를 throw했는지 여부를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsExceptional">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an unhandled exception was thrown; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">처리되지 않은 예외를 throw했으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>Gets whether any iteration of the loop has called the <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> method.</source>
          <target state="translated">루프 반복에서 <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> 메서드를 호출했는지 여부를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any iteration has stopped the loop by calling the <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> 메서드를 호출하여 반복에서 루프를 중지했으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>For long-running iterations of the loop, you can retrieve the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> property to determine whether any iterations of the loop that began execution before the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method are still executing.</source>
          <target state="translated">장기 실행 루프의 반복에 대 한 값을 검색할 수 있습니다는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> 여부 루프의 모든 반복 하는 호출 전에 실행을 시작한 속성 확인 하는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드가 계속 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>You can then use the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> property to determine whether they should return immediately or execute normally.</source>
          <target state="translated">값을 사용할 수 있습니다는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> 즉시 반환 해야 하거나 정상적으로 실행 여부를 결정 하는 속성입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>The following example executes up to 10,000 iterations of a loop in parallel.</source>
          <target state="translated">다음 예제에서는 병렬에서 루프의 반복이 최대 10, 000를 실행합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</source>
          <target state="translated">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>A randomly generated value determines on which iteration of the loop the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method is called.</source>
          <target state="translated">루프의 반복에 결정 하는 임의로 생성 된 값은 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>Because iterations of the loop are still likely to be executing when the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method is called, the lambda expression calls the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> method to check whether another iteration has called the <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method.</source>
          <target state="translated">루프의 반복은 여전히 때 실행할 수 있기 때문에 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드가 호출 되는 람다 식 호출은 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
          <source>If it returns <ph id="ph1">`true`</ph>, the iteration returns immediately.</source>
          <target state="translated">반환 하는 경우 <ph id="ph1">`true`</ph>, 반복 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>Gets the lowest iteration of the loop from which <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> was called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph>이 호출된 루프의 가장 낮은 반복을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>The lowest iteration from which <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> was called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph>이 호출된 가장 낮은 반복입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>In the case of a <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /&gt;</ph> loop, the value is based on an internally-generated index.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /&gt;</ph> 루프의 경우 값은 내부에서 생성된 인덱스를 기반으로 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>It is possible for multiple iterations of a parallel loop to call the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">작업을 호출 하는 병렬 루프의 여러 번 반복 수는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>If they do, this value is the smallest index of an iteration that called <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph>.</source>
          <target state="translated">이 값은 호출 하는 반복의 가장 작은 인덱스 그럴 경우 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>If no iteration of the loop called <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph>, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">루프의 반복이 없는 메서드를 호출 하면 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph>,이 속성은 반환 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>Note that the property value is unaffected by calls to the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method.</source>
          <target state="translated">속성 값에 대 한 호출의 영향을 받지 않습니다는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>In long-running iterations in which all iterations after the iteration that calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method need not run, the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property is used to terminate iterations that began execution before the call to the <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">호출 하는 반복 후 모든 반복의 장기 실행 반복에는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드를 실행할 필요가는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성에 대 한 호출 하기 전에 실행을 시작 하는 반복을 종료 하는 데 사용 됩니다는 <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>To stop iterations whose index is greater than the lowest break iteration from competing execution, you should do the following:</source>
          <target state="translated">인덱스 경쟁 실행에서 가장 낮은 중단 반복 보다 크면 반복을 중지 하려면 다음을 수행 해야 합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>Check whether the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">확인 여부는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 속성은 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>Exit from the iteration if its index is greater than the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property value.</source>
          <target state="translated">해당 항목이 있는 인덱스 보다 큰 경우 반복에서 종료는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>The example provides an illustration.</source>
          <target state="translated">예제에서는 그림을 제공합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>The following example executes up to 100 iterations of a loop in parallel.</source>
          <target state="translated">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</source>
          <target state="translated">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>A randomly generated value determines on which iteration of the loop the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method is called.</source>
          <target state="translated">루프의 반복에 결정 하는 임의로 생성 된 값은 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>This prevents iterations whose index is greater than the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property value from starting after the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method, but it does not affect any iterations that have already begun executing.</source>
          <target state="translated">이렇게 하면 인덱스 보다 큽니다. 반복 되지 않습니다.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성 값에 대 한 호출 후 시작을 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 하지만 메서드를 이미 아직 실행이 시작 하는 모든 반복에 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>To prevent these from completing, each iteration calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> method to check whether another iteration has called the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">각 반복에서 완료를 방지 하기 위해 호출 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>If so, the iteration checks the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property and, if it is greater than the current iteration's index value, returns immediately.</source>
          <target state="translated">따라서 반복의 값을 확인 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> value is out of scope outside of the parallel loop, you must assign it to a variable that is visible outside of the loop if you want to preserve its value.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 값 병렬 루프 외부에서 범위를 벗어나면 값을 유지 하려는 경우 루프 외부에서 볼 수 있는 변수에 할당 해야 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>Gets whether the current iteration of the loop should exit based on requests made by this or other iterations.</source>
          <target state="translated">루프의 현재 반복이 해당 반복 또는 다른 반복에서 수행한 요청에 따라 종료되어야 하는지 여부를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current iteration should exit; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 반복이 종료되어야 하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph> under any of the following conditions:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 속성이 <ph id="ph2">`true`</ph> 다음 조건에서:</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>An iteration of the loop calls <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph>.</source>
          <target state="translated">루프 호출의 반복 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>An iteration of the loop throws an exception.</source>
          <target state="translated">루프의 반복 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>The loop is canceled.</source>
          <target state="translated">루프 취소 됩니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>When this property is <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> class will proactively attempt to prohibit additional iterations of the loop from starting execution.</source>
          <target state="translated">이 속성이 <ph id="ph1">`true`</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> 클래스 추가 반복에서 루프의 실행을 시작 하지 못하게 하려면 사전에 시도 됩니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>However, there may be cases where it is unable to prevent additional iterations from starting.</source>
          <target state="translated">그러나 경우 처음부터 추가 반복을 방지 하기 위해 수 없으면 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>It may also be the case that a long-running iteration has already begun execution.</source>
          <target state="translated">장기 실행 반복 하는 이미 시작 되었음을 실행 하는 경우 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>In such cases, iterations may explicitly check the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> property and cease execution if the property returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이러한 경우 반복 명시적으로 확인 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 속성 실행을 중지 속성이 반환 하는 경우 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>The following example executes up to 100 iterations of a loop in parallel.</source>
          <target state="translated">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</source>
          <target state="translated">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>A randomly generated value determines on which iteration of the loop the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method is called.</source>
          <target state="translated">루프의 반복에 결정 하는 임의로 생성 된 값은 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>This prevents iterations whose index is greater than the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property value from starting after the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method, but it does not affect any iterations that have already begun executing.</source>
          <target state="translated">이렇게 하면 인덱스 보다 큽니다. 반복 되지 않습니다.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성 값에 대 한 호출 후 시작을 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 하지만 메서드를 이미 아직 실행이 시작 하는 모든 반복에 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>To prevent these from completing, each iteration calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> method to check whether another iteration has called the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> method.</source>
          <target state="translated">각 반복에서 완료를 방지 하기 위해 호출 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A&gt;</ph> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.Break%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
          <source>If so, the iteration checks the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> property and, if it is greater than the current iteration's index value, returns immediately.</source>
          <target state="translated">따라서 반복의 값을 확인 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A&gt;</ph> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>Communicates that the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Parallel" /&gt;</ph> loop should cease execution at the system's earliest convenience.</source>
          <target state="translated">시스템에서 편의상 빨리 수행하는 반복에서 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Parallel" /&gt;</ph> 루프의 실행이 중단되도록 통신합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>Calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method indicates that any iterations of the loop that have not yet started need not be run.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드가 나타내는 아직 시작 되지 않은 루프의 반복 실행할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>It effectively cancels any additional iterations of the loop.</source>
          <target state="translated">효과적으로 루프의 모든 추가 반복을 취소합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>However, it does not stop any iterations that have already begun execution.</source>
          <target state="translated">그러나 모든 반복 실행을 이미 시작을 중지 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>Calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method causes the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> property to return <ph id="ph3">`true`</ph> for any iteration of the loop that is still executing.</source>
          <target state="translated">호출의 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드를 사용 하면은 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> 반환할 속성 <ph id="ph3">`true`</ph> 아직 실행 되는 루프의 반복에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>This is particularly useful for long-running iterations, which can check the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> property and exit early if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">이 확인할 수 있는 장기 실행 반복 하는 데 특히 유용는 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> 속성과 해당 값이 있는 경우에 일찍 종료 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> is typically employed in search-based algorithms, where once a result is found, no other iterations need be executed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 여기서 범위가 변경 되 면 있으면, 다른 반복을 실행할 필요가 검색 기반 알고리즘에서 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>The following example executes up to 10,000 iterations of a loop in parallel.</source>
          <target state="translated">다음 예제에서는 병렬에서 루프의 반복이 최대 10, 000를 실행합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</source>
          <target state="translated">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>A randomly generated value determines on which iteration of the loop the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method is called.</source>
          <target state="translated">루프의 반복에 결정 하는 임의로 생성 된 값은 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>As the output from the example shows, no iterations execute after the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method.</source>
          <target state="translated">반복 실행에 대 한 호출 후 예제의 출력에서 볼 수 있듯이 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>Because iterations of the loop are still likely to be executing when the <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method is called, each iteration calls the <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> method to check whether another iteration has called the <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> method.</source>
          <target state="translated">루프의 반복은 여전히 때 실행할 수 있기 때문에 <ph id="ph1">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드가 호출 되 면 호출 하는 각 반복에서 <ph id="ph2">&lt;xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A&gt;</ph> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <ph id="ph3">&lt;xref:System.Threading.Tasks.ParallelLoopState.Stop%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>If it returns <ph id="ph1">`true`</ph>, the iteration returns immediately.</source>
          <target state="translated">반환 하는 경우 <ph id="ph1">`true`</ph>, 반복 즉시 반환 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> method was called previously.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> 메서드가 이미 호출되었습니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.ParallelLoopState.Stop">
          <source><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph> may not be used in combination by iterations of the same loop.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /&gt;</ph>은 동일한 루프의 반복을 조합하여 사용할 수 없습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>