<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e4244160069333f5d930b81c7b54173c2ad6d6a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <TypeSignature Language="VB.NET" Value="Public Class ParallelLoopState" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelLoopState" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="1c258-101">병렬 루프의 반복이 다른 반복과 상호 작용하도록 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1c258-101">Enables iterations of parallel loops to interact with other iterations.</span>
      </span>
      <span data-ttu-id="1c258-102">이 클래스의 인스턴스는 <see cref="T:System.Threading.Tasks.Parallel" /> 클래스에 의해 각 루프에 제공됩니다. 사용자 코드에 인스턴스를 만들 수는 없습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1c258-102">An instance of this class is provided by the <see cref="T:System.Threading.Tasks.Parallel" /> class to each loop; you can not create instances in your code.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1c258-103">참고가이 클래스의 인스턴스를 인스턴스화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-103">Note that you cannot instantiate an instance of this class.</span></span> <span data-ttu-id="1c258-104">에 대 한 호출에서 인수로 컴파일러에서 자동으로 생성 되는 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-104">It is automatically generated by the compiler as an argument in a call to the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1c258-105">예제에서는 그림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-105">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="1c258-106">와 같은 생성 `for` 및 `foreach` (C#의) 및 `For` 및 `For Each` (Visual Basic)에서는 순차적으로 또는 집합에 있는 첫 번째 개체에서 가장 높은 최저 인덱스에서 마지막까지 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-106">Constructs such as `for` and `foreach` (in C#) and `For` and `For Each` (in Visual Basic) execute sequentially from the lowest index to the highest or from the first object in a set to the last.</span></span> <span data-ttu-id="1c258-107">반면,는 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-107">In contrast, the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> methods do not.</span></span> <span data-ttu-id="1c258-108">루프의 각 반복을 병렬로 실행할 때문에 시작 하 고 순서에 관계 없이 종료 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-108">Because individual iterations of the loop run in parallel, they can begin and end in any order.</span></span> <span data-ttu-id="1c258-109"><xref:System.Threading.Tasks.ParallelLoopState> 서로 상호 작용 하 여 병렬 루프의 반복이 개별 클래스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-109">The <xref:System.Threading.Tasks.ParallelLoopState> class allows individual iterations of parallel loops to interact with one another.</span></span> <span data-ttu-id="1c258-110"><xref:System.Threading.Tasks.ParallelLoopState> 클래스 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-110">The <xref:System.Threading.Tasks.ParallelLoopState> class allows you to:</span></span>  
  
-   <span data-ttu-id="1c258-111">현재 반복을 종료 하 고 호출 하 여 처음부터 모든 추가 반복을 방지는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-111">Exit the current iteration and prevent any additional iterations from starting by calling the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span> <span data-ttu-id="1c258-112">이미 실행을 시작 하는 반복에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-112">This does not affect iterations that have already begun execution.</span></span>  
  
-   <span data-ttu-id="1c258-113">현재 인덱스 보다 큰 인덱스를 포함 하는 반복 호출 하 여 실행할 수 없도록 방지는 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-113">Prevent any iterations with an index greater than the current index from executing by calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="1c258-114">이미 실행을 시작 하는 반복에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-114">This does not affect iterations that have already begun execution.</span></span>  
  
-   <span data-ttu-id="1c258-115">값을 검색 하 여 루프 반복에서 예외가 발생 했는지 확인는 <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-115">Determine whether an exception has occurred in any loop iteration by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> property.</span></span>  
  
-   <span data-ttu-id="1c258-116">루프의 반복이 호출 하는지 여부를 결정는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 값을 검색 하 여 메서드에 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-116">Determine whether any iteration of the loop has called the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property.</span></span> <span data-ttu-id="1c258-117">이 속성을 사용 하 여 호출 하기 전에 시작 된 루프의 반복에서 반환할 수는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드 하지만 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-117">You can use this property to return from iterations of the loop that started before the call to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method but are still executing.</span></span>  
  
-   <span data-ttu-id="1c258-118">루프의 반복이 호출 하는지 여부를 결정은 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 또는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드 값을 검색 하 여 예외를 throw 또는 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-118">Determine whether any iteration of the loop has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> or <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method or has thrown an exception by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property.</span></span>  
  
-   <span data-ttu-id="1c258-119">인덱스의 값을 검색 하 여 Break가 호출 하는 반복의 인덱스 보다 큽니다. 장기 실행 반복에서 종료는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-119">Exit from a long-running iteration whose index is greater than the index of an iteration in which Break was called by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1c258-120">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-120">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="1c258-121">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-121">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="1c258-122">루프의 반복에 결정 하는 임의로 생성 된 값은 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-122">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="1c258-123">인덱스 보다 크면 반복 하는 예제에서 출력으로의 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 를 호출한 후 시작 하는 속성 값은 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-123">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="1c258-124">루프의 반복은 여전히 때 실행할 수 있기 때문에 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드가 호출 되 면 각 반복 호출는 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 다른 반복이 호출 되어 있는지 여부를 확인 하는 속성의 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-124">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="1c258-125">속성 값이 `true`, 반복의 값을 검사는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-125">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="1c258-126">A <see cref="T:System.Threading.Tasks.ParallelLoopState" /> 인스턴스는 인스턴스가 제공 된 루프의 본문 내 에서만 사용 될 것입니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1c258-126">A <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instance is meant to be used only within the body of the loop to which an instance was provided.</span>
      </span>
      <span data-ttu-id="1c258-127">제공 된 사용 하 여 안전 하지 않습니다 <see cref="T:System.Threading.Tasks.ParallelLoopState" /> 관련된 루프 후 인스턴스 종료 나 명시적으로 다른 스레드에서에 전달할 안전성 고 언제 든 지 액세스할 이러한 스레드에 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1c258-127">It is not safe to use a provided <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instance after the associated loop ends, nor is it safe to explicitly hand it off to other threads and have those threads access it at any time.</span>
      </span>
      <span data-ttu-id="1c258-128">다른 <see cref="T:System.Threading.Tasks.ParallelLoopState" /> 인스턴스 루프에 관련 된 각 스레드에 제공 됩니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1c258-128">A different <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instance will be provided to each thread involved in a loop.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberSignature Language="VB.NET" Value="Public Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Break();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1c258-129">현재 반복 이외에 시스템에서 편의상 빨리 수행하는 반복에서 <see cref="T:System.Threading.Tasks.Parallel" /> 루프의 반복 실행이 중단되도록 통신합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-129">Communicates that the <see cref="T:System.Threading.Tasks.Parallel" /> loop should cease execution of iterations beyond the current iteration at the system's earliest convenience.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1c258-130"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 현재 반복 후 반복을 실행 해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-130"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> indicates that no iterations after the current iteration should be run.</span></span> <span data-ttu-id="1c258-131">효과적으로 루프의 모든 추가 반복을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-131">It effectively cancels any additional iterations of the loop.</span></span> <span data-ttu-id="1c258-132">그러나 모든 반복 실행을 이미 시작을 중지 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-132">However, it does not stop any iterations that have already begun execution.</span></span> <span data-ttu-id="1c258-133">예를 들어 경우 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 반복 0에서 1, 000, 모든 반복을 100 보다 작은 해야 계속 실행 되지만 적용 되지 않은 아직 시작 되지 않습니다 1000 통해는 101부터 반복 실행 되어 병렬 루프의 100 번째 반복에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-133">For example, if <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is called from the 100th iteration of a parallel loop iterating from 0 to 1,000, all iterations less than 100 should still be run, but the iterations from 101 through to 1000 that have not yet started are not executed.</span></span>  
  
 <span data-ttu-id="1c258-134">장기 실행 반복 실행 이미 수에 대 한 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 설정는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성을 현재 인덱스의 현재 값 보다 작은 경우 현재 반복 인덱스 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-134">For long-running iterations that may already be executing, <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> sets the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property to the current iteration's index if the current index is less than the current value of <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>.</span></span> <span data-ttu-id="1c258-135">인덱스 경쟁 실행에서 가장 낮은 중단 반복 보다 크면 반복을 중지 하려면 다음을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-135">To stop iterations whose index is greater than the lowest break iteration from competing execution, you should do the following:</span></span>  
  
1.  <span data-ttu-id="1c258-136">확인 여부는 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 속성은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-136">Check whether the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property is `true`.</span></span>  
  
2.  <span data-ttu-id="1c258-137">해당 항목이 있는 인덱스 보다 큰 경우 반복에서 종료는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-137">Exit from the iteration if its index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value.</span></span>  
  
 <span data-ttu-id="1c258-138">예제에서는 그림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-138">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="1c258-139"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 일반적으로 순서는 데이터 원본에는 검색 기반 알고리즘에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-139"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is typically employed in search-based algorithms where an ordering is present in the data source.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1c258-140">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-140">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="1c258-141">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-141">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="1c258-142">루프의 반복에 결정 하는 임의로 생성 된 값은 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-142">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="1c258-143">인덱스 보다 크면 반복 하는 예제에서 출력으로의 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 를 호출한 후 시작 하는 속성 값은 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-143">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="1c258-144">루프의 반복은 여전히 때 실행할 수 있기 때문에 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드가 호출 되 면 각 반복 호출는 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 다른 반복이 호출 되어 있는지 여부를 확인 하는 속성의 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-144">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="1c258-145">속성 값이 `true`, 반복의 값을 검사는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-145">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1c258-146">
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 메서드가 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-146">The <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> method was previously called.</span>
          </span>
          <span data-ttu-id="1c258-147">
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 및 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />은 동일한 루프의 반복을 조합하여 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-147">
              <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> and <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> may not be used in combination by iterations of the same loop.</span>
          </span>
        </exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExceptional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExceptional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1c258-148">루프 반복이 해당 반복에서 처리되지 않은 예외를 throw했는지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-148">Gets whether any iteration of the loop has thrown an exception that went unhandled by that iteration.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1c258-149">처리되지 않은 예외를 throw했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-149">
              <see langword="true" /> if an unhandled exception was thrown; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStopped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStopped { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1c258-150">루프 반복에서 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 메서드를 호출했는지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-150">Gets whether any iteration of the loop has called the <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1c258-151">
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 메서드를 호출하여 반복에서 루프를 중지했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-151">
              <see langword="true" /> if any iteration has stopped the loop by calling the <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1c258-152">장기 실행 루프의 반복에 대 한 값을 검색할 수 있습니다는 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 여부 루프의 모든 반복 하는 호출 전에 실행을 시작한 속성 확인 하는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드가 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-152">For long-running iterations of the loop, you can retrieve the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property to determine whether any iterations of the loop that began execution before the call to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method are still executing.</span></span> <span data-ttu-id="1c258-153">값을 사용할 수 있습니다는 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 즉시 반환 해야 하거나 정상적으로 실행 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-153">You can then use the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property to determine whether they should return immediately or execute normally.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1c258-154">다음 예제에서는 병렬에서 루프의 반복이 최대 10, 000를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-154">The following example executes up to 10,000 iterations of a loop in parallel.</span></span> <span data-ttu-id="1c258-155">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-155">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="1c258-156">루프의 반복에 결정 하는 임의로 생성 된 값은 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-156">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called.</span></span> <span data-ttu-id="1c258-157">루프의 반복은 여전히 때 실행할 수 있기 때문에 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드가 호출 되는 람다 식 호출은 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-157">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called, the lambda expression calls the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span> <span data-ttu-id="1c258-158">반환 하는 경우 `true`, 반복 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-158">If it returns `true`, the iteration returns immediately.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LowestBreakIteration As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;long&gt; LowestBreakIteration { Nullable&lt;long&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1c258-159">
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />이 호출된 루프의 가장 낮은 반복을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-159">Gets the lowest iteration of the loop from which <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> was called.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1c258-160">
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />이 호출된 가장 낮은 반복입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-160">The lowest iteration from which <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> was called.</span>
          </span>
          <span data-ttu-id="1c258-161">
            <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> 루프의 경우 값은 내부에서 생성된 인덱스를 기반으로 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-161">In the case of a <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> loop, the value is based on an internally-generated index.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1c258-162">작업을 호출 하는 병렬 루프의 여러 번 반복 수는 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-162">It is possible for multiple iterations of a parallel loop to call the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="1c258-163">이 값은 호출 하는 반복의 가장 작은 인덱스 그럴 경우 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-163">If they do, this value is the smallest index of an iteration that called <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="1c258-164">루프의 반복이 없는 메서드를 호출 하면 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>,이 속성은 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-164">If no iteration of the loop called <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, this property returns `null`.</span></span> <span data-ttu-id="1c258-165">속성 값에 대 한 호출의 영향을 받지 않습니다는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-165">Note that the property value is unaffected by calls to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span>  
  
 <span data-ttu-id="1c258-166">호출 하는 반복 후 모든 반복의 장기 실행 반복에는 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드를 실행할 필요가는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성에 대 한 호출 하기 전에 실행을 시작 하는 반복을 종료 하는 데 사용 됩니다는 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-166">In long-running iterations in which all iterations after the iteration that calls the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method need not run, the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property is used to terminate iterations that began execution before the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="1c258-167">인덱스 경쟁 실행에서 가장 낮은 중단 반복 보다 크면 반복을 중지 하려면 다음을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-167">To stop iterations whose index is greater than the lowest break iteration from competing execution, you should do the following:</span></span>  
  
1.  <span data-ttu-id="1c258-168">확인 여부는 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 속성은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-168">Check whether the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property is `true`.</span></span>  
  
2.  <span data-ttu-id="1c258-169">해당 항목이 있는 인덱스 보다 큰 경우 반복에서 종료는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-169">Exit from the iteration if its index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value.</span></span>  
  
 <span data-ttu-id="1c258-170">예제에서는 그림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-170">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1c258-171">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-171">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="1c258-172">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-172">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="1c258-173">루프의 반복에 결정 하는 임의로 생성 된 값은 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-173">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="1c258-174">이렇게 하면 인덱스 보다 큽니다. 반복 되지 않습니다.는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성 값에 대 한 호출 후 시작을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 하지만 메서드를 이미 아직 실행이 시작 하는 모든 반복에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-174">This prevents iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value from starting after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method, but it does not affect any iterations that have already begun executing.</span></span> <span data-ttu-id="1c258-175">각 반복에서 완료를 방지 하기 위해 호출 된 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-175">To prevent these from completing, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="1c258-176">따라서 반복의 값을 확인 하는 경우는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-176">If so, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="1c258-177">때문에 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 값 병렬 루프 외부에서 범위를 벗어나면 값을 유지 하려는 경우 루프 외부에서 볼 수 있는 변수에 할당 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-177">Note that, because the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> value is out of scope outside of the parallel loop, you must assign it to a variable that is visible outside of the loop if you want to preserve its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldExitCurrentIteration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldExitCurrentIteration { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1c258-178">루프의 현재 반복이 해당 반복 또는 다른 반복에서 수행한 요청에 따라 종료되어야 하는지 여부를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-178">Gets whether the current iteration of the loop should exit based on requests made by this or other iterations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1c258-179">현재 반복이 종료되어야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-179">
              <see langword="true" /> if the current iteration should exit; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1c258-180"><xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 속성이 `true` 다음 조건에서:</span><span class="sxs-lookup"><span data-stu-id="1c258-180">The <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property is set to `true` under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="1c258-181">루프 호출의 반복 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 또는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-181">An iteration of the loop calls <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> or <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>.</span></span>  
  
-   <span data-ttu-id="1c258-182">루프의 반복 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-182">An iteration of the loop throws an exception.</span></span>  
  
-   <span data-ttu-id="1c258-183">루프 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-183">The loop is canceled.</span></span>  
  
 <span data-ttu-id="1c258-184">이 속성이 `true`, <xref:System.Threading.Tasks.Parallel> 클래스 추가 반복에서 루프의 실행을 시작 하지 못하게 하려면 사전에 시도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-184">When this property is `true`, the <xref:System.Threading.Tasks.Parallel> class will proactively attempt to prohibit additional iterations of the loop from starting execution.</span></span> <span data-ttu-id="1c258-185">그러나 경우 처음부터 추가 반복을 방지 하기 위해 수 없으면 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-185">However, there may be cases where it is unable to prevent additional iterations from starting.</span></span>  
  
 <span data-ttu-id="1c258-186">장기 실행 반복 하는 이미 시작 되었음을 실행 하는 경우 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-186">It may also be the case that a long-running iteration has already begun execution.</span></span> <span data-ttu-id="1c258-187">이러한 경우 반복 명시적으로 확인 된 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 속성 실행을 중지 속성이 반환 하는 경우 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-187">In such cases, iterations may explicitly check the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property and cease execution if the property returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1c258-188">다음 예제에서는 루프의 최대 100 개의 반복이 병렬로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-188">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="1c258-189">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-189">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="1c258-190">루프의 반복에 결정 하는 임의로 생성 된 값은 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-190">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="1c258-191">이렇게 하면 인덱스 보다 큽니다. 반복 되지 않습니다.는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성 값에 대 한 호출 후 시작을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 하지만 메서드를 이미 아직 실행이 시작 하는 모든 반복에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-191">This prevents iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value from starting after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method, but it does not affect any iterations that have already begun executing.</span></span> <span data-ttu-id="1c258-192">각 반복에서 완료를 방지 하기 위해 호출 된 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-192">To prevent these from completing, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="1c258-193">따라서 반복의 값을 확인 하는 경우는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 속성을 현재 반복 인덱스 값 보다 큰 경우 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-193">If so, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1c258-194">시스템에서 편의상 빨리 수행하는 반복에서 <see cref="T:System.Threading.Tasks.Parallel" /> 루프의 실행이 중단되도록 통신합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-194">Communicates that the <see cref="T:System.Threading.Tasks.Parallel" /> loop should cease execution at the system's earliest convenience.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1c258-195">호출 된 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드가 나타내는 아직 시작 되지 않은 루프의 반복 실행할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-195">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method indicates that any iterations of the loop that have not yet started need not be run.</span></span> <span data-ttu-id="1c258-196">효과적으로 루프의 모든 추가 반복을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-196">It effectively cancels any additional iterations of the loop.</span></span> <span data-ttu-id="1c258-197">그러나 모든 반복 실행을 이미 시작을 중지 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-197">However, it does not stop any iterations that have already begun execution.</span></span>  
  
 <span data-ttu-id="1c258-198">호출의 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드를 사용 하면은 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 반환할 속성 `true` 아직 실행 되는 루프의 반복에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-198">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method causes the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property to return `true` for any iteration of the loop that is still executing.</span></span> <span data-ttu-id="1c258-199">이 확인할 수 있는 장기 실행 반복 하는 데 특히 유용는 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 속성과 해당 값이 있는 경우에 일찍 종료 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-199">This is particularly useful for long-running iterations, which can check the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property and exit early if its value is `true`.</span></span>  
  
 <span data-ttu-id="1c258-200"><xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 여기서 범위가 변경 되 면 있으면, 다른 반복을 실행할 필요가 검색 기반 알고리즘에서 일반적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-200"><xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> is typically employed in search-based algorithms, where once a result is found, no other iterations need be executed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1c258-201">다음 예제에서는 병렬에서 루프의 반복이 최대 10, 000를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-201">The following example executes up to 10,000 iterations of a loop in parallel.</span></span> <span data-ttu-id="1c258-202">각 반복 1, 000 밀리초를 1에서 임의의 간격에 대 한 일시 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-202">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="1c258-203">루프의 반복에 결정 하는 임의로 생성 된 값은 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-203">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called.</span></span> <span data-ttu-id="1c258-204">반복 실행에 대 한 호출 후 예제의 출력에서 볼 수 있듯이 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-204">As the output from the example shows, no iterations execute after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 <span data-ttu-id="1c258-205">루프의 반복은 여전히 때 실행할 수 있기 때문에 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드가 호출 되 면 호출 하는 각 반복에서 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 다른 반복이 호출 되어 있는지 여부를 확인 하는 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1c258-205">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span> <span data-ttu-id="1c258-206">반환 하는 경우 `true`, 반복 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c258-206">If it returns `true`, the iteration returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1c258-207">
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 메서드가 이미 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-207">The <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> method was called previously.</span>
          </span>
          <span data-ttu-id="1c258-208">
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 및 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />은 동일한 루프의 반복을 조합하여 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1c258-208">
              <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> and <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> may not be used in combination by iterations of the same loop.</span>
          </span>
        </exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      </Docs>
    </Member>
  </Members>
</Type>