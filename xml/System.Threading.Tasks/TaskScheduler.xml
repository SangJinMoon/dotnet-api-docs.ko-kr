<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9101875b3c768590b23db0c0c08ee17d09fc5e38" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609224" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="84362-101">작업을 스레드의 큐에 대기하는 낮은 수준의 작업을 처리하는 개체를 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="84362-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-102">인스턴스는 <xref:System.Threading.Tasks.TaskScheduler> 클래스 작업 스케줄러를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="84362-103">작업 스케줄러는 작업이 실제로 실행되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="84362-104">기본 작업 스케줄러는 부하 분산을 위한 작업 가로채기, 최대 처리량을 위한 스레드 삽입/폐기 및 전반적으로 뛰어난 성능을 제공하는 .NET Framework 4 스레드 풀을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="84362-105">대부분의 시나리오에서는 이것만으로 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="84362-106"><xref:System.Threading.Tasks.TaskScheduler> 클래스 사용자 지정 가능한 모든 일정 논리에 대 한 확장 지점 역할도 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="84362-107">디버거 실행에 대 한 작업 및 방법을 예약 된 작업을 예약 하는 방법을 제공 해야 같은 메커니즘이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="84362-108">특별 한 기능에 필요한 경우 사용자 지정 스케줄러를 만들고 특정 작업 또는 쿼리에 대 한 사용 하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="84362-109">항목 내용:</span><span class="sxs-lookup"><span data-stu-id="84362-109">In this topic:</span></span>  
[<span data-ttu-id="84362-110">기본 작업 스케줄러 및 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="84362-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="84362-111">전역 큐와 로컬 큐 비교</span><span class="sxs-lookup"><span data-stu-id="84362-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="84362-112">작업 가로채기</span><span class="sxs-lookup"><span data-stu-id="84362-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="84362-113">장기 실행 작업</span><span class="sxs-lookup"><span data-stu-id="84362-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="84362-114">작업 인라인 처리</span><span class="sxs-lookup"><span data-stu-id="84362-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="84362-115">동기화 컨텍스트 지정</span><span class="sxs-lookup"><span data-stu-id="84362-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="84362-116">기본 작업 스케줄러 및 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="84362-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="84362-117">작업 병렬 라이브러리 및 PLINQ에 대 한 기본 스케줄러를 사용 하 여 표현 되는.NET Framework 스레드 풀을는 <xref:System.Threading.ThreadPool> 클래스, 큐 및 작업을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="84362-118">스레드 풀에서 제공 하는 정보를 사용 하는 <xref:System.Threading.Tasks.Task> 형식 효율적으로 병렬화 하는 작업 및 쿼리가 종종 나타내는 세분화 된 병렬 처리 (짧은 수명의 작업 단위)를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="84362-119">전역 큐와 로컬 큐 비교</span><span class="sxs-lookup"><span data-stu-id="84362-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="84362-120">스레드 풀 전역 FIFO (선입 선출) 큐 각 응용 프로그램 도메인의 스레드에 대 한 작업을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="84362-121">프로그램을 호출할 때마다 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (또는 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) 메서드를 작업이 공유 큐에 배치 되며 최종적으로 사용할 수 있는 다음 스레드 큐 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="84362-122">.NET Framework 4부터이 큐가 향상 되었습니다 유사한 잠금 없는 알고리즘을 사용 하 여 <xref:System.Collections.Concurrent.ConcurrentQueue%601> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="84362-123">이 잠금 없는 구현을 사용 하 여 스레드 풀 데 큐 및 작업 항목 큐에서 제거 하면 시간을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="84362-124">이 성능 혜택은 스레드 풀을 사용 하는 모든 프로그램에 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="84362-125">다른 작업의 컨텍스트에서 생성되지 않은 작업인 최상위 작업은 다른 작업 항목과 마찬가지로 전역 큐에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="84362-126">그러나 다른 작업의 컨텍스트에서 생성된 중첩된 작업이나 자식 작업은 전혀 다르게 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="84362-127">자식 작업이나 중첩된 작업은 부모 작업이 실행되는 스레드와 관련된 로컬 큐에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="84362-128">부모 작업은 최상위 작업이거나 다른 작업의 자식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="84362-129">이 스레드가 추가 작업을 수행할 준비가 되면 먼저 로컬 큐를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="84362-130">작업 항목이 대기 중이면 신속하게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="84362-131">로컬 큐를 마지막에 선출 lifo (후입선출) 경합을 줄이고 캐시 집약성을 유지 하려면에서 액세스 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="84362-132">자식 작업 및 중첩 된 작업에 대 한 자세한 내용은 참조 하세요. [연결 된 자식 작업과 분리 된 자식 작업](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="84362-133">로컬 큐 사용 하 여 전역 큐에 대 한 압력 감소 뿐만 아니라 데이터 집약성의 이점도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="84362-134">로컬에서 작업 항목 큐 자주 물리적으로 서로 근처에 있는 메모리 참조 데이터 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="84362-135">이러한 경우에는 데이터가 이미 캐시에서 실행 되는 첫 번째 작업 후 신속 하 게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="84362-136">둘 다 [PLINQ (병렬 LINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) 고 <xref:System.Threading.Tasks.Parallel> 중첩 된 작업 및 자식 작업을 광범위 하 게, 클래스 및 속도 크게 향상 로컬 작업 큐를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="84362-137">작업 가로채기</span><span class="sxs-lookup"><span data-stu-id="84362-137">Work stealing</span></span>  
 <span data-ttu-id="84362-138">.NET Framework 4 부터는 스레드 풀 기능도 되는지 확인 하기 위해 스레드가 늘어난 유휴 여전히 다른 큐에 대기 중인 작업이 있는 동안 작업 가로채기 알고리즘을 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="84362-139">스레드 풀 스레드가 추가 작업을 수행할 준비가 되면 먼저 로컬 큐의 시작 부분을 확인한 다음 전역 큐, 다른 스레드의 로컬 큐 순으로 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="84362-140">다른 스레드의 로컬 큐에서 작업 항목을 찾은 경우 먼저 추론을 적용하여 작업을 효율적으로 실행할 수 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="84362-141">가능한 경우 FIFO 순서 대로 끝 부분에서 작업 항목을 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="84362-142">이러한 과정을 통해 각 로컬 큐에서의 경합이 줄어들고 데이터 집약성이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="84362-143">이 아키텍처는 스레드 풀을 부하 분산 이전 버전 보다 더 효율적으로 작업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-143">This architecture helps the  thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="84362-144">장기 실행 작업</span><span class="sxs-lookup"><span data-stu-id="84362-144">Long-running tasks</span></span>  
 <span data-ttu-id="84362-145">작업이 로컬 큐에 배치되지 않도록 명시적으로 차단할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="84362-146">예를 들어 특정 작업 항목이 비교적 오랜 시간 동안 실행되며 로컬 큐의 다른 모든 작업 항목을 차단할 가능성이 있음을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="84362-147">이 경우 로컬 큐의 다른 스레드나 작업 항목의 정방향 진행을 차단하지 않도록 작업에 추가 스레드가 필요할 수도 있다는 힌트를 스케줄러에 제공하는 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 옵션을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="84362-148">이 옵션을 사용 하 여 않으려면 스레드 풀 완전히 전역 및 로컬 큐를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="84362-149">작업 인라인 처리</span><span class="sxs-lookup"><span data-stu-id="84362-149">Task inlining</span></span>  
 <span data-ttu-id="84362-150">일부 경우 사례를 <xref:System.Threading.Tasks.Task> 대기 중인에 실행 될 수 있습니다 동기적으로 대기 작업을 수행 하는 스레드에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="84362-151">추가 스레드가 필요를 방지 하 고 그렇지 않으면 차단 되었을 기존 스레드를 사용 하 여 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="84362-152">재진입으로 인 한 오류를 방지 하려면 작업 인라인 처리는 대기 대상이 관련 스레드의 로컬 큐에 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-152">To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="84362-153">동기화 컨텍스트 지정</span><span class="sxs-lookup"><span data-stu-id="84362-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="84362-154"><xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 메서드를 사용하여 작업이 특정 스레드에서 실행 예약되도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="84362-155">이 기능은 UI 개체가 만들어진 스레드와 동일한 스레드에서 실행되는 코드로 사용자 인터페이스 개체에 대한 액세스가 종종 제한되는 Windows Forms 및 Windows Presentation Foundation과 같은 프레임워크에서 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="84362-156">다음 예제에서는 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 사용자 인터페이스 (UI) 컨트롤에서 만든 동일한 스레드에서 작업을 예약 하려면 Windows Presentation Foundation (WPF) 앱에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="84362-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="84362-157">지정된 된 디렉터리에서 임의로 선택 된 이미지의 시스템을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84362-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="84362-158">WPF 개체를 로드 하 고 이미지를 크기 조정에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="84362-159">원시 픽셀은 사용 하는 작업에 전달 된 <xref:System.Threading.Tasks.Parallel.For%2A> 큰 단일 바이트 배열로 픽셀 데이터를 작성 하는 루프입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="84362-160">동기화가 필요 하지 되므로 동일한 배열 요소를 차지 하는 두 개의 타일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="84362-161">타일의 위치는 다른 타일과 독립적으로 계산 되므로 순서에 관계 없이 작성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="84362-162">대형 배열은 그러면 픽셀 데이터 이미지 컨트롤을 로드 되는 UI 스레드에서 실행 되는 작업에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="84362-163">이 예제에서는 UI 스레드에서 데이터를 이동, 병렬 루프를 사용 하 여 수정 및 <xref:System.Threading.Tasks.Task> 개체 및 UI 스레드에서 실행 되는 작업을 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="84362-164">이 방법은 작업 병렬 라이브러리를 사용 하 여 WPF API에서 지원 되지 않습니다 또는 충분히 빠르지 않은 작업을 수행 해야 할 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="84362-165">Wpf에서는 이미지 시스템을 만드는 또 다른 방법은 사용 하는 것을 <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> 제어 하 고 이미지를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="84362-166"><xref:System.Windows.Controls.WrapPanel> 타일 배치 작업을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="84362-167">그러나이 작업 UI 스레드에서 수행할 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="84362-168">예제를 만들려면 Visual Studio에서 WPF 응용 프로그램 프로젝트를 만들고 원하는 이름을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-168">To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</span></span> <span data-ttu-id="84362-169">다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-169">Then do the following:</span></span>  
  
1.  <span data-ttu-id="84362-170">디자인 뷰에서 <xref:System.Windows.Controls.Image> 에서 제어 합니다 **도구 상자** 디자인 화면으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface.</span></span> <span data-ttu-id="84362-171">XAML 뷰에서 "Left."으로 가로 맞춤을 지정</span><span class="sxs-lookup"><span data-stu-id="84362-171">In XAML view, specify the horizontal alignment as "Left."</span></span> <span data-ttu-id="84362-172">런타임 시 컨트롤은 동적으로 조정 하기 때문에 크기가 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-172">The size does not matter because the control is be dynamically resized at run time.</span></span> <span data-ttu-id="84362-173">"이미지" 기본 이름을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-173">Accept the default name, "image".</span></span>  
  
2.  <span data-ttu-id="84362-174">끌어서를 <xref:System.Windows.Controls.Button> 에서 제어 합니다 **도구 상자** 응용 프로그램 창의 왼쪽된 아래 부분에 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-174">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="84362-175">추가 단추를 두 번 클릭을 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-175">Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler.</span></span> <span data-ttu-id="84362-176">XAML 뷰에서 지정 된 <xref:System.Windows.Controls.ContentControl.Content%2A> "는 시스템을 확인 합니다." 및 "Left"으로 가로 맞춤을 지정 하는 대로 단추의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-176">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</span></span> <span data-ttu-id="84362-177">"Button" 기본 이름을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-177">Accept the default name, "button".</span></span>  
  
3.  <span data-ttu-id="84362-178">이 예제에서 코드를 사용 하 여 MainWindow.xaml.vb 또는 MainWindow.xaml.cs 파일의 전체 내용을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-178">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="84362-179">작업 영역의 이름을 프로젝트 이름과 일치 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-179">Make sure that the name of the workspace matches the project name.</span></span>  
  
4.  <span data-ttu-id="84362-180">이 예제에서는 C:\Users\Public\Pictures\Sample 사진 라는 디렉터리에서 JPEG 이미지를 읽고\\합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-180">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="84362-181">디렉터리 만들기, 일부 이미지를 배치 또는 이미지가 포함 된 일부 다른 디렉터리를 가리키도록 경로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-181">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span>  
  
 <span data-ttu-id="84362-182">이 예제에서는 몇 가지 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-182">This example has some limitations.</span></span> <span data-ttu-id="84362-183">예를 들어만 32 비트-픽셀당 이미지는 지원 됩니다. 다른 형식의 이미지에서 손상 된를 <xref:System.Windows.Media.Imaging.BitmapImage> 개체 크기 조정 작업 중입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-183">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="84362-184">또한 소스 이미지 모두 여야 합니다 타일 크기를 초과 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-184">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="84362-185">자세한 연습을 여러 픽셀 형식 및 파일 크기를 처리할 수 있는 기능을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-185">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84362-186">다음 예제에서 가져온 것은 [Samples for Parallel Programming.NET Framework 4를 사용 하 여](http://go.microsoft.com/fwlink/?LinkID=165717) MSDN 코드 갤러리 웹 사이트입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-186">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="84362-187">앱에서 사용 되는 스레드 수를 제한 하는 사용자 지정 작업 스케줄러를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84362-187">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="84362-188">그런 다음 두 가지 작업 집합을 시작 하 고 작업과 작업이 실행 되는 스레드 관련 정보가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-188">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="84362-189">코드 갤러리에서 사용할 수 있는 몇 가지 샘플 작업 스케줄러는 또한: [.NET Framework 4를 사용한 병렬 프로그래밍에 대 한 샘플](http://go.microsoft.com/fwlink/?LinkID=165717)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-189">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="84362-190">모든 추상 멤버 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 형식은 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="84362-190">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84362-191">
            <see cref="T:System.Threading.Tasks.TaskScheduler" /> 을(를) 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-191">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84362-192">현재 실행 중인 작업과 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="84362-193">현재 실행 중인 작업과 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-194">작업 내에서 호출 되지 않을 때 <xref:System.Threading.Tasks.TaskScheduler.Current%2A> 돌아갑니다는 <xref:System.Threading.Tasks.TaskScheduler.Default%2A> 스케줄러입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="84362-195">자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84362-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84362-196">.NET Framework에 의해 제공된 기본 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 인스턴스를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-196">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="84362-197">기본 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 인스턴스를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-197">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-198">자세한 내용은 [작업 스케줄러](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-198">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84362-199">현재 <see cref="T:System.Threading.SynchronizationContext" />와 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-199">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84362-200">
            <see cref="P:System.Threading.SynchronizationContext.Current" />에 따라 결정되는 현재 <see cref="T:System.Threading.SynchronizationContext" />와 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-200">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-201">모든 <xref:System.Threading.Tasks.Task> 인스턴스가 반환 된 대기 중인 스케줄러에 대 한 호출을 통해 실행 됩니다는 <xref:System.Threading.SynchronizationContext.Post%2A> 메서드 컨텍스트를 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-201">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="84362-202">자세한 내용은 [작업 스케줄러](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-202">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="84362-203">현재 SynchronizationContext를 TaskScheduler로 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-203">The current SynchronizationContext may not be used as a TaskScheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84362-204">디버거를 지원하기 위해 현재 스케줄러의 큐에 대기되어 실행을 기다리고 있는 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 열거 가능한 형식을 생성합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-204">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84362-205">디버거가 현재 이 스케줄러의 큐에 대기된 작업을 트래버스할 수 있도록 허용하는 열거 가능한 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-205">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-206">파생 된 클래스 <xref:System.Threading.Tasks.TaskScheduler> 디버거 통합을 지원 하기 위해이 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-206">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="84362-207">디버거 데이터에 대 한 액세스를 요청 하는 경우에이 메서드.NET 프레임 워크에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-207">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="84362-208">디버깅 작업에 액세스 하는 유틸리티에 의해 이동 열거형 반환 된 사용자 인터페이스에서이 정보는 표현을 제공 하려면 디버거를 사용 하도록 설정 하면이 스케줄러를 현재 큐에 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-208">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="84362-209">이 메서드를 호출 하는 경우 프로세스의 다른 모든 스레드는 고정 하는 것이 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-209">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="84362-210">따라서 차단 시킬 수 있는 다른 스레드와 동기화를 방지 하려면 중요 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-210">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="84362-211">동기화가 필요한 경우이 메서드에서 잠금을 가져올 수 없는 디버거를 중단 하지 않습니다 있도록 예외를 throw 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-211">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</span></span> <span data-ttu-id="84362-212">다음 예제에서는 C#에서 한 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="84362-212">The following example shows one possible approach in C#:</span></span>  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="84362-213">또한이 메서드를 반환 하는 열거형 수정 해서는 안 전체적으로 표시 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="84362-213">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="84362-214">반환 된 열거형 null이 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-214">The returned enumerable should never be null.</span></span> <span data-ttu-id="84362-215">가 현재 큐에 대기 중인된 작업이 없는 경우 빈 열거형을 대신 반환 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-215">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="84362-216">사용자 지정 디버거를 구현 하는 개발자는이 메서드를 직접 호출 하지 않아야 하지만 내부 래퍼 메서드를 사용 해야 `GetScheduledTasksForDebugger` 대신: `internal Task[] GetScheduledTasksForDebugger()`합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-216">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="84362-217">이 래퍼 메서드에서 열거 하는 대신 작업의 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-217">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="84362-218">내부 메서드를 사용 하 여 현재 스케줄러의 목록을 검색할 `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-218">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="84362-219">이 정적 메서드는 모든 활성의 배열을 반환 <xref:System.Threading.Tasks.TaskScheduler> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="84362-219">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="84362-220">사용할 수 있습니다 `GetScheduledTasksForDebugger` 각 스케줄러 인스턴스에 예약 된 작업 목록을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-220">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="84362-221">이 스케줄러는 현재 대기 중인 작업 목록을 생성할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-221">This scheduler is unable to generate a list of queued tasks at this time.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84362-222">이 <see cref="T:System.Threading.Tasks.TaskScheduler" />의 고유 ID를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-222">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="84362-223">이 <see cref="T:System.Threading.Tasks.TaskScheduler" />의 고유 ID를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-223">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-224">자세한 내용은 [작업 스케줄러](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-224">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84362-225">이 <see cref="T:System.Threading.Tasks.TaskScheduler" />가 지원할 수 있는 최대 동시성 수준을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-225">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="84362-226">최대 동시성 수준을 나타내는 정수를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-226">Returns an integer that represents the maximum concurrency level.</span>
          </span>
          <span data-ttu-id="84362-227">기본 스케줄러는 <see cref="F:System.Int32.MaxValue" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-227">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-228">자세한 내용은 [작업 스케줄러](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-228">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="84362-229">큐에 대기할 <see cref="T:System.Threading.Tasks.Task" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-229">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84362-230">
            <see cref="T:System.Threading.Tasks.Task" />를 스케줄러의 큐에 대기합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-230">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-231">파생 된 클래스 <xref:System.Threading.Tasks.TaskScheduler> 스케줄러에서 예약 된 작업을 허용 하도록이 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-231">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="84362-232">일반적인 구현은 작업은 나중에 특정 시간에 해당 태스크를 실행 중인 스레드에 의해 서비스 됩니다는 내부 데이터 구조에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-232">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="84362-233">이 메서드는.NET 프레임 워크에서 호출 되어야 하는 기능만 하며 파생된 클래스에서 직접 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-233">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="84362-234">이 시스템의 일관성을 유지 하는 데 필요한 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-234">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84362-235">
            <paramref name="task" /> 인수가 null입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-235">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="84362-236">큐에서 제거할 <see cref="T:System.Threading.Tasks.Task" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-236">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84362-237">이전에 이 스케줄러의 큐에 대기된 <see cref="T:System.Threading.Tasks.Task" />를 큐에서 제거하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-237">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84362-238">
            <paramref name="task" /> 인수가 큐에서 제거되었는지 여부를 나타내는 부울입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-238">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-239">자세한 내용은 [작업 스케줄러](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-239">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 <span data-ttu-id="84362-240">이 메서드는에서 실행할 수는 finally 블록; 따라서 반환할 최대한 신속 하 게 되므로 모든 리소스와 같은 <xref:System.Threading.CancellationTokenRegistration> 적시에서의 개체를 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-240">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84362-241">
            <paramref name="task" /> 인수가 null입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-241">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="84362-242">실행할 <see cref="T:System.Threading.Tasks.Task" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-242">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84362-243">이 스케줄러에 제공된 <see cref="T:System.Threading.Tasks.Task" />를 실행하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-243">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84362-244">
            <paramref name="task" />가 실행되었으면 true이고, 그렇지 않으면 false인 부울입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-244">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span>
          </span>
          <span data-ttu-id="84362-245">실행이 실패하는 일반적인 이유는 작업이 이전에 실행되었거나 다른 스레드에서 실행 중이기 때문입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-245">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-246">스케줄러 구현이 제공 됩니다 <xref:System.Threading.Tasks.Task> 인스턴스를 통해 실행 되는 <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> 메서드 또는 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84362-246">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="84362-247">스케줄러가 제공 된 작업을 실행 하는 적절 한 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 이렇게 하려면 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-247">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="84362-248">TryExecuteTask 작업 호출, 예외 처리, 상태 관리 및 수명 주기 컨트롤을 포함 하 여 작업을 실행 하는 모든 측면을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-248">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="84362-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 이 스케줄러에는.NET Framework 인프라에서 제공 하는 작업에만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="84362-250">사용자 지정 메커니즘을 통해 얻은 임의 작업을 실행 하는 사용 되지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-250">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="84362-251">
            <paramref name="task" />는 이 스케줄러와 연결되어 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-251">The <paramref name="task" /> is not associated with this scheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="84362-252">실행할 <see cref="T:System.Threading.Tasks.Task" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-252">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span>
          </span>
        </param>
        <param name="taskWasPreviouslyQueued">
          <span data-ttu-id="84362-253">작업이 이전에 큐에 대기되었는지 여부를 나타내는 부울입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-253">A Boolean denoting whether or not task has previously been queued.</span>
          </span>
          <span data-ttu-id="84362-254">이 매개 변수가 True이면 작업이 이전에 큐에 대기된 것일 수 있습니다. False이면 작업이 큐에 대기되지 않은 것입니다. 작업을 큐에 대기하지 않고 인라인으로 실행하려면 이 호출을 수행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-254">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84362-255">제공된 <see cref="T:System.Threading.Tasks.Task" />를 이 호출에서 동기적으로 실행할 수 있는지 여부를 확인하고 실행 가능할 경우 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-255">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84362-256">작업이 인라인으로 실행되었는지 여부를 나타내는 부울 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-256">A Boolean value indicating whether the task was executed inline.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-257">파생 된 클래스 <xref:System.Threading.Tasks.TaskScheduler> 해당 작업 개체에서 대기를 시작 하는 스레드는 태스크의 인라인 실행을 지원 하려면이 함수를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-257">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="84362-258">인라인 실행 선택 사항이 며 false를 반환 하 여 요청을 거부 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-258">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="84362-259">그러나 더 많은 작업을 수행할 수 있는 인라인 될, 더 나은 스케줄러 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-259">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="84362-260">사실, 스케줄러는 인라인 너무 적게 수 있습니다. 교착 상태가 발생할 수. 있습니다</span><span class="sxs-lookup"><span data-stu-id="84362-260">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="84362-261">적절 한 구현은 scheduler에 의해 보장 하는 정책에서 실행 하는 요청이 인라인으로 포함할 수 있습니다 성공적으로 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-261">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="84362-262">예를 들어, 태스크를 실행 하는 전용된 스레드를 사용 하는 스케줄러를 해당 스레드에서 모든 인라인 처리 요청이 성공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-262">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="84362-263">스케줄러를 인라인 실행을 수행 하기로 한 경우 작업을 수행 해야 기본 TaskScheduler 호출 하 여 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 메서드 반환 값을 전파 제공 된 작업 개체를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-263">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="84362-264">인라인 처리 요청을 수용 하기로 결정 하는 경우는 내부 데이터 구조에서 인라인된 작업을 제거 하려면 스케줄러에 대 한 적절 한 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-264">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="84362-265">단는 상황에 따라 스케줄러를 묻는 메시지가 나타날 수 인라인을 사용 하 여 이전에 제공 되지 않았습니다 하는 작업은 <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84362-265">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="84362-266">파생 된 스케줄러는 호출 스레드는 자체 일정에 지정된 된 작업 실행에 적합 하 고 실행 정책이 관련 되어 있는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-266">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="84362-267">자세한 내용은 [작업 스케줄러](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-267">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84362-268">
            <paramref name="task" /> 인수가 null입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-268">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="84362-269">
            <paramref name="task" />가 이미 실행되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-269">The <paramref name="task" /> was already executed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84362-270">오류가 발생한 작업의 확인되지 않은 예외가 기본적으로 프로세스를 종료하는 예외 에스컬레이션 정책을 트리거하려고 할 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84362-270">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84362-271">이 응용 프로그램 도메인 전체 이벤트에서 트리거 (기본적으로 종료 하는 프로세스)는 예외 에스컬레이션 정책을 방지 하는 메커니즘을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-271">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="84362-272">개발자가 작업 기반 비동기 코드를 작성 하는 데 쉽게는 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 관찰 되지 않은 예외에 대 한 기본 예외 동작을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="84362-272">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="84362-273">관찰 되지 않은 예외를 여전히 발생 하지만 <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> 예외를 기본적으로 프로세스는 종료 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-273">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="84362-274">대신, 이벤트 처리기에서 예외를 관찰 하는 여부에 관계 없이 이벤트가 발생 한 후 예외가 런타임에서 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84362-274">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="84362-275">이 동작을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84362-275">This behavior can be configured.</span></span> <span data-ttu-id="84362-276">로 시작 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 구성 요소를 사용 하 여 동작으로 되돌리려면는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 프로세스를 종료 하 고:</span><span class="sxs-lookup"><span data-stu-id="84362-276">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>