<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TaskScheduler.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ddd94061f594e353cba8674c76ffcb77a643ddb1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ddd94061f594e353cba8674c76ffcb77a643ddb1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Represents an object that handles the low-level work of queuing tasks onto threads.</source>
          <target state="translated">작업을 스레드의 큐에 대기하는 낮은 수준의 작업을 처리하는 개체를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class represents a task scheduler.</source>
          <target state="translated">인스턴스는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> 작업 스케줄러를 나타내는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A task scheduler ensures that the work of a task is eventually executed.</source>
          <target state="translated">작업 스케줄러는 작업이 실제로 실행되도록 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</source>
          <target state="translated">기본 작업 스케줄러는 부하 분산을 위한 작업 가로채기, 최대 처리량을 위한 스레드 삽입/폐기 및 전반적으로 뛰어난 성능을 제공하는 .NET Framework 4 스레드 풀을 기반으로 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It should be sufficient for most scenarios.</source>
          <target state="translated">대부분의 시나리오에서는 이것만으로 충분합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class also serves as the extension point for all customizable scheduling logic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> 클래스는 모든 사용자 지정 가능한 예약 논리에 대 한 확장 지점으로도 사용 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</source>
          <target state="translated">디버거를 실행 하는 작업 및 방법을 예약 된 작업을 예약 하는 방법을 노출 되어야 합니다와 같은 메커니즘 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</source>
          <target state="translated">특수 기능이 필요한 경우 사용자 지정 스케줄러를 만들고 특정 작업이 나 쿼리에 사용 하도록 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this topic:</source>
          <target state="translated">항목 내용:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The default task scheduler and the thread pool<ept id="p1">](#Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>기본 작업 스케줄러 및 스레드 풀<ept id="p1">](#Default)</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The global queue vs. local queues<ept id="p1">](#Queues)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>전역 큐와 로컬 큐 비교<ept id="p1">](#Queues)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Work stealing<ept id="p1">](#Stealing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>작업 가로채기<ept id="p1">](#Stealing)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Long-running tasks<ept id="p1">](#LongRunning)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>장기 실행 작업<ept id="p1">](#LongRunning)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Task inlining<ept id="p1">](#Inlining)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>작업 인라인 처리<ept id="p1">](#Inlining)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Specifying a synchronization context<ept id="p1">](#Sync)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>동기화 컨텍스트 지정<ept id="p1">](#Sync)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler and the thread pool</source>
          <target state="translated">기본 작업 스케줄러 및 스레드 풀</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class, to queue and execute work.</source>
          <target state="translated">작업 병렬 라이브러리 및 PLINQ에 대 한 기본 스케줄러에 의해 표현 되는.NET Framework 스레드 풀을 사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> 클래스 큐에 대기 시키고 작업을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool uses the information that is provided by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</source>
          <target state="translated">스레드 풀에서 제공 되는 정보를 사용 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 종류는 병렬 작업 및 쿼리가 종종 나타내는 세분화 된 병렬 처리 (짧은 수명의 작업 단위)를 효율적으로 지원 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The global queue vs. local queues</source>
          <target state="translated">전역 큐와 로컬 큐 비교</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</source>
          <target state="translated">스레드 풀 전역 FIFO (선입 선출) 작업 큐 각 응용 프로그램 도메인의 스레드에 대 한 유지 관리 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Whenever a program calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (or <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</source>
          <target state="translated">프로그램을 호출할 때마다는 <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (또는 <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) 메서드를 작업은이 공유 큐에 배치 및 결국 사용할 수 있는 다음 스레드 지연 취소 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> class.</source>
          <target state="translated">.NET Framework 4 부터는이 큐 늘었습니다 유사한 잠금 없는 알고리즘을 사용 하 여 <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</source>
          <target state="translated">이러한 잠금 없는 구현을 사용 하 여 스레드 풀 대부분 큐 및 작업 항목 큐에 넣고 제거 때 시간을 보냅니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This performance benefit is available to all programs that use the thread pool.</source>
          <target state="translated">이 성능상의 이점을 스레드 풀을 사용 하는 모든 프로그램 ´ ù.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</source>
          <target state="translated">다른 작업의 컨텍스트에서 생성되지 않은 작업인 최상위 작업은 다른 작업 항목과 마찬가지로 전역 큐에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, nested or child tasks, which are created in the context of another task, are handled quite differently.</source>
          <target state="translated">그러나 다른 작업의 컨텍스트에서 생성된 중첩된 작업이나 자식 작업은 전혀 다르게 처리됩니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</source>
          <target state="translated">자식 작업이나 중첩된 작업은 부모 작업이 실행되는 스레드와 관련된 로컬 큐에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The parent task may be a top-level task or it also may be the child of another task.</source>
          <target state="translated">부모 작업은 최상위 작업이거나 다른 작업의 자식일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When this thread is ready for more work, it first looks in the local queue.</source>
          <target state="translated">이 스레드가 추가 작업을 수행할 준비가 되면 먼저 로컬 큐를 확인합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If work items are waiting there, they can be accessed quickly.</source>
          <target state="translated">작업 항목이 대기 중이면 신속하게 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</source>
          <target state="translated">로컬 큐 방식으로 lifo (후입선출) 하 캐시 집약성을 유지 하 고 경합을 줄이고에서 액세스 됩니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For more information about child tasks and nested tasks, see <bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</source>
          <target state="translated">자식 작업 및 중첩 된 작업에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>연결 된 자식 작업과 분리 된 자식 작업<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</source>
          <target state="translated">로컬 큐를 사용 하는 전역 큐의 부하가 감소할 뿐 아니라 데이터 집약성의 이점도 있습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work items in the local queue frequently reference data structures that are physically near one another in memory.</source>
          <target state="translated">로컬에서 작업 항목 큐 메모리에 물리적으로 서로 가까운 있고 참조 데이터 구조 경우가 많습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</source>
          <target state="translated">이러한 경우에 데이터 후 첫 번째 작업 실행에 빠르게 액세스할 수 캐시에 이미 있으며 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Both <bpt id="p1">[</bpt>Parallel LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> and the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</source>
          <target state="translated">둘 다 <bpt id="p1">[</bpt>PLINQ (병렬 LINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> 및 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> 클래스 중첩 된 작업 및 자식 작업을 광범위 하 게 하며 로컬 작업 큐를 사용 하 여 속도 향상 시킵니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work stealing</source>
          <target state="translated">작업 가로채기</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</source>
          <target state="translated">.NET Framework 4 부터는 스레드 풀 기능도 되는지 확인 하기 위해 스레드가 없는 방문 직원은 유휴 다른 스레드의 큐에 대기 중인 작업이 있는 동안 작업 가로채기 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</source>
          <target state="translated">스레드 풀 스레드가 추가 작업을 수행할 준비가 되면 먼저 로컬 큐의 시작 부분을 확인한 다음 전역 큐, 다른 스레드의 로컬 큐 순으로 확인합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</source>
          <target state="translated">다른 스레드의 로컬 큐에서 작업 항목을 찾은 경우 먼저 추론을 적용하여 작업을 효율적으로 실행할 수 있는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it can, it de-queues the work item from the tail (in FIFO order).</source>
          <target state="translated">가능한 경우 FIFO 순서 대로 꼬리에서 작업 항목을 큐 제거 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This reduces contention on each local queue and preserves data locality.</source>
          <target state="translated">이러한 과정을 통해 각 로컬 큐에서의 경합이 줄어들고 데이터 집약성이 유지됩니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This architecture helps the  thread pool load-balance work more efficiently than past versions did.</source>
          <target state="translated">이 아키텍처는 스레드 풀을 부하 분산 이전 버전과 달리 보다 더 효율적으로 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Long-running tasks</source>
          <target state="translated">장기 실행 작업</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You may want to explicitly prevent a task from being put on a local queue.</source>
          <target state="translated">작업이 로컬 큐에 배치되지 않도록 명시적으로 차단할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</source>
          <target state="translated">예를 들어 특정 작업 항목이 비교적 오랜 시간 동안 실행되며 로컬 큐의 다른 모든 작업 항목을 차단할 가능성이 있음을 알고 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this case, you can specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</source>
          <target state="translated">이 경우 로컬 큐의 다른 스레드나 작업 항목의 정방향 진행을 차단하지 않도록 작업에 추가 스레드가 필요할 수도 있다는 힌트를 스케줄러에 제공하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> 옵션을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this option you avoid the thread pool completely, including the global and local queues.</source>
          <target state="translated">이 옵션을 사용 하 여 않으려면 스레드 풀 완전히 전역 및 로컬 큐를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Task inlining</source>
          <target state="translated">작업 인라인 처리</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In some cases when a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</source>
          <target state="translated">경우에 따라 시기는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 대기 중인 on, 그 수 동기적으로 실행 되도록 대기 작업을 수행 하는 스레드에서 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</source>
          <target state="translated">이 추가 스레드가 필요 없도록 하 고 그렇지 않으면 차단 되었을 기존 스레드를 대신 사용 하 여 성능을 향상 시킵니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</source>
          <target state="translated">재진입으로 인해 오류 방지를 위해 작업 인라인 처리는 대기 대상이 관련 스레드의 로컬 큐에서 발견 된 경우에 발생 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Specifying a synchronization context</source>
          <target state="translated">동기화 컨텍스트 지정</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method to specify that a task should be scheduled to run on a particular thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> 메서드를 사용하여 작업이 특정 스레드에서 실행 예약되도록 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</source>
          <target state="translated">이 기능은 UI 개체가 만들어진 스레드와 동일한 스레드에서 실행되는 코드로 사용자 인터페이스 개체에 대한 액세스가 종종 제한되는 Windows Forms 및 Windows Presentation Foundation과 같은 프레임워크에서 유용합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> Windows Presentation Foundation (WPF) 응용 프로그램에 사용자 인터페이스 (UI) 컨트롤이 만들어진 스레드와 동일한 스레드에서 작업을 예약 하려면 메서드.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example creates a mosaic of images that are randomly selected from a specified directory.</source>
          <target state="translated">이 예에서는 지정된 된 디렉터리에서 임의로 선택 된 이미지의 모자이크를 만듭니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The WPF objects are used to load and resize the images.</source>
          <target state="translated">WPF 개체 로드 및 이미지 크기를 조정 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The raw pixels are then passed to a task that uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> loop to write the pixel data into a large single-byte array.</source>
          <target state="translated">원시 (픽셀)를 사용 하는 작업에 전달 되어는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> 루프를 큰 단일 바이트 배열로 픽셀 데이터를 쓸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>No synchronization is required because no two tiles occupy the same array elements.</source>
          <target state="translated">두 개의 조각이 차지 동일한 배열 요소는 동기화는 필요 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The tiles can also be written in any order because their position is calculated independently of any other tile.</source>
          <target state="translated">타일의 위치는 다른 타일 독립적으로 계산 필드 이므로 순서에 관계 없이 작성할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</source>
          <target state="translated">그러면 큰 배열이 픽셀 데이터를 이미지 컨트롤에 로드 하는 위치는 UI 스레드에서 실행 되는 작업에 전달 됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example moves data off the UI thread, modifies it by using parallel loops and <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects, and then passes it back to a task that runs on the UI thread.</source>
          <target state="translated">이 예제에서는 UI 스레드에서 데이터를 이동, 병렬 루프를 사용 하 여 수정 및 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 하 고 다음 UI 스레드에서 실행 되는 작업에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</source>
          <target state="translated">이 방법은 작업 병렬 라이브러리를 사용 하 여 WPF API에서 지원 되지 않는 또는 충분히 빠르지 않은 하는 작업을 수행 해야 할 경우에 유용 합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Another way to create an image mosaic in WPF is to use a <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> control and add images to it.</source>
          <target state="translated">WPF의 이미지 모자이크를 만드는 또 다른 방법은 사용 하는 것을 <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> 제어 하 고 이미지를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> handles the work of positioning the tiles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> 타일의 위치를 지정 하는 작업 처리 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, this work can only be performed on the UI thread.</source>
          <target state="translated">그러나이 작업은 UI 스레드에서 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</source>
          <target state="translated">예제를 만들려면 Visual Studio에서 WPF 응용 프로그램 프로젝트를 만들고 원하는 이름을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Then do the following:</source>
          <target state="translated">다음을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In design view, drag an <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the design surface.</source>
          <target state="translated">디자인 뷰에서 <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> 에서 제어는 <bpt id="p1">**</bpt>도구 상자<ept id="p1">**</ept> 디자인 화면으로 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the horizontal alignment as "Left."</source>
          <target state="translated">XAML 뷰에서 "Left"로 가로 맞춤을 지정</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The size does not matter because the control is be dynamically resized at run time.</source>
          <target state="translated">런타임 시 컨트롤은 동적으로 조정 하기 때문에 크기 중요 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "image".</source>
          <target state="translated">"이미지" 기본 이름을 적용 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Drag a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the lower left part of the application window.</source>
          <target state="translated">끌어서는 <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> 에서 제어는 <bpt id="p1">**</bpt>도구 상자<ept id="p1">**</ept> 응용 프로그램 창의 왼쪽된 아래 부분에 있습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Double-click the button to add a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event handler.</source>
          <target state="translated">추가 하려면 단추를 두 번 클릭 한 <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> 이벤트 처리기입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</source>
          <target state="translated">XAML 뷰에서 지정 된 <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> "모자이크" 그대로 수행"및"Left"로 가로 맞춤을 지정 하는 대로 단추의 속성입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "button".</source>
          <target state="translated">"Button" 기본 이름을 적용 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</source>
          <target state="translated">MainWindow.xaml.vb 또는 MainWindow.xaml.cs 파일의 전체 내용이이 예제의 코드를에서 바꿉니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Make sure that the name of the workspace matches the project name.</source>
          <target state="translated">작업 영역 이름은 프로젝트 이름과 일치 하는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures<ph id="ph1">\\</ph>.</source>
          <target state="translated">이 예제에서는 C:\Users\Public\Pictures\Sample 그림 라는 디렉터리에서 JPEG 이미지를 읽고<ph id="ph1">\\</ph>합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</source>
          <target state="translated">디렉터리를 만들, 일부 이미지를 배치 하거나 이미지가 포함 된 몇 가지 다른 디렉터리를 참조 하도록 경로 변경 합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This example has some limitations.</source>
          <target state="translated">이 예제에는 몇 가지 제한 사항이 있습니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> object during the resizing operation.</source>
          <target state="translated">예를 들어만 32 비트-픽셀 당 이미지만 지원 됩니다. 이미지를 다른 형식에 의해 손상 되는 <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> 크기 조정 작업 중에 개체입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Also, the source images must all be larger than the tile size.</source>
          <target state="translated">또한 소스 이미지 모든 보다 커야 타일 크기입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</source>
          <target state="translated">자세한 연습을 여러 픽셀 형식 및 파일 크기를 처리 하는 기능을 추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example is taken from the <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> on the MSDN Code Gallery Web site.</source>
          <target state="translated">다음 예제에서 가져온 것은 <bpt id="p1">[</bpt>.NET Framework 4를 사용한 병렬 프로그래밍에 대 한 샘플<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> MSDN 코드 갤러리 웹 사이트에 있습니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It creates a custom task scheduler that limits the number of threads used by the app.</source>
          <target state="translated">응용 프로그램에서 사용 되는 스레드 수를 제한 하는 사용자 지정 작업 스케줄러를 만듭니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</source>
          <target state="translated">다음 두 가지 작업 집합을 시작 하 고 작업은 작업이 실행 되는 스레드에 대 한 정보를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In addition, several sample task schedulers are available on Code Gallery: <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</source>
          <target state="translated">코드 갤러리에서 사용할 수 있는 몇 가지 샘플 작업 스케줄러는 또한: <bpt id="p1">[</bpt>.NET Framework 4를 사용한 병렬 프로그래밍에 대 한 샘플<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>All members of the abstract <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> type are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">추상의 모든 구성원이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 종류는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.#ctor">
          <source>Initializes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 을(를) 초기화합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">현재 실행 중인 작업과 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">현재 실행 중인 작업과 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>When not called from within a task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> will return the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> scheduler.</source>
          <target state="translated">작업 내에서 호출 되지 않을 때 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> 는 반환 된 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> 스케줄러입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Gets the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance that is provided by the .NET Framework.</source>
          <target state="translated">.NET Framework에 의해 제공된 기본 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 인스턴스를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Returns the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance.</source>
          <target state="translated">기본 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 인스턴스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 스케줄러<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>와 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>, as determined by <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>에 따라 결정되는 현재 <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>와 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>All <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances queued to the returned scheduler will be executed through a call to the <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method on that context.</source>
          <target state="translated">모든 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 인스턴스가 반환 하는 대기 중인 스케줄러에 대 한 호출을 통해 실행 됩니다는 <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> 해당 컨텍스트에서 메서드.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 스케줄러<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>The current SynchronizationContext may not be used as a TaskScheduler.</source>
          <target state="translated">현재 SynchronizationContext를 TaskScheduler로 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>For debugger support only, generates an enumerable of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances currently queued to the scheduler waiting to be executed.</source>
          <target state="translated">디버거를 지원하기 위해 현재 스케줄러의 큐에 대기되어 실행을 기다리고 있는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 열거 가능한 형식을 생성합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</source>
          <target state="translated">디버거가 현재 이 스케줄러의 큐에 대기된 작업을 트래버스할 수 있도록 허용하는 열거 가능한 형식입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method in order to support integration with debuggers.</source>
          <target state="translated">클래스에서 파생 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> 디버거와 통합을 지원 하기 위해이 메서드를 구현 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This method will only be invoked by the .NET Framework when the debugger requests access to the data.</source>
          <target state="translated">디버거 데이터에 대 한 액세스를 요청 하는 경우에이 메서드는.NET Framework에서 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</source>
          <target state="translated">유틸리티의 작업 액세스를 디버그 하 여 트래버스 될 반환 되는 열거 가능한 사용자 인터페이스에서이 정보에 대 한 표현을 제공 하기 위해 디버거에서 사용이 스케줄러를 현재 큐에 저장 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>It is important to note that, when this method is called, all other threads in the process will be frozen.</source>
          <target state="translated">즉,이 메서드가 호출 될 때 프로세스의 다른 모든 스레드 고정지 것입니다 확인 하는 것이 유용 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</source>
          <target state="translated">따라서이 차단를 야기할 수 있는 다른 스레드와 동기화를 방지 하기 위해 중요 합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</source>
          <target state="translated">동기화가 필요한 데,이 메서드가 잠금을 획득할 수 없는 경우는 디버거가 충돌 하지 않도록 예외를 throw 해야 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The following example shows one possible approach in C#:</source>
          <target state="translated">다음 예제에서는 C#의 한 가지 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Additionally, this method and the enumerable returned must not modify any globally visible state.</source>
          <target state="translated">또한이 메서드와 열거 가능한 반환 값 전체에 표시 상태를 모두 수정 해서는 안 됩니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The returned enumerable should never be null.</source>
          <target state="translated">열거 가능한 반환 해야 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If there are currently no queued tasks, an empty enumerable should be returned instead.</source>
          <target state="translated">현재 대기 중인된 작업이 있으면 빈 열거형 대신 반환 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <ph id="ph1">`GetScheduledTasksForDebugger`</ph> instead: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</source>
          <target state="translated">구현 하는 사용자 지정 디버거 개발자가이 메서드를 직접 호출 하지 않아야 하지만 내부 래퍼 메서드를 사용 해야 <ph id="ph1">`GetScheduledTasksForDebugger`</ph> 대신: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This wrapper method returns an array of tasks instead of an enumerable.</source>
          <target state="translated">이 래퍼 메서드에서 열거 가능한 대신 작업의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>To retrieve a list of active schedulers, use the internal method <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</source>
          <target state="translated">내부 메서드를 사용 하 여 활성 스케줄러가 목록이 검색 하려면 <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This static method returns an array of all active <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> instances.</source>
          <target state="translated">이 정적 메서드는 모든 활성의 배열을 반환 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>You can then use <ph id="ph1">`GetScheduledTasksForDebugger`</ph> on each scheduler instance to retrieve its list of scheduled tasks.</source>
          <target state="translated">사용할 수 있습니다 <ph id="ph1">`GetScheduledTasksForDebugger`</ph> 각 스케줄러 인스턴스에 예약 된 작업의 해당 목록을 검색할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This scheduler is unable to generate a list of queued tasks at this time.</source>
          <target state="translated">이 스케줄러는 현재 대기 중인 작업 목록을 생성할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Gets the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>의 고유 ID를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Returns the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>의 고유 ID를 반환합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 스케줄러<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Indicates the maximum concurrency level this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> is able to support.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>가 지원할 수 있는 최대 동시성 수준을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Returns an integer that represents the maximum concurrency level.</source>
          <target state="translated">최대 동시성 수준을 나타내는 정수를 반환합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>The default scheduler returns <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">기본 스케줄러는 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 스케줄러<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be queued.</source>
          <target state="translated">큐에 대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>Queues a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to the scheduler.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 스케줄러의 큐에 대기합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method to accept tasks being scheduled on the scheduler.</source>
          <target state="translated">클래스에서 파생 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> 스케줄러에서 예약 된 작업을 수락 하려면이 메서드를 구현 합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</source>
          <target state="translated">일반적인 구현 작업을 나중에 시간에 해당 작업 실행할 스레드에 의해 서비스 됩니다 하는 내부 데이터 구조에 저장 됩니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</source>
          <target state="translated">이 메서드는.NET Framework에 의해 호출 되는 기능만 하며 파생된 클래스에서 직접 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This is necessary for maintaining the consistency of the system.</source>
          <target state="translated">시스템의 일관성을 유지 하는 데 필요한입니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be dequeued.</source>
          <target state="translated">큐에서 제거할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>Attempts to dequeue a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that was previously queued to this scheduler.</source>
          <target state="translated">이전에 이 스케줄러의 큐에 대기된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 큐에서 제거하려고 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>A Boolean denoting whether the <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument was successfully dequeued.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 인수가 큐에서 제거되었는지 여부를 나타내는 부울입니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 스케줄러<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> objects can be disposed of in a timely manner.</source>
          <target state="translated">이 메서드를 실행할 수 있습니다는; finally 블록 따라서 반환 해야 최대한 빨리 하므로 모든 리소스와 같은 <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> 개체 적시에 처리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object to be executed.</source>
          <target state="translated">실행할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Attempts to execute the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> on this scheduler.</source>
          <target state="translated">이 스케줄러에 제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 실행하려고 합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A Boolean that is true if <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was successfully executed, false if it was not.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph>가 실행되었으면 true이고, 그렇지 않으면 false인 부울입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</source>
          <target state="translated">실행이 실패하는 일반적인 이유는 작업이 이전에 실행되었거나 다른 스레드에서 실행 중이기 때문입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Scheduler implementations are provided with <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances to be executed through either the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method or the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> method.</source>
          <target state="translated">스케줄러 구현은 함께 제공 되는지에 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 인스턴스를 통해 실행 되는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> 메서드 또는 <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>When the scheduler deems it appropriate to run the provided task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> should be used to do so.</source>
          <target state="translated">스케줄러가 제공 된 작업을 실행 하는 적절 한 경우 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> 그러려면 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</source>
          <target state="translated">TryExecuteTask 작업 호출, 예외 처리, 상태 관리 및 수명 주기 컨트롤을 포함 하 여 작업을 실행 하는의 모든 측면을 처리 합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> .NET Framework 인프라를 통해이 스케줄러에 제공 된 작업에만 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>It should not be used to execute arbitrary tasks obtained through custom mechanisms.</source>
          <target state="translated">사용자 지정 메커니즘을 통해 얻은 임의의 작업을 실행 하려면 미사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> is not associated with this scheduler.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph>는 이 스케줄러와 연결되어 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be executed.</source>
          <target state="translated">실행할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean denoting whether or not task has previously been queued.</source>
          <target state="translated">작업이 이전에 큐에 대기되었는지 여부를 나타내는 부울입니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</source>
          <target state="translated">이 매개 변수가 True이면 작업이 이전에 큐에 대기된 것일 수 있습니다. False이면 작업이 큐에 대기되지 않은 것입니다. 작업을 큐에 대기하지 않고 인라인으로 실행하려면 이 호출을 수행합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Determines whether the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> can be executed synchronously in this call, and if it can, executes it.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 이 호출에서 동기적으로 실행할 수 있는지 여부를 확인하고 실행 가능할 경우 실행합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean value indicating whether the task was executed inline.</source>
          <target state="translated">작업이 인라인으로 실행되었는지 여부를 나타내는 부울 값입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</source>
          <target state="translated">클래스에서 파생 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> 해당 작업 개체에서 대기를 시작 하는 스레드에서 작업의 인라인 실행을 지원 하기 위해이 함수를 구현 합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Inline execution is optional, and the request may be rejected by returning false.</source>
          <target state="translated">인라인 실행 선택 사항이 며 요청 false를 반환 하 여 거부 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>However, the more tasks that can be inlined, the better the scheduler will scale.</source>
          <target state="translated">그러나 더 많은 작업 수행할 수 있는 인라인 처리할 수를 더 스케줄러 크기를 조정 합니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>In fact, a scheduler that inlines too little may be prone to deadlocks.</source>
          <target state="translated">사실, 스케줄러 해당 인라인 너무 적게 수 있습니다 교착 상태가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</source>
          <target state="translated">적절 한 구현 하는 스케줄러에서 보장 하는 정책에서 실행 하는 요청이 성공적으로 인라인 할 수를 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</source>
          <target state="translated">예를 들어 스케줄러는 전용된 스레드를 사용 하 여 작업을 실행할를 해당 스레드에서 인라이닝 요청이 성공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> method with the provided task object, propagating the return value.</source>
          <target state="translated">스케줄러는 인라인 실행을 수행 하려는 경우, 작업을 수행 해야 기본 TaskScheduler 호출 하 여 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> 메서드 반환 값을 전파 제공 된 작업 개체를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</source>
          <target state="translated">인라인 처리 요청을 사용 하기로 결정 하는 경우는 내부 데이터 구조에서 인라인된 작업을 제거 하는 스케줄러에 대 한 적합할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method.</source>
          <target state="translated">단는 상황에 따라 스케줄러 해야 할 수 인라인 작업을 사용 하 여 이전에 제공 되지 않았습니다 고 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</source>
          <target state="translated">파생 된 스케줄러는 호출 스레드는 자체 일정에 지정된 된 작업을 실행 하는 데 적합 하며 실행 정책이 관련 되어 있는지 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 스케줄러<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was already executed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph>가 이미 실행되었습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</source>
          <target state="translated">오류가 발생한 작업의 확인되지 않은 예외가 기본적으로 프로세스를 종료하는 예외 에스컬레이션 정책을 트리거하려고 할 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</source>
          <target state="translated">이 응용 프로그램 도메인 전체 이벤트 트리거되는 (기본적으로를 종료 하는 프로세스) 에스컬레이션 정책에 예외를 방지 하는 메커니즘을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>To make it easier for developers to write asynchronous code based on tasks, the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> changes the default exception behavior for unobserved exceptions.</source>
          <target state="translated">작업 기반 비동기 코드를 작성 하 고 개발자가 쉽게 수행할 수 있도록는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 관찰 되지 않은 예외에 대 한 기본 예외 동작을 변경 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Although unobserved exceptions still raise the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> exception, the process does not terminate by default.</source>
          <target state="translated">여전히 관찰 되지 않은 예외를 발생는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> 예외를 기본적으로는 프로세스는 종료 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</source>
          <target state="translated">대신, 이벤트가 발생 한 이벤트 처리기에서 예외를 관찰 하는 여부 후 런타임에서 예외 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This behavior can be configured.</source>
          <target state="translated">이 동작을 구성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can use the  configuration element to revert to the behavior of the <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> and terminate the process:</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 구성 요소를 사용 하 여의 동작으로 되돌리려면는 <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> 프로세스를 종료 하 고:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>