<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Task.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d920b17ab80db20fab0e3101b745858eade81dd1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d920b17ab80db20fab0e3101b745858eade81dd1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Represents an asynchronous operation.</source>
          <target state="translated">비동기 작업을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class represents a single operation that does not return a value and that usually executes asynchronously.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 클래스는 반환 하지 않는 한 값과는 일반적으로 한 번의 작업을 비동기적으로 실행 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects are one of the central components of the  <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> first introduced in the .NET Framework 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체는의 중앙 구성 요소 중 하나는 <bpt id="p1">[</bpt>작업 기반 비동기 패턴<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> .NET Framework 4에서 처음 도입 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because the work performed by a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property, as well as the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> properties, to determine the   state of a task.</source>
          <target state="translated">작업에서 수행 되므로 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 일반적으로 비동기적으로 실행 스레드 풀 스레드에서 동기적으로 주 응용 프로그램 스레드를 사용 하지 않고는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성을으로 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, 및 <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> 속성 작업의 상태를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Most commonly, a lambda expression is used to specify the work that the task is to perform.</source>
          <target state="translated">가장 일반적으로 작업을 수행 하는 작업을 지정 하는 람다 식 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For operations that return values, you use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class.</source>
          <target state="translated">값을 반환 하는 작업을 사용 하 여 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In this section:</source>
          <target state="translated">섹션 내용</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Task instantiation examples<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>작업의 인스턴스화 예<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Creating and executing a task<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>만들기 및 작업 실행<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Separating task creation and execution<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>분리 작업 만들기 및 실행<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Waiting for one or more tasks to complete<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>하나 이상의 작업이 완료 되기를 기다리는 중<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Tasks and culture<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>작업 및 문화권<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>For debugger developers<ept id="p1">](#Debugger)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>디버거 개발자를 위한<ept id="p1">](#Debugger)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task instantiation</source>
          <target state="translated">작업 인스턴스화</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates and executes four tasks.</source>
          <target state="translated">다음 예제에서는 만들고 4 개 작업을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Three tasks execute an <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegate named <ph id="ph2">`action`</ph>, which accepts an argument of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">세 가지 작업을 실행 한 <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> 라는 대리자 <ph id="ph2">`action`</ph>, 형식의 인수를 허용 하는 <ph id="ph3">&lt;xref:System.Object&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A fourth task executes a lambda expression (an <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate) that is defined inline in the call to the task creation method.</source>
          <target state="translated">네 번째 작업을 실행 하는 람다 식 (한 <ph id="ph1">&lt;xref:System.Action&gt;</ph> 위임) 작업 생성 방법에 대 한 호출에 인라인으로 정의 즉 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Each task is instantiated and run in a different way:</source>
          <target state="translated">각 작업 인스턴스화되고를 다른 방식으로 실행 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t1`</ph> is instantiated by calling a Task class constructor, but is started by calling its <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> method only after task <ph id="ph3">`t2`</ph> has started.</source>
          <target state="translated">작업 <ph id="ph1">`t1`</ph> 기능은 작업 클래스 생성자를 호출 하 여 시작 되지만 호출 하 여 시작 해당 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> 작업 후에 메서드 <ph id="ph3">`t2`</ph> 시작 했습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t2`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">작업 <ph id="ph1">`t2`</ph> 인스턴스화하고 호출 하 여 단일 메서드 호출에서 시작 된 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t3`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">작업 <ph id="ph1">`t3`</ph> 인스턴스화하고 호출 하 여 단일 메서드 호출에서 시작 된 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t4`</ph> is executed synchronously on the main thread by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method.</source>
          <target state="translated">작업 <ph id="ph1">`t4`</ph> 주 스레드에서 호출 하 여 동기적으로 실행 되는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because task <ph id="ph1">`t4`</ph> executes synchronously, it executes on the main application thread.</source>
          <target state="translated">때문에 작업 <ph id="ph1">`t4`</ph> 동기적으로 실행 되는 주 응용 프로그램 스레드에서 실행 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The remaining tasks execute asynchronously typically on one or more thread pool threads.</source>
          <target state="translated">나머지 작업 실행 일반적으로 하나 이상의 스레드 풀 스레드에서 비동기적으로 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Creating and executing a task</source>
          <target state="translated">만들기 및 작업 실행</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances may be created in a variety of ways.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 여러 가지 방법으로 인스턴스를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The most common approach, which is available starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, is to call the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method.</source>
          <target state="translated">부터 사용할 수 있는 가장 일반적인 방법은 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 정적을 호출 하는 것 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a simple way to start a task using default values and without requiring additional parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> 메서드 기본값을 사용 하는 작업을 시작 하는 간단한 방법을 제공 하 고 추가 매개 변수를 요구 하지 않고 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to start a task that loops and then displays the number of loop iterations:</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> 루프를 실행 한 다음 루프의 반복 수를 표시 하는 작업을 시작 하는 메서드:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>An alternative, and the most common method to start a task in <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, is the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">대신, 및는 작업을 시작 하는 가장 일반적인 방법은 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, 정적은 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> 속성에서 반환 된 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method let you specify parameters to pass to the task creation options and a task scheduler.</source>
          <target state="translated">오버 로드는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> 메서드를 사용 하면 작업 생성 옵션 및 작업 스케줄러에 전달할 매개 변수를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method to start a task.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> 메서드를 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is functionally equivalent to the code in the previous example.</source>
          <target state="translated">앞의 예제 코드를 기능적으로 같습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more complete examples, see <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>.</source>
          <target state="translated">자세한 예제를 보려면 참조 <bpt id="p1">[</bpt>작업 기반 비동기 프로그래밍<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Separating task creation and execution</source>
          <target state="translated">분리 작업 만들기 및 실행</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class also provides constructors that initialize the task but that do not schedule it for execution.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 클래스 생성자는 작업을 초기화 하는 있지만 예약 하지 않는 실행을 위해 제공 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For performance reasons, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> method to schedule the task for execution at a later time.</source>
          <target state="translated">성능상의 이유로 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> 방법은 만들고 계산 작업을 예약 하기 위한 기본 메커니즘 하지만 생성 및 일정 예약 구분 해야 하는 시나리오에 대 한 생성자를 사용 하 여를 다음 호출할 수 있습니다는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> 나중에 실행에 대 한 작업을 예약 하는 메서드.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Waiting for one or more tasks to complete</source>
          <target state="translated">하나 이상의 작업이 완료 되기를 기다리는 중</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</source>
          <target state="translated">작업은 일반적으로 스레드 풀 스레드에서 비동기적으로 실행, 되므로 스레드를 만들고 작업을 시작 하는 작업을 인스턴스화해야 하는 즉시 실행을 계속 합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</source>
          <target state="translated">경우에 따라 호출 스레드가 있는 기본 응용 프로그램 스레드 문화권 인 경우 응용 프로그램을 해지할 수 있습니다 하기 전에 먼저 작업이 실제로 실행을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</source>
          <target state="translated">다른 응용 프로그램의 논리는 하나 이상의 작업 실행을 완료 하는 경우에 호출 스레드가 계속 실행 해야 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a <ph id="ph1">`Wait`</ph> method to wait for one or more tasks to complete.</source>
          <target state="translated">호출 스레드의 실행을 동기화 할 수와 비동기 작업을 하기를 실행 하는 호출 하 여 한 <ph id="ph1">`Wait`</ph> 하나 이상의 작업을 완료할 때까지 대기 하는 메서드.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>To wait for a single task to complete, you can call its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">완료 하는 단일 작업에 대 한 대기를 호출 하면 해당 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A call to the  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method blocks the calling thread until the single class instance has completed execution.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드는 단일 클래스 인스턴스는 실행이 완료 될 때까지 호출 스레드를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example calls the parameterless <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method to wait unconditionally until a task completes.</source>
          <target state="translated">다음 예제에서는 매개 변수가 없는 호출 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> 메서드는 작업이 완료 될 때까지 무조건 대기할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The task simulates work by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to sleep for two seconds.</source>
          <target state="translated">호출 하 여 작업을 시뮬레이션 하는 작업의 <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> 메서드를 2 초 동안 대기 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also conditionally wait for a task to complete.</source>
          <target state="translated">또한 조건에 따라 작업을 완료 하려면 대기할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> 메서드는 작업이 완료 될 때까지 호출 스레드를 차단 또는 제한 시간 간격이 경과, 중 더 먼저 발생 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</source>
          <target state="translated">고 때문에 다음 예제에서는 2 초 동안 대기 하지만 제한 시간이 만료 될 때까지 호출 스레드 차단 1 초 시간 제한 값을 정의 하는 작업을 시작 하기 전에 작업 실행을 완료 했습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also supply a cancellation token by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> and  <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> methods.</source>
          <target state="translated">호출 하 여 취소 토큰을 제공할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>If the  token's <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, the wait is cancelled; if it becomes true while the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method terminates.</source>
          <target state="translated">경우 토큰의 <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> 속성은 <ph id="ph2">`true`</ph>, 취소; 동안 true가 되는 경우는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</source>
          <target state="translated">대기 하려는 경우에 따라 완료 되더라도 하지 마십시오 하의 작업을 실행 하는 일련의 첫 번째 작업는 보험입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For this purpose, you can call one of the overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">이 작업을 위해 수 중 하나를 호출의 오버 로드는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</source>
          <target state="translated">다음 예제에서는 간격 확인는 난수 생성기에서 대기 하는 각각 세 가지 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method waits for the first task to complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> 메서드 첫 번째 작업이 완료 되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The example then displays information about the status of all three tasks.</source>
          <target state="translated">다음 예에서는 세 작업의 상태에 대 한 정보를 표시합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also wait for all of a series of tasks to complete by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method.</source>
          <target state="translated">모든 일련의 작업을 호출 하 여 완료에 대 한 않을 수도 있습니다는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates ten tasks, waits for all ten to complete, and then displays their status.</source>
          <target state="translated">다음 예제에서는 10 개의 작업을 만듭니다., 대기를 완료 하려면 모든 10에 대 한 다음 해당 상태를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the <ph id="ph1">`Wait`</ph> method, as the following example shows.</source>
          <target state="translated">하나 이상의 작업이 완료 되기를 기다릴 때 호출 스레드에서 실행 중인 작업에서 throw 된 예외가 전파 됩니다 참고는 <ph id="ph1">`Wait`</ph> 다음 예제와 같이 메서드.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It launches 12 tasks, three of which complete normally and three of which throw an exception.</source>
          <target state="translated">정상적으로 완료 중 3 개 12 작업, 및에서 예외는 throw 중 3 개를 시작 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Of the remaining six tasks, three are cancelled before the start, and three are cancelled while they executing.</source>
          <target state="translated">나머지 6 가지 작업 중, 시작 되기 전에 취소는 3 개 하 고 3 개를 실행 하는 동안 취소 됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Exceptions are thrown in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method call and are handled by a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">예외가 throw 되는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> 되며 메서드 호출에 의해 처리는 <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> 블록.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information on exception handling in task-based asynchronous operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">작업 기반 비동기 작업에서 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Tasks and culture</source>
          <target state="translated">작업 및 문화권</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Starting with desktop apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the thread that creates and invokes a task becomes part of the thread's context.</source>
          <target state="translated">대상으로 하는 데스크톱 응용 프로그램으로 시작 된 <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>를 만들고 작업을 호출 하는 스레드의 문화권에서 스레드의 컨텍스트에의 일부가 됩니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</source>
          <target state="translated">즉, 작업이 실행 되는 스레드의 현재 문화권에 관계 없이 작업의 현재 문화권은 호출 스레드의 문화권 합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For apps that target versions of the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the task is the culture of the thread on which the task executes.</source>
          <target state="translated">이전에.NET Framework의 버전을 대상으로 하는 앱에 대 한는 <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, 작업의 문화권은 작업이 실행 되는 스레드의 문화권입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information, see the "Culture and task-based asynchronous operations" section in the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> topic.</source>
          <target state="translated">자세한 내용은의 "문화권 및 작업 기반 비동기 작업" 섹션을 참조 하십시오.는 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> 항목입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Store apps follow the Windows Runtime in setting and getting the default culture.</source>
          <target state="translated">스토어 앱 설정 및 기본 문화권을 가져오는에서 Windows Runtime을 따릅니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For debugger developers</source>
          <target state="translated">디버거 개발자를 위한</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</source>
          <target state="translated">사용자 지정 디버거를 구현 하는 개발자에 대 한 작업의 여러 내부 및 전용 멤버 (릴리스 간에 변경 될 수 있습니다 이러한) 유용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_taskId`</ph> field serves as the backing store for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the <ph id="ph3">`s_taskIdCounter`</ph> counter is used to retrieve the next available ID for a task).</source>
          <target state="translated"><ph id="ph1">`m_taskId`</ph> 필드에 대 한 백업 저장소로 사용 된 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> 에 액세스 하는 디버거에서 직접이 필드 더 효율적일 수 있습니다 속성의 getter 메서드를 통해 동일한 값에 액세스 하는 보다 속성 (의 <ph id="ph3">`s_taskIdCounter`</ph> 카운터는 사용 하는 작업에 대 한 사용 가능한 다음 ID)입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Similarly, the <ph id="ph1">`m_stateFlags`</ph> field stores information about the current lifecycle stage of the task, information also accessible through the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">마찬가지로,는 <ph id="ph1">`m_stateFlags`</ph> 정보를 통해 액세스할 수 있는 작업의 현재 수명 주기 단계에 대 한 정보를 저장 하는 필드는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_action`</ph> field stores a reference to the task's delegate, and the <ph id="ph2">`m_stateObject`</ph> field stores the async state passed to the task by the developer.</source>
          <target state="translated"><ph id="ph1">`m_action`</ph> 필드는 작업의 대리자에 대 한 참조를 저장 및 <ph id="ph2">`m_stateObject`</ph> 필드에는 개발자가 작업에 전달 된 비동기 상태를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Finally, for debuggers that parse stack frames, the <ph id="ph1">`InternalWait`</ph> method serves a potential marker for when a task is entering a wait operation.</source>
          <target state="translated">스택 프레임을 구문 분석 하에 대 한 마지막으로 <ph id="ph1">`InternalWait`</ph> 메서드 작업 대기 작업을 시작 하는 경우의 잠재적 표식을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>All members of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, except for <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>, are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">모든 구성원 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 제외 하 고 <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action.</source>
          <target state="translated">지정된 작업을 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to create tasks that retrieve the filenames in specified directories.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> 생성자에서 파일 이름을 검색 하는 작업을 만드는 디렉터리를 지정 합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">모든 작업이 단일 파일 이름을 쓸 <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">이 예에서는 다음 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> 모든 작업을 완료 하 고 다음에 기록 하는 파일 이름의 총 개수를 표시 하는 메서드는 <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example is identical, except that it used the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to instantiate and run the task in a single operation.</source>
          <target state="translated">다음 예제에서는 같습니다 제외 하 고 사용 하는 것은 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> 메서드를 인스턴스화할 때 한 번에 작업을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The method returns the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that represents the task.</source>
          <target state="translated">메서드는 반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 작업을 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that the new  task will observe.</source>
          <target state="translated">작업이 관찰할 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and <ph id="ph2">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</source>
          <target state="translated">지정된 작업을 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>을 초기화합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Cancellation in Managed Threads<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 병렬 처리 (작업 병렬 라이브러리)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> 및 <bpt id="p2">[</bpt>관리 되는 스레드의 취소<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> C:\Windows\System32 디렉터리에 있는 파일을 반복 하는 작업을 만드는 생성자입니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">람다 식 호출은 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> 각 파일에 대 한 정보를 추가 하는 메서드는 <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">분리 된 각에 의해 호출 되는 중첩 된 작업의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> 루프 취소 토큰의 상태를 확인 하 고, 취소를 요청한 경우 호출 하는 <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> 에서 처리 되는 예외는 <ph id="ph3">`catch`</ph> 호출 호출 스레드를 차단 된 <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method is then called to start the task.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> 그런 다음 작업을 시작 하려는 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">작업의 동작을 사용자 지정하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          <target state="translated">지정된 작업 및 만들기 옵션을 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and state.</source>
          <target state="translated">지정된 작업 및 상태를 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The following example defines an array of 6-letter words.</source>
          <target state="translated">다음 예제에서는 6 단어의 배열을 정의합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Each word is then passed as an argument to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> constructor, whose <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</source>
          <target state="translated">각 단어에 대 한 인수로 전달 됩니다는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> 생성자를 가진 <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> 대리자는 단어의 문자를 스크램블 다음 원래 단어와 해당 암호화 된 버전을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that the new task will observe.</source>
          <target state="translated">작업이 관찰할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">작업의 동작을 사용자 지정하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          <target state="translated">지정된 작업 및 만들기 옵션을 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Task Cancellation<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업 병렬 처리 (작업 병렬 라이브러리)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> 및 <bpt id="p2">[</bpt>작업 취소<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>을 만든 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>가 이미 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe.</source>
          <target state="translated">새 작업이 관찰할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">지정된 작업, 상태 및 옵션을 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>을 만든 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>가 이미 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">작업의 동작을 사용자 지정하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">지정된 작업, 상태 및 옵션을 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">작업에서 실행할 코드를 나타내는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe..</source>
          <target state="translated">새 작업이 관찰할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">작업의 동작을 사용자 지정하는 데 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">지정된 작업, 상태 및 옵션을 사용하여 새 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 및 정적을 호출 하 여 작업은 시작 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">이 생성자에 의해 제공 되는 유일한 이점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>을 만든 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>가 이미 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Gets the state object supplied when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> was created, or null if none was supplied.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 만들 때 제공된 상태 개체를 가져오거나, 제공된 개체가 없는 경우 null을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that represents the state data that was passed in to the task when it was created.</source>
          <target state="translated">작업을 만들 때 작업에 전달된 상태 데이터를 나타내는 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Cast the object back to the original type to retrieve its data.</source>
          <target state="translated">개체 데이터를 검색 하도록 원래 형식으로 다시 캐스팅 합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Gets a task that has already completed successfully.</source>
          <target state="translated">이미 성공적으로 완료된 작업을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>The successfully completed task.</source>
          <target state="translated">작업을 완료했습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>This property returns a task whose <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">작업을 반환 하는이 속성이 해당 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성이로 설정 된 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>To create task that returns a value and runs to completion, call the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method.</source>
          <target state="translated">값을 반환 하 고 완료 될 때까지 실행 하는 작업을 만들려면 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Repeated attempts to retrieve this property value may not always return the same instance.</source>
          <target state="translated">이 속성 값을 검색 하려는 시도가 여러 번 같은 인스턴스를 항상 반환 하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to attempt to marshal the continuation back to the original context captured; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">캡처된 원래 컨텍스트로 연속 마샬링하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>Configures an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 기다리는 데 사용되는 awaiter를 구성합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>An object used to await this task.</source>
          <target state="translated">이 작업을 기다리는 데 사용되는 개체입니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The following example defines a task that populates an array with 100 random date and time values.</source>
          <target state="translated">다음 예제에서는 100 임의의 날짜 및 시간 값 배열을 정보를 표시 하는 작업을 정의 합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>It uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method to select the earliest and the latest date values once the array is fully populated.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> 배열의 완전히 채웠으므로 되 면 가능한 한 빨리 및 최신 날짜 값을 선택 하는 메서드.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Because a console application may terminate before the continuation task executes, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method is called to ensure that the continuation finishes executing before the example ends.</source>
          <target state="translated">연속 작업이 실행 되기 전에 콘솔 응용 프로그램을 종료할 수 있습니다 때문에 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> 메서드는 연속 작업 예에서는 종료 되기 전에 실행이 완료 되는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>For an additional example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</source>
          <target state="translated">추가 예제를 참조 하십시오. <bpt id="p1">[</bpt>연속 작업을 사용 하 여 작업 연결<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An action to run when the task completes.</source>
          <target state="translated">작업이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">호출자 제공 상태 정보를 받으며 대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되면 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>A new continuation task.</source>
          <target state="translated">새 연속 작업입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 있는 되거나 취소 인해 일찍 종료 되어 완료 되는지 합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Creates a continuation that receives a cancellation token and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료될 때 취소 토큰을 받고 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">토큰을 만든 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>는 이미 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">지정된 <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>에 따라 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes when the target task completes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 따라 대상 작업이 완료되면 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 연속 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The following example demonstrates using <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> to specify that a continuation task should run synchronously when the antecedent task completes.</source>
          <target state="translated">다음 예제를 사용 하 여 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> 에 선행 작업이 완료 되 면 연속 작업이 동기적으로 실행 되도록 지정 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>(If the specified task has already completed by the time <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> is called, the synchronous continuation will run on the thread calling <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</source>
          <target state="translated">(시간에서 지정된 된 작업에 이미 완료 된 경우 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> 호출 되는 동기 연속은 스레드 호출에서 실행 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">연속 작업은 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료될 때 호출자 제공 상태 정보 및 취소 토큰을 받고 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">호출자 제공 상태 정보를 받으며 대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되면 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation executes based on a set of specified conditions.</source>
          <target state="translated">연속 작업은 지정된 조건의 집합에 따라 실행됩니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 연속 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">호출자 제공 상태 정보를 받으며 대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되면 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">연속 작업은 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">지정된 <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>에 따라 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes when the target task competes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 따라 대상 작업이 완료되면 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives a cancellation token and uses a specified scheduler.</source>
          <target state="translated">연속 작업이 취소 토큰을 받고 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</source>
          <target state="translated">다음은 작업을 실행 하도록 백그라운드와 사용자 인터페이스 스레드 ContinueWith를 사용한 예입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">토큰을 만든 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>는 이미 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 동작입니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료될 때 호출자 제공 상태 정보 및 취소 토큰을 받고 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation executes based on a set of specified conditions and uses a specified scheduler.</source>
          <target state="translated">연속 작업은 지정된 조건의 집합에 따라 실행되며 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A new continuation task.</source>
          <target state="translated">새 연속 작업입니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The following example shows how to use the ContinueWith method:</source>
          <target state="translated">다음 예제에서는 ContinueWith 메서드를 사용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">호출자 제공 상태 정보를 받으며 대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The continuation receives a cancellation token.</source>
          <target state="translated">연속 작업이 취소 토큰을 받습니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">토큰을 만든 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>는 이미 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run according to the condition specified in <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>에 지정된 조건에 따라 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          <target state="translated">지정된 연속 작업 옵션에 따라 실행되고 값을 가져오는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 연속 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">연속 작업은 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The continuation receives caller-supplied state information and a cancellation token.</source>
          <target state="translated">연속 작업은 호출자 제공한 상태 정보 및 취소 토큰을 받습니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되면 지정된 작업 연속 옵션에 따라 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation receives caller-supplied state information.</source>
          <target state="translated">연속 작업은 호출자 제공 상태 정보를 받습니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 연속 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and uses a specified scheduler.</source>
          <target state="translated">연속 작업은 호출자 제공 상태 정보를 받고 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 를 예약할 수 없습니다 실행에 대 한 현재 작업이 완료 될 때까지 인해 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 완료 여부.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions.<ept id="p1">&lt;/c&gt;</ept></source>
          <target state="translated">지정된 <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>에 따라 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          <target state="translated">지정된 연속 작업 옵션에 따라 실행되고 값을 가져오는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation is passed a cancellation token and uses a specified scheduler.</source>
          <target state="translated">연속 작업에 취소 토큰이 전달되고 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following example shows how to use the ContinueWith method with continuation options:</source>
          <target state="translated">다음 예제에서는 연속 작업 옵션으로 ContinueWith 메서드를 사용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">토큰을 만든 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>는 이미 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 null입니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">연속 작업에서 생성되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이 완료될 때 실행할 함수입니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">새 연속 작업에 할당할 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">여기에는 <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>와 같은 조건과 <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph> 등의 실행 옵션이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          <target state="translated">연속 작업과 연결하고 연속 작업의 실행에 사용할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">대상 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이(가) 완료되고 값을 가져오면 지정된 작업 연속 옵션에 따라 실행되는 연속 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</source>
          <target state="translated">연속 작업은 호출자 제공 상태 정보 및 취소 토큰을 받고 지정된 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">새 연속 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">반환 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">통해 기준을 지정 하는 경우는 <ph id="ph1">`continuationOptions`</ph> 매개 변수 충족 되지 않고, 연속 작업을 취소할지 대신 예약 합니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> 인수는 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>에 대해 잘못된 값을 지정합니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          <target state="translated">이 작업을 만드는 데 사용된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          <target state="translated">이 작업을 만드는 데 사용된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Returns the ID of the currently executing <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">현재 실행 중인 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>의 ID를 반환합니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>An integer that was assigned by the system to the currently-executing task.</source>
          <target state="translated">시스템에서 현재 실행 중인 작업에 할당한 정수입니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> is a <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> 이 <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> Visual basic에서) 작업이 실행 되 고 있는 코드에서 현재 실행 중인 작업의 식별자를 가져오는 데 사용 되는 속성입니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>It differs from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, which returns the identifier of a particular <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instance.</source>
          <target state="translated">다른는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> 특정 식별자를 반환 하는 속성 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>If you attempt to retrieve the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> value from outside the code that a task is executing, the property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">검색을 시도 하는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> 작업이 실행 되 고 있는 코드 외부에서 값을 속성은 반환 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Note는 충돌 변수가 매우 드문 경우 이기는 하지만 작업 식별자는 하지 않을 고유 하 게 합니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete after a time delay.</source>
          <target state="translated">시간 지연 후 완료되는 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          <target state="translated">반환된 작업을 완료하기 전에 대기하는 시간(밀리초)입니다. -1은 무기한 대기를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Creates a task that completes after a time delay.</source>
          <target state="translated">시간 지연 후 완료되는 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>A task that represents the time delay.</source>
          <target state="translated">시간 지연을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method is typically used to delay the operation of all or part of a task for a specified time interval.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> 메서드는 지정된 된 시간 간격에 대 한 모든 작업 또는 작업의 일부를 지연 일반적으로 사용 합니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Most commonly, the time delay is introduced:</source>
          <target state="translated">가장 일반적으로 시간 지연을 도입 되었습니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>At the beginning of the task, as the following example shows.</source>
          <target state="translated">에 다음 예제와 같이 작업의 시작 부분을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Sometime while the task is executing.</source>
          <target state="translated">사용 하는 동안 작업이 실행 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes as a child task within a task, as the following example shows.</source>
          <target state="translated">이 경우에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> 메서드는 태스크 내에서 자식 작업으로 다음 예제와 같이 실행 합니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Note that since the task that calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes asynchronously, the parent task must wait for it to complete by using the <ph id="ph2">`await`</ph> keyword.</source>
          <target state="translated">호출 하는 작업 이후에 참고는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> 메서드가 비동기적으로 실행, 부모 작업을 사용 하 여 완료 되기를 기다려야는 <ph id="ph2">`await`</ph> 키워드입니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>After the specified time delay, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">에 지정 된 시간 지연 후 작업이 완료 되는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This method depends on the system clock.</source>
          <target state="translated">이 방법은 시스템 클록에 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">즉, 시간 연기 하는 경우 시스템 클록의 해상도 용량이 약 됩니다는 <ph id="ph1">`millisecondsDelay`</ph> 인수를 사용 하는 약 15 밀리초 Windows 시스템에서 시스템 클록의 해상도 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는의 간단한 사용은 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> 인수가 -1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          <target state="translated">반환된 작업이 완료되기 전에 대기하는 시간 범위입니다. <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph>는 무기한 대기를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>Creates a task that completes after a specified time interval.</source>
          <target state="translated">지정된 시간 제한 간격 후 완료되는 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>A task that represents the time delay.</source>
          <target state="translated">시간 지연을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>After the specified time delay, the task is completed in <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">지정 된 시간 지연 후 작업의 완료 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">사용 시나리오 및 추가 예에 대 한 설명서를 참조 하십시오.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This method depends on the system clock.</source>
          <target state="translated">이 방법은 시스템 클록에 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">즉, 시간 연기 하는 경우 시스템 클록의 해상도 용량이 약 됩니다는 <ph id="ph1">`delay`</ph> 인수를 사용 하는 약 15 밀리초 Windows 시스템에서 시스템 클록의 해상도 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는의 간단한 사용은 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph>는 <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph> 이외의 음의 시간 간격을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> 인수의 <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> 속성은 <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큽니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          <target state="translated">반환된 작업을 완료하기 전에 대기하는 시간(밀리초)입니다. -1은 무기한 대기를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          <target state="translated">반환된 작업을 완료하기 전에 확인되는 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a time delay.</source>
          <target state="translated">시간 지연 후 완료되는 취소 가능 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          <target state="translated">시간 지연을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">취소 토큰, 지정 된 시간 지연이 전에 신호를 받으면는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> 예외 결과 및 작업에서 완료 되는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">작업이 완료 되는 그렇지 않은 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 지정된 시간 지연 기간이 경과 되 면 상태입니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">사용 시나리오 및 추가 예에 대 한 설명서를 참조 하십시오.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">이 방법은 시스템 클록에 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">즉, 시간 연기 하는 경우 시스템 클록의 해상도 용량이 약 됩니다는 <ph id="ph1">`millisecondsDelay`</ph> 인수를 사용 하는 약 15 밀리초 Windows 시스템에서 시스템 클록의 해상도 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one second delay.</source>
          <target state="translated">다음 예제에서는 한 호출을 포함 하는 작업을 시작는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> 1 초 지연 메서드.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">지연 간격은 경과 하기 전에 토큰이 취소 됩니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">이 예제에서 출력을 보여 줍니다, 결과적으로, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> throw 되며, 및 작업의 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성이로 설정 되어 <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> 인수가 -1보다 작습니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          <target state="translated">반환된 작업이 완료되기 전에 대기하는 시간 범위입니다. <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph>는 무기한 대기를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          <target state="translated">반환된 작업을 완료하기 전에 확인되는 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a specified time interval.</source>
          <target state="translated">지정된 시간 제한 간격 후 완료되는 취소 가능 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          <target state="translated">시간 지연을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">취소 토큰, 지정 된 시간 지연이 전에 신호를 받으면는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> 예외 결과 및 작업에서 완료 되는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">작업이 완료 되는 그렇지 않은 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 지정된 시간 지연 기간이 경과 되 면 상태입니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">사용 시나리오 및 추가 예에 대 한 설명서를 참조 하십시오.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">이 방법은 시스템 클록에 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">즉, 시간 연기 하는 경우 시스템 클록의 해상도 용량이 약 됩니다는 <ph id="ph1">`delay`</ph> 인수를 사용 하는 약 15 밀리초 Windows 시스템에서 시스템 클록의 해상도 보다 작습니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one-and-a-half second delay.</source>
          <target state="translated">다음 예제에서는 한 호출을 포함 하는 작업을 시작는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> 메서드 1 및-2.5 두 번째 지연 시간입니다.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">지연 간격은 경과 하기 전에 토큰이 취소 됩니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">이 예제에서 출력을 보여 줍니다, 결과적으로, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> throw 되며, 및 작업의 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성이로 설정 되어 <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</source>
          <target state="translated">이 예제에서는 잠재적 경합 상태를 포함 하는 참고: 토큰이 취소 되 면 지연 시간을 비동기적으로 실행 작업에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Although the 1.5 second delay from the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method makes that assumption likely, it is nevertheless possible that the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method could return before the token is cancelled.</source>
          <target state="translated">1.5 초를 호출 하 여 연기할 수 있지만 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> 메서드 하면 아니라고 가능성이, 불가능 그럼에도 불구 하 고는에 대 한 호출은 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> 메서드 토큰을 취소 하기 전에 반환할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>In that case, the example produces the following output:</source>
          <target state="translated">이 경우 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph>는 <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph> 이외의 음의 시간 간격을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> 인수의 <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> 속성은 <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큽니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>가 이미 삭제된 경우</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 클래스가 구현 하는 <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> 내부적으로 구현 하는 리소스를 사용 하기 때문에 인터페이스 <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">그러나 경우에 특히 응용 프로그램 대상은 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 이상 버전에서는를 호출 하지 않아도 됩니다 또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> 성능이 나 확장성 테스트를 나타내지 않는 경우 사용 패턴에 따라, 응용 프로그램의 성능 향상의 작업을 삭제 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업을 삭제 해야 합니까?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> 와.NET 블로그에서 병렬 프로그래밍 합니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          <target state="translated">작업은 최종 상태(<ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>) 중 하나가 아닙니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>A Boolean value that indicates whether this method is being called due to a call to <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph> 호출로 인해 이 메서드가 호출되는지 여부를 나타내는 부울 값입니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Disposes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, releasing all of its unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 삭제하고 관리되지 않는 해당 리소스를 모두 해제합니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 클래스가 구현 하는 <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> 내부적으로 구현 하는 리소스를 사용 하기 때문에 인터페이스 <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">그러나 경우에 특히 응용 프로그램 대상은 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 이상 버전에서는를 호출 하지 않아도 됩니다 또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> 성능이 나 확장성 테스트를 나타내지 않는 경우 사용 패턴에 따라, 응용 프로그램의 성능 향상의 작업을 삭제 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>작업을 삭제 해야 합니까?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> 와.NET 블로그에서 병렬 프로그래밍 합니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          <target state="translated">작업은 최종 상태(<ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>) 중 하나가 아닙니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Unlike most of the members of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class, this method is not thread-safe.</source>
          <target state="translated">대부분의 멤버의 달리는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 클래스,이 메서드는 스레드로부터 안전 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph>가 중간에 종료되도록 한 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed successfully or has not yet thrown any exceptions, this will return <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 완료되었거나 예외를 아직 throw하지 않은 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>The <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph>가 중간에 종료되도록 한 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> or in accesses to the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">처리 되지 않은 예외를 throw 하는 작업 결과 예외를 저장 하 고에 래핑하여 전파는 <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> 호출에서 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 또는 대 한 액세스는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</source>
          <target state="translated">종료자 스레드에서 가비지 수집 작업 인스턴스가 사용 하는 시간에 관찰 된 모든 예외를 전파 됩니다.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Exception Handling (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">자세한 내용 및 예제에 대 한 참조 <bpt id="p1">[</bpt>예외 처리 (작업 병렬 라이브러리)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Provides access to factory methods for creating and configuring <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> 인스턴스를 만들고 구성하는 팩터리 메서드에 대한 액세스를 제공합니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>A factory object that can create a variety of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects.</source>
          <target state="translated">다양한 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> 개체를 만들 수 있는 팩터리 개체입니다.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>This property returns a default instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> class that is identical to the one created by calling the parameterless <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">이 속성의 기본 인스턴스를 반환 합니다.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> 매개 변수가 없는 호출 하 여 만든 동일한 클래스 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It has the following property values:</source>
          <target state="translated">여기에 다음 속성 값에 있습니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source><ph id="ph1">`null`</ph>, or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">`null`</ph>또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The most common use of this property is to create and start a new task in a single call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">이 속성의 사용 되는 가장 일반적인 만들고 한 번 호출 하는 새 작업을 시작 하는 것은 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> method provides the easiest way to create a <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object with default configuration values.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> 메서드를 만드는 가장 쉬운 방법은 제공는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 기본 구성 값을 가진 개체입니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The following example uses the static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> property to make two calls to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 정적 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> 속성에 대 한 두 호출을는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</source>
          <target state="translated">첫 번째는 두 번째 사용자의 내 문서 디렉터리의 하위 디렉터리의 이름으로 배열을 채웁니다 하는 동안 사용자의 내 문서 디렉터리의 파일 이름 사용 하 여 배열을 채웁니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</source>
          <target state="translated">그런 다음 호출 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> 메서드를 처음 두 개의 작업이 실행을 완료 한 후 두 배열에서 파일 및 디렉터리의 수에 대 한 정보를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          <target state="translated">작업을 완료하는 데 사용할 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          <target state="translated">지정된 취소 토큰을 사용하여 취소로 인해 완료된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          <target state="translated">취소된 작업입니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>에 대해 취소가 요청되지 않았습니다. 해당 <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> 속성은 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">작업에서 반환되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          <target state="translated">작업을 완료하는 데 사용할 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          <target state="translated">지정된 취소 토큰을 사용하여 취소로 인해 완료된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          <target state="translated">취소된 작업입니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>에 대해 취소가 요청되지 않았습니다. 해당 <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> 속성은 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The exception with which to complete the task.</source>
          <target state="translated">작업을 완료하는 데 사용할 예외입니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that has completed with a specified exception.</source>
          <target state="translated">지정된 예외를 사용하여 완료된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The faulted task.</source>
          <target state="translated">오류가 발생한 작업입니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">이 메서드가 만드는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성은 <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> 및 해당 <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> 속성 포함 <ph id="ph5">`exception`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">메서드는 작업을 수행 하는 작업에서 긴 코드 경로 실행 하기 전에 예외를 throw 합니다는 즉시 알고 있는 경우에 주로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> overload.</source>
          <target state="translated">예를 들어 참조는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">작업에서 반환되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The exception with which to complete the task.</source>
          <target state="translated">작업을 완료하는 데 사용할 예외입니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed with a specified exception.</source>
          <target state="translated">지정된 예외를 사용하여 완료된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>을 만듭니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The faulted task.</source>
          <target state="translated">오류가 발생한 작업입니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">이 메서드가 만드는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 개체 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성은 <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> 및 해당 <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> 속성 포함 <ph id="ph5">`exception`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">메서드는 작업을 수행 하는 작업에서 긴 코드 경로 실행 하기 전에 예외를 throw 합니다는 즉시 알고 있는 경우에 주로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The example provides an illustration.</source>
          <target state="translated">예제에서는 그림을 제공합니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">다음 예제에서는 이름이 명령줄 인수로 전달 되는 각 디렉터리에 있는 파일의 바이트 수를 계산 하는 명령줄 유틸리티입니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> method to create a faulted task if a particular subdirectory does not exist.</source>
          <target state="translated">인스턴스화하는 긴 코드 경로 실행 하는 대신 한 <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> 개체의 값을 검색 하 고 해당 <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> 디렉터리에 있는 각 파일에 대 한 속성을이 예에서는 단순히 호출는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> 특정 오류가 발생 한 작업을 만드는 메서드를 하위 디렉터리가 존재 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">작업에서 반환되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The result to store into the completed task.</source>
          <target state="translated">완료된 작업에 저장할 결과입니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed successfully with the specified result.</source>
          <target state="translated">지정된 결과로 완료되는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>을 만듭니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The successfully completed task.</source>
          <target state="translated">작업을 완료했습니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph3">`result`</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">이 메서드가 만드는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 개체 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> 속성은 <ph id="ph3">`result`</ph> 및 해당 <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성은 <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The method is commonly used when the return value of a task is immediately known without executing a longer code path.</source>
          <target state="translated">메서드는 작업의 반환 값 긴 코드 경로 실행 하지 않고 즉시 알려져 있는 경우에 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The example provides an illustration.</source>
          <target state="translated">예제에서는 그림을 제공합니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>To create a Task object that does not return a value, retrieve the Task object from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> property.</source>
          <target state="translated">값을 반환 하지 않는 작업 개체를 만들려면에서 작업 개체를 검색 합니다.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">다음 예제에서는 이름이 명령줄 인수로 전달 되는 각 디렉터리에 있는 파일의 바이트 수를 계산 하는 명령줄 유틸리티입니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method to create a task whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is zero (0) if a directory has no files.</source>
          <target state="translated">인스턴스화하는 긴 코드 경로 실행 하는 대신는 <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> 개체의 값을 검색 하 고 해당 <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> 디렉터리에 있는 각 파일에 대 한 속성을이 예에서는 단순히 호출는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> 메서드는 작업을 만들 인 <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> 속성은 영 (0) 디렉터리에 파일이 있습니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>Gets an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 기다리는 데 사용되는 awaiter를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>An awaiter instance.</source>
          <target state="translated">awaiter 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>This method is intended for compiler use rather than for use in application code.</source>
          <target state="translated">컴파일러 사용 하기 위해이 아니라 응용 프로그램 코드에서 사용 하기 위해이 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Id">
          <source>Gets an ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스에 대한 ID를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>The identifier that is assigned by the system to this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          <target state="translated">시스템이 이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스에 할당한 식별자입니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</source>
          <target state="translated">작업 Id 요청 시 할당 하 고 처리할 인스턴스를 만들 작업에서 순서.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Note는 충돌 변수가 매우 드문 경우 이기는 하지만 작업 식별자는 하지 않을 고유 하 게 합니다.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>To get the task ID of the currently executing task from within code that that task is executing, use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> property.</source>
          <target state="translated">해당 작업이 실행 되는 코드 내에서 현재 실행 중인 작업의 작업 ID를 가져오려면는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has completed execution due to being canceled.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스가 취소되어 실행을 완료했는지를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed due to being canceled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 작업이 취소되어 완료되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>A <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will complete in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state under any of the following conditions:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 은 완료 되는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 다음 조건에서 상태:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> was marked for cancellation before the task started executing,</source>
          <target state="translated">해당 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> 하도록 표시 되었으나 취소 작업을 실행 하기 전에</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by throwing an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> that bears the same <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">취소 요청에는 이미 신호를 승인 했습니다 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> throw 하 여 프로그램 <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> 동일한 갖습니다 <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by calling the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">취소 요청에는 이미 신호를 승인 했습니다 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> 호출 하 여는 <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> 에서 메서드는 <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">값을 검색 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has completed.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 완료되었는지를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업이 완료되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> will return <ph id="ph2">`true`</ph> when the task is in one of the three final states: <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> 반환 <ph id="ph2">`true`</ph> 작업 중인 경우 최종의 세 가지 상태 중 하나: <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, 또는 <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">값을 검색 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Gets whether the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed due to an unhandled exception.</source>
          <target state="translated">처리되지 않은 예외로 인해 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 완료되었는지를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has thrown an unhandled exception; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 작업이 처리되지 않은 예외를 throw했으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the task's <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> is equal to <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, and its <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property will be non-null.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> 은 <ph id="ph2">`true`</ph>, 작업의 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 같으면 <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, 및 해당 <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> 속성은 null이 아닌 됩니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">값을 검색 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Queues the specified work to run on the ThreadPool and returns a task or <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> handle for that work.</source>
          <target state="translated">지정한 작업을 ThreadPool에서 실행하도록 큐에 대기시키고 해당 작업에 대한 작업 또는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> 핸들을 반환합니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a set of overloads that make it easy to start a task by using default values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> 메서드 쉽게 기본값을 사용 하 여 작업을 시작 하는 오버 로드 집합을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is a lightweight alternative to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> overloads.</source>
          <target state="translated">경량급 대안을 이기는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The work to execute asynchronously</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          <target state="translated">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>A task that represents the work queued to execute in the ThreadPool.</source>
          <target state="translated">스레드 풀에서 실행하도록 큐에 대기된 작업(work)을 나타내는 작업(task)입니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method allows you to create and execute a task in a single method call and is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> 방법은을 만들고 단일 메서드 호출에서 작업을 실행 하면 되며 대안을 찾을 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">다음 기본 값으로 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">취소 토큰은 <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">해당 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> 속성 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">기본 작업 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example defines a <ph id="ph1">`ShowThreadInfo`</ph> method  that displays the <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> of the current thread.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`ShowThreadInfo`</ph> 표시 하는 메서드로 <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> 현재 스레드의 합니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It is called directly from the application thread, and is called from the <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">응용 프로그램 스레드에서 직접 호출 하 고에서 호출 되는 <ph id="ph1">&lt;xref:System.Action&gt;</ph> 전달 된 대리자는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</source>
          <target state="translated">다음 예제에서는 태스크를 실행 하는 코드를 정의 하는 람다 식을 사용 하 여 이전 쿼리와 비슷합니다.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The examples show that the asynchronous task executes on a different thread than the main application thread.</source>
          <target state="translated">기본 응용 프로그램 스레드가 아닌 다른 스레드에서 비동기 작업 실행을 예제 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that the task completes and displays its output before the application ends.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드를 사용 하면 작업이 완료 되는 응용 프로그램 종료 되기 전에 해당 출력을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Otherwise, it is possible that the <ph id="ph1">`Main`</ph> method will complete before the task finishes.</source>
          <target state="translated">그렇지 않은 경우 가능한 하는 <ph id="ph1">`Main`</ph> 메서드는 작업이 완료 되기 전에 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">다음 예제는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</source>
          <target state="translated">디렉터리 이름 배열을 정의 하 고 각 디렉터리에 파일 이름을 검색 하려면 별도 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">모든 작업이 단일 파일 이름을 쓸 <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">이 예에서는 다음 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> 모든 작업을 완료 하 고 다음에 기록 하는 파일 이름의 총 개수를 표시 하는 메서드는 <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The work to execute asynchronously</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <ph id="ph1">&lt;paramref name="function" /&gt;</ph>에서 반환된 작업에 대한 프록시를 반환합니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph>에서 반환하는 작업에 대한 프록시를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token that can be used to cancel the work</source>
          <target state="translated">작업을 취소하는 데 사용할 수 있는 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          <target state="translated">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          <target state="translated">취소 토큰에서 작업을 취소할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A task that represents the work queued to execute in the thread pool.</source>
          <target state="translated">스레드 풀에서 실행하도록 큐에 대기된 작업(work)을 나타내는 작업(task)입니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">작업 실행이 시작 되기 전에 취소 요청 되 면 작업이 실행 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">대신으로 설정 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태와 throw는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> 메서드는 대안을 찾을 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">다음 기본 값으로 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">해당 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> 속성 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">기본 작업 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> 메서드를 C:\Windows\System32 디렉터리에 있는 파일을 반복 하는 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">람다 식 호출은 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> 각 파일에 대 한 정보를 추가 하는 메서드는 <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">분리 된 각에 의해 호출 되는 중첩 된 작업의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> 루프 취소 토큰의 상태를 확인 하 고, 취소를 요청한 경우 호출 하는 <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> 에서 처리 되는 예외는 <ph id="ph3">`catch`</ph> 호출 호출 스레드를 차단 된 <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>과 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously.</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work.</source>
          <target state="translated">작업을 취소하는 데 사용해야 하는 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <ph id="ph1">&lt;paramref name="function" /&gt;</ph>에서 반환된 작업에 대한 프록시를 반환합니다.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph>에서 반환하는 작업에 대한 프록시를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>과 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">프록시 작업에서 반환되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The work to execute asynchronously</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">지정된 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <ph id="ph2">&lt;paramref name="function" /&gt;</ph>에서 반환된 <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph>에 대한 프록시를 반환합니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph>에서 반환하는 <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph>에 대한 프록시를 나타내는 <ph id="ph3">&lt;paramref name="function" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The return type of the task.</source>
          <target state="translated">작업의 반환 유형입니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The work to execute asynchronously.</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> object that represents that work.</source>
          <target state="translated">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>A task object that represents the work queued to execute in the thread pool.</source>
          <target state="translated">스레드 풀에서 실행하도록 큐에 대기된 작업을 나타내는 작업 개체입니다.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> 메서드는 대안을 찾을 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It creates a task with the following default values:</source>
          <target state="translated">다음 기본 값으로 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">취소 토큰은 <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">해당 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> 속성 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It uses the default task scheduler.</source>
          <target state="translated">기본 작업 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The following example counts the approximate number of words in text files that represent published books.</source>
          <target state="translated">다음 예에서는 게시 된 책을 나타내는 텍스트 파일에 있는 단어의 대략적인 수를 셉니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</source>
          <target state="translated">각 태스크는 파일을 열면, 전체 콘텐츠를 비동기적으로 읽는 및 정규식을 사용 하 여 단어 개수를 계산 하는 일을 담당 합니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> 메서드를 호출 하는 콘솔에 각 책의 단어 개수를 표시 하기 전에 모든 작업이 완료 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The regular expression <ph id="ph1">`\p{P}*\s+`</ph> matches zero, one, or more punctuation characters followed by one or more whitespace characters.</source>
          <target state="translated">정규식 <ph id="ph1">`\p{P}*\s+`</ph> 0, 1 또는 문장 부호 문자가 더 이상 다음에 하나 이상의 공백 문자가 일치 합니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It assumes that the total number of matches equals the approximate word count.</source>
          <target state="translated">일치 하는 항목의 총 수가 대략적인 단어 수를 가정 합니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">프록시 작업에서 반환되는 결과의 형식입니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          <target state="translated">작업을 취소하는 데 사용해야 하는 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">지정된 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <ph id="ph2">&lt;paramref name="function" /&gt;</ph>에서 반환된 <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph>에 대한 프록시를 반환합니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph>에서 반환하는 <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph>에 대한 프록시를 나타내는 <ph id="ph3">&lt;paramref name="function" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>과 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The result type of the task.</source>
          <target state="translated">작업의 결과 형식입니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">비동기적으로 실행할 작업입니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          <target state="translated">작업을 취소하는 데 사용해야 하는 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> object that represents that work.</source>
          <target state="translated">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          <target state="translated">취소 토큰에서 작업을 취소할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents the work queued to execute in the thread pool.</source>
          <target state="translated">스레드 풀에서 실행하도록 큐에 대기된 작업을 나타내는 <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">작업 실행이 시작 되기 전에 취소 요청 되 면 작업이 실행 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">대신으로 설정 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태와 throw는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> 메서드는 대안을 찾을 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">다음 기본 값으로 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">해당 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> 속성 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">기본 작업 스케줄러를 사용합니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">다음 예제에서는 반복 2 백만의 값에는 카운터가 증가 될 때까지 20 개의 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">처음 10 개의 작업에 도달 하면 2 백만, 취소 토큰이 취소 되 고 해당 카운터 2 백만 도착 하지 않은 모든 작업이 취소 됩니다.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example shows possible output.</source>
          <target state="translated">출력을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</source>
          <target state="translated">사용 하는 대신는 <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> 예외를 검사 하는 속성 예제에서는 성공적으로 완료 하 고 있는 취소 되었습니다 결정 하는 모든 작업을 반복 합니다.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For those that have completed, it displays the value returned by the task.</source>
          <target state="translated">완료 된 것을 대 한 작업에 의해 반환 되는 값 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Because cancellation is cooperative, each task can decide how to respond to cancellation.</source>
          <target state="translated">취소는 공동 각 작업에 취소에 응답 하는 방법을 결정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</source>
          <target state="translated">한다는 점을 제외 하 고 작업의 반복은 완료 하지 않고 예외를 throw 수를 반환 된 토큰이 취소 되 면 다음 예제는 첫 번째 같습니다.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example still must handle the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</source>
          <target state="translated">이 예제에서는 여전히 처리 해야 합니다는 <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> 예외를 이후 취소가 요청 될 때 시작 되지 않은 모든 작업은 여전히 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="function" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>과 연결된 <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph>가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>에서 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>를 동기적으로 실행합니다.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>에서 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>를 동기적으로 실행합니다.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</source>
          <target state="translated">일반적으로 작업 스레드 풀 스레드에서 비동기적으로 실행 되 고 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method are associated with the current <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> and are run on the calling thread.</source>
          <target state="translated">호출 하 여 실행 된 작업의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> 메서드 현재 연관 된 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> 는 호출 스레드에서 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</source>
          <target state="translated">대상 스케줄러는 호출 스레드에서이 작업을 실행 하는 것을 지원 하지 않으면, 작업 스케줄러에서 실행 하기 위해 예약 됩니다 및 작업 실행이 완료 될 때까지 호출 스레드가 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Even though the task runs synchronously, the calling thread should still call <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to handle any exceptions that the task might throw.</source>
          <target state="translated">호출 스레드가 계속 호출 해야 작업을 동기적으로 실행 하는 경우에 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 작업에서 throw 할 수 있는 예외를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>For more information on exception handling, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">호출 하 여 실행 된 작업의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> 메서드를 호출 하 여 인스턴스화될는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">동기적으로 실행 되도록 작업에 있어야 합니다.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>A task may be started and run only once.</source>
          <target state="translated">작업을 시작 하 고 한 번만 실행 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">예외에서 두 번째 시간 결과 작업을 예약 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The following example compares a task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method with one executed asynchronously.</source>
          <target state="translated">다음 예제에서는 비교를 호출 하 여 실행 되는 태스크는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> 메서드를 비동기적으로 실행 하나를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</source>
          <target state="translated">작업의 작업 ID 및 스레드 ID를 표시 하는 동일한 람다 식 실행 두 경우 모두 실행 되는 작업입니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task calculates the sum of the integers between 1 and 1,000,000.</source>
          <target state="translated">작업 1에서 1,000,000 사이의 정수의 합을 계산합니다.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>As the output from the example shows, the task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method runs on the application thread, while the asynchronous task does not.</source>
          <target state="translated">작업을 호출 하 여 실행할 예제의 출력에서 볼 수 있듯이 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> 비동기 태스크는 손실 응용 프로그램 스레드에서 메서드를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 시작할 수 있는 상태가 아닙니다.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler on which to attempt to run this task inline.</source>
          <target state="translated">이 작업을 인라인으로 실행하려고 하는 스케줄러입니다.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> provided.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>에서 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>를 동기적으로 실행합니다.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">호출 하 여 실행 된 작업의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> 메서드를 호출 하 여 인스턴스화될는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> 클래스 생성자입니다.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">동기적으로 실행 되도록 작업에 있어야 합니다.는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>A task may be started and run only once.</source>
          <target state="translated">작업을 시작 하 고 한 번만 실행 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">예외에서 두 번째 시간 결과 작업을 예약 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</source>
          <target state="translated">대상 스케줄러는 현재 스레드에서이 작업을 실행 하는 것을 지원 하지 않으면, 작업 스케줄러에서 실행 하기 위해 예약 됩니다 및 작업 실행이 완료 될 때까지 현재 스레드는 차단 됩니다.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Because of this, the calling thread does not need to call a method such as <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to ensure that the task has completed execution.</source>
          <target state="translated">이 인해 호출 스레드가 메서드를 호출 하는 등 필요 하지 않습니다 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 작업 실행을 완료 되었는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>For more information on exception handling for task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에 대 한 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 시작할 수 있는 상태가 아닙니다.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 시작합니다.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 시작하고 현재 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>에 실행을 예약합니다.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>A task may be started and run only once.</source>
          <target state="translated">작업을 시작 하 고 한 번만 실행 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">작업 다시 예약 하려고 시도 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> is used to execute a task that has been created by calling one of the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> constructors.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> 중 하나를 호출 하 여 만든 작업을 실행 하는 데 사용 되는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</source>
          <target state="translated">일반적으로 이렇게 하면 사용자가 만든 작업을 조건부로 실행 등의 실행에서 작업의 생성을 분리 해야 할 경우.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">실행에서 작업 인스턴스화를 구분 하려면 필요 하지 않습니다는 보다 일반적인 사례에 대해 오버 로드를 호출 하는 권장는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to instantiate a new <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that displays its task ID and managed thread ID and then executes a loop.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> 생성자를 인스턴스화하는 새 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 해당 작업 ID 및 관리 되는 스레드 ID를 표시 한 다음 루프를 실행 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method to execute the task.</source>
          <target state="translated">그런 다음 호출 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> 메서드 작업을 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Since this is a console app, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is necessary to prevent the app from terminating before the task finishes execution.</source>
          <target state="translated">콘솔 응용 프로그램에 대 한 호출 이므로 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드는 응용 프로그램 작업의 실행이 완료 되기 전에 종료 되지 않도록 하려면 필요 합니다.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 시작할 수 있는 상태가 아닙니다.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> with which to associate and execute this task.</source>
          <target state="translated">이 작업을 연결하고 실행할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the specified <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>를 시작하고 지정된 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>에 실행을 예약합니다.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>A task may only be started and run only once.</source>
          <target state="translated">작업 시작 및만 한 번만 실행 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">작업 다시 예약 하려고 시도 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">태스크 작업에서 throw 된 예외 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>예외 처리<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 시작할 수 있는 상태가 아닙니다.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler was unable to queue this task.</source>
          <target state="translated">스케줄러가 이 작업을 큐에 대기할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Status">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task.</source>
          <target state="translated">이 작업의 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph>를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task instance.</source>
          <target state="translated">이 작업 인스턴스의 현재 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">값을 검색 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> and <bpt id="p2">[</bpt>How to: Cancel a Task and Its Children<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</source>
          <target state="translated">자세한 내용 및 예제에 대 한 참조 <bpt id="p1">[</bpt>연속 작업을 사용 하 여 작업 연결<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> 및 <bpt id="p2">[</bpt>하는 방법: 작업 및 해당 자식 취소<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">다음 예제에서는 반복 2 백만의 값에는 카운터가 증가 될 때까지 20 개의 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">처음 10 개의 작업에 도달 하면 2 백만, 취소 토큰이 취소 되 고 해당 카운터 2 백만 도착 하지 않은 모든 작업이 취소 됩니다.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The example then examines the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property of each task to indicate whether it completed successfully or was cancelled.</source>
          <target state="translated">이 예제에서는 다음을 검사 하는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 를 성공적으로 완료 하거나 취소 여부를 나타내는 각 태스크의 속성입니다.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For those that completed, it displays the value returned by the task.</source>
          <target state="translated">완료 하는 것에 대 한 작업에 의해 반환 되는 값 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Using the wait functionality provided by <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> is preferable to using <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> for similar functionality.</source>
          <target state="translated">제공 하 여 대기 기능을 사용 하 여 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> 를 사용 하는 것이 좋습니다 <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> 유사한 기능에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>For more information, see the "Waiting on Tasks" section in <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Using TPL with Other Asynchronous Patterns<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>.</source>
          <target state="translated">자세한 내용은의 "작업에서 대기 중" 섹션을 참조 하십시오. <bpt id="p1">[</bpt>작업 기반 비동기 프로그래밍<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> 및 <bpt id="p2">[</bpt>기타 비동기 패턴과 함께 TPL을 사용 하 여<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source>Gets an indication of whether the operation completed synchronously.</source>
          <target state="translated">작업이 동기적으로 완료되었는지를 나타내는 표시를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation completed synchronously; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">작업이 동기적으로 끝났으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> is a synchronization method that causes the calling thread to wait until the current task has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 호출 스레드가 현재 작업이 완료 될 때까지 대기 하는 동기화 메서드입니다.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</source>
          <target state="translated">현재 태스크 실행을 시작 하지 않았으면, 대기 메서드 스케줄러에서 작업을 제거 하 고 현재 스레드에 대 인라인으로 실행 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</source>
          <target state="translated">이렇게 하기 위해 수 없는 경우 또는 현재 작업이 시작 되 고 이미 실행 하는 경우 작업이 완료 될 때까지 호출 스레드를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information, see <bpt id="p1">[</bpt>Task.Wait and "Inlining"<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>Task.Wait 및 "인라인"<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> 와.NET 블로그에서 병렬 프로그래밍 합니다.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to: Wait on One or More Tasks to Complete<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>.</source>
          <target state="translated">자세한 내용 및 예제에 대 한 참조 <bpt id="p1">[</bpt>하는 방법: 하나 또는 이상의 작업을 완료할 때까지 대기한<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">다음 예제에서는 1 백만 0과 100 사이의 임의의 정수를 생성 하 고 평균을 계산 하는 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method to ensure that the task completes before the application terminates.</source>
          <target state="translated">이 예제에서는 사용은 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드를 응용 프로그램을 종료 하기 전에 작업이 완료 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</source>
          <target state="translated">그렇지 않은 경우 콘솔 응용 프로그램 이기 때문에 예제에서는 종료 되기 전에 작업에서 계산 하 고 평균을 표시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The task was canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> 개체가 있습니다.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">작업을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">예외나 예외에 대한 정보를 포함하는 <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>(-1)입니다.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified number of milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 지정된 시간(밀리초) 내에 실행을 완료할 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>의 실행이 할당된 시간 안에 완료되었으면 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> 호출 스레드가 현재 작업 인스턴스는 다음 중 하나가 발생할 때까지 완료를 대기 하는 동기화 메서드입니다.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task completes successfully.</source>
          <target state="translated">작업이 성공적으로 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">작업 자체가 취소 되거나 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">처리 하는 경우에 <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> 속성 예외 또는 예외에 대 한 세부 정보를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">에 정의 된 간격 <ph id="ph1">`millisecondsTimeout`</ph> 경과 합니다.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">이 경우 현재 스레드의 실행을 다시 시작 하 고 메서드가 반환 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">다음 예제에서는 5 백만 0과 100 사이의 난수를 생성 하 고 평균을 계산 하는 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> 응용 프로그램이 150 밀리초 내에 완료를 대기 하는 메서드.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">응용 프로그램 정상적으로 완료 되 면 작업에는 합계 및 스냅숏이 생성 하는 난수의 평균 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">제한 시간 간격이 경과할 경우 종료 하기 전에 메시지를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task was canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> 개체가 있습니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">작업을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">예외나 예외에 대한 정보를 포함하는 <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 동안 관찰할 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The wait terminates if a cancellation token is canceled before the task completes.</source>
          <target state="translated">작업이 완료되기 전에 취소 토큰이 취소되면 대기가 종료됩니다.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> 메서드 만듭니다 취소할 수 있는 대기; 즉, 현재 스레드를 다음 중 하나가 발생할 때까지 대기 하면 발생 합니다.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task completes.</source>
          <target state="translated">작업을 완료합니다.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The cancellation token is canceled.</source>
          <target state="translated">취소 토큰이 취소 됩니다.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">이 경우에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">취소는 <ph id="ph1">`cancellationToken`</ph> 취소 토큰이 취소 토큰이 전달 또한 취소를 처리할 준비가 되어 하지 않는 한 실행 중인 작업에 영향을 주지 합니다.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled.</source>
          <target state="translated">전달 된 <ph id="ph1">`cancellationToken`</ph> 이 메서드를 개체에는 단순히 대기가 취소 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</source>
          <target state="translated">다음 예제에서는 간단한 작업의 완료에 대 한 대기를 취소 하는 취소 토큰 사용을 예를 보여줍니다.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A task is launched, calls the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</source>
          <target state="translated">작업이 시작을 호출 하 여 <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> 5 초 동안 취소 토큰 소스 취소 토큰 및 다음 지연 하는 메서드.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Note that the task itself has not been passed the cancellation token and is not cancelable.</source>
          <target state="translated">작업 자체가 취소 토큰이 전달 되지 않은 고은 취소할 수 없는 참고 합니다.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The application thread calls the task's <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> is thrown.</source>
          <target state="translated">응용 프로그램 스레드가 호출 작업의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> 취소 토큰이 취소 되 면 인데 메서드는 작업이 완료 될 때까지 기다리는를 보냈으나 대기가 취소 될 <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The exception handler reports the exception and then sleeps for six seconds.</source>
          <target state="translated">예외 처리기는 예외를 보고 하 고 6 초 동안 대기 합니다.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>As the output from the example shows, that delay allows the task to complete in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">이러한 지연 시간 작업에서 완료할 수 있도록 예제의 출력에서 볼 수 있듯이 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>을 취소했습니다.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task has been disposed.</source>
          <target state="translated">작업이 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> 개체가 있습니다.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">작업을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">예외나 예외에 대한 정보를 포함하는 <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)을 나타내는 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>이거나, 무한 대기하도록 -1밀리초를 나타내는 <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified time interval.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 지정된 시간 간격 내에 실행을 완료할 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>의 실행이 할당된 시간 안에 완료되었으면 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> 호출 스레드가 현재 작업 인스턴스는 다음 중 하나가 발생할 때까지 완료를 대기 하는 동기화 메서드입니다.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task completes successfully.</source>
          <target state="translated">작업이 성공적으로 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">작업 자체가 취소 되거나 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">처리 하는 경우에 <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> 속성 예외 또는 예외에 대 한 세부 정보를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The interval defined by <ph id="ph1">`timeout`</ph> elapses.</source>
          <target state="translated">에 정의 된 간격 <ph id="ph1">`timeout`</ph> 경과 합니다.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">이 경우 현재 스레드의 실행을 다시 시작 하 고 메서드가 반환 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">다음 예제에서는 5 백만 0과 100 사이의 난수를 생성 하 고 평균을 계산 하는 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">이 예제에서는 사용 된 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> 응용 프로그램이 150 밀리초 내에 완료를 대기 하는 메서드.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">응용 프로그램 정상적으로 완료 되 면 작업에는 합계 및 스냅숏이 생성 하는 난수의 평균 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">제한 시간 간격이 경과할 경우 종료 하기 전에 메시지를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task was canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> 개체가 있습니다.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">작업을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">예외나 예외에 대한 정보를 포함하는 <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>(-1)입니다.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 동안 관찰할 취소 토큰입니다.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</source>
          <target state="translated">작업이 완료되기 전에 취소 토큰이 취소되었거나 시간 제한 간격이 경과되었으면 대기가 종료됩니다.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>의 실행이 할당된 시간 안에 완료되었으면 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> 호출 스레드가 현재 작업 인스턴스는 다음 중 하나가 발생할 때까지 완료를 대기 하는 동기화 메서드입니다.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task completes successfully.</source>
          <target state="translated">작업이 성공적으로 완료 됩니다.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">작업 자체가 취소 되거나 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">처리 하는 경우에 <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> 속성 예외 또는 예외에 대 한 세부 정보를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> cancellation token is canceled.</source>
          <target state="translated"><ph id="ph1">`cancellationToken`</ph> 취소 토큰이 취소 합니다.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">이 경우에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">에 정의 된 간격 <ph id="ph1">`millisecondsTimeout`</ph> 경과 합니다.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">이 경우 현재 스레드의 실행을 다시 시작 하 고 메서드가 반환 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">취소는 <ph id="ph1">`cancellationToken`</ph> 취소 토큰이 취소 토큰이 전달 또한 취소를 처리할 준비가 되어 하지 않는 한 실행 중인 작업에 영향을 주지 합니다.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled based on some condition.</source>
          <target state="translated">전달 된 <ph id="ph1">`cancellationToken`</ph> 개체를이 메서드에 단순히 허용을 취소 하기 위해 대기 기반 조건에 있습니다.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> 제한 시간 값과는 취소 토큰에 제공 하는 메서드는 작업의 완료에 대 한 대기를 종료할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A new thread is started and executes the <ph id="ph1">`CancelToken`</ph> method, which pauses and then calls the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel the cancellation tokens.</source>
          <target state="translated">새 스레드가 시작 되 고 실행는 <ph id="ph1">`CancelToken`</ph> 메서드를 일시 중지 하 고 다음 호출에서 <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> 취소 토큰을 취소 하는 메서드.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A task is then launched and delays for 5 seconds.</source>
          <target state="translated">작업 한 다음을 실행 하 고 5 초 동안 지연 시킵니다.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드를 호출 하는 작업의 완료를 기다리는 및 간단한 시간 제한 값 및 취소 토큰을 모두 제공 됩니다.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</source>
          <target state="translated">대기가 취소 토큰으로 인해 취소 되었습니다 여부 시간 제한 간격이 경과 하기 때문에 예는 정확한 결과에 따라 달라 지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>을 취소했습니다.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> 개체가 있습니다.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">작업을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">예외나 예외에 대한 정보를 포함하는 <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">제공된 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">제공된 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The following example starts 10 tasks, each of which is passed an index as a state object.</source>
          <target state="translated">다음 예에서는 인덱스 상태 개체로 전달 되는 각각 10 개의 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Tasks with an index from two to five throw exceptions.</source>
          <target state="translated">두 개에서 5 개로 인덱스를 사용 하 여 작업 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method wraps all exceptions in an <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> object and propagates it to the calling thread.</source>
          <target state="translated">에 대 한 호출은 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> 메서드의 모든 예외를 래핑하는 <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> 개체 하 고 호출 스레드에 전파 합니다.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>에서 하나 이상의 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 빈 배열인 경우</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상이 취소된 경우</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> exception contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> exception in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">작업이 취소된 경우 <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> 예외에는 해당 <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션의 <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> 예외가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>(-1)입니다.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          <target state="translated">모든 제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 지정된 시간(밀리초) 내에 실행을 완료할 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">모든 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 인스턴스의 실행이 할당된 시간 안에 완료되었으면 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>에서 하나 이상의 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상이 취소된 경우</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">작업이 취소된 경우 <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph>의 <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph>이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 빈 배열인 경우</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 동안 확인할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          <target state="translated">대기가 취소되지 않는 경우 제공된 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 실행을 완료하기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated"><ph id="ph1">`cancellationToken`</ph> 인수는 대기 작업을 취소 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> as noted above.</source>
          <target state="translated">작업의 취소 하는 고유한 작업 및 신호를 보낼는 <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> 위에서 언급 한 대로 합니다.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>을 취소했습니다.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상이 취소된 경우</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">작업이 취소된 경우 <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph>의 <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph>이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 빈 배열인 경우</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>에서 하나 이상의 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)을 나타내는 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>이거나, 무한 대기하도록 -1밀리초를 나타내는 <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for all of the provided cancellable <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          <target state="translated">모든 제공된 취소 가능한 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 지정된 시간 간격 내에 실행을 완료할 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">모든 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 인스턴스의 실행이 할당된 시간 안에 완료되었으면 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>에서 하나 이상의 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상이 취소된 경우</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">작업이 취소된 경우 <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph>의 <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph>이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 빈 배열인 경우</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>(-1)입니다.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 동안 확인할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</source>
          <target state="translated">제공된 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 지정된 시간(밀리초) 내에 실행을 완료하기를 기다리거나 대기가 취소될 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">모든 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 인스턴스의 실행이 할당된 시간 안에 완료되었으면 <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated"><ph id="ph1">`cancellationToken`</ph> 인수는 대기 작업을 취소 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> noted above.</source>
          <target state="translated">작업의 취소 하는 고유한 작업 및 신호를 보낼는 <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> 위에서 언급 합니다.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>에서 하나 이상의 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상이 취소된 경우</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">작업이 취소된 경우 <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph>의 <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> 컬렉션에 <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph>이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 빈 배열인 경우</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>을 취소했습니다.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체 중 임의 개체의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체 중 임의 개체의 실행이 완료되기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The index of the completed <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object in the <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> 배열에서 완료된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</source>
          <target state="translated">다음 예제에서는 50 밀리초 최소 또는 최대 1,050 시간 (밀리초)에 대 한 대기는 각각 5 개 작업을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> method then waits for any of the tasks to complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> 메서드 다음의 작업을 완료할 때까지 대기 합니다.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</source>
          <target state="translated">모든 작업의 현재 상태 뿐만 아니라 대기를 종료 하는 작업의 작업 ID를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>(-1)입니다.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          <target state="translated">모든 제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 지정된 시간(밀리초) 내에 실행을 완료할 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열 인수의 완료된 작업 인덱스이거나, 제한 시간이 초과되었으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 동안 확인할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          <target state="translated">대기가 취소되지 않는 경우 제공된 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 실행을 완료하기를 기다립니다.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열 인수에서 완료된 작업의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>을 취소했습니다.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)을 나타내는 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>이거나, 무한 대기하도록 -1밀리초를 나타내는 <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          <target state="translated">모든 제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 지정된 시간 간격 내에 실행을 완료할 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열 인수의 완료된 작업 인덱스이거나, 제한 시간이 초과되었으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">대기할 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 인스턴스의 배열입니다.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>(-1)입니다.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          <target state="translated">작업이 완료되기를 기다리는 동안 확인할 <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</source>
          <target state="translated">모든 제공된 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 지정된 시간(밀리초) 내에 실행을 완료하기를 기다리거나 취소 토큰이 취소될 때까지 기다립니다.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열 인수의 완료된 작업 인덱스이거나, 제한 시간이 초과되었으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>가 삭제된 경우</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수에 null 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>을 취소했습니다.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when all of the supplied tasks have completed.</source>
          <target state="translated">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an enumerable collection have completed.</source>
          <target state="translated">열거 가능한 컬렉션의 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 완료되면 완료될 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">제공된 모든 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">오버 로드는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> 반환 하는 메서드는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체는 일반적으로 일련의 작업에서 throw 된 예외 또는 일련의 작업의 상태에 관심 있는 때 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">에 대 한 호출 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> 메서드 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">제공된 된 작업의 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료 되는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> 상태에 해당 예외 각각 제공된 된 작업의 래핑 해제 된 예외 집합의 집계를 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">반환된 된 작업에 종료 됩니다 제공된 된 작업 중에 오류가 발생 하는 경우 그 중 하나 이상 취소는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">결과 작업에 종료 됩니다 작업 중에 오류가 발생 하는 경우 취소 된 작업이 없거나는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">반환 된 작업이 즉시 전환 되 태스크가 제공 된 배열/열거 가능한 들어 있는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태에 호출자에 게 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">다음 예제에서는 배열에 있는 Url을 ping 하는 작업의 집합을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">작업에 저장 되는 <ph id="ph1">`List&lt;Task&gt;`</ph> 에 전달 되는 컬렉션은 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">호출 후의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드를 사용 하면 모든 스레드가 완료 한,이 예제에서는 검사 하는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> 있는 모든 작업에 오류가 있는지 여부를 확인 하는 속성입니다.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated"><ph id="ph2">&lt;see langword="null" /&gt;</ph> 작업이 포함된 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an array have completed.</source>
          <target state="translated">배열의 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 개체가 완료되면 완료될 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">제공된 모든 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">오버 로드는 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> 반환 하는 메서드는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> 개체는 일반적으로 일련의 작업에서 throw 된 예외 또는 일련의 작업의 상태에 관심 있는 때 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">에 대 한 호출 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> 메서드 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">제공된 된 작업의 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료 되는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> 상태에 해당 예외 각각 제공된 된 작업의 래핑 해제 된 예외 집합의 집계를 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">반환된 된 작업에 종료 됩니다 제공된 된 작업 중에 오류가 발생 하는 경우 그 중 하나 이상 취소는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">결과 작업에 종료 됩니다 작업 중에 오류가 발생 하는 경우 취소 된 작업이 없거나는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">반환 된 작업이 즉시 전환 되 태스크가 제공 된 배열/열거 가능한 들어 있는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태에 호출자에 게 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">다음 예제에서는 배열에 있는 Url을 ping 하는 작업의 집합을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is converted to an array and passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">작업에 저장 되는 <ph id="ph1">`List&lt;Task&gt;`</ph> 배열로 변환 되 고 전달 하는 컬렉션의 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">호출 후의 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> 메서드를 사용 하면 모든 스레드가 완료 한,이 예제에서는 검사 하는 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> 있는 모든 작업에 오류가 있는지 여부를 확인 하는 속성입니다.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated"><ph id="ph2">&lt;see langword="null" /&gt;</ph> 작업이 포함된 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">완료된 작업의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an enumerable collection have completed.</source>
          <target state="translated">열거 가능한 컬렉션의 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> 개체가 완료되면 완료될 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">제공된 모든 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">에 대 한 호출 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> 메서드 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">그러나 반환 된에 대 한 호출 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> 속성 작업이 호출 스레드를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">제공된 된 작업의 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료 되는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> 상태에 해당 예외 각각 제공된 된 작업의 래핑 해제 된 예외 집합의 집계를 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">반환된 된 작업에 종료 됩니다 제공된 된 작업 중에 오류가 발생 하는 경우 그 중 하나 이상 취소는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">결과 작업에 종료 됩니다 작업 중에 오류가 발생 하는 경우 취소 된 작업이 없거나는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> 반환된 된 작업의 속성이 제공 된 대로 동일한 순서로 제공된 된 작업의 결과 모두 포함 된 배열에 설정 됩니다 (예: 입력 작업을 포함 하는 배열 t1, t2, t3, 출력 작업의 경우 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> 속성은 반환 <ph id="ph3">`TResult[]`</ph> 여기서 <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If the <ph id="ph1">`tasks`</ph> argument contains no tasks, the returned task will immediately transition to a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">경우는 <ph id="ph1">`tasks`</ph> 인수에는 태스크가 포함 된, 반환 된 작업이 즉시 전환 되는 <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태에 호출자에 게 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">반환 된 <ph id="ph1">`TResult[]`</ph> 0 요소 배열 됩니다.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">다음 예제에는 1에서 1,000 사이의 임의의 숫자 1, 000를 만들어 평균을 계산 하는 난수 생성기를 인스턴스화하는 각각 한 10 가지 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> 메서드 같은 시드 값을 가진 만들어지지 않으므로 있도록 난수 생성기의 인스턴스화를 지연 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> 다음 메서드는 <ph id="ph2">&lt;xref:System.Int64&gt;</ph> 각 작업에서 계산 된 평균 포함 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">이러한 전반적인 평균 계산에 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">이 경우 10 개의 개별 작업에 저장 되는 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> 인터페이스를 구현합니다.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated"><ph id="ph2">&lt;see langword="null" /&gt;</ph> 작업이 포함된 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">완료된 작업의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an array have completed.</source>
          <target state="translated">배열의 모든 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> 개체가 완료되면 완료될 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">제공된 모든 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">에 대 한 호출 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> 메서드 호출 스레드를 차단 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">그러나 반환 된에 대 한 호출 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> 속성 작업이 호출 스레드를 차단 합니다.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">제공된 된 작업의 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료 되는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> 상태에 해당 예외 각각 제공된 된 작업의 래핑 해제 된 예외 집합의 집계를 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">반환된 된 작업에 종료 됩니다 제공된 된 작업 중에 오류가 발생 하는 경우 그 중 하나 이상 취소는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">결과 작업에 종료 됩니다 작업 중에 오류가 발생 하는 경우 취소 된 작업이 없거나는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> 반환된 된 작업의 제공 된 대로 동일한 순서로 제공된 된 작업의 결과 모두 포함 된 배열에 설정할 수는 (예: 입력 작업을 포함 하는 배열 t1, t2, t3, 출력 작업의 경우 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> 돌아갑니다는 <ph id="ph3">`TResult[]`</ph> 여기서 <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">반환 된 작업이 즉시 전환 되 태스크가 제공 된 배열/열거 가능한 들어 있는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> 상태에 호출자에 게 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">반환 된 <ph id="ph1">`TResult[]`</ph> 0 요소 배열 됩니다.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">다음 예제에는 1에서 1,000 사이의 임의의 숫자 1, 000를 만들어 평균을 계산 하는 난수 생성기를 인스턴스화하는 각각 한 10 가지 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">`Task&lt;Int64&gt;`</ph> array.</source>
          <target state="translated">이 경우 10 개의 개별 작업에 저장 되는 <ph id="ph1">`Task&lt;Int64&gt;`</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> 메서드 같은 시드 값을 가진 만들어지지 않으므로 있도록 난수 생성기의 인스턴스화를 지연 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> 다음 메서드는 <ph id="ph2">&lt;xref:System.Int64&gt;</ph> 각 작업에서 계산 된 평균 포함 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">이러한 전반적인 평균 계산에 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated"><ph id="ph2">&lt;see langword="null" /&gt;</ph> 작업이 포함된 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">제공된 한 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">반환 작업의 결과는 완료된 작업입니다.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">반환된 된 작업은 완료 되 면 완료 제공된 된 작업을 모두 완료 했습니다.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state  with its Result set to the first task to complete.</source>
          <target state="translated">반환된 된 작업에 종료 항상 됩니다는 <ph id="ph1">`RanToCompletion`</ph> 상태의 첫 번째 작업을 완료로 설정 하는 결과입니다.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">첫 번째 작업이 완료 되기를 인해 종료 된 경우에 마찬가지입니다는 <ph id="ph1">`Canceled`</ph> 또는 <ph id="ph2">`Faulted`</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">null 작업이 포함되었거나 비어 있는 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">제공된 한 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">반환 작업의 결과는 완료된 작업입니다.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">반환된 된 작업은 완료 되 면 완료 제공된 된 작업을 모두 완료 했습니다.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state   with its <ph id="ph2">`Result`</ph> set to the first task to complete.</source>
          <target state="translated">반환된 된 작업에 종료 항상 됩니다는 <ph id="ph1">`RanToCompletion`</ph> 상태의 해당 <ph id="ph2">`Result`</ph> 첫 번째 작업을 완료로 설정 합니다.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">첫 번째 작업이 완료 되기를 인해 종료 된 경우에 마찬가지입니다는 <ph id="ph1">`Canceled`</ph> 또는 <ph id="ph2">`Faulted`</ph> 상태입니다.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 null인 경우</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">null 작업이 포함되었거나 비어 있는 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">완료된 작업의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">제공된 한 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">반환 작업의 결과는 완료된 작업입니다.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">반환된 된 작업은 완료 되 면 완료 제공된 된 작업을 모두 완료 했습니다.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">반환된 된 작업 항상 RanToCompletion 상태의 첫 번째 작업을 완료로 설정 하는 결과 함께 종료 됩니다.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">첫 번째 작업이 완료 되기를 Faulted 또는 Canceled 상태에서 종료 하는 경우에 마찬가지입니다.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">null 작업이 포함되었거나 비어 있는 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">완료된 작업의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">완료를 기다리는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">제공된 한 작업의 완료를 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">반환 작업의 결과는 완료된 작업입니다.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">반환된 된 작업은 완료 되 면 완료 제공된 된 작업을 모두 완료 했습니다.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">반환된 된 작업 항상 RanToCompletion 상태의 첫 번째 작업을 완료로 설정 하는 결과 함께 종료 됩니다.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">첫 번째 작업이 완료 되기를 Faulted 또는 Canceled 상태에서 종료 하는 경우에 마찬가지입니다.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 인수가 null인 경우</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">null 작업이 포함되었거나 비어 있는 <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> 배열입니다.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Creates an awaitable task that asynchronously yields back to the current context when awaited.</source>
          <target state="translated">대기할 때 현재 컨텍스트로 비동기적으로 전환되는 awaitable 작업을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</source>
          <target state="translated">대기할 때 대기 시의 현재 컨텍스트로 비동기적으로 전환될 컨텍스트입니다.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> is non-null, it is treated as the current context.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>가 null이 아닌 경우 현재 컨텍스트로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</source>
          <target state="translated">그렇지 않으면 현재 실행 중인 작업과 관련된 작업 스케줄러를 현재 컨텍스트로 처리됩니다.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>You can use <ph id="ph1">`await Task.Yield();`</ph> in an asynchronous method to force the method to complete asynchronously.</source>
          <target state="translated">사용할 수 있습니다 <ph id="ph1">`await Task.Yield();`</ph> 메서드를 비동기적으로 완료 하려면 비동기 메서드는에 있습니다.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If there is a current synchronization context (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> object), this will post the remainder of the method’s execution back to that context.</source>
          <target state="translated">현재 동기화 컨텍스트를 없을 경우 (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> 개체),이를 해당 컨텍스트로 메서드 실행의 나머지 부분에서는 게시 합니다.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>However, the context will decide how to prioritize this work relative to other work that may be pending.</source>
          <target state="translated">그러나 컨텍스트 보류 될 수 있는 다른 작업을 기준으로이 작업 우선 순위를 지정 하는 방법을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</source>
          <target state="translated">대부분의 UI 환경에서 UI 스레드에서 존재 하는 동기화 컨텍스트 입력 및 렌더링 작업 보다 더 높은 상황에 맞는에 게시 된 작업의 우선 순위 종종 됩니다.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For this reason, do not rely on <ph id="ph1">`await Task.Yield();`</ph> to keep a UI responsive.</source>
          <target state="translated">이러한 이유로 의존 하지 마십시오 <ph id="ph1">`await Task.Yield();`</ph> 하는 UI를 응답 가능한 상태로 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For more information, see the entry <bpt id="p1">[</bpt>Useful Abstractions Enabled with ContinueWith<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">자세한 내용은 항목을 참조 하십시오. <bpt id="p1">[</bpt>ContinueWith 사용 하도록 설정 유용한 추상화<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> 와.NET 블로그에서 병렬 프로그래밍 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>