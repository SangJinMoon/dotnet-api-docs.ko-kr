<Type Name="Task&lt;TResult&gt;" FullName="System.Threading.Tasks.Task&lt;TResult&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cf0281184adbbe318952dab5ad2fb0f56bb28bf5" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395268" /></Metadata><TypeSignature Language="C#" Value="public class Task&lt;TResult&gt; : System.Threading.Tasks.Task" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task`1&lt;TResult&gt; extends System.Threading.Tasks.Task" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Task(Of TResult)&#xA;Inherits Task" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class Task : System::Threading::Tasks::Task" />
  <TypeSignature Language="F#" Value="type Task&lt;'Result&gt; = class&#xA;    inherit Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Threading.Tasks.Task</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TResult"><span data-ttu-id="c301f-101">이 <see cref="T:System.Threading.Tasks.Task`1" />에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-101">The type of the result produced by this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></typeparam>
    <summary><span data-ttu-id="c301f-102">값을 반환할 수 있는 비동기 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-102">Represents an asynchronous operation that can return a value.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-103"><xref:System.Threading.Tasks.Task%601> 클래스는 일반적으로 하 고 값을 반환 하는 단일 작업을 비동기적으로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-103">The <xref:System.Threading.Tasks.Task%601> class represents a single operation that returns a value and that usually executes asynchronously.</span></span> <span data-ttu-id="c301f-104"><xref:System.Threading.Tasks.Task%601> 개체는의 중앙 구성 요소 중 하나는 [작업 기반 비동기 패턴](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) .NET Framework 4에서 처음 도입 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-104"><xref:System.Threading.Tasks.Task%601> objects are one of the central components of the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) first introduced in the .NET Framework 4.</span></span> <span data-ttu-id="c301f-105">작업을 수행 하므로 <xref:System.Threading.Tasks.Task%601> 개체 일반적으로 비동기적으로 실행 스레드 풀 스레드에서 동기적으로 주 애플리케이션 스레드에서 사용할 수 있습니다 것이 아니라 합니다 <xref:System.Threading.Tasks.Task.Status%2A> 속성인 뿐만 <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, 및 <xref:System.Threading.Tasks.Task.IsFaulted%2A> 속성에는 작업의 상태를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-105">Because the work performed by a <xref:System.Threading.Tasks.Task%601> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref:System.Threading.Tasks.Task.Status%2A> property, as well as the <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, and <xref:System.Threading.Tasks.Task.IsFaulted%2A> properties, to determine the   state of a task.</span></span> <span data-ttu-id="c301f-106">가장 일반적으로 작업을 수행 하는 작업을 지정 하는 람다 식 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-106">Most commonly, a lambda expression is used to specify the work that the task is to perform.</span></span>  
  
 <span data-ttu-id="c301f-107"><xref:System.Threading.Tasks.Task%601> 인스턴스는 여러 가지 방법으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-107"><xref:System.Threading.Tasks.Task%601> instances may be created in a variety of ways.</span></span> <span data-ttu-id="c301f-108">부터 사용할 수 있는 가장 일반적인 방법은 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 정적 호출 하는 것 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-108">The most common approach, which is available starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], is to call the static <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-109">이러한 메서드는 추가 매개 변수를 획득 하지 않고 기본값을 사용 하 여 작업을 시작 하는 간단한 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-109">These methods provide a simple way to start a task by using default values and without acquiring additional parameters.</span></span> <span data-ttu-id="c301f-110">다음 예제에서는 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 루프를 실행 한 다음 루프 반복 횟수를 표시 하는 작업을 시작 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c301f-110">The following example uses the <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method to start a task that loops and then displays the number of loop iterations:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task\`1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/run1.vb#6)]  
  
 <span data-ttu-id="c301f-111">대신 및 작업을 시작 하는 가장 일반적인 방법은 합니다 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 정적 호출 하는 것 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-111">An alternative, and the most common way to start a task in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], is to call the static <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-112"><xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> 속성에서 반환을 <xref:System.Threading.Tasks.TaskFactory> 개체 및 <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> 속성에서 반환을 <xref:System.Threading.Tasks.TaskFactory%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-112">The <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory> object, and the <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory%601> object.</span></span> <span data-ttu-id="c301f-113">오버 로드는 `StartNew` 메서드를 사용 하면 인수를 전달, 작업 만들기 옵션을 정의 및 작업 스케줄러 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-113">Overloads of their `StartNew` method let you pass arguments, define task creation options, and specify a task scheduler.</span></span> <span data-ttu-id="c301f-114">다음 예제에서는 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> 메서드 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-114">The following example uses the <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> method to start a task.</span></span> <span data-ttu-id="c301f-115">이전 예제에서 코드에 기능적으로 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-115">It is functionally equivalent to the code in the previous example.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task\`1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/startnew1.vb#7)]  
  
 <span data-ttu-id="c301f-116">자세한 예제를 보려면 [태스크 기반 비동기 프로그래밍](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-116">For more complete examples, see [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span></span>  
  
 <span data-ttu-id="c301f-117"><xref:System.Threading.Tasks.Task%601> 클래스는 또한 작업을 초기화 하는 하지만 해당 실행에 대 한 예약 하지 않습니다 하는 생성자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-117">The <xref:System.Threading.Tasks.Task%601> class also provides constructors that initialize the task but that do not schedule it for execution.</span></span> <span data-ttu-id="c301f-118">성능상의 이유로 합니다 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 고 `Task.Factory.StartNew` 메서드를 만들고 계산 태스크를 예약 하기 위한 기본 메커니즘이 있지만 작업 만들기 및 예약을 구분 해야 합니다는 시나리오에 대 한 생성자를 사용할 수 있습니다, 그리고 및 작업의 <xref:System.Threading.Tasks.Task.Start%2A> 메서드를 사용 하 여 나중에 실행에 대 한 작업 일정을 다음 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-118">For performance reasons, the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> and `Task.Factory.StartNew` methods are the preferred mechanisms for creating and scheduling computational tasks, but for scenarios where task creation and scheduling must be separated, the constructors may be used, and the task's <xref:System.Threading.Tasks.Task.Start%2A> method may then be used to schedule the task for execution at a later time.</span></span>  
  
 <span data-ttu-id="c301f-119">대상으로 하는 데스크톱 앱을 사용 하 여 시작 합니다 [!INCLUDE[net_v46](~/includes/net-v46-md.md)], 스레드 컨텍스트의 일부가 만들고 작업을 호출 하는 스레드의 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-119">Starting with desktop apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the thread that creates and invokes a task becomes part of the thread's context.</span></span> <span data-ttu-id="c301f-120">즉, 태스크가 실행 하는 스레드의 현재 문화권에 관계 없이 현재 태스크의 문화권이 호출 스레드의 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-120">That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</span></span> <span data-ttu-id="c301f-121">이전에.NET Framework의 버전을 대상으로 하는 앱에 대 한는 [!INCLUDE[net_v46](~/includes/net-v46-md.md)], 작업의 문화권은 태스크가 실행 하는 스레드의 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-121">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the task is the culture of the thread on which the task executes.</span></span> <span data-ttu-id="c301f-122">자세한 내용은 "문화권 및 작업 기반 비동기 작업" 섹션을 참조 합니다 <xref:System.Globalization.CultureInfo> 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-122">For more information, see the "Culture and task-based asynchronous operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span> <span data-ttu-id="c301f-123">스토어 앱에 설정 하 고 기본 문화권을 가져오는 Windows 런타임을 따라 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-123">Note that Store apps follow the Windows Runtime in setting and getting the default culture.</span></span>  
  
<span data-ttu-id="c301f-124">사용할 값을 반환 하지 않는 작업의 경우는 <xref:System.Threading.Tasks.Task> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-124">For operations that do not return a value, you use the <xref:System.Threading.Tasks.Task> class.</span></span> <span data-ttu-id="c301f-125">참조 형식이 아닌 값 형식에는 더 간단한 작업에 대 한 C# 7을 사용 하 여 개발 하는 경우 사용 된 <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> 않으면 C# 7부터 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-125">If you're developing with C# 7, for a more lightweight task that is a value type rather than a reference type, use the <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> structure; it is supported starting with C# 7.</span></span> 
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="c301f-126">모든 구성원이 <see cref="T:System.Threading.Tasks.Task`1" />를 제외 하 고 <see cref="M:System.Threading.Tasks.Task.Dispose" />는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-126">All members of <see cref="T:System.Threading.Tasks.Task`1" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-127">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-127">Task Parallel Library (TPL)</span></span></related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-128">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-128">Task-based Asynchronous Programming</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="c301f-129">.NET Framework 사용한 병렬 프로그래밍 샘플</span><span class="sxs-lookup"><span data-stu-id="c301f-129">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c301f-130">새 <see cref="T:System.Threading.Tasks.Task`1" /> 개체를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-130">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; function" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-131">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-131">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-132">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-132">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <summary><span data-ttu-id="c301f-133">지정된 함수를 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-133">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-134">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-134">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="c301f-135">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-135">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c301f-136">다음 예에서는 게시 된 책을 나타내는 텍스트 파일의 단어의 대략적인 수를 셉니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-136">The following example counts the approximate number of words in text files that represent published books.</span></span> <span data-ttu-id="c301f-137">각 태스크는 파일을 열고 전체 콘텐츠를 비동기적으로 읽고, 정규식을 사용 하 여 단어 수를 계산 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-137">Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</span></span> <span data-ttu-id="c301f-138"><xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> 메서드는 콘솔에 각 책의 단어 수를 표시 하기 전에 모든 작업 완료를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-138">The <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> method is called to ensure that all tasks have completed before displaying the word count of each book to the console.</span></span>  
  
 <span data-ttu-id="c301f-139">개체 인스턴스화 예제는 각 파일이 있는지 보증할 수 있습니다 개체 실행이 예제에서에서 분리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-139">Object instantiation is separated from object execution in this example so that the example can ensure that each file exists.</span></span> <span data-ttu-id="c301f-140">그렇지 않으면 누락 된 파일의 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-140">If they do not,  it displays the name of the missing file.</span></span> <span data-ttu-id="c301f-141">를 호출 합니다 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> 각 태스크를 실행 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-141">Otherwise, it calls the <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> method to launch each task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run3.vb#2)]  
  
 <span data-ttu-id="c301f-142">정규식 패턴 `\p{P}*\s+` 0, 1 또는 뒤에 하나 이상의 공백 문자가 문장 부호 문자가 더 이상 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-142">The regular expression pattern `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more white-space characters.</span></span> <span data-ttu-id="c301f-143">일치 항목의 총 수가 대략적인 단어 수를 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-143">It assumes that the total number of matches equals the approximate word count.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-144"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-144">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-145">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-145">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-146">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-146">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-147">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-147">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-148">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-148">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-149">동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-149">An object representing data to be used by the action.</span></span></param>
        <summary><span data-ttu-id="c301f-150">지정된 함수 및 상태를 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-150">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-151">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-151">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-152">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-152">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-153"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-153">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-154">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-154">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-155">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-155">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-156">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-156">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-157">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-157">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-158">이 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-158">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to this task.</span></span></param>
        <summary><span data-ttu-id="c301f-159">지정된 함수를 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-159">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-160">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-160">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="c301f-161">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-161">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-162"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-162">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-163"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-163">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-164">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-164">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-165">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-165">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult), creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-166">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-166">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-167">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-167">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c301f-168">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-168">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c301f-169">지정된 함수 및 만들기 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-169">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-170">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-170">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-171">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-171">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-172"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-172">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-173"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-173">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-174">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-174">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-175">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-175">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-176">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-176">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-177">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-177">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-178">함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-178">An object representing data to be used by the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-179">새 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-179">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to the new task.</span></span></param>
        <summary><span data-ttu-id="c301f-180">지정된 작업, 상태 및 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-180">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-181">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-181">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-182">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-182">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-183"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-183">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-184"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-184">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-185">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-185">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-186">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-186">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-187">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-187">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-188">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-188">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-189">함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-189">An object representing data to be used by the function.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c301f-190">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-190">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c301f-191">지정된 작업, 상태 및 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-191">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-192">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-192">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-193">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-193">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-194"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-194">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-195"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-195">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-196">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-196">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-197">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-197">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-198">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-198">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-199">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-199">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-200">새 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-200">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c301f-201">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-201">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c301f-202">지정된 함수 및 만들기 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-202">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-203">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-203">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="c301f-204">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-204">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-205"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-205">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-206"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-206">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-207"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-207">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-208">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-208">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-209">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-209">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c301f-210">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-210">The delegate that represents the code to execute in the task.</span></span> <span data-ttu-id="c301f-211">함수가 완료되면 작업의 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 속성이 함수의 결과 값을 반환하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-211">When the function has completed, the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-212">함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-212">An object representing data to be used by the function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-213">새 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-213">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to the new task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c301f-214">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-214">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c301f-215">지정된 작업, 상태 및 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task`1" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-215">Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-216">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task%601> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-216">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task%601> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-217">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-217">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-218"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-218">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-219"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-219">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-220"><paramref name="function" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-220">The <paramref name="function" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-221">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-221">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-222">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-222">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1&lt;!TResult&gt; ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="override this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;'Result&gt;" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><span data-ttu-id="c301f-223">캡처된 원래 컨텍스트로 연속 마샬링하려면 true이고, 그렇지 않으면 false입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-223">true to attempt to marshal the continuation back to the original context captured; otherwise, false.</span></span></param>
        <summary><span data-ttu-id="c301f-224">이 <see cref="T:System.Threading.Tasks.Task`1" />를 기다리는 데 사용되는 awaiter를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-224">Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></summary>
        <returns><span data-ttu-id="c301f-225">이 작업을 기다리는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-225">An object used to await this task.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c301f-226">다른 작업이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-226">Creates a continuation task that executes when another task completes.</span></span></summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-227">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-227">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-228">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-228">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-229">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-229">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-230"><see cref="T:System.Threading.Tasks.Task`1" /> 선행 작업이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-230">An action to run when the antecedent <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-231">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-231">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="c301f-232">대상 작업이 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-232">Creates a continuation that executes asynchronously when the target task completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-233">새 연속 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-233">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-234">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 일찍 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-234">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c301f-235">다음 예제에서는 에라토스테네스의 체를 사용 하 여 사용자가 입력 한 값 1 사이의 소수를 계산 하는 선행 태스크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-235">The following example creates an antecedent task that uses the Sieve of Eratosthenes to calculate the prime numbers between 1 and a value entered by the user.</span></span> <span data-ttu-id="c301f-236">소수에 대 한 정보를 저장 하는 배열을 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-236">An array is used to hold information about the prime numbers.</span></span> <span data-ttu-id="c301f-237">배열 인덱스 번호를 나타내며 요소의 값 복합 숫자 인지를 나타냅니다 (해당 값이 `true`) 또는 소수 (해당 값은 `false`).</span><span class="sxs-lookup"><span data-stu-id="c301f-237">The array index represents the number, and the element's value indicates whether that number is composite (its value is `true`) or prime (its value is `false`).</span></span> <span data-ttu-id="c301f-238">그러면이 태스크는 정수 배열에서 소수를 추출 하 고 표시 하는 일을 담당 하는 연속 작업에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-238">This task is then passed to a continuation task, which is responsible for extracting the prime numbers from the integer array and displaying them.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-239"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-239">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-240"><paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-240">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-241">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-241">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-242">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-242">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-243">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-243">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-244"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-244">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-245">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-245">When run, the delegate is   passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-246">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-246">An object representing data to be used by the continuation action.</span></span></param>
        <summary><span data-ttu-id="c301f-247">상태 정보가 전달되며 대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료되면 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-247">Creates a continuation that is passed state information and that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-248">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-248">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-249">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-249">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c301f-250">다음 예제에서는 2에서 20 사이의 정수를 전달 하 고 처음 10 명의 지 수를 포함 하는 배열을 반환 하는 작업 (n에서<sup>1</sup> 1~n<sup>10</sup>) 해당 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-250">The following example creates a task that is passed an integer between 2 and 20 and returns an array that contains the first ten exponents (from n<sup>1</sup> to n<sup>10</sup>) of that number.</span></span> <span data-ttu-id="c301f-251">연속 작업을 담당 합니다는 지 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-251">A continuation task is then responsible for displaying the exponents.</span></span> <span data-ttu-id="c301f-252">선행 작업 및 원래 선행 작업에서 생성 된 지 수를 모두 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-252">It is passed both the antecedent and the original number whose exponents the antecedent generates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continuewith3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continuewith3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-253"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-253">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-254">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-254">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-255"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-255">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-256">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-256">When run, the delegate is passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-257">새 연속 작업에 전달되는 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-257">The cancellation token that is passed to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="c301f-258">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 비동기적으로 실행되는 취소 가능 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-258">Creates a cancelable continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-259">새 연속 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-259">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-260">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-260">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c301f-261">다음 예제에서는 에라토스테네스의 체를 사용 하 여 사용자가 입력 한 값 1 사이의 소수를 계산 하는 선행 태스크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-261">The following example creates an antecedent task that uses the Sieve of Eratosthenes to calculate the prime numbers between 1 and a value entered by the user.</span></span> <span data-ttu-id="c301f-262">소수에 대 한 정보를 저장 하는 배열을 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-262">An array is used to hold information about the prime numbers.</span></span> <span data-ttu-id="c301f-263">배열 인덱스 번호를 나타내며 요소의 값 복합 숫자 인지를 나타냅니다 (해당 값이 `true`) 또는 소수 (해당 값은 `false`).</span><span class="sxs-lookup"><span data-stu-id="c301f-263">The array index represents the number, and the element's value indicates whether that number is composite (its value is `true`) or prime (its value is `false`).</span></span> <span data-ttu-id="c301f-264">그러면이 태스크는 정수 배열에서 소수를 추출 하 고 표시 하는 일을 담당 하는 연속 작업에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-264">This task is then passed to a continuation task, which is responsible for extracting the prime numbers from the integer array and displaying them.</span></span>  
  
 <span data-ttu-id="c301f-265">취소 토큰은 선행 작업 및 연속 작업에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-265">A cancellation token is passed to both the antecedent and the continuation task.</span></span> <span data-ttu-id="c301f-266"><xref:System.Timers.Timer?displayProperty=nameWithType> 개체 100 밀리초의 시간 제한 값을 정의를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-266">A <xref:System.Timers.Timer?displayProperty=nameWithType> object is used to define a timeout value of 100 milliseconds.</span></span> <span data-ttu-id="c301f-267">이벤트가 발생 하는 경우는 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출 하 고 취소 토큰은 작업의 취소를 요청 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-267">If the event fires, the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called, and the cancellation token is used to request cancellation of the tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue1.vb#1)]  
  
 <span data-ttu-id="c301f-268">일반적으로, 만료 시간 제한 간격을 사용 하면 약 100,000의 값을 제공 하며 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트가 발생 하 고 취소 요청을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-268">Typically, supplying a value of about 100,000 causes the timeout interval to expire and the <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> event to fire, and the cancellation request to be set.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-269"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-269">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="c301f-270">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-270">-or-</span></span> 
<span data-ttu-id="c301f-271"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-271">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-272"><paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-272">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-273">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-273">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-274">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-274">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-275">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-275">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-276"><paramref name="continuationOptions" />에 지정된 조건에 따른 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-276">An action to according the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="c301f-277">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-277">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-278">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-278">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-279">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-279">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c301f-280"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-280">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="c301f-281">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-281">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-282">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-282">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c301f-283">통해 연속 조건을 지정 하는 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-283">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 <span data-ttu-id="c301f-284">자세한 내용은 [연속 작업을 사용하여 작업 연결](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c301f-284">For more information, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-285"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-285">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-286"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-286">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-287"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-287">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-288">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-288">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-289">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-289">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-290">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-290">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-291"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-291">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-292">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-292">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-293">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-293">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c301f-294">대상 <see cref="T:System.Threading.Tasks.Task`1" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-294">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-295">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-295">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-296">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-296">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-297"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-297">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-298"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-298">The <paramref name="continuationAction" /> argument is null.</span></span>  
  
<span data-ttu-id="c301f-299">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-299">-or-</span></span> 
<span data-ttu-id="c301f-300"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-300">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-301">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-301">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-302">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-302">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-303">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-303">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-304"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-304">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-305">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-305">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-306">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-306">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-307">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-307">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="c301f-308">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-308">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-309">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-309">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-310">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-310">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-311"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-311">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-312">제공된 <see cref="T:System.Threading.CancellationToken" />이 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-312">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-313">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-313">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-314"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-314">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-315">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-315">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-316">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-316">An object representing data to be used by the continuation action.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-317">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-317">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-318">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-318">This includes criteria, such  as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c301f-319">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-319">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-320">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-320">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-321">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-321">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c301f-322">통해 연속 조건을 지정 하는 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-322">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-323"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-323">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-324"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-324">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-325">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-325">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-326"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-326">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-327">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-327">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-328">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-328">An object representing data to be used by the continuation action.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-329">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-329">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c301f-330">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-330">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-331">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-331">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-332">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-332">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-333"><paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-333">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-334">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-334">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-335"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-335">An action to run according the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="c301f-336">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-336">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-337">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-337">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-338">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-338">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-339">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-339">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-340">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-340">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c301f-341"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-341">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="c301f-342">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-342">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-343">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-343">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c301f-344">조건을 통해 지정 된 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-344">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span> <span data-ttu-id="c301f-345">자세한 내용은 [연속 작업을 사용하여 작업 연결](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c301f-345">For more information, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-346"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-346">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="c301f-347">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-347">-or-</span></span> 
<span data-ttu-id="c301f-348"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-348">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-349"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-349">The <paramref name="continuationAction" /> argument is null.</span></span>  
  
<span data-ttu-id="c301f-350">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-350">-or-</span></span> 
<span data-ttu-id="c301f-351"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-351">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-352"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-352">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-353">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-353">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-354">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-354">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-355">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-355">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c301f-356"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-356">An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-357">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-357">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-358">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-358">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-359">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-359">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-360">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-360">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-361">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-361">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as  well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-362">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-362">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="c301f-363">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-363">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-364">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-364">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-365">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-365">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="c301f-366">조건을 통해 지정 된 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-366">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-367"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-367">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-368"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-368">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-369">제공된 <see cref="T:System.Threading.CancellationToken" />이 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-369">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-370">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-370">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult)) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-371">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-371">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-372"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-372">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-373">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-373">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="c301f-374">대상 <see cref="T:System.Threading.Tasks.Task`1" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-374">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-375">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-375">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-376">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-376">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-377"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-377">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-378"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-378">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-379">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-379">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-380">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-380">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-381">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-381">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-382">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-382">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-383"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-383">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-384">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-384">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-385">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-385">An object representing data to be used by the continuation function.</span></span></param>
        <summary><span data-ttu-id="c301f-386">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-386">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-387">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-387">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-388">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-388">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current  task has completed, whether it completes due to running to completion successfully, faulting due  to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c301f-389">다음 예제에서는 연속 작업의 체인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-389">The following example creates a chain of continuation tasks.</span></span> <span data-ttu-id="c301f-390">현재 시간을 제공 하는 각 작업을 <xref:System.DateTime> 상태 인수에 대 한 개체를 <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%2CSystem.Object%7D%2CSystem.Object%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-390">Each task provides the current time, a <xref:System.DateTime> object, for the state argument of the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%2CSystem.Object%7D%2CSystem.Object%29> method.</span></span> <span data-ttu-id="c301f-391">각 <xref:System.DateTime> 값에 계속 작업이 만들어진 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-391">Each <xref:System.DateTime> value represents the time at which the continue task is created.</span></span> <span data-ttu-id="c301f-392">각 태스크에서 생성 하 고 결과 두 번째로 <xref:System.DateTime> 태스크를 완료 하는 시간을 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-392">Each task produces as its result a second <xref:System.DateTime> value that represents the time at which the task finishes.</span></span> <span data-ttu-id="c301f-393">모든 작업을 마친 후 예제에서는 날짜 및 시간 각 연속 작업을 시작 및 완료를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-393">After all tasks finish, the example displays the date and times at which each continuation task starts and finishes.</span></span>  
  
 [!code-csharp[TPL_ContinuationState#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-394"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-394">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-395">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-395">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-396">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-396">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-397"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-397">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-398">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-398">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-399">새 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-399">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <summary><span data-ttu-id="c301f-400">대상 <see cref="T:System.Threading.Tasks.Task`1" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-400">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-401">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-401">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-402">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-402">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-403"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-403">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="c301f-404">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-404">-or-</span></span> 
<span data-ttu-id="c301f-405"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-405">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-406"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-406">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-407">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-407">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-408">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-408">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-409">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-409">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-410">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-410">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-411"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-411">A function to run according the condition specified in <paramref name="continuationOptions" />.</span></span>  
  
<span data-ttu-id="c301f-412">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-412">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-413">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-413">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-414">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-414">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c301f-415"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-415">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="c301f-416">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-416">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-417">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-417">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="c301f-418">합니다 `continuationFunction`를 실행 하는 경우 반환할지를 <xref:System.Threading.Tasks.Task%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-418">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span> 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-419"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-419">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-420"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-420">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-421"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-421">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-422">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-422">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-423">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-423">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-424">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-424">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-425">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-425">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-426"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-426">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-427">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-427">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-428">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-428">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c301f-429">대상 <see cref="T:System.Threading.Tasks.Task`1" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-429">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-430">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-430">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-431">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-431">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-432"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-432">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-433"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-433">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="c301f-434">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-434">-or-</span></span> 
<span data-ttu-id="c301f-435"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-435">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-436">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-436">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-437">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-437">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-438">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-438">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-439">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-439">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-440"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-440">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-441">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-441">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-442">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-442">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-443">새 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-443">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <summary><span data-ttu-id="c301f-444">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-444">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-445">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-445">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-446">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-446">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current  task has completed, whether it completes due to running to completion successfully, faulting due  to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-447"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-447">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-448">제공된 <see cref="T:System.Threading.CancellationToken" />이 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-448">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-449">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-449">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-450">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-450">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-451"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-451">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-452">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-452">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-453">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-453">An object representing data to be used by the continuation function.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-454">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-454">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-455">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-455">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c301f-456">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-456">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-457">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-457">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-458">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-458">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current  task has completed, whether it completes due to running to completion successfully, faulting due  to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="c301f-459">합니다 `continuationFunction`를 실행 하는 경우 반환할지를 <xref:System.Threading.Tasks.Task%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-459">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="c301f-460">이 작업의 완료 상태 ContinueWith 호출에서 반환 된 작업에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-460">This task's completion state will be transferred to the task returned from the ContinueWith call.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-461"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-461">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-462"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-462">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-463">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-463">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-464">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-464">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-465"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-465">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-466">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-466">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-467">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-467">An object representing data to be used by the continuation function.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-468">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-468">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c301f-469">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-469">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-470">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-470">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-471">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-471">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-472"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-472">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-473">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-473">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-474">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-474">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-475"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-475">A function to run according the condition specified in <paramref name="continuationOptions" />.</span></span>  
  
<span data-ttu-id="c301f-476">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-476">When run, the delegate will be passed as an argument this completed task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-477">새 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-477">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-478">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-478">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-479">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-479">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-480">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-480">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c301f-481"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-481">Creates a continuation that executes according the condition specified in <paramref name="continuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="c301f-482">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-482">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-483">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-483">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="c301f-484">합니다 `continuationFunction`를 실행 하는 경우 반환할지를 <xref:System.Threading.Tasks.Task%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-484">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-485"><see cref="T:System.Threading.Tasks.Task`1" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-485">The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.</span></span>  
  
<span data-ttu-id="c301f-486">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-486">-or-</span></span> 
<span data-ttu-id="c301f-487"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-487">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-488"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-488">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="c301f-489">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-489">-or-</span></span> 
<span data-ttu-id="c301f-490"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-490">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-491"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-491">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-492">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-492">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-493">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-493">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-494">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-494">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult"><span data-ttu-id="c301f-495">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-495">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c301f-496"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-496">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c301f-497">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-497">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c301f-498">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-498">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c301f-499">새 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-499">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c301f-500">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-500">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c301f-501">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-501">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c301f-502">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-502">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c301f-503">대상 <see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-503">Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c301f-504">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-504">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-505">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-505">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 <span data-ttu-id="c301f-506">합니다 `continuationFunction`를 실행 하는 경우 반환할지를 <xref:System.Threading.Tasks.Task%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-506">The `continuationFunction`, when executed, should return a <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="c301f-507">반환 된 작업에이 작업의 완료 상태를 전송할는 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-507">This task's completion state will be transferred to the task returned from the <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> call.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c301f-508"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-508">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c301f-509"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-509">The  <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c301f-510">제공된 <see cref="T:System.Threading.CancellationToken" />이 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-510">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md"><span data-ttu-id="c301f-511">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="c301f-511">Chaining Tasks by Using Continuation Tasks</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory&lt;TResult&gt; Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory`1&lt;!TResult&gt; Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ Factory { System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c301f-512"><see cref="T:System.Threading.Tasks.Task`1" /> 인스턴스를 만들고 구성하는 팩터리 메서드에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-512">Provides access to factory methods for creating and configuring <see cref="T:System.Threading.Tasks.Task`1" /> instances.</span></span></summary>
        <value><span data-ttu-id="c301f-513">다양한 <see cref="T:System.Threading.Tasks.Task`1" /> 개체를 만들 수 있는 팩터리 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-513">A factory object that can create a variety of <see cref="T:System.Threading.Tasks.Task`1" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-514">이 속성의 기본 인스턴스를 반환 합니다 <xref:System.Threading.Tasks.TaskFactory%601> 클래스는 매개 변수가 없는 호출 하 여 만든 동일한 <xref:System.Threading.Tasks.TaskFactory%601.%23ctor?displayProperty=nameWithType> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-514">This property returns a default instance of the <xref:System.Threading.Tasks.TaskFactory%601> class that is identical to the one created by calling the parameterless <xref:System.Threading.Tasks.TaskFactory%601.%23ctor?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="c301f-515">다음 속성 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-515">It has the following property values:</span></span>  
  
|<span data-ttu-id="c301f-516">속성</span><span class="sxs-lookup"><span data-stu-id="c301f-516">Property</span></span>|<span data-ttu-id="c301f-517">값</span><span class="sxs-lookup"><span data-stu-id="c301f-517">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory%601.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.Scheduler%2A?displayProperty=nameWithType>|<span data-ttu-id="c301f-518">`null`또는 <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="c301f-518">`null`, or <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span></span>|  
  
 <span data-ttu-id="c301f-519">이 속성의 가장 일반적인 용도 만들고 단일 호출에서 새 작업을 시작 하는 것은 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-519">The most common use of this property is to create and start a new task in a single call to the <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c301f-520">부터 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]의 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드를 만드는 가장 쉬운 방법은 제공을 <xref:System.Threading.Tasks.Task%601> 기본 구성 값을 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-520">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method provides the easiest way to create a <xref:System.Threading.Tasks.Task%601> object with default configuration values.</span></span>  
  
 <span data-ttu-id="c301f-521">다음 예제에서는 정적 <xref:System.Threading.Tasks.Task%601.Factory%2A> 속성에 대 한 세 개의 호출을는 <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-521">The following example uses the static <xref:System.Threading.Tasks.Task%601.Factory%2A> property to make three calls to the <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c301f-522">첫 번째 시작을 `Task<Int32>` 1을 반환 하는 람다 식을 실행 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-522">The first starts a `Task<Int32>` object, which executes a lambda expression that returns 1.</span></span> <span data-ttu-id="c301f-523">두 번째 시작을 `Task<Test>` 새 인스턴스화하는 람다 식을 실행 하는 개체 `Test` 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="c301f-523">The second starts a `Task<Test>` object, which executes a lambda expression that instantiates a new `Test` instance.</span></span> <span data-ttu-id="c301f-524">세 번째 시작을 `Task<String[]>` 개체를 실행 하려면 C:\Users\Public\Pictures\Sample Pictures\ 디렉터리의 파일을 열거 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-524">The third starts a `Task<String[]>` object, which enumerates the files in the C:\Users\Public\Pictures\Sample Pictures\ directory.</span></span> <span data-ttu-id="c301f-525">(참고 예의 성공적인 실행 한다는 디렉터리가 존재 하 고 파일을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-525">(Note that successful execution of the example requires that the directory exist and that it contain files.</span></span>  
  
 [!code-csharp[TPL#10](~/samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/returnavalue10.cs#10)]
 [!code-vb[TPL#10](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/10_returnavalue.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-526">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-526">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-527">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-527">Task-based Asynchronous Programming</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt; GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter`1&lt;!TResult&gt; GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter&lt;TResult&gt; GetAwaiter();" />
      <MemberSignature Language="F#" Value="override this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter&lt;'Result&gt;" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c301f-528">이 <see cref="T:System.Threading.Tasks.Task`1" />를 기다리는 데 사용되는 awaiter를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-528">Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></summary>
        <returns><span data-ttu-id="c301f-529">awaiter 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-529">An awaiter instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-530">이 메서드 코드에서 직접 사용 하지 않고 컴파일러 사용자를 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-530">This method is intended for compiler user rather than use directly in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public TResult Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TResult Result" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Result" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Result As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TResult Result { TResult get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : 'Result" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c301f-531">이 <see cref="T:System.Threading.Tasks.Task`1" />의 결과 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-531">Gets the result value of this <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></summary>
        <value><span data-ttu-id="c301f-532">이 결과 값 <see cref="T:System.Threading.Tasks.Task`1" />, 작업의 형식 매개 변수와 동일한 형식인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-532">The result value of this <see cref="T:System.Threading.Tasks.Task`1" />, which is of the same type as the task's type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c301f-533">비동기 작업이 완료 될 때까지 호출 스레드를 차단 하는 속성의 get 접근자에 액세스 호출 하는 것과 동일 합니다 <xref:System.Threading.Tasks.Task.Wait%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c301f-533">Accessing the property's get accessor blocks the calling thread until the asynchronous operation is complete; it is equivalent to calling the <xref:System.Threading.Tasks.Task.Wait%2A> method.</span></span>  
  
 <span data-ttu-id="c301f-534">작업의 결과가 제공 되 면 저장 되 고 후속 호출에서 즉시 반환 되는 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-534">Once the result of an operation is available, it is stored and is returned immediately on subsequent calls to the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="c301f-535">이때 작업의 작업 중에 예외가 발생 하는 경우 또는 작업, 취소 하는 경우는 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성 값을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-535">Note that, if an exception occurred during the operation of the task, or if the task has been cancelled, the <xref:System.Threading.Tasks.Task%601.Result%2A> property does not return a value.</span></span> <span data-ttu-id="c301f-536">대신 throw 값 속성에 액세스 하는 동안는 <xref:System.AggregateException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-536">Instead, attempting to access the property value throws an <xref:System.AggregateException> exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c301f-537">다음 예제는 이름이 명령줄 인수로 전달 되는 각 디렉터리에 있는 파일의 바이트 수를 계산 하는 명령줄 유틸리티입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-537">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="c301f-538">인스턴스화하는 람다 식을 실행 디렉터리에 파일이 있으면를 <xref:System.IO.FileStream> 디렉터리에 각 파일에 대 한 개체의 값을 검색 하 고 해당 <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-538">If the directory contains files, it executes a lambda expression that instantiates a <xref:System.IO.FileStream> object for each file in the directory and retrieves the value of its <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c301f-539">단순히 호출에서 디렉터리에 있는 파일이 없는 경우는 <xref:System.Threading.Tasks.Task.FromResult%2A> 작업을 만드는 방법입니다 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 영 (0).</span><span class="sxs-lookup"><span data-stu-id="c301f-539">If a directory contains no files, it simply calls the <xref:System.Threading.Tasks.Task.FromResult%2A> method to create a task whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is zero (0).</span></span> <span data-ttu-id="c301f-540">디렉터리의 모든 파일에 바이트의 총 수는에서 사용할 수 있는 작업을 마치면는 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-540">When the tasks finish, the total number of bytes in all a directory's files is available from the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c301f-541">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-541">The task was canceled.</span></span> <span data-ttu-id="c301f-542"><see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-542">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="c301f-543">또는</span><span class="sxs-lookup"><span data-stu-id="c301f-543">-or-</span></span> 
<span data-ttu-id="c301f-544">작업을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="c301f-544">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="c301f-545">예외나 예외에 대한 정보를 포함하는 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="c301f-545">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c301f-546">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="c301f-546">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c301f-547">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c301f-547">Task-based Asynchronous Programming</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md"><span data-ttu-id="c301f-548">방법: 작업에서 값 반환</span><span class="sxs-lookup"><span data-stu-id="c301f-548">How to: Return a Value from a Task</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>