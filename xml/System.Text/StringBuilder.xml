<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="be19bdb3283edd18f1fefcc8e73a6e60f1c1de24" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911222" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>변경할 수 있는 문자열을 나타냅니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스는 값을 변경할 수 있는 문자 시퀀스로 문자열 형식 개체를 나타냅니다.  
  
 섹션 내용  
  
-   [String 및 StringBuilder 형식](#StringAndSB)  
  
-   [StringBuilder의 작동 원리](#HowWorks)  
  
-   [메모리 할당](#Memory)  
  
-   [StringBuilder 개체 인스턴스화](#Instantiating)  
  
-   [StringBuilder 메서드 호출](#Calling)  
  
-   [StringBuilder 작업 수행](#Operations)  
  
    -   [StringBuilder 문자를 반복합니다.](#Iterating)  
  
    -   [StringBuilder 개체에 텍스트 추가](#Adding)  
  
    -   [StringBuilder 개체에서 텍스트를 삭제합니다.](#Deleting)  
  
    -   [StringBuilder 개체의 텍스트를 수정합니다.](#Modifying)  
  
-   [StringBuilder 개체에서 텍스트 검색](#Searching)  
  
-   [StringBuilder 개체를 문자열로 변환](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>String 및 StringBuilder 형식  
 하지만 <xref:System.Text.StringBuilder> 및 <xref:System.String> 둘 다 시퀀스를 나타내는 문자은 다르게 구현 됩니다. <xref:System.String> 변경할 수 없는 형식이입니다. 수정 하려면 표시 되는 각 작업 즉, 한 <xref:System.String> 개체는 실제로 새 문자열을 만듭니다.  
  
 예를 들어 호출 된 <xref:System.String.Concat%2A?displayProperty=nameWithType> 이라는 문자열 변수 값을 변경 하려면 다음 C# 예제에서 메서드가 나타납니다 `value`합니다. 실제로 <xref:System.String.Concat%2A> 메서드가 반환 되는 `value` 에서 주소 및 다른 값을 가진 개체를는 `value` 메서드에 전달 된 개체입니다. 이 예제에서는 해야 컴파일됩니다를 사용 하는 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 광범위 한 문자열 조작 (예: 여러 번 루프에서에서 문자열을 수정 하는 앱)를 수행 하는 루틴의 경우 문자열을 반복 해 서 수정 성능이 크게 저하를 정확한 수 있습니다. 사용 하는 대체 항목은 <xref:System.Text.StringBuilder>를 변경할 수 있는 문자열 클래스인 합니다. 클래스의 인스턴스를 만든 후이 변경할 수 있도록 추가, 제거, 교체, 또는 문자를 삽입 하 여 의미 하는 방법으로도 합니다. A <xref:System.Text.StringBuilder> 개체는 문자열에 확장을 수용 하기 위해 버퍼를 유지 합니다. 대화방 언어가 경우 버퍼에 새 데이터가 추가 됩니다. 그렇지 않으면 새, 더 큰 버퍼를 할당 하 고 원래 버퍼의 데이터를 새 버퍼에 복사 되 고 새 데이터 그런 다음 새 버퍼에 추가 됩니다.  
  
> [!IMPORTANT]
>  하지만 <xref:System.Text.StringBuilder> 클래스에는 일반적으로 보다 더 나은 성능을 제공는 <xref:System.String> 클래스 하지 자동으로 대체 해야 <xref:System.String> 와 <xref:System.Text.StringBuilder> 문자열을 조작 하 고 싶을 때마다 합니다. 성능에 대해 새 문자열, 응용 프로그램을 실행 하는 시스템 및 작업 유형을 할당할 메모리의 양 문자열의 크기에 따라 달라 집니다. 준비 확인 하 여 앱을 테스트 해야 하는지 여부를 <xref:System.Text.StringBuilder> 실제로 성능이 크게 향상을 제공 합니다.  
  
 사용 하는 것이 좋습니다는 <xref:System.String> 이러한 조건 클래스:  
  
-   때 앱 설정 됩니다. 문자열에 있는 변경 수는 적습니다. 이러한 경우 <xref:System.Text.StringBuilder> 수 제안을 무시할 수 또는 성능 향상을 통해 <xref:System.String>합니다.  
  
-   경우는 고정된 된 수의 문자열 리터럴과 함께 특히 연결 작업을 수행 합니다. 이 경우 컴파일러는 단일 작업으로 연결 작업을 결합할 수 있습니다.  
  
-   문자열을 빌드하는 동안 다양 한 검색 작업을 수행할 수 있을 때. <xref:System.Text.StringBuilder> 와 같은 클래스에 검색 방법 `IndexOf` 또는 `StartsWith`합니다. 변환 해야 합니다는 <xref:System.Text.StringBuilder> 개체는 <xref:System.String> 하 고이 이러한 작업을 사용 하 여 성능상의 이점이 부정할 수에 대 한 <xref:System.Text.StringBuilder>합니다. 자세한 내용은 참조는 [StringBuilder 개체에서 텍스트 검색](#Searching) 섹션.  
  
 사용 하는 것이 좋습니다는 <xref:System.Text.StringBuilder> 이러한 조건 클래스:  
  
-   예상 하는 응용 프로그램 (예: 사용자 입력을 포함 하는 문자열의 임의의 숫자를 연결 하는 루프를 사용 하는 경우) 디자인 타임에 문자열에 변경 내용 수 알된 수 있도록 합니다.  
  
-   문자열을 상당히 많이 변경 하 여 앱을 예상 하 합니다.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>StringBuilder의 작동 원리  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> 속성은 문자 수를 나타냅니다는 <xref:System.Text.StringBuilder> 개체에 현재 포함 되어 있습니다. 문자를 추가 하는 경우는 <xref:System.Text.StringBuilder> 개체의 크기를 같아질 때까지 해당 길이 증가 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> 개체가 포함 될 수 있는 문자 수를 정의 하는 속성입니다. 추가 된 문자 수가 인해의 길이 <xref:System.Text.StringBuilder> 의 값은 현재 용량, 새로운 메모리를 초과 하는 개체 할당는 <xref:System.Text.StringBuilder.Capacity%2A> 속성 두 배가 됩니다, 새 문자가 추가 되어는 <xref:System.Text.StringBuilder> 개체 및 해당 <xref:System.Text.StringBuilder.Length%2A>속성 조정 됩니다. 에 대 한 추가 메모리는 <xref:System.Text.StringBuilder> 개체에 정의 된 값에 도달할 때까지 동적으로 할당 되는 <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> 속성입니다. 에 대 한 없습니다 추가 메모리를 할당할 수는 최대 용량에 도달 하면는 <xref:System.Text.StringBuilder> 개체 및 문자를 추가 하거나 해당 최대 용량을 초과 확장 하려는 중 하나를 throw 한 <xref:System.ArgumentOutOfRangeException> 또는 <xref:System.OutOfMemoryException> 예외입니다.  
  
 다음 예제에서는 어떻게는 <xref:System.Text.StringBuilder> 개체는 새로운 메모리를 할당 하 고 개체에 할당 된 문자열 확장 될 때 해당 용량을 늘리십시오. 코드는 만듭니다는 <xref:System.Text.StringBuilder> 기본 (매개 변수가 없는) 생성자를 호출 하 여 개체입니다. 이 개체의 기본 용량 16 자 이며 최대 용량 십억을 2 개 이상의 문자입니다. 추가 된 문자열 "This is 문장." 기본 용량을 초과 하는 문자열 길이 (19 문자 수) 때문에 새 메모리 할당 효과가 <xref:System.Text.StringBuilder> 개체입니다. 개체의 용량을 두 배로 만듭니다 32 자로, 새 문자열 추가 되 고 개체의 길이 19 자과 같습니다. 코드는 다음 추가 하는 "This is 추가 문장." 값에는 <xref:System.Text.StringBuilder> 11 번 개체입니다. 때마다 추가 작업 하면의 길이 <xref:System.Text.StringBuilder> 용량, 기존 용량을 초과 하는 개체의 두 배가 됩니다 및 <xref:System.Text.StringBuilder.Append%2A> 작업이 성공 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>메모리 할당  
 기본 용량은 <xref:System.Text.StringBuilder> 개체가 16 자가 고 기본 최대 용량 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다. 이러한 기본 값이 호출 하는 경우 사용 되는 <xref:System.Text.StringBuilder.%23ctor> 및 <xref:System.Text.StringBuilder.%23ctor%28System.String%29> 생성자입니다.  
  
 초기 용량을 명시적으로 정의할 수 있습니다는 <xref:System.Text.StringBuilder> 다음과 같은 방법으로 개체:  
  
-   중 하나를 호출 하 여는 <xref:System.Text.StringBuilder> 생성자를 포함 하는 `capacity` 개체를 만들 때 매개 변수입니다.  
  
-   새 값을 명시적으로 할당 하 여는 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> 속성을 기존 확장 <xref:System.Text.StringBuilder> 개체입니다. 참고 새 용량 보다 크거나 용량 기존 보다 작은 경우 속성 예외를 throw 하는 <xref:System.Text.StringBuilder> 개체의 최대 용량입니다.  
  
-   호출 하 여는 <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> 메서드 새 용량을 사용 합니다. 새 용량 보다 클 수 없습니다는 <xref:System.Text.StringBuilder> 개체의 최대 용량입니다. 그러나에 할당 하는 달리는 <xref:System.Text.StringBuilder.Capacity%2A> 속성 <xref:System.Text.StringBuilder.EnsureCapacity%2A> 경우 예외를 throw 하지 않습니다 원하는 새 용량을 사용 하면 기존 용량 보다 적습니다;이 경우는 메서드는 영향을 주지 않습니다.  
  
 문자열의 길이에 할당 된 경우는 <xref:System.Text.StringBuilder> 개체 생성자 호출에 기본 용량 또는 지정된 된 용량을 초과 <xref:System.Text.StringBuilder.Capacity%2A> 속성으로 지정 된 문자열의 길이 `value` 매개 변수입니다.  
  
 최대 용량을 명시적으로 정의할 수 있습니다는 <xref:System.Text.StringBuilder> 호출 하 여 개체는 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자입니다. 최대 용량에 새 값을 할당 하 여 변경할 수 없습니다는 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성을 읽기 전용 이기 때문에 있습니다.  
  
 이전 섹션으로 쇼, 기존 용량이 부족 추가 메모리가 때마다 할당의 용량는 <xref:System.Text.StringBuilder> 개체에 정의 된 값 만큼 double 값은 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성입니다.  
  
 일반적으로 기본 용량 및 최대 용량은 대부분의 응용 프로그램에 적합 합니다. 다음과 같은 경우에 이러한 값을 설정 하는 것이 좋습니다.  
  
-   하는 경우의 최종 크기는 <xref:System.Text.StringBuilder> 개체는 일반적으로 몇 메가바이트 보다 더 큰 많지 증가 수 있습니다. 이 경우 있을 수 있습니다 초기 설정에서 몇 가지 성능상의 이점을 <xref:System.Text.StringBuilder.Capacity%2A> 속성 상당히 높은 값으로 너무 많은 메모리 재할당에 대 한 필요 하지 않도록 합니다.  
  
-   앱 제한 된 메모리를 사용 하는 시스템에서 실행 되는 합니다. 설정 하려는 경우는 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성을 보다 작은 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 앱 메모리 사용이 제한 된 환경에서 실행을 만들 수 있는 큰 문자열을 처리 하는 경우.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>StringBuilder 개체 인스턴스화  
 인스턴스화하는 <xref:System.Text.StringBuilder> 하나는 다음 표에 나열 된 6 개 오버 로드 된 클래스 생성자를 호출 하 여 개체입니다. 인스턴스화하는 생성자 중 3 개는 <xref:System.Text.StringBuilder> 해당 값이 빈 문자열을 설정 하지만 해당 <xref:System.Text.StringBuilder.Capacity%2A> 및 <xref:System.Text.StringBuilder.MaxCapacity%2A> 다르게 값입니다. 나머지 세 명의 생성자 정의 <xref:System.Text.StringBuilder> 특정 문자열 값 및 용량 개체입니다. 기본 최대 용량을 사용 하 여 세 명의 생성자의 두 <xref:System.Int32.MaxValue?displayProperty=nameWithType>, 세 번째 작업을 사용 하면 최대 용량을 설정할 수 있습니다.  
  
|생성자|문자열 값|용|최대 용량|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|으로 정의 되는 `capacity` 매개 변수|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|으로 정의 되는 `capacity` 매개 변수|으로 정의 되는 `maxCapacity` 매개 변수|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|으로 정의 되는 `value` 매개 변수|16 또는 `value`합니다. <xref:System.String.Length%2A>는 값 중 큰|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|으로 정의 되는 `value` 매개 변수|으로 정의 되는 `capacity` 매개 변수 또는 `value`합니다. <xref:System.String.Length%2A>는 값 중 큰 합니다.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|정의 방법 `value`합니다. <xref:System.String.Substring%2A>(`startIndex`, `length`)|으로 정의 되는 `capacity` 매개 변수 또는 `value`합니다. <xref:System.String.Length%2A>는 값 중 큰 합니다.|으로 정의 되는 `maxCapacity` 매개 변수|  
  
 다음 예제에서는 이러한 생성자 오버 로드 중 3 개를 사용 하 여 인스턴스화할 수 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>StringBuilder 메서드 호출  
 대부분의 문자열을 수정 하는 메서드의 <xref:System.Text.StringBuilder> 인스턴스 동일한 해당 인스턴스에 대 한 참조를 반환 합니다. 이렇게 하면 호출할 <xref:System.Text.StringBuilder> 두 가지 방법으로 메서드:  
  
-   개별 메서드를 호출 하 고 다음 예제에서는 마찬가지로 반환 값을 무시 수 있습니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   단일 문에서 일련의 메서드 호출을 만들 수 있습니다. 연속 작업을 연결 하는 단일 문을 작성 하려는 경우 편리할 수 있습니다. 다음 예제에서는 한 줄의 코드를 이전 예제에서 세 개의 메서드 호출을 통합합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>StringBuilder 작업 수행  
 메서드를 사용할 수는 <xref:System.Text.StringBuilder> 를 반복, 추가, 삭제 또는 수정에 문자 클래스는 <xref:System.Text.StringBuilder> 개체입니다.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>StringBuilder 문자를 반복합니다.  
 에 있는 문자에 액세스할 수 있습니다는 <xref:System.Text.StringBuilder> 사용 하 여 개체는 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 속성입니다. C#에서는 <xref:System.Text.StringBuilder.Chars%2A> 은 인덱서; Visual basic에서은의 기본 속성은 <xref:System.Text.StringBuilder> 클래스입니다. 이렇게 하면 설정 하거나 명시적으로 참조 하지 않고만 인덱스를 사용 하 여 개별 문자를 검색 하는 <xref:System.Text.StringBuilder.Chars%2A> 속성입니다. 에 문자를 입력 한 <xref:System.Text.StringBuilder> 개체의 인덱스 0 (영)부터 시작 하 고 인덱싱할 계속 <xref:System.Text.StringBuilder.Length%2A> -1입니다.  
  
 다음 예제는 <xref:System.Text.StringBuilder.Chars%2A> 속성입니다. 에 10 개의 난수가 추가 <xref:System.Text.StringBuilder> 개체, 한 다음 각 문자를 반복 합니다. 문자의 유니코드 범주 이면 <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, 수 1 씩 감소 (또는 해당 값이 0이 9로 수 변경). 내용을 표시 하는 예제는 <xref:System.Text.StringBuilder> 전과 후의 개별 문자 값이 변경 되었는지 모두 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>StringBuilder 개체에 텍스트 추가  
 <xref:System.Text.StringBuilder> 의 내용을 확장을 위한 다음 메서드를 포함 하는 클래스는 <xref:System.Text.StringBuilder> 개체:  
  
-   <xref:System.Text.StringBuilder.Append%2A> 메서드는 추가 문자열, 부분 문자열, 문자 배열, 문자 배열의 일부 단일 문자를 여러 번 반복 하거나 기본 데이터의 문자열 표현의 형식을로 <xref:System.Text.StringBuilder> 개체입니다.  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A> 메서드를 줄 종결자와 함께 문자열 또는 줄 종결자를 차례로 추가 <xref:System.Text.StringBuilder> 개체입니다.  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드 추가 하 한 <xref:System.Text.StringBuilder> 개체입니다. 결과 문자열에 포함 된 개체의 문자열 표현에는 현재 시스템 문화권 또는 지정 된 문화권의 서식 지정 규칙 반영할 수 있습니다.  
  
-   <xref:System.Text.StringBuilder.Insert%2A> 메서드 삽입 여러 반복 되는 문자열, 문자열, 부분 문자열의 지정된 된 위치에는 문자 배열, 문자 배열의 일부 또는 기본 데이터의 문자열 표현을 입력는 <xref:System.Text.StringBuilder> 개체입니다. 위치는 0부터 시작 인덱스에 의해 정의 됩니다.  
  
 다음 예제에서는 <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, 및 <xref:System.Text.StringBuilder.Insert%2A> 의 텍스트를 확장 하는 메서드는 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>StringBuilder 개체에서 텍스트를 삭제합니다.  
 <xref:System.Text.StringBuilder> 클래스의 현재 크기를 줄일 수 있는 메서드를 포함 <xref:System.Text.StringBuilder> 인스턴스. <xref:System.Text.StringBuilder.Clear%2A> 메서드는 모든 문자를 제거 하 고 설정의 <xref:System.Text.StringBuilder.Length%2A> 속성을 0으로 합니다. <xref:System.Text.StringBuilder.Remove%2A> 메서드는 지정된 된 특정 인덱스 위치에서 시작 하는 문자 수가 삭제 합니다. 또한의 끝에서 문자를 제거할 수 있습니다는 <xref:System.Text.StringBuilder> 개체를 설정 하 여 해당 <xref:System.Text.StringBuilder.Length%2A> 속성을 현재 인스턴스의 길이 보다 작은 값입니다.  
  
 텍스트의 일부를 제거 하는 다음 예제는 <xref:System.Text.StringBuilder> 개체를 결과 용량, 최대 용량 및 길이 속성 값을 표시 한 다음 호출에서 <xref:System.Text.StringBuilder.Clear%2A> 에서 모든 문자를 제거 하는 메서드는 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>StringBuilder 개체의 텍스트를 수정합니다.  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> 메서드는 문자 또는 전체에 있는 문자열의 모든 항목을 바꿉니다 <xref:System.Text.StringBuilder> 개체 또는 특정 문자 범위입니다. 다음 예제에서는 <xref:System.Text.StringBuilder.Replace%2A> 물음표 (?)와 모든 느낌표 (!)에서 바꾸려면 메서드는 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>StringBuilder 개체에서 텍스트 검색  
 <xref:System.Text.StringBuilder> 클래스는 비슷한 메서드를 포함 하지는 <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 및 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 에서 제공 하는 메서드는 <xref:System.String> 클래스는 특정 문자 또는 부분 문자열에 대 한 개체를 검색할 수 있습니다. 존재 여부를 결정 하거나 부분 문자열의 문자 위치를 시작 하려면 검색 하는 한 <xref:System.String> 문자열 검색 방법 또는 정규식 메서드 중 하나를 사용 하 여 값입니다. 다음 표에서 같이 이러한 검색을 구현 하는 방법은 네 가지입니다.  
  
|기술|전문가|단점|  
|---------------|----------|----------|  
|에 추가 하기 전에 문자열 값에서 검색 된 <xref:System.Text.StringBuilder> 개체입니다.|부분 문자열의 존재 여부를 확인 하는 데 유용 합니다.|부분 문자열의 인덱스 위치는 중요 한 경우에 사용할 수 없습니다.|  
|호출 <xref:System.Text.StringBuilder.ToString%2A> 반환 된 검색 <xref:System.String> 개체입니다.|사용 하기 쉬운 텍스트를 할당 하는 경우는 <xref:System.Text.StringBuilder> 개체를 수정 하기 시작 합니다.|반복적으로 호출 하는 경우 다루기 <xref:System.Text.StringBuilder.ToString%2A> 모든 텍스트에 추가 되기 전에 수정 작업을 확인 해야 하는 경우는 <xref:System.Text.StringBuilder> 개체입니다.<br /><br /> 끝에서 작동 하도록 주의 해야 합니다는 <xref:System.Text.StringBuilder> 변경 하는 경우 개체의 텍스트입니다.|  
|사용 하 여는 <xref:System.Text.StringBuilder.Chars%2A> 속성을 순차적으로 문자 범위를 검색 합니다.|개별 문자 또는 작은 부분 문자열을 염려 하는 경우에 유용 합니다.|검색할 문자 수가 큰 경우 또는 검색 논리가 복잡 한 경우 복잡 합니다.<br /><br />반복된 메서드 호출을 통해 매우 큰 증가 하는 개체에 대 한 성능이 매우 저하 결과입니다.  |  
|변환에서 <xref:System.Text.StringBuilder> 개체를 한 <xref:System.String> 개체를에 수정 작업을 수행는 <xref:System.String> 개체입니다.|수정 횟수가 작을 경우에 유용 합니다.|성능 이점은 부정는 <xref:System.Text.StringBuilder> 수정 횟수가 크면 클래스입니다.|  
  
 이러한 기술을 더 자세히 살펴보겠습니다.  
  
-   검색의 목표에 저장 하기 전에 문자열을 검색할 수 문자열이 특정 부분 (즉, 필요가 없는 경우에 부분 문자열의 위치)가 있는지 확인 하는 경우는 <xref:System.Text.StringBuilder> 개체입니다. 다음 예에서는 가능한 한 구현을 제공합니다. 정의 `StringBuilderFinder` 클래스의 생성자에 대 한 참조를 전달 되는 <xref:System.Text.StringBuilder> 개체와 문자열에서 찾을 하위 문자열입니다. 이 예제에서는 기록 된 온도가 화씨 또는 섭씨로, 및에서 적절 한 소개 텍스트의 시작 부분에 추가 하는지 여부를 확인을 시도 하는 경우는 <xref:System.Text.StringBuilder> 개체입니다. 난수 생성기 섭씨 또는 화씨에서 데이터를 포함 하는 배열을 선택 하는 데 사용 됩니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   호출의 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 변환 하는 메서드는 <xref:System.Text.StringBuilder> 개체를 한 <xref:System.String> 개체입니다. 와 같은 메서드를 사용 하 여 문자열을 검색할 수 있습니다 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 또는 <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, 또는 정규식을 사용할 수 있습니다 및 <xref:System.Text.RegularExpressions.Regex> 패턴을 검색 하는 클래스입니다. 때문에 둘 다 <xref:System.Text.StringBuilder> 및 <xref:System.String> 문자, 부분 문자열의 인덱스 위치에 문자를 저장 하기 위해 인코딩을 u t F-16을 사용 하 여 개체 및 정규식 일치 항목은 두 개체 모두에서 동일 합니다. 이렇게 하면 사용 하도록 <xref:System.Text.StringBuilder> 해당 텍스트에서 찾을 수 같은 위치에서 변경 하는 메서드는 <xref:System.String> 개체입니다.  
  
    > [!NOTE]
    >  끝에서 작동 해야이 방식을 채택 하는 경우는 <xref:System.Text.StringBuilder> 를 반복적으로 변환 하는 것이 않아도 해당 시작 하는 개체는 <xref:System.Text.StringBuilder> 개체를 문자열로 합니다.  
  
     다음 예제에서 이 방법을 보여 줍니다. 4 개에 영어 알파벳의 각 문자를 저장 한 <xref:System.Text.StringBuilder> 개체입니다. 텍스트를 다음 변환 된 <xref:System.String> 개체 및 정규식을 사용 하 여 각 4 자리 시퀀스의 시작 위치를 식별 합니다. 마지막으로, 첫 번째 시퀀스를 제외 하 고 각 4 자리 시퀀스 앞에 밑줄을 추가 하 고 대문자로 시퀀스의 첫 번째 문자를 변환 합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   사용 하 여는 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 속성에 있는 문자의 범위를 순차적으로 검색을 <xref:System.Text.StringBuilder> 개체입니다. 검색할 문자 수가 또는 검색 논리는 특히 복잡 한 경우이 방법은 실용적 아닐 수 있습니다. 문자-인덱스 기반 액세스에 대 한 성능에 미치는 영향에 대 한 매우 큰, chunked <xref:System.Text.StringBuilder> 개체에 대 한 설명서를 참조 하십시오.는 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 속성입니다. 
  
     다음 예제는 앞의 예와 기능이 동일 하지만에 구현 방식이 달라 합니다. 사용 하 여는 <xref:System.Text.StringBuilder.Chars%2A> 문자 값이 변경 되는 시기를 감지 하는 속성 해당 위치에 밑줄을 삽입 하 고 새 시퀀스의 첫 번째 문자를 대문자로 변환 합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   수정 되지 않은 모든 텍스트에 저장할는 <xref:System.Text.StringBuilder> 개체를 호출 하는 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 변환 하는 메서드는 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 개체를에 수정 작업을 수행는 <xref:System.String> 개체입니다. 약간만 수정; 있는 경우이 방법을 사용할 수 있습니다. 그렇지 않으면 변경할 수 없는 문자열 작업의 비용 사용의 성능 이점을 부정할 수 있습니다는 <xref:System.Text.StringBuilder> 개체입니다.  
  
     다음 예제에서는 앞의 두 예제 기능이 동일 하지만에 구현 방식이 달라 합니다. 만듭니다는 <xref:System.Text.StringBuilder> 개체,으로 변환 하는 <xref:System.String> 개체를 다음 정규식을 사용 하 여 문자열에서 모든 나머지 수정 작업을 수행 합니다. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> 메서드 각 일치 항목에 교체를 수행 하는 람다 식을 사용 합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>StringBuilder 개체를 문자열로 변환  
 <xref:System.Text.StringBuilder> 개체에 표시되는 문자열을 <xref:System.String> 매개 변수를 가진 메서드에 전달하거나 사용자 인터페이스에 표시하려면 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 개체로 변환해야 합니다. 이 변환을 호출 하 여 수행 된 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 메서드. 예시의 경우 호출 하는 이전 예제를 참조 하십시오.는 <xref:System.Text.StringBuilder.ToString%2A> 변환 하는 메서드는 <xref:System.Text.StringBuilder> 문자열로 개체 정규식 메서드에 전달할 수 있도록 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 정의한 메서드를 호출 하는 방법을 보여 줍니다는 <xref:System.Text.StringBuilder> 클래스입니다.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 인스턴스의 문자열 값으로 설정 되 <xref:System.String.Empty?displayProperty=nameWithType>, 용량 구현의 기본 용량으로 설정 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 <xref:System.Text.StringBuilder.%23ctor%2A> 매개 변수가 없는 생성자입니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">이 인스턴스의 제안된 시작 크기입니다.</param>
        <summary>지정된 용량을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 에 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값의 <xref:System.Text.StringBuilder> 개체 하 고 저장할 추가 메모리를 할당 합니다.  
  
 이 인스턴스의 문자열 값으로 설정 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 경우 `capacity` 가 0 이면 구현의 기본 용량을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법을 <xref:System.Text.StringBuilder.%23ctor%2A> 생성자 지정한 용량을 사용 합니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">인스턴스 값을 초기화하는 데 사용되는 문자열입니다. <c>값</c>이 <see langword="null" />이면 새 <see cref="T:System.Text.StringBuilder" />에 빈 문자열(<see cref="F:System.String.Empty" />)이 포함됩니다.</param>
        <summary>지정된 문자열을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`가 `null`이면 새 <xref:System.Text.StringBuilder>에 빈 문자열(<xref:System.String.Empty>)이 포함됩니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법을 <xref:System.Text.StringBuilder.%23ctor%2A> 생성자 문자열을 사용 합니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" />의 제안된 시작 크기입니다.</param>
        <param name="maxCapacity">현재 문자열에 포함할 수 있는 최대 문자 수입니다.</param>
        <summary>지정된 용량으로 시작되어 지정된 최대 용량까지 커질 수 있는 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 에 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값의 <xref:System.Text.StringBuilder> 개체 하 고 저장할 추가 메모리를 할당 합니다.  
  
 경우 `capacity` 가 0 이면 구현의 기본 용량을 사용 합니다.  
  
 `maxCapacity` 속성의 현재 인스턴스에 저장할 수 있는 문자 최대 수를 정의 합니다. 에 해당 값이 할당 된 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `maxCapacity` 값의 <xref:System.Text.StringBuilder> 개체가 추가 메모리를 할당 하지는 않지만 대신 예외를 throw 합니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법을 <xref:System.Text.StringBuilder.%23ctor%2A> 지정 된 용량 및 최대 용량 포함 된 생성자입니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" />가 1보다 작거나 <paramref name="capacity" />가 0보다 작거나 <paramref name="capacity" />가 <paramref name="maxCapacity" />보다 큰 경우</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">인스턴스 값을 초기화하는 데 사용되는 문자열입니다. <c>값</c>이 <see langword="null" />이면 새 <see cref="T:System.Text.StringBuilder" />에 빈 문자열(<see cref="F:System.String.Empty" />)이 포함됩니다.</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" />의 제안된 시작 크기입니다.</param>
        <summary>지정된 문자열과 용량을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 에 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값의 <xref:System.Text.StringBuilder> 개체 하 고 저장할 추가 메모리를 할당 합니다.  
  
 경우 `capacity` 가 0 이면 구현의 기본 용량을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법을 <xref:System.Text.StringBuilder.%23ctor%2A> 생성자는 초기 문자열 및 지정 된 용량을 사용 합니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스 값을 초기화하는 데 사용된 부분 문자열이 포함된 문자열입니다. <c>값</c>이 <see langword="null" />이면 새 <see cref="T:System.Text.StringBuilder" />에 빈 문자열(<see cref="F:System.String.Empty" />)이 포함됩니다.</param>
        <param name="startIndex">부분 문자열이 시작되는 <c>값</c> 내의 위치입니다.</param>
        <param name="length">부분 문자열에 있는 문자의 수입니다.</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" />의 제안된 시작 크기입니다.</param>
        <summary>지정된 부분 문자열과 용량을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 에 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값의 <xref:System.Text.StringBuilder> 개체 하 고 저장할 추가 메모리를 할당 합니다.  
  
 경우 `capacity` 가 0 이면 구현의 기본 용량을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법을 <xref:System.Text.StringBuilder.%23ctor%2A> 생성자 문자열을 사용 합니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="startIndex" />와 <paramref name="length" />의 합이 <paramref name="value" /> 내에 위치하지 않는 경우</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">추가할 Boolean 값입니다.</param>
        <summary>지정된 부울 값의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> 메서드 호출의 <xref:System.Boolean.ToString?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value`합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 8비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> 메서드 호출의 <xref:System.Byte.ToString%28System.IFormatProvider%29> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">추가할 UTF-16 인코딩된 코드 단위입니다.</param>
        <summary>지정된 <see cref="T:System.Char" /> 개체의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자 배열입니다.</param>
        <summary>지정된 배열의 유니코드 문자에 대한 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 지정 된 배열에 있는 모든 문자가 현재 인스턴스에 추가 같은 순서로 표시 된 대로 `value`합니다. 경우 `value` 은 `null`, 변경 되지 않습니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 10진수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> 메서드 호출의 <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 배정밀도 부동 소수점 숫자의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> 메서드 호출의 <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 16비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> 메서드 호출의 <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 32비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> 메서드 호출의 <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 64비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> 메서드 호출의 <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">추가할 개체입니다.</param>
        <summary>지정된 개체의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다. 정의 `Dog` 클래스, 만들어집니다는 `Dog` 개체와 세 번 호출 하는 <xref:System.Text.StringBuilder.Append%2A> dog의 이름 및 종류를 포함 하는 문자열을 만드는 메서드를 합니다.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> 메서드 호출의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value`합니다. 경우 `value` 은 `null`에 변경 되지 않습니다는 <xref:System.Text.StringBuilder> 개체입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 8비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> 메서드 호출의 <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 단정밀도 부동 소수점 숫자의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> 메서드 호출의 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자열입니다.</param>
        <summary>지정된 문자열의 복사본을 이 인스턴스의 끝에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 경우 `value` 은 `null`, 변경 되지 않습니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 16비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> 메서드 호출의 <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value`합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 32비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> 호출은 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 64비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> 메서드 호출의 <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 메서드를 `value` 현재 문화권에 대 한 합니다. 형식을 제어 하기 위해 `value`, 호출 된 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자입니다.</param>
        <param name="repeatCount">
          <c>값</c>을 추가할 횟수입니다.</param>
        <summary>유니코드 문자에 대한 문자열 표현의 지정된 복사본 수를 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" />가 0보다 작은 경우  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">문자의 배열에 대한 포인터입니다.</param>
        <param name="valueCount">배열에 있는 문자의 수입니다.</param>
        <summary>지정된 주소에서 시작하는 유니코드 문자의 배열을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 추가 `valueCount` 주소에서 시작 하는 문자 `value` 현재 인스턴스를 합니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 개체입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" />가 0보다 작은 경우  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" />이(가) null 포인터입니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">문자 배열입니다.</param>
        <param name="startIndex">
          <c>값</c>의 시작 위치입니다.</param>
        <param name="charCount">추가할 문자 수입니다.</param>
        <summary>유니코드 문자의 지정된 하위 배열에 대한 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지정 된 범위에 있는 문자의 추가 `value` 현재 인스턴스에 있습니다. 경우 `value` 은 `null` 및 `startIndex` 및 `count` 둘 다 0, 아니요 변경 내용이 있습니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />이고 <paramref name="startIndex" /> 및 <paramref name="charCount" />는 0이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="startIndex" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="startIndex" /> + <paramref name="charCount" />이 <paramref name="value" />의 길이보다 큽니다.  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 부분 문자열이 포함된 문자열입니다.</param>
        <param name="startIndex">
          <c>값</c> 내에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="count">
          <c>값</c>에서 추가할 문자 수입니다.</param>
        <summary>지정된 부분 문자열의 복사본을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지정 된 범위에 있는 문자의 추가 `value` 현재 인스턴스에 있습니다. 경우 `value` 은 `null` 및 `startIndex` 및 `count` 둘 다 0, 아니요 변경 내용이 있습니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정를 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해를 호출할 수는 메서드 또는 속성에 대 한 기존 참조 있으며 반환 값을 할당할 필요가 없습니다는 <xref:System.Text.StringBuilder> 다음 예제와 같이 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />이고 <paramref name="startIndex" /> 및 <paramref name="count" />는 0이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="startIndex" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="startIndex" /> + <paramref name="count" />이 <paramref name="value" />의 길이보다 큽니다.  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목이 단일 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns>
          <paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목이 <paramref name="arg0" />의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 텍스트 표현으로 개체의 값을 변환 하 고 현재에서 표현을 포함 하는.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를 서식 항목 이라고 합니다. 형식 항목의 인덱스 0에 해당 하도록 해야 합니다. `arg0`를이 메서드의 매개 변수 목록에서 단일 개체입니다. 포맷 프로세스는 각 형식 항목의 문자열 표현으로 대체 `arg0`합니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `arg0` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 문자열 표현으로 바뀝니다 `arg0`합니다. 서식 항목이 포함 된 경우 `formatString` 및 `arg0` 구현 하는 <xref:System.IFormattable> 인터페이스 다음 `arg0.ToString(formatString, null)` 서식을 정의 합니다. 그렇지 않으면 `arg0.ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 은 "에 기부 해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 는 정수 값 10 이면 반환 값은 "10 식량 캔을 저희 자선 기구에 기부에 대 한 감사 합니다." 됩니다  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스는 0(영)보다 작고, 또는 1보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="args">형식을 지정할 개체의 배열입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 형식 항목은 매개 변수 배열에 있는 해당 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns>
          <paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 텍스트 표현으로 개체의 값을 변환 하 고 현재에서 표현을 포함 하는.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를이 메서드의 매개 변수 목록에 있는 개체에 해당 하는 서식 항목 이라고 합니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `args` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 에 해당 개체의 문자열 표현으로 바뀝니다 `args`합니다. 서식 항목이 포함 된 경우 `formatString` 에 있는 해당 개체 및 `args` 구현 하는 <xref:System.IFormattable> 인터페이스, 다음 `args[index].ToString(formatString, provider)` 서식을 정의 합니다. 그렇지 않으면 `args[index].ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 은 "에 기부 해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 는 정수 값 10 이면 반환 값은 "10 식량 캔을 저희 자선 기구에 기부에 대 한 감사 합니다." 됩니다  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">형식을 지정할 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 지정된 형식 공급자를 사용하여 각 서식 항목이 단일 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 <paramref name="format" />의 문자열 표현으로 바뀐  <paramref name="arg0" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 의 값으로 변환 하는.NET Framework의 `arg0` 텍스트 표현으로 현재에서 표현을 포함 하 고 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를 서식 항목 이라고 합니다. 이 메서드에 단일 인수를 가진 인수 목록이 포함 되어 있습니다. 각 형식 항목의 인덱스 (0) 여야 합니다. 포맷 프로세스는 각 형식 항목의 문자열 표현으로 대체 `arg0`합니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 이 경우 이후에 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 메서드 인수 목록의 값을 단일 인수가 있습니다. *인덱스* 항상 0 이어야 합니다. 그렇지 않을 경우는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `provider` 매개 변수는 지정 된 <xref:System.IFormatProvider> 개체에 대 한 서식 지정 정보를 제공할 수 있는 구현 `args`합니다. `provider`는 다음과 같을 수 있습니다.  
  
-   A <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 경우 숫자 값입니다.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 경우 날짜 및 시간 값입니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공 하는 `arg0`합니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다.  
  
 경우는 `provider` 매개 변수는 `null`서식 지정, 현재 문화권에서 정보를 가져옵니다.  
  
 `arg0` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 문자열 표현으로 바뀝니다 `arg0`합니다. 서식 항목이 포함 된 경우 `formatString` 및 `arg0` 구현 하는 <xref:System.IFormattable> 인터페이스 다음 `arg0.ToString(formatString, provider)` 서식을 정의 합니다. 그렇지 않으면 `arg0.ToString()` 서식을 정의 합니다.  
  
   
  
## Examples  
 다음 두 호출이 포함 된는 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 메서드. 모두 영어 Great Britain (EN-GB) 문화권의 형식 규칙을 사용합니다. 문자열 표현을 삽입 하는 첫 번째는 <xref:System.Decimal> 결과 문자열에 통화 값입니다. 두 번째 삽입 한 <xref:System.DateTime> 결과의 두 위치에 값 문자열에 첫 번째만 포함 하는 짧은 날짜 문자열 및 두 번째 짧은 시간 문자열입니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스가 0보다 작거나, 1보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="args">형식을 지정할 개체의 배열입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목은 지정된 서식 공급자를 사용하여 매개 변수 배열에 있는 해당 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 해당하는 개체 인수의 문자열 표현으로 바뀐 <paramref name="format" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 텍스트 표현으로 개체의 값을 변환 하 고 현재에서 표현을 포함 하는.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를이 메서드의 매개 변수 목록에 있는 개체에 해당 하는 서식 항목 이라고 합니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `provider` 매개 변수는 지정 된 <xref:System.IFormatProvider> 개체에 대 한 서식 지정 정보를 제공할 수 있는 구현 `args`합니다. `provider`는 다음과 같을 수 있습니다.  
  
-   A <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 숫자 값에 대 한 문화권별 서식 지정 정보를 제공 하는 개체 `args`합니다.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 의 날짜 및 시간 값에 대 한 문화권별 서식 지정 정보를 제공 하는 개체 `args`합니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 하나 이상의 개체에 대 한 서식 지정 정보를 제공 하는 구현 `args`합니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다. 다음 섹션에서 두 번째 예는 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 를 사용자 지정 메서드 호출 <xref:System.IFormatProvider> 구현 합니다.  
  
 경우는 `provider` 매개 변수는 `null`, 현재 문화권에서 형식 공급자 정보를 가져옵니다.  
  
 `args` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 에 해당 개체의 문자열 표현으로 바뀝니다 `args`합니다. 서식 항목이 포함 된 경우 `formatString` 에 있는 해당 개체 및 `args` 구현 하는 <xref:System.IFormattable> 인터페이스, 다음 `args[index].ToString(formatString, provider)` 서식을 정의 합니다. 그렇지 않으면 `args[index].ToString()` 서식을 정의 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 다음 예제에서는 사용자 지정을 정의 <xref:System.IFormatProvider> 라는 구현 `CustomerFormatter` 네 번째와 일곱 번째 자릿수 이후 10 자리 고객 하이픈으로 번호 형식입니다. 에 전달 되는 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 메서드 서식이 지정 된 고객 번호 및 고객 이름을 포함 하는 문자열을 만듭니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목이 두 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns>
          <paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 텍스트 표현으로 개체의 값을 변환 하 고 현재에서 표현을 포함 하는.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로 0 개 이상의 인덱싱된 자리 표시자와, 해당 하는 서식 항목 이라고 `arg0` 및 `arg1`를이 메서드의 매개 변수 목록에서 두 개체입니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `arg0` 및 `arg1` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 중 하나의 문자열 표현으로 바뀝니다 `arg0` 또는 `arg1`합니다. 서식 항목이 포함 된 경우 `formatString` 해당 개체가 구현 하 고는 <xref:System.IFormattable> 인터페이스 다음 `arg` *x* `.ToString(formatString, provider)` 서식, 여기서 정의 *x* 인수의 인덱스가입니다. 그렇지 않으면 `arg` *x* `.ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 은 "에 기부 해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 는 정수 값 10 이면 반환 값은 "10 식량 캔을 저희 자선 기구에 기부에 대 한 감사 합니다." 됩니다  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스가 0보다 작거나 2보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 지정된 형식 공급자를 사용하여 각 형식 항목이 두 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 해당하는 개체 인수의 문자열 표현으로 바뀐 <paramref name="format" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 텍스트 표현으로 개체의 값을 변환 하 고 현재에서 표현을 포함 하는.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를이 메서드의 매개 변수 목록에 있는 개체에 해당 하는 서식 항목 이라고 합니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `provider` 매개 변수는 지정 된 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공할 수 있는 `arg0` 및 `arg1`합니다. `provider`는 다음과 같을 수 있습니다.  
  
-   A <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 또는 `arg1` 경우 숫자 값입니다.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 또는 `arg1` 경우 날짜 및 시간 값입니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공 하는 `arg0` 및 `arg1`합니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다.  
  
 경우는 `provider` 매개 변수는 `null`, 현재 문화권에서 형식 공급자 정보를 가져옵니다.  
  
 `arg0` 및 `arg1` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 해당 인덱스를 가진 개체의 문자열 표현으로 바뀝니다. 서식 항목이 포함 된 경우 `formatString` 및 해당 인수를 구현 하는 <xref:System.IFormattable> 인터페이스를 다음 인수 `ToString(formatString, provider)` 메서드 서식을 정의 합니다. 그렇지 않으면 인수의 `ToString()` 메서드 서식을 정의 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> 제네릭에 저장 된 시간 및 온도 데이터를 표시 하는 메서드 <xref:System.Collections.Generic.Dictionary%602> 개체입니다. 형식 문자열의 서식을 지정 하려면 개체에만 있지만 세 개의 형식 항목에 있는지 확인 합니다. 가 두 형식 (날짜 및 시간 값) 목록에서 첫 번째 개체를 사용 하기 때문에 이것이: 첫 번째 형식 항목 표시 되는 경우 시간 및 두 번째 날짜를 표시 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스가 0보다 작거나 2보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목이 세 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns>
          <paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 텍스트 표현으로 개체의 값을 변환 하 고 현재에서 표현을 포함 하는.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로 0 개 이상의 인덱싱된 자리 표시자와, 해당 하는 서식 항목 이라고 `arg0` 통해 `arg2`를이 메서드의 매개 변수 목록에 있는 개체입니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `arg0``arg1`, 및 `arg2` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 중 하나의 문자열 표현으로 바뀝니다 `arg0`, `arg1`, 또는 `arg2`서식 항목의 인덱스에 따라 합니다. 형식 항목을 포함 하는 경우 `formatString` 에 있는 해당 개체 및 `args` 구현 하는 <xref:System.IFormattable> 인터페이스 다음 `arg` *x* `.ToString(formatString, null)` 서식, 여기서 정의 * x* 인수의 인덱스입니다. 그렇지 않으면 `arg` *x* `.ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 은 "에 기부 해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 는 정수 값 10 이면 반환 값은 "10 식량 캔을 저희 자선 기구에 기부에 대 한 감사 합니다." 됩니다  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스가 0보다 작거나, 3보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 지정된 형식 공급자를 사용하여 각 형식 항목이 세 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 해당하는 개체 인수의 문자열 표현으로 바뀐 <paramref name="format" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 텍스트 표현으로 개체의 값을 변환 하 고 현재에서 표현을 포함 하는.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 0 매개 변수 구성 되거나 더 많은 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를이 메서드의 매개 변수 목록에 있는 개체에 해당 하는 서식 항목 이라고 합니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 매개 변수 목록에서 0부터 시작 위치입니다. 지정 하는 개체가 경우 *인덱스* 은 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수는 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽 맞춤; 음수 이면 왼쪽 맞춤 됩니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 형식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `provider` 매개 변수는 지정 된 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공할 수 있는 `arg0` 및 `arg1`합니다. `provider`는 다음과 같을 수 있습니다.  
  
-   A <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 또는 `arg1` 경우 숫자 값입니다.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0`, `arg1`, 또는 `arg2` 경우 날짜 및 시간 값입니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공 하는 `arg0`, `arg1`, 및 `arg2`합니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다.  
  
 경우는 `provider` 매개 변수는 `null`, 현재 문화권에서 형식 공급자 정보를 가져옵니다.  
  
 `arg0``arg1`, 및 `arg2` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 해당 인덱스를 가진 개체의 문자열 표현으로 바뀝니다. 서식 항목이 포함 된 경우 `formatString` 및 해당 인수를 구현 하는 <xref:System.IFormattable> 인터페이스를 다음 인수 `ToString(formatString, provider)` 메서드 서식을 정의 합니다. 그렇지 않으면 인수의 `ToString()` 메서드 서식을 정의 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 부울 결과 설명 하기 위해 메서드 `And` 정수 값으로 작업 합니다. 각 항목의 형식이 두 가지 방법으로 하기 때문에 형식 문자열에 6 개의 형식 항목을 포함 하지만 해당 인수 목록에 메서드가 세 개의 항목이 note 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
 또는  
  
 형식 항목의 인덱스가 0보다 작거나 3보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 끝에 기본 줄 종결자 또는 지정한 문자열의 복사본과 기본 줄 종결자를 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 개체의 끝에 기본 줄 종결자를 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 줄 종결자는의 현재 값은 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 속성입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendLine%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자열입니다.</param>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 개체의 끝에 지정한 문자열의 복사본과 기본 줄 종결자를 차례로 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 줄 종결자는의 현재 값은 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 속성입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체는 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이의 용량은 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 및 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 메서드.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 인스턴스에 의해 할당된 메모리에 포함할 수 있는 최대 문자 수를 가져오거나 설정합니다.</summary>
        <value>현재 인스턴스에 의해 할당된 메모리에 포함할 수 있는 최대 문자 수입니다. 값 범위는 <see cref="P:System.Text.StringBuilder.Length" />에서 <see cref="P:System.Text.StringBuilder.MaxCapacity" />까지일 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> 현재 인스턴스의 문자열 값에 영향을 주지 않습니다. <xref:System.Text.StringBuilder.Capacity%2A> 없으면으로 축소 보다 작은 <xref:System.Text.StringBuilder.Length%2A>합니다.  
  
 <xref:System.Text.StringBuilder> 동적으로 필요할 때 더 많은 공간을 할당 하 고 증가 <xref:System.Text.StringBuilder.Capacity%2A> 적절 하 게 합니다. 성능상의 이유로 한 <xref:System.Text.StringBuilder> 필요한 보다 더 많은 메모리를 할당할 수 있습니다. 할당 된 메모리 크기는 구현 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Set 작업에 지정된 값이 이 인스턴스의 현재 길이보다 작습니다.  
  
 또는  
  
 Set 작업에 지정된 값이 최대 용량보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">문자의 위치입니다.</param>
        <summary>이 인스턴트에서 특정 위치에 있는 문자를 가져오거나 설정합니다.</summary>
        <value>
          <paramref name="index" /> 위치에 있는 유니코드 문자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` 매개 변수는 내에서 문자 위치에서 <xref:System.Text.StringBuilder>합니다. 문자열의 첫 번째 문자 인덱스 0입니다. 문자열의 길이가 포함 된 문자의 수입니다. 액세스 가능한 마지막 문자는 <xref:System.Text.StringBuilder> 인스턴스 인덱스에는 <xref:System.Text.StringBuilder.Length%2A> -1입니다.  
  
 <xref:System.Text.StringBuilder.Chars%2A> 기본 속성은는 <xref:System.Text.StringBuilder> 클래스입니다. C#의 인덱서입니다. 즉, 개별 문자에서 검색할 수 있습니다는 <xref:System.Text.StringBuilder.Chars%2A> 공백, 영문자의 수를 계산 하는 다음 예에서 표시 된 것 처럼 속성 및 문자열에 문장 부호 문자입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>성능 및 문자 기반 인덱싱

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          문자를 설정하는 동안 <paramref name="index" />가 이 인스턴스의 범위를 벗어납니다.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          문자를 가져오는 동안 <paramref name="index" />가 이 인스턴스의 범위를 벗어납니다.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 인스턴스에서 모든 문자를 제거합니다.</summary>
        <returns>
          <see cref="P:System.Text.StringBuilder.Length" />가 0인 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> 설정에 해당 하는 편리한 메서드입니다는 <xref:System.Text.StringBuilder.Length%2A> 0 (영)는 현재 인스턴스의 속성입니다.  
  
 호출 된 <xref:System.Text.StringBuilder.Clear%2A> 메서드는 현재 인스턴스를 수정 하지 않습니다 <xref:System.Text.StringBuilder.Capacity%2A> 또는 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder> 문자열로 호출 개체는 <xref:System.Text.StringBuilder.Clear%2A> 메서드를 한 다음 새 문자열을 추가 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">이 인스턴스에서 문자가 복사되기 시작하는 위치입니다. 인덱스는 0부터 시작합니다.</param>
        <param name="destination">문자가 복사될 배열입니다.</param>
        <param name="destinationIndex">문자가 복사될 <c>대상</c>의 시작 위치입니다. 인덱스는 0부터 시작합니다.</param>
        <param name="count">복사될 문자 수입니다.</param>
        <summary>이 인스턴스에서 지정한 세그먼트의 문자를 대상 <see cref="T:System.Char" /> 배열에서 지정한 세그먼트에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A> 효율적으로의 연속 섹션을 복사 해야 할 때 특수 한 상황에서 사용할 메서드는 <xref:System.Text.StringBuilder> 개체 배열입니다. 배열의 크기는 고정된 미리 할당 된, 및 전역 액세스가 가능 해야 합니다.  
  
 예를 들어, 응용 프로그램 채울 수 없습니다는 <xref:System.Text.StringBuilder> 문자의 다 수 포함 된 개체 다음 사용 하 여는 <xref:System.Text.StringBuilder.CopyTo%2A> 작은, 연속 된 부분을 복사 하려면은 <xref:System.Text.StringBuilder> 조각이 처리 되는 배열에는 개체입니다. 경우에 있는 모든 데이터는 <xref:System.Text.StringBuilder> 개체 처리의 크기는 <xref:System.Text.StringBuilder> 개체가 0으로 설정 되 고 주기가 반복 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.CopyTo%2A> 메서드.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="sourceIndex" />가 이 인스턴스의 길이보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" />가 이 인스턴스의 길이보다 큽니다.  
  
 또는  
  
 <paramref name="destinationIndex" /> + <paramref name="count" />이 <paramref name="destination" />의 길이보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">확보할 최소 용량입니다.</param>
        <summary>이 <see cref="T:System.Text.StringBuilder" /> 인스턴스의 용량이 최소한 지정된 값이 되도록 합니다.</summary>
        <returns>이 인스턴스의 새 용량입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 용량이 보다 작은 `capacity` 매개 변수를이 인스턴스에 대 한 다시 할당 이상을 보유할 수 `capacity` 문자 수; 그렇지 않으면 메모리는 그대로 유지 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.EnsureCapacity%2A> 메서드.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작은 경우  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">이 인스턴스와 비교할 개체 또는 <see langword="null" />입니다.</param>
        <summary>이 인스턴스가 지정된 개체와 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>
          이 인스턴스와 <paramref name="sb" />에 같은 문자열, <see cref="P:System.Text.StringBuilder.Capacity" /> 및 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 값이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드에서는 <xref:System.Text.StringBuilder.Equals%2A> 두 검사 하도록 <xref:System.Text.StringBuilder> 개체가 서로 같은지 합니다. 각 개체에 작은 변경 내용이 고 결과 콘솔에 표시 됩니다는 메서드는 반복적으로 호출 됩니다.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 문자 위치에 있는 이 인스턴스에 부울 값의 문자열 표현을 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 필요에 따라 용량이 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 8비트 부호 없는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 유니코드 문자의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 문자 배열입니다.</param>
        <summary>지정된 유니코드 문자 배열의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 경우 `value` 은 `null`, <xref:System.Text.StringBuilder> 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>10진수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>배정밀도 부동 소수점 숫자의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 16비트 부호 있는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 32비트 부호 있는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 있는 64비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 개체이거나 <see langword="null" />입니다.</param>
        <summary>개체의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 경우 `value` 은 `null`,이 인스턴스의 값이 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 8비트 부호 있는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 필요에 따라 용량이 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>단정밀도 부동 소수점 숫자의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 문자열입니다.</param>
        <summary>문자열을 지정한 인덱스에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 필요에 따라 용량이 조정 됩니다.  
  
 이 인스턴스의 <xref:System.Text.StringBuilder> 변경 되지 `value` 은 `null`, 또는 `value` 않습니다 `null` 아니지만 길이가 0입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작거나 이 인스턴스의 현재 길이보다 큰 경우  
  
 또는  
  
 이 <see cref="T:System.Text.StringBuilder" /> 개체의 현재 길이와 <paramref name="value" />의 길이를 더한 값이 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과하는 경우</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 없는 16비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 없는 32비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 없는 64비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 인해 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw 된 <see cref="T:System.OutOfMemoryException" />합니다.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 문자열입니다.</param>
        <param name="count">
          <c>값</c>을 삽입할 횟수입니다.</param>
        <summary>지정된 하나 이상의 문자열의 복사본을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료한 후에 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 이 <xref:System.Text.StringBuilder> 경우 개체는 변경 되지 않습니다 `value` 은 `null`, `value` 않습니다 `null` 아니지만 길이가 0 또는 `count` 은 0입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작거나 이 인스턴스의 현재 길이보다 큰 경우  
  
 또는  
  
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.OutOfMemoryException">
          <paramref name="value" />의 길이에 <paramref name="count" />를 곱한 값과 이 <see cref="T:System.Text.StringBuilder" /> 개체의 현재 길이를 더한 값이 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과하는 경우</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">문자 배열입니다.</param>
        <param name="startIndex">
          <c>값</c> 내의 시작 인덱스입니다.</param>
        <param name="charCount">삽입할 문자 수입니다.</param>
        <summary>유니코드 문자의 지정된 하위 배열에 대한 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자가 이동 됩니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />이고 <paramref name="startIndex" /> 및 <paramref name="charCount" />는 0이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />, <paramref name="startIndex" /> 또는 <paramref name="charCount" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="index" />가 이 인스턴스의 길이보다 큽니다.  
  
 또는  
  
 <paramref name="startIndex" />와 <paramref name="charCount" />의 합이 <paramref name="value" /> 내에 위치하지 않는 경우  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 개체의 길이를 가져오거나 설정합니다.</summary>
        <value>이 인스턴스의 길이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 길이 <xref:System.Text.StringBuilder> 의 해당 번호로 개체 이루어집니다 <xref:System.Char> 개체입니다.  
  
 마찬가지로 <xref:System.String.Length%2A?displayProperty=nameWithType> 속성에는 <xref:System.Text.StringBuilder.Length%2A> 속성은 현재 string 개체의 길이 나타냅니다. 와 달리는 <xref:System.String.Length%2A?displayProperty=nameWithType> 속성 읽기 전용 즉는 <xref:System.Text.StringBuilder.Length%2A> 속성에 저장 된 문자열의 길이 수정할 수 있습니다는 <xref:System.Text.StringBuilder> 개체입니다.  
  
 지정된 된 길이 현재 현재 길이 보다 작은 경우 <xref:System.Text.StringBuilder> 개체가 지정 된 길이로 잘립니다. 지정 된 길이 현재 문자열의 마지막 현재 길이 보다 큰 경우 <xref:System.Text.StringBuilder> 개체 유니코드 NULL 문자로 채워집니다 (U + 0000)입니다.  
  
 지정된 된 길이 현재 용량 보다 큰 경우 <xref:System.Text.StringBuilder.Capacity%2A> 지정된 된 길이 보다 크거나 있도록 증가 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Length%2A> 속성입니다.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">설정된 값이 0보다 작거나 <see cref="P:System.Text.StringBuilder.MaxCapacity" />보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 인스턴스의 최대 용량을 가져옵니다.</summary>
        <value>이 인스턴스가 보유할 수 있는 최대 문자 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현에 대 한 최대 용량은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다. 그러나이 값은 구현 별로 되며 다른 또는 이후 구현에서 다를 수 있습니다. 최대 용량을 명시적으로 설정할 수는 <xref:System.Text.StringBuilder> 호출 하 여 개체는 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자입니다.  
  
 에[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]인스턴스화할 때는 <xref:System.Text.StringBuilder> 호출 하 여 개체는 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자, 길이의 용량은 <xref:System.Text.StringBuilder> 인스턴스 값 이상으로 증가할 수 해당 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다는 <xref:System.Text.StringBuilder.Append%2A> 및 <xref:System.Text.StringBuilder.AppendFormat%2A> 작은 문자열을 추가 하는 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">제거할 문자 수입니다.</param>
        <summary>이 인스턴스에서 지정된 문자 범위를 제거합니다.</summary>
        <returns>삭제 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 메서드는 현재 인스턴스에서 지정 된 범위의 문자를 제거합니다. 에 있는 문자 (`startIndex` + `length`)로 이동 `startIndex`, 현재 인스턴스의 문자열 값 만큼 줄어듭니다 및 `length`합니다. 현재 인스턴스의 용량 영향을 받지 않습니다.  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> 현재 값 수정 <xref:System.Text.StringBuilder> 인스턴스 및 해당 인스턴스를 반환 합니다. 만들 고 새 반환 되지 않는 <xref:System.Text.StringBuilder> 개체입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Remove%2A> 메서드.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작거나 <paramref name="startIndex" /> + <paramref name="length" />가 이 인스턴스의 길이보다 큽니다.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 발견되는 지정된 문자 또는 문자열을 지정된 다른 문자 또는 문자열로 모두 바꿉니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">바꿀 문자입니다.</param>
        <param name="newChar">
          <c>oldChar</c>를 바꾸는 문자입니다.</param>
        <summary>이 인스턴스에서 발견되는 지정된 문자를 지정된 다른 문자로 모두 바꿉니다.</summary>
        <returns>
          <paramref name="oldChar" />가 <paramref name="newChar" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 횟수를 식별 하는 서 수, 대/소문자 구분 비교를 수행 `oldChar` 현재 인스턴스에 있습니다. 현재 크기 <xref:System.Text.StringBuilder> 교체 후 인스턴스는 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">바꿀 문자열입니다.</param>
        <param name="newValue">
          <c>oldValue</c>를 바꾸는 문자열이거나 <see langword="null" />입니다.</param>
        <summary>이 인스턴스에서 발견되는 지정된 문자열을 지정된 다른 문자열로 모두 바꿉니다.</summary>
        <returns>
          <paramref name="oldValue" />의 모든 인스턴스가 <paramref name="newValue" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 횟수를 식별 하는 서 수, 대/소문자 구분 비교를 수행 `oldValue` 현재 인스턴스에 있습니다. 경우 `newValue` 은 `null` 또는 <xref:System.String.Empty?displayProperty=nameWithType>의 항목을 모두 `oldValue` 제거 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" />의 길이가 0인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">바꿀 문자입니다.</param>
        <param name="newChar">
          <c>oldChar</c>를 바꾸는 문자입니다.</param>
        <param name="startIndex">부분 문자열이 시작되는 인스턴스 내의 위치입니다.</param>
        <param name="count">부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 부분 문자열에서 발견되는 지정된 문자를 지정된 다른 문자로 모두 바꿉니다.</summary>
        <returns>
          <paramref name="oldChar" />가 <paramref name="startIndex" />에서부터 <paramref name="startIndex" /> + <paramref name="count" /> -1의 범위에 있는 <paramref name="newChar" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 횟수를 식별 하는 서 수, 대/소문자 구분 비교를 수행 `oldChar` 현재 인스턴스에 있습니다. 현재 크기 <xref:System.Text.StringBuilder> 개체는 교체 후 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" />가 이 인스턴스의 길이보다 큽니다.  
  
 또는  
  
 <paramref name="startIndex" /> 또는 <paramref name="count" />가 0보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">바꿀 문자열입니다.</param>
        <param name="newValue">
          <c>oldValue</c>를 바꾸는 문자열이거나 <see langword="null" />입니다.</param>
        <param name="startIndex">부분 문자열이 시작되는 인스턴스 내의 위치입니다.</param>
        <param name="count">부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 부분 문자열에서 발견되는 지정된 문자열을 지정된 다른 문자열로 모두 바꿉니다.</summary>
        <returns>
          <paramref name="oldValue" />의 모든 인스턴스가 <paramref name="startIndex" />에서 <paramref name="startIndex" /> + <paramref name="count" /> - 1 범위에 있는 <paramref name="newValue" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 횟수를 식별 하는 서 수, 대/소문자 구분 비교를 수행 `oldValue` 에 지정된 된 부분 문자열입니다. 경우 `newValue` 은 `null` 또는 <xref:System.String.Empty?displayProperty=nameWithType>의 항목을 모두 `oldValue` 제거 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" />의 길이가 0인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="startIndex" />와 <paramref name="count" />의 합이 이 인스턴스 내에 있지 않은 문자 위치를 나타내는 경우  
  
 또는  
  
 이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">serialization 정보로 채울 개체입니다.</param>
        <param name="context">serialize된 데이터를 저장 및 검색할 위치입니다. 나중에 사용하기 위해 예약되어 있습니다.</param>
        <summary>현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 deserialize하는 데 필요한 데이터로 <see cref="T:System.Text.StringBuilder" /> 개체를 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` 매개 변수는 나중에 사용할 수는 예약 되어 있으며이 작업에 참여 하지 않습니다.  
  
 자세한 내용은 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.StringBuilder" />의 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
        <returns>이 인스턴스와 같은 값을 가진 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 해야 합니다는 <xref:System.Text.StringBuilder.ToString%2A> 변환 하는 메서드는 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 이 나타내는 문자열을 전달할 수 전에 개체는 <xref:System.Text.StringBuilder> 개체 변수가 있는 메서드를는 <xref:System.String> 매개 변수 또는 사용자 인터페이스에 표시 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.StringBuilder.ToString%2A> 메서드를 호출하는 방법을 보여 줍니다. 이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Text.StringBuilder> 클래스입니다.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="length">부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 부분 문자열 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
        <returns>이 인스턴스의 지정된 부분 문자열과 같은 값을 가진 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 해야 합니다는 <xref:System.Text.StringBuilder.ToString%2A> 변환 하는 메서드는 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 이 나타내는 문자열을 전달할 수 전에 개체는 <xref:System.Text.StringBuilder> 개체 변수가 있는 메서드를는 <xref:System.String> 매개 변수 또는 사용자 인터페이스에 표시 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="startIndex" />와 <paramref name="length" />의 합이 현재 인스턴스의 길이보다 큰 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>