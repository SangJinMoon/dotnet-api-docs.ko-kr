<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adda8f83141f6520fcaefa264a4ae9446935542e" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683694" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a character encoding.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인코딩은 유니코드 문자 집합을 바이트 시퀀스로 변환하는 프로세스입니다. 반면, 디코딩은 유니코드 문자 집합으로 인코딩된 바이트 시퀀스로 변형 하는 프로세스입니다. 지 원하는 다른 인코딩 및 유니코드 변환 형식 (Utf)에 대 한 내용은 <xref:System.Text.Encoding>, 참조 [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
 <xref:System.Text.Encoding> 바이트 배열과 같은 임의의 이진 데이터 대신 유니코드 문자에 대해 수행 하려고 합니다. 텍스트에 임의의 이진 데이터를 인코딩해야 하는 경우와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 .NET Framework의 다음 구현에서는 <xref:System.Text.Encoding> 현재 유니코드 인코딩 및 기타 인코딩을 지원 하기 위해 클래스:  
  
-   <xref:System.Text.ASCIIEncoding> 단일 7 비트 ASCII 문자로 유니코드 문자를 인코딩합니다. 이 인코딩은 U + 사이의 문자 값만 지원 0000 및 U + 007F 합니다. 코드 페이지 20127입니다. 통해서도 사용할 수는 <xref:System.Text.Encoding.ASCII%2A> 속성입니다.  
  
-   <xref:System.Text.UTF7Encoding> utf-7 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. 이 인코딩은 모든 유니코드 문자 값을 지원합니다. 코드 페이지 65000입니다. 통해서도 사용할 수는 <xref:System.Text.Encoding.UTF7%2A> 속성입니다.  
  
-   <xref:System.Text.UTF8Encoding> utf-8 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. 이 인코딩은 모든 유니코드 문자 값을 지원합니다. 코드 페이지 65001입니다. 통해서도 사용할 수는 <xref:System.Text.Encoding.UTF8%2A> 속성입니다.  
  
-   <xref:System.Text.UnicodeEncoding> utf-16 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. Little endian 및 big endian 바이트 순서가 둘 다 사용할 수 있습니다. 통해서도 사용할 수는 <xref:System.Text.Encoding.Unicode%2A> 속성 및 <xref:System.Text.Encoding.BigEndianUnicode%2A> 속성입니다.  
  
-   <xref:System.Text.UTF32Encoding> utf-32 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. 모두 little endian (코드 페이지 12000) 및 big endian (코드 페이지 12001) 바이트 순서가 지원 됩니다. 통해서도 사용할 수는 <xref:System.Text.Encoding.UTF32%2A> 속성입니다.  
  
 <xref:System.Text.Encoding> 클래스는 다른 인코딩과 유니코드 간 변환 주로 합니다. 종종 파생 중 하나는 응용 프로그램에 대 한 올바른 선택입니다.  
  
 사용 하 여는 <xref:System.Text.Encoding.GetEncoding%2A> 다른 인코딩을 얻는 메서드를 호출 하 고는 <xref:System.Text.Encoding.GetEncodings%2A> 모든 인코딩 목록을 가져올 메서드를 합니다.  
  
 다음 표에서.NET Framework에서 지 원하는 인코딩과 나열 합니다. 각 인코딩의 코드 페이지 번호 목록과 인코딩의 값 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 및 <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> 속성입니다. 마지막 열에 별표가 나타냅니다 코드 페이지 기본 플랫폼에 관계 없이.NET Framework에서 기본적으로 지원 됩니다. 참고 코드 갖는 페이징 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 국제 표준에 해당 하는 속성 전체 해당 표준 준수 하지 않습니다.  
  
|코드 페이지|이름|표시 이름|.NET framework 지원|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM EBCDIC (미국-캐나다)||  
|437|IBM437|OEM United States||  
|500|IBM500|IBM EBCDIC (국제)||  
|708|ASMO 708|아랍어 (ASMO 708)||  
|720|DOS-720|아랍어 (DOS)||  
|737|ibm737|그리스어 (DOS)||  
|775|ibm775|발트어 (DOS)||  
|850|ibm850|서유럽어 (DOS)||  
|852|ibm852|중앙 유럽어 (DOS)||  
|855|IBM855|OEM 키릴 자모||  
|857|ibm857|터키어 (DOS)||  
|858|IBM00858|OEM 다국 라틴 문자 I||  
|860|IBM860|포르투갈어 (DOS)||  
|861|ibm861|아이슬란드어 (DOS)||  
|862|DOS-862|히브리어 (DOS)||  
|863|IBM863|프랑스어 캐나다 (DOS)||  
|864|IBM864|아랍어 (864)||  
|865|IBM865|북유럽 (DOS)||  
|866|cp866|키릴 자모 (DOS)||  
|869|ibm869|그리스어, 최신 (DOS)||  
|870|IBM870|IBM EBCDIC (다국어 라틴어-2)||  
|874|windows-874|태국어 (Windows)||  
|875|cp875|IBM EBCDIC (현대 그리스어)||  
|932|shift_jis|일본어 (SHIFT-JIS)||  
|936|gb2312|중국어 간체 (GB2312)|✓|  
|949|ks_c_5601-1987|한국어||  
|950|big5|중국어 번체 (Big5)||  
|1026|IBM1026|IBM EBCDIC (터키어 라틴어-5)||  
|1047|IBM01047|IBM 라틴어 1||  
|1140|IBM01140|IBM EBCDIC (미국-캐나다-유럽)||  
|1141|IBM01141|IBM EBCDIC (독일 유로)||  
|1142|IBM01142|IBM EBCDIC (덴마크) (노르웨이 유로)||  
|1143|IBM01143|IBM EBCDIC (핀란드 스웨덴 유로)||  
|1144|IBM01144|IBM EBCDIC (미국-유럽)||  
|1145|IBM01145|IBM EBCDIC (스페인 유로)||  
|1146|IBM01146|IBM EBCDIC (영국 유로)||  
|1147|IBM01147|IBM EBCDIC (프랑스 유로)||  
|1148|IBM01148|IBM EBCDIC (International 유로)||  
|1149|IBM01149|IBM EBCDIC (아이슬란드어 유로)||  
|1200|utf-16|유니코드(Unicode)|✓|  
|1201|unicodeFFFE|유니코드 (Big endian)|✓|  
|1250|windows-1250|중앙 유럽어 (Windows)||  
|1251|windows-1251|키릴 자모 (Windows)||  
|1252|Windows-1252|서유럽어 (Windows)|✓|  
|1253|windows-1253|그리스어 (Windows)||  
|1254|windows-1254|터키어 (Windows)||  
|1255|windows-1255|히브리어 (Windows)||  
|1256|windows-1256|아랍어 (Windows)||  
|1257|windows-1257|발트어 (Windows)||  
|1258|windows-1258|베트남어 (Windows)||  
|1361|조합|한국어 (조합)||  
|10000|macintosh|서유럽어 (Mac)||  
|10001|x-mac-일본어|일본어 (Mac)||  
|10002|x-mac-중국어 번체|중국어 번체 (Mac)||  
|10003|x-mac-한국어|한국어 (Mac)|✓|  
|10004|x-mac-아랍어|아랍어 (Mac)||  
|10005|x-mac-히브리어|히브리어 (Mac)||  
|10006|x-mac-그리스어|그리스어 (Mac)||  
|10007|x-mac-cyrillic|키릴 자모 (Mac)||  
|10008|x-mac-chinesesimp|중국어 간체 (Mac)|✓|  
|10010|루마니아어-mac-x|루마니아어 (Mac)||  
|10017|우크라이나어-mac-x|우크라이나어 (Mac)||  
|10021|x-mac-태국어|태국어 (Mac)||  
|10029|x-mac-ce|중앙 유럽어 (Mac)||  
|10079|x-mac-아이슬란드어|아이슬란드어 (Mac)||  
|10081|x-mac-터키어|터키어 (Mac)||  
|10082|x-mac-크로아티아어|크로아티아어 (Mac)||  
|12000|utf-32|유니코드 (u t F-32)|✓|  
|12001|utf-32BE|유니코드 (utf-32 Big endian)|✓|  
|20000|x-중국어-CN|중국어 번체 (CN)||  
|20001|x-cp20001|TCA 대만||  
|20002|x-중국어-Eten|중국어 번체 (Eten)||  
|20003|x-cp20003|IBM5550 대만||  
|20004|x-cp20004|방송 대만||  
|20005|x-cp20005|Wang 대만||  
|20105|x-IA5|서유럽어 (IA5)||  
|20106|x-IA5-독일어|독일어 (IA5)||  
|20107|x-IA5-Swedish|스웨덴어 (IA5)||  
|20108|x IA5 언어|노르웨이어 (IA5)||  
|20127|us-ascii|US ASCII|✓|  
|20261|x-cp20261|T.61||  
|20269|x-cp20269|ISO-6937||  
|20273|IBM273|IBM EBCDIC (독일)||  
|20277|IBM277|IBM EBCDIC (덴마크 노르웨이)||  
|20278|IBM278|IBM EBCDIC (핀란드 스웨덴)||  
|20280|IBM280|IBM EBCDIC (미국)||  
|20284|IBM284|IBM EBCDIC (스페인)||  
|20285|IBM285|IBM EBCDIC (영국)||  
|20290|IBM290|IBM EBCDIC (일본어 가타카나)||  
|20297|IBM297|IBM EBCDIC (프랑스)||  
|20420|IBM420|IBM EBCDIC (아랍어)||  
|20423|IBM423|IBM EBCDIC (그리스어)||  
|20424|IBM424|IBM EBCDIC (히브리어)||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (한국어 확장)||  
|20838|IBM-태국어|IBM EBCDIC (태국)||  
|20866|koi8-r|키릴 자모 (KOI8-R)||  
|20871|IBM871|IBM EBCDIC (아이슬란드어)||  
|20880|IBM880|IBM EBCDIC (키릴 자모 러시아어)||  
|20905|IBM905|IBM EBCDIC (터키어)||  
|20924|IBM00924|IBM 라틴어 1||  
|20932|EUC-JP|일본어 (JIS 0208-1990 및 0212-1990)||  
|20936|x-cp20936|중국어 간체 (GB2312-80)|✓|  
|20949|x-cp20949|한국어 (완성)|✓|  
|21025|cp1025|IBM EBCDIC (키릴 자모 세르비아어 불가리아어)||  
|21866|koi8-u|키릴 자모 (KOI8-U)||  
|28591|iso-8859-1|서유럽어 (ISO)|✓|  
|28592|iso-8859-2|중앙 유럽어 (ISO)||  
|28593|iso-8859-3|라틴어 3 (ISO)||  
|28594|iso-8859-4|발트어 (ISO)||  
|28595|iso-8859-5|키릴 자모 (ISO)||  
|28596|iso-8859-6|아랍어 (ISO)||  
|28597|iso-8859-7|그리스어 (ISO)||  
|28598|iso-8859-8|히브리어 (Iso-visual)|✓|  
|28599|iso-8859-9|터키어 (ISO)||  
|28603|iso-8859-13|에스토니아어 (ISO)||  
|28605|iso-8859-15|라틴어 9 (ISO)||  
|29001|x 에우로파|에우로파||  
|38598|iso-8859-8-i|히브리어 (ISO 논리)|✓|  
|50220|iso-2022-jp|일본어 (JIS)|✓|  
|50221|csISO2022JP|일본어 (Jis-allow 1 byte Kana)|✓|  
|50222|iso-2022-jp|일본어 (Jis-allow 1 byte Kana-따라서 / SI)|✓|  
|50225|iso-2022-서울|한국어 (ISO)|✓|  
|50227|x-cp50227|중국어 간체 (iso-2022)|✓|  
|51932|euc-jp|일본어 (EUC)|✓|  
|51936|EUC CN|중국어 간체 (EUC)|✓|  
|51949|euc 서울|한국어 (EUC)|✓|  
|52936|hz-gb-2312|중국어 간체 (HZ)|✓|  
|54936|GB18030|중국어 간체 (GB18030)|✓|  
|57002|x-iscii-de|ISCII 데바나가리어|✓|  
|57003|x iscii 수|ISCII 벵골어|✓|  
|57004|x-iscii-ta|ISCII 타밀어|✓|  
|57005|x-iscii-te|ISCII 텔루구어|✓|  
|57006|x iscii 다른 이름으로|ISCII 아샘어|✓|  
|57007|x-iscii 또는|ISCII 오리야어|✓|  
|57008|x-iscii-ka|ISCII 카나다어|✓|  
|57009|x iscii ma|ISCII 말라얄람어|✓|  
|57010|x-iscii-gu|ISCII 구자라트어|✓|  
|57011|x-iscii-pa|ISCII 펀잡어|✓|  
|65000|utf-7|유니코드 (utf-7)|✓|  
|65001|utf-8|유니코드(UTF-8)|✓|  
  
 다음 예제에서는 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> 및 <xref:System.Text.Encoding.GetEncoding%28System.String%29> 그리스어 (Windows)를 가져오는 메서드를 코드 페이지 인코딩. 비교는 <xref:System.Text.Encoding> 같은지 및 지도 그리스어 알파벳의 유니코드 코드 포인트 및 각 문자에 대해 해당 코드 페이지 값을 표시 한 다음 표시 하는 메서드 호출에서 반환 된 개체입니다.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 U t F-16 및 u t F-32 인코더 big endian 바이트 순서를 사용할 수 있습니다 (최상위 바이트 첫 번째) 또는 little endian 바이트 순서 (최하위 바이트 첫 번째). 예를 들어 한 (U + 0041)으로 serialize 되는 영문 대문자 (16 진수)에서 다음과 같습니다.  
  
-   Utf-16 big endian 바이트 순서: 00 41  
  
-   Utf-16 little endian 바이트 순서: 41 00  
  
-   U t F-32 big endian 바이트 순서: 00 00 00 41  
  
-   U t F-32 little endian 바이트 순서: 41 00 00 00  
  
 기본 바이트 순서를 사용 하 여 유니코드 문자를 저장 하려면 일반적으로 더 효율적입니다. 예를 들어 Intel 컴퓨터 등의 little endian 플랫폼에서 little endian 바이트 순서를 사용 하는 것이 좋습니다.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> 메서드 (BOM)의 바이트 순서 표시를 포함 하는 바이트 배열을 검색 합니다. 바이트 배열이 인코딩된 스트림의에 접두어로 추가 되는, 디코더가 사용 된 인코딩 형식을 식별 하는 데 도움이 됩니다.  
  
 바이트 순서 및 바이트 순서 표시에 대 한 자세한 내용은 유니코드 표준을 참조는 [유니코드 홈페이지](http://go.microsoft.com/fwlink/?LinkId=37123)합니다.  
  
 인코딩 클래스를 사용 하는 오류를 참고:  
  
-   자동으로 변경 하는 "?" 문자입니다.  
  
-   "가장 적합 한" 문자를 사용 합니다.  
  
-   사용 하는 응용 프로그램별 동작으로 변경 된 <xref:System.Text.EncoderFallback> 및 <xref:System.Text.DecoderFallback> 유니코드 U + FFFD 대체 문자를 사용 하 여 클래스입니다.  
  
 모든 데이터 스트림 오류에 예외를 throw 해야 합니다. 응용 프로그램 해당 하는 경우 "throwonerror" 플래그를 사용 하거나 사용 합니다.는 <xref:System.Text.EncoderExceptionFallback> 및 <xref:System.Text.DecoderExceptionFallback> 클래스입니다. 자동 맞춤된 대체는 데이터 손실 또는 혼동을 일으킬 수 있으므로 단순한 문자 대체 보다 느립니다 사용 하지 않는 것이 좋습니다. ANSI 인코딩을 자동 맞춤된 동작이 기본값입니다.  
  
   
  
## Examples  
 다음 예제에서는 한 인코딩에서 다른 인코딩으로에서 문자열로 변환 합니다.  
  
> [!NOTE]
>  바이트 [] 형식의 배열에는 인코딩된 데이터를 포함 되어 있는이 예의 유일한 형식입니다. .NET 문자 및 문자열 형식을 사용 하는 유니코드, 하므로 <xref:System.Text.Encoding.GetChars%2A> 호출 데이터를 다시 유니코드 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스는이 생성자를 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">The code page identifier of the preferred encoding.  
  
 -or-  
  
 0, to use the default encoding.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스는이 생성자를 재정의 합니다.  
  
 파생된 클래스에서이 생성자를 호출 만들기는 <xref:System.Text.Encoding> 인코딩 및 디코딩 작업 모두에 대 한 최적 맞춤된 대체 (fallback)를 사용 하는 개체입니다. 둘 다는 <xref:System.Text.Encoding.DecoderFallback%2A> 및 <xref:System.Text.Encoding.EncoderFallback%2A> 속성 읽기 전용 이며 수정할 수 없습니다. 파생 된 클래스에 대 한 대체 (fallback) 전략을 제어 하려면 <xref:System.Text.Encoding>, 호출 된 <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> is less than zero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">The encoding code page identifier.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 `protected`; 파생 클래스에서 재정의 합니다.  
  
 대체 인코딩 및 디코딩 전략을 제어 하는 파생된 클래스에서이 생성자를 호출 합니다. <xref:System.Text.Encoding> 클래스 생성자 인코더 또는 디코더가 대체 (fallback) 개체를 만든 후에 설정할 수를 허용 하지 않는 읽기 전용 인코딩 개체를 만듭니다.  
  
 어느 경우 `encoderFallback` 또는 `decoderFallback` 매개 변수가 null 이면 최적 맞춤된 대체 (fallback) 해당 대체 (fallback) 전략으로 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the ASCII (7-bit) character set.</summary>
        <value>ASCII(7비트) 문자 집합에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII 문자는 U + 0000 ~ U + 007F에서에서 가장 낮은 128 개의 유니코드 문자일 제한 됩니다.  
  
 앱에 대 한 ASCII 인코딩을 선택할 때 다음 사항을 고려 합니다.  
  
-   ASCII 인코딩 하는 것은 ASCII를 필요로 하는 프로토콜에 대 한 일반적으로 적합 합니다.  
  
-   8 비트 인코딩 (때때로 이라고는 하지를 "ASCII")가 필요한 경우 ascii 좋습니다 인코딩을 u t F-8 인코딩. 0-7F 문자에 대 한 결과 동일 하지만 u t F-8을 사용 하 여 나타낼 수 있는 모든 유니코드 문자는 표시 하 여 데이터 손실을 방지할 수 있습니다. ASCII 인코딩 8 번째에 비트 악의적인 사용을 허용할 수 있는 모호성 하지만 인코딩을 u t F-8 8 비트에 대 한 모호성을 제거 합니다.  
  
-   .NET Framework 버전 2.0에서는 하기 전에.NET Framework 8 번째 비트를 무시 하 여 스푸핑 허용 합니다. .NET Framework 2.0 부터는 ASCII가 아닌 코드 포인트 동안 변경 디코딩.  
  
 <xref:System.Text.ASCIIEncoding> 이 속성에서 반환 되는 개체는 응용 프로그램에 대 한 적절 한 동작을 없을 수 있습니다. 교체 대체 (fallback)를 사용 하 여 인코딩할 수 없는 각 문자열과 디코딩할 수 없는 각 바이트를 물음표로 바꿉니다 ("?") 문자. 대신, 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 메서드를 인스턴스화하는 <xref:System.Text.ASCIIEncoding> 하나 대체가 개체는 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 다음 예제에서는 ASCII ASCII 범위 외부에 있는 문자에 인코딩의 효과 보여 줍니다.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-16 format that uses the big endian byte order.</summary>
        <value>Big-Endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> 이 속성에서 반환 되는 개체는 응용 프로그램에 대 한 적절 한 동작을 없을 수 있습니다. 교체 대체 (fallback)를 사용 하 여 인코딩할 수 없는 각 문자열과 디코딩할 수 없는 각 바이트를 물음표로 바꿉니다 ("?") 문자. 대신, 호출 수는 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 를 big endian 인스턴스화하는 생성자 <xref:System.Text.UnicodeEncoding> 하나 대체가 개체는 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 반환 된 <xref:System.Text.UnicodeEncoding> 개체에 <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, 및 <xref:System.Text.Encoding.WebName%2A> 속성 이름 "unicodeFFFE"을 생성 합니다. Utf-16 big endian 바이트 순서 표시 16 진수 FEFF 이지만, "이름"unicodeFFFE 바이트 순서 표시가 little endian Windows 컴퓨터에서 16 진수 FFFE로 표시 되기 때문에 선택 되었습니다.  
  
   
  
## Examples  
 다음 예제에서는 u t F-16으로 인코딩된 big endian 바이트 순서를 사용 하 여 텍스트 파일을 읽습니다.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</summary>
        <value>메일 에이전트 본문 태그에 사용할 수 있는 현재 <see cref="T:System.Text.Encoding" />의 이름입니다.  
  
 또는  
  
 현재 <see cref="T:System.Text.Encoding" />을 사용할 수 없으면 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 해야 본문 이름에 대 한 인코딩이 필요한 경우 <xref:System.Text.Encoding.GetEncoding%2A> 와 <xref:System.Text.Encoding.BodyName%2A> 속성입니다. 종종 메서드 호출에 제공 된 테스트 인코딩과에서 다른 인코딩을 검색 합니다. 전자 메일 응용 프로그램만 일반적으로 이러한 인코딩을 검색; 필요가 인코딩을 설명 하는 다른 대부분 응용 프로그램을 사용 해야 해당 <xref:System.Text.Encoding.WebName%2A>합니다.  
  
 일부 경우의 값에는 <xref:System.Text.Encoding.BodyName%2A> 속성은 해당 인코딩을 정의 하는 국제 표준에 해당 합니다. 표준에 포함 하 여 전체에서 구현 따르는지 하는 것은 아닙니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 대 한 서로 다른 이름을 검색 하 고 다른 하나 이상의 이름의 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 하지만 것과 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <returns>A copy of the current <see cref="T:System.Text.Encoding" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복제본은 쓰기 가능한 경우에 원래 <xref:System.Text.Encoding> 개체가 읽기 전용입니다. 따라서 복사본의 속성을 수정할 수 있습니다.  
  
 개체의 단순 복사본에만 개체의 복사본이입니다. 개체가 다른 개체에 대 한 참조를 포함 하는 경우 단순 복사는 참조 개체의 복사본을 만들지 않습니다. 원래 개체를 대신 참조 합니다. 이와 반대로 개체의 전체 복사본을 개체의 복사본 및 해당 개체에서 직접 또는 간접적으로 참조 하는 모든 대상을 복사를 만듭니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />의 코드 페이지 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩에 대 한 서로 다른 이름을 검색 하 고 다른 하나 이상의 이름의 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 하지만 것과 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts a byte array from one encoding to another.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">The encoding format of <c>bytes</c>.</param>
        <param name="dstEncoding">The target encoding format.</param>
        <param name="bytes">The bytes to convert.</param>
        <summary>Converts an entire byte array from one encoding to another.</summary>
        <returns>An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 ASCII로 인코딩된 문자열을 유니코드로 인코딩된 문자열로 변환합니다. ASCII 인코딩 개체에서 반환 된 <xref:System.Text.Encoding.ASCII%2A> 속성 교체 대체 (fallback)를 사용 하 고 Pi 문자는 ASCII 문자 집합의 일부가 아닙니다., Pi 문자 예제의 출력으로를 물음표로 대체 됩니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="dstEncoding" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">The encoding of the source array, <c>bytes</c>.</param>
        <param name="dstEncoding">The encoding of the output array.</param>
        <param name="bytes">The array of bytes to convert.</param>
        <param name="index">The index of the first element of <c>bytes</c> to convert.</param>
        <param name="count">The number of bytes to convert.</param>
        <summary>Converts a range of bytes in a byte array from one encoding to another.</summary>
        <returns>An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="dstEncoding" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" /> 개체에 대한 디코더 대체 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> 개체 문자도 인코딩된 바이트 시퀀스를 디코딩할 수 없는 때 호출 되는 오류 처리기를 나타냅니다. 처리기 형식 중 하나로 사용할 수 있습니다.  
  
-   가장 적합된 한 대체 (fallback) 처리기를 디코딩할 수 없는 바이트 일부 적절 한 대체 문자로 대체 합니다.  
  
-   교체 대체 (fallback) 처리기를 디코딩할 수 없는 바이트 일부 임의의 대체 문자로 대체 하는 합니다. .NET Framework 포함 한 교체 대체 (fallback) 처리기 <xref:System.Text.DecoderFallback>, 디코딩할 수 없는 바이트를 물음표로 대체는 기본적으로 ("?") 문자.  
  
-   예외 대체 (fallback) 처리기 바이트를 디코딩할 수 없는 경우 예외를 throw 합니다. .NET Framework 포함 한 예외 대체 (fallback) 처리기 <xref:System.Text.DecoderExceptionFallback>, throw 하는 <xref:System.Text.DecoderFallbackException> 바이트를 디코딩할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value in a set operation is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default encoding for this .NET implementation.</summary>
        <value>이.NET 구현에 대 한 인코딩을 기본값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  서로 다른 컴퓨터는 기본적으로 다른 인코딩을 사용할 수 및 기본 인코딩을 단일 컴퓨터에서 변경할 수 있습니다. 사용 하는 경우는 <xref:System.Text.Encoding.Default%2A> 인코딩을 인코딩 및 디코딩 스트리밍 컴퓨터 간에 또는 동일한 컴퓨터에 서로 다른 시간에 검색 데이터를 변환할 수도 있습니다 하지 해당 데이터 정확 합니다. 또한에서 반환 된 인코딩을 <xref:System.Text.Encoding.Default%2A> 속성 최적 맞춤된 대체 (fallback)를 사용 하 여 지원 되지 않는 문자 코드 페이지에서 지원 되는 문자에 매핑합니다. 이러한 이유로, 기본 인코딩을 사용 하 여 권장 되지 않습니다. 인코딩된 바이트 디코딩되 위해이 유니코드 인코딩인와 같은 사용 해야 <xref:System.Text.UTF8Encoding> 또는 <xref:System.Text.UnicodeEncoding>합니다. 또한 인코딩 및 디코딩을 위한 동일한 형식을 사용 함을 확인 하는 상위 수준 프로토콜을 사용할 수 있습니다.  

### <a name="the-default-property-in-the-net-framework"></a>.NET Framework의 기본 속성

Windows 바탕 화면에서.NET framework에서는 <xref:System.Text.Encoding.Default%2A> 항상 시스템의 현재 코드 페이지를 가져오고 만듭니다는 <xref:System.Text.Encoding> 것에 해당 하는 개체입니다. 현재 코드 페이지에는 ASCII 문자 코드 페이지에서 함께 달라 지는 추가 문자 집합을 포함 하는 ANSI 코드 페이지를 수 있습니다. 때문에 모든 <xref:System.Text.Encoding.Default%2A> 인코딩 ANSI 코드 페이지에 따라 데이터가 손실, 사용 하는 것이 좋습니다는 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 인코딩 대신 합니다. U t F-8 동일 U + 00에서 U + 7F 범위는 주로 발생 하지만 손실 없이 ASCII 범위 밖의 문자를 인코딩할 수도 있습니다.

## <a name="the-default-property-on-net-core"></a>.NET Core에서 기본 속성

.NET core는 <xref:System.Text.Encoding.Default%2A> 속성은 항상 반환 된 <xref:System.Text.UTF8Encoding>합니다. U t F-8은 모든 운영 체제 (Windows, Linux 및 최대 OS X)에서 실행 되는.NET Core 응용 프로그램에서 지원 됩니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" /> 개체에 대한 인코더 대체 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> 개체 문자를 인코딩된 바이트 시퀀스로 변환할 수 없을 때 호출 되는 오류 처리기를 나타냅니다. 처리기 형식 중 하나로 사용할 수 있습니다.  
  
-   가장 적합된 한 대체 (fallback) 처리기 문자를 인코딩할 수 없는 일부 적절 한 대체 문자로 대체 합니다.  
  
-   교체 대체 (fallback) 처리기입니다 일부 임의의 대체 문자로 인코딩할 수 없는 문자를 바꿉니다. .NET Framework 포함 한 교체 대체 (fallback) 처리기 <xref:System.Text.EncoderFallback>를 인코딩할 수 없는 문자를 물음표로 대체는 기본적으로 ("?") 문자.  
  
-   예외 대체 (fallback) 처리기가 문자를 인코딩할 수 없는 경우 예외를 throw 하는 합니다. .NET Framework 포함 한 예외 대체 (fallback) 처리기 <xref:System.Text.EncoderExceptionFallback>, throw 하는 <xref:System.Text.EncoderFallbackException> 문자를 디코딩할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value in a set operation is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the human-readable description of the current encoding.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />에 대해 사람이 읽을 수 있는 설명입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> 속성이 표시 됩니다. 에 전달 될 수 있는 이름을 찾으려면는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드를 사용 하 여는 <xref:System.Text.Encoding.WebName%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 대 한 서로 다른 이름을 검색 하 고 다른 하나 이상의 이름의 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 하지만 것과 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to compare with the current instance.</param>
        <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 인스턴스 <xref:System.Text.Encoding> 동일한 코드 페이지에 해당 하는 경우 같은 개체로 간주 되는지 및 해당 `EncoderFallback` 및 `DecoderFallback` 개체는 동일 합니다. 특히, 모든 파생된 코드 페이지 0의 코드 페이지가 있고 해당 대체는 일반적으로 `null` (`Nothing` Visual Basic.net에서). 따라서 이러한 모두 같은 개체로 간주 되는지 서로 합니다. 결과 때 <xref:System.Text.Encoding.Equals%2A> 해시 테이블을 채우는 데 사용 됩니다, 모든 파생 인코딩이 같으며 및 동일한 해시 테이블 슬롯에 속합니다.  
  
   
  
## Examples  
 다음 예제에서는 같은 인코딩 (각각 하나) 및 다른 이름으로, 두 인스턴스를 가져오고 동일성을 검사 합니다.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</summary>
        <returns>The number of bytes produced by encoding all the characters in the specified character array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하기 위해 호출 된 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출 된 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   문자열 버전을 사용 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the set of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하기 위해 호출 된 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출 된 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   응용 프로그램의 문자열 버전을 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A> 것이 좋습니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자열 또는 문자열에 범위를 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 필요한 결과 바이트를 저장 하기 위해 호출 해야는 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출 된 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드를 사용 하기 위한 몇 가지 고려 사항입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   문자열 버전을 사용 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%2A> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하기 위해 호출 된 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출 된 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   응용 프로그램의 문자열 버전을 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A> 것이 좋습니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 3 개의 문자 배열의 문자를 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
 -or-  
  
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, encodes a set of characters into a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the characters to encode.</param>
        <summary>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어 서로게이트 쌍을 포함 하는 문자 시퀀스를 끝낼 수는 상위 서로게이트입니다. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트가 함께 사용할 수 있도록 해당 상위 서로게이트를 기억 합니다. <xref:System.Text.Encoding> 문자로 보내지며 상태를 유지 하기 위해 할 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 호출 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the characters to encode.</param>
        <summary>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어 서로게이트 쌍을 포함 하는 문자 시퀀스를 끝낼 수는 상위 서로게이트입니다. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트가 함께 사용할 수 있도록 해당 상위 서로게이트를 기억 합니다. <xref:System.Text.Encoding> 문자로 보내지며 상태를 유지 하기 위해 할 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자열 또는 문자열에 범위를 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어 서로게이트 쌍을 포함 하는 문자 시퀀스를 끝낼 수는 상위 서로게이트입니다. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트가 함께 사용할 수 있도록 해당 상위 서로게이트를 기억 합니다. <xref:System.Text.Encoding> 문자로 보내지며 상태를 유지 하기 위해 할 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 3 개의 문자 배열의 문자를 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
 -or-  
  
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">A pointer to the location at which to start writing the resulting sequence of bytes.</param>
        <param name="byteCount">The maximum number of bytes to write.</param>
        <summary>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</summary>
        <returns>The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 필요한 결과 바이트를 저장 하기 위해 호출 된 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출 된 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 는 에서제공하는개체<xref:System.Text.Encoding.GetDecoder%2A> 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어 서로게이트 쌍을 포함 하는 문자 시퀀스를 끝낼 수는 상위 서로게이트입니다. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트가 함께 사용할 수 있도록 해당 상위 서로게이트를 기억 합니다. <xref:System.Text.Encoding> 문자로 보내지며 상태를 유지 하기 위해 할 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> is less than the resulting number of bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하기 위해 호출 해야는 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출 된 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어 서로게이트 쌍을 포함 하는 문자 시퀀스를 끝낼 수는 상위 서로게이트입니다. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트가 함께 사용할 수 있도록 해당 상위 서로게이트를 기억 합니다. <xref:System.Text.Encoding> 문자로 보내지며 상태를 유지 하기 위해 할 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 3 개의 문자 배열의 문자를 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  
  
 -or-  
  
 <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  
  
 -or-  
  
 <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하기 위해 호출 해야는 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출 된 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합을 인코딩할 될 바이트 수를 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 단일 입력된 스트림 여러 변환을 처리 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 및 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱의 코드 페이지는 많은 입력된 문자를 인코딩하고 여러 번 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 시켜야 고려 하 여 유지 되는 상태 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어 서로게이트 쌍을 포함 하는 문자 시퀀스를 끝낼 수는 상위 서로게이트입니다. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트가 함께 사용할 수 있도록 해당 상위 서로게이트를 기억 합니다. <xref:System.Text.Encoding> 문자로 보내지며 상태를 유지 하기 위해 할 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 응용 프로그램에서 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히를 사용 하 여 여러 번 호출 된 몇 가지 빠른 기법을 사용 하면는 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 버전 바이트 배열을 지 원하는 것이 가장 좋습니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 하는 합니다. 스트림의 연속 인코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자열 또는 문자열에 범위를 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  
  
 -or-  
  
 <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  
  
 -or-  
  
 <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 결과 문자를 저장 하기 위해 사용 해야는 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드. 최대 배열 크기를 계산 하려면 사용할지는 <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> 메서드. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드 디코딩될, 바이트의 시퀀스의 문자 수를 확인 및 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력된 스트림에 대 한 패스가 여러 개를 처리 하는 메서드.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 및 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱 암호 해독 하는 코드 페이지에서 여러 입력된 바이트 고 여러 번 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 아마도 필요한 호출 간에 상태를 유지 관리 합니다.  
  
-   응용 프로그램에서 문자열 출력을 처리 하는 경우 사용 해야는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드가 문자열 길이 확인 하 고 해야 버퍼를 할당 되므로 약간 더 느려집니다 결과 <xref:System.String> 형식이 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출 된 몇 가지 빠른 기법을 허용 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 >를 지 원하는 문자를 출력 하는 버전 버퍼는 최상의 선택입니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 합니다. 연속 스트림의 디코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자열, 바이트의 배열에 인코딩한 다음 바이트 문자 배열을 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 필요한 결과 문자를 저장 하기 위해 사용 해야는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> 메서드 디코딩될, 바이트의 시퀀스의 문자 수를 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력된 스트림에 대 한 패스가 여러 개를 처리 하는 메서드.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 및 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱 암호 해독 하는 코드 페이지에서 여러 입력된 바이트 고 여러 번 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 아마도 필요한 호출 간에 상태를 유지 관리 합니다.  
  
-   이 사용 하도록 좋습니다 응용 프로그램에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드가 문자열 길이 확인 하 고 해야 버퍼를 할당 되므로 약간 더 느려집니다 결과 <xref:System.String> 형식이 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출 된 몇 가지 빠른 기법을 허용 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 >를 지 원하는 문자를 출력 하는 버전 버퍼는 최상의 선택입니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 합니다. 연속 스트림의 디코딩에 대 한이 메서드는 대개 최선의 선택.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하기 위해 사용 해야는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> 메서드 디코딩될, 바이트의 시퀀스의 문자 수를 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력된 스트림에 대 한 패스가 여러 개를 처리 하는 메서드.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 및 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱 암호 해독 하는 코드 페이지에서 여러 입력된 바이트 고 여러 번 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 아마도 필요한 호출 간에 상태를 유지 관리 합니다.  
  
-   이 사용 하도록 좋습니다 응용 프로그램에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드가 문자열 길이 확인 하 고 해야 버퍼를 할당 되므로 약간 더 느려집니다 결과 <xref:System.String> 형식이 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출 된 몇 가지 빠른 기법을 허용 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 >를 지 원하는 문자를 출력 하는 버전 버퍼는 최상의 선택입니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 합니다. 연속 스트림의 디코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 한 인코딩에서 다른 인코딩으로에서 문자열로 변환 합니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 다음 예제에서는 문자열을 인코딩한, 바이트의 배열에 바이트 범위 문자 배열로 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
 -or-  
  
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, decodes a sequence of bytes into a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</summary>
        <returns>A character array containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스를 문자를 가져옵니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다른 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 때문에 <xref:System.Text.Encoding> 분리 된 변환이 필요 동안 <xref:System.Text.Decoder> 단일 입력된 스트림에 대 한 패스가 여러 개를 위해 설계 되었습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩하는 데 필요한 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> 메서드 디코딩될, 바이트의 시퀀스의 문자 수를 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력된 스트림에 대 한 패스가 여러 개를 처리 하는 메서드.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 및 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱 암호 해독 하는 코드 페이지에서 여러 입력된 바이트 고 여러 번 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 것 호출 간에 상태를 유지 하기 때문에 필요가 바이트 시퀀스는 일괄 처리 될 때 중단 될 수 있습니다. (예를 들어 iso-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에서 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체를 호출 하는 있지만 <xref:System.Text.Decoder> 다음 호출에 대 한 이러한 시퀀스를 기억 합니다.)  
  
-   이 사용 하도록 좋습니다 응용 프로그램에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드가 문자열 길이 확인 하 고 해야 버퍼를 할당 되므로 약간 더 느려집니다 결과 <xref:System.String> 형식이 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출 된 몇 가지 빠른 기법을 허용 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 >를 지 원하는 문자를 출력 하는 버전 버퍼는 최상의 선택입니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 합니다. 연속 스트림의 디코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자열, 바이트의 배열에 인코딩한 다음 바이트 문자 배열을 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</summary>
        <returns>A character array containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스를 문자를 가져옵니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다른 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 때문에 <xref:System.Text.Encoding> 분리 된 변환이 필요 동안 <xref:System.Text.Decoder> 단일 입력된 스트림에 대 한 패스가 여러 개를 위해 설계 되었습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩하는 데 필요한 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> 메서드 디코딩될, 바이트의 시퀀스의 문자 수를 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력된 스트림에 대 한 패스가 여러 개를 처리 하는 메서드.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 및 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱 암호 해독 하는 코드 페이지에서 여러 입력된 바이트 고 여러 번 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 것 호출 간에 상태를 유지 하기 때문에 필요가 바이트 시퀀스는 일괄 처리 될 때 중단 될 수 있습니다. (예를 들어 iso-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에서 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체를 호출 하는 있지만 <xref:System.Text.Decoder> 다음 호출에 대 한 이러한 시퀀스를 기억 합니다.)  
  
-   이 사용 하도록 좋습니다 응용 프로그램에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드가 문자열 길이 확인 하 고 해야 버퍼를 할당 되므로 약간 더 느려집니다 결과 <xref:System.String> 형식이 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출 된 몇 가지 빠른 기법을 허용 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 >를 지 원하는 문자를 출력 하는 버전 버퍼는 최상의 선택입니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 합니다. 연속 스트림의 디코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 인코딩한, 바이트의 배열에 바이트 범위 문자 배열로 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
 -or-  
  
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">A pointer to the location at which to start writing the resulting set of characters.</param>
        <param name="charCount">The maximum number of characters to write.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</summary>
        <returns>The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 필요한 결과 문자를 저장 하기 위해 사용 해야는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스를 문자를 가져옵니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다른 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 때문에 <xref:System.Text.Encoding> 분리 된 변환이 필요 동안 <xref:System.Text.Decoder> 단일 입력된 스트림에 대 한 패스가 여러 개를 위해 설계 되었습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 는 에서제공하는개체<xref:System.Text.Encoding.GetDecoder%2A> 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩하는 데 필요한 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> 메서드 디코딩될, 바이트의 시퀀스의 문자 수를 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력된 스트림에 대 한 패스가 여러 개를 처리 하는 메서드.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 및 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱 암호 해독 하는 코드 페이지에서 여러 입력된 바이트 고 여러 번 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 것 호출 간에 상태를 유지 하기 때문에 필요가 바이트 시퀀스는 일괄 처리 될 때 중단 될 수 있습니다. (예를 들어 iso-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에서 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체를 호출 하는 있지만 <xref:System.Text.Decoder> 다음 호출에 대 한 이러한 시퀀스를 기억 합니다.)  
  
-   응용 프로그램에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드를 사용 하는 것이 좋습니다. 이 메서드가 문자열 길이 확인 하 고 해야 버퍼를 할당 되므로 약간 더 느려집니다 결과 <xref:System.String> 형식이 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출 된 몇 가지 빠른 기법을 허용 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 >를 지 원하는 문자를 출력 하는 버전 버퍼는 최상의 선택입니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 합니다. 연속 스트림의 디코딩에 대 한이 메서드는 대개 최선의 선택.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> is less than the resulting number of characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="byteIndex">The index of the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">The character array to contain the resulting set of characters.</param>
        <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</summary>
        <returns>The actual number of characters written into <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하기 위해 사용 해야는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 입력된 바이트 시퀀스에서 문자를 가져옵니다. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 다르면 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 때문에 <xref:System.Text.Encoding> 분리 된 변환이 필요 동안 <xref:System.Text.Decoder> 용인지 단일 입력된 스트림에 대 한 패스가 여러 개 있습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩하는 데 필요한 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> 메서드 디코딩될, 바이트의 시퀀스의 문자 수를 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드 불연속 변환 달리 필요는 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력된 스트림에 대 한 패스가 여러 개를 처리 하는 메서드.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 및 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 몇 가지 프로그래밍 고려 사항 사용 하기 위해 다음이 방법 중입니다.  
  
-   앱 암호 해독 하는 코드 페이지에서 여러 입력된 바이트 고 여러 번 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 것 호출 간에 상태를 유지 하기 때문에 필요가 바이트 시퀀스는 일괄 처리 될 때 중단 될 수 있습니다. (예를 들어 iso-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A >를 호출 하 고 다음의 시작 부분에 계속 [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A >를 호출 합니다. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 이러한 불완전 한 시퀀스에 대 한 대체를 호출 하는 있지만 <xref:System.Text.Decoder> 다음 호출에 대 한 이러한 시퀀스를 기억 합니다.)  
  
-   응용 프로그램에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드를 사용 하는 것이 좋습니다. 이 메서드가 문자열 길이 확인 하 고 해야 버퍼를 할당 되므로 약간 더 느려집니다 결과 <xref:System.String> 형식이 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출 된 몇 가지 빠른 기법을 허용 합니다. 그러나에는이 메서드 버전은 안전 하지 않습니다 때로는, 포인터가 필요 하므로 주의 해야 합니다.  
  
-   앱에서 많은 양의 데이터를 변환 해야 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 >를 지 원하는 문자를 출력 하는 버전 버퍼는 최상의 선택입니다.  
  
-   사용 하는 것이 좋습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작아서 경우 예외를 throw 합니다. 연속 스트림의 디코딩에 대 한이 메서드는 대개 최선의 선택.  
  
   
  
## Examples  
 다음 예제에서는 한 인코딩에서 다른 인코딩으로에서 문자열로 변환 합니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 다음 예제에서는 문자열을 인코딩한, 바이트의 배열에 바이트 범위 문자 배열로 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  
  
 -or-  
  
 <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.  
  
 -or-  
  
 <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.  
  
 -or-  
  
 <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 메서드 순차 바이트 블록을 유사한 방식으로 문자의 순차 블록 변환는 <xref:System.Text.Encoding.GetChars%2A> 이 클래스의 메서드. 그러나 한 <xref:System.Text.Decoder> 블록으로 확장 되는 바이트 시퀀스를 디코딩하고 올바르게 있도록 호출 간의 상태 정보를 관리 합니다. <xref:System.Text.Decoder> 또한 데이터 블록의 끝에 후행 바이트를 보존 하 고 다음 디코딩 작업에서 후행 바이트를 사용 합니다. 따라서 <xref:System.Text.Encoding.GetDecoder%2A> 및 <xref:System.Text.Encoding.GetEncoder%2A> 는 전체 데이터 스트림 하는 대신 데이터 블록을 처리 하기 때문에 네트워크 전송 및 파일 작업에 유용 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>기본 구현은 반환 하는 <see cref="T:System.Text.Decoder" /> 를 호출 하는 <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> 및 <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> 현재 메서드 <see cref="T:System.Text.Encoding" />합니다. 반환 하려면이 메서드를 재정의 해야는 <see cref="T:System.Text.Decoder" /> 을 호출 간에 상태를 유지 관리 합니다.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드 문자의 순차 블록 순차 블록의 바이트 유사한 방식으로 변환 된 <xref:System.Text.Encoding.GetBytes%2A> 이 클래스의 메서드. 그러나 한 <xref:System.Text.Encoder> 블록으로 확장 되는 문자 시퀀스 올바르게 인코딩하기 호출 간의 상태 정보를 관리 합니다. <xref:System.Text.Encoder> 또한 전처리 후행 데이터 블록의 끝에 문자 하 고 다음 인코딩 작업에 후행 문자를 사용 합니다. 예를 들어 데이터 블록 짝이 맞지 않는 상위 서로게이트를 마무리할 수 있습니다 및 다음 데이터 블록에 일치 하는 하위 서로게이트 있을 수 있습니다. 따라서 <xref:System.Text.Encoding.GetDecoder%2A> 및 <xref:System.Text.Encoding.GetEncoder%2A> 는 전체 데이터 스트림 하는 대신 데이터 블록을 처리 하기 때문에 네트워크 전송 및 파일 작업에 유용 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>기본 구현은 반환 하는 <see cref="T:System.Text.Encoder" /> 를 호출 하는 <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> 및 <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> 현재 메서드 <see cref="T:System.Text.Encoding" />합니다. 반환 하려면이 메서드를 재정의 해야는 <see cref="T:System.Text.Encoder" /> 을 호출 간에 상태를 유지 관리 합니다.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an encoding for the specified code page.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.  
  
 -or-  
  
 0 (zero), to use the default encoding.</param>
        <summary>Returns the encoding associated with the specified code page identifier.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대체 (fallback) 처리기의 인코딩 형식에 따라 달라 집니다 `codepage`합니다. 경우 `codepage` 코드 페이지 또는 더블 바이트 문자 집합 (DBCS) 인코딩을, 최적 맞춤된 대체 (fallback) 처리기가 사용 됩니다. 그렇지 않은 경우 대체 하는 대체 (fallback) 처리기가 사용 됩니다. 이러한 대체 (fallback) 처리기를 앱에 대 한 적절 한 수 있습니다. 으로 지정 된 인코딩을 사용 하는 대체 (fallback) 처리기를 지정 하려면 `codepage`를 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 오버 로드 합니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하기 위해 기본 플랫폼에 의존 합니다. 그러나.NET Framework는 기본적으로 일부 인코딩을 지원 합니다. 목록이 코드 페이지에 대 한 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져올 메서드를 <xref:System.Text.EncodingInfo> 모든 인코딩에 대 한 정보를 포함 하는 개체입니다.  
  
 기본적으로 특정 플랫폼 버전의.NET Framework에서 지원 되는 인코딩은 외에 <xref:System.Text.Encoding.GetEncoding%2A> 메서드를 등록 하 여 사용할 수 있는 모든 추가 인코딩을 반환는 <xref:System.Text.EncodingProvider> 개체입니다. 인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체의 경우이 메서드가 등록 마지막 하나를 반환 합니다.  

0에 대 한 값을 제공할 수도 있습니다는 `codepage` 인수입니다. 정확한 동작은 해당 여부 모든 인코딩 적용 된 사용 가능한 등록 하 여에 따라 프로그램 <xref:System.Text.EncodingProvider> 개체:

- 하나 이상의 인코딩 공급자를 등록 한 경우 마지막으로 인코딩 시기를 반환 하도록 선택 했습니다 등록 된 공급자의 인코딩을 반환 된 <xref:System.Text.Encoding.GetEncoding%2A> 메서드에 전달 됩니다는 `codepage` 0의 인수입니다.     

- .NET Framework에서 인코딩 없이 경우 공급자가 등록을 하는 경우는 <xref:System.Text.CodePagesEncodingProvider> 등록 된 인코딩 공급자가 등록 된 인코딩 공급자가 없습니다 처리 하는 경우 또는 `codepage` 값 운영 체제의 현재 코드 페이지 0을 반환 합니다. Windows 시스템에서 현재 코드 페이지를 확인 하려면 Windows 호출 [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows 바탕 화면에서.NET Framework에서 함수입니다.

- .NET Core를 인코딩 공급자가 등록 또는 등록 된 없는 인코딩 공급자를 처리 하는 경우에 없는 경우에 `codepage` 값 0을 반환 된 <xref:System.Text.UTF8Encoding>합니다.
  
> [!NOTE]
>  일부 지원 되지 않는 코드 페이지 원인은 <xref:System.ArgumentException> throw 될 다른 반면는 <xref:System.NotSupportedException>합니다. 따라서 코드 모든 catch 해야 예외 섹션에 표시 된 예외입니다.  
  
> [!NOTE]
>  ANSI 코드 페이지에는 서로 다른 컴퓨터에서 서로 다를 수와 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다. 이 경우 현재 코드 페이지는 ANSI 코드 페이지 인코딩 및 디코딩하는 기본 코드 페이지를 사용 하 여 데이터 반환 `Encoding.GetEncoding(0)` 권장 되지 않습니다. 가장 일관 된 결과 유니코드 인코딩인 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고와 같은 특정 코드 페이지 대신 사용 해야 합니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정으로 캐시 된 인스턴스를 반환합니다. 다른 설정을 사용 하 여 인스턴스를 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어는 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  

   
  
## Examples  
 다음 예제에서는 같은 인코딩 (코드 페이지에서 하나) 및 다른 이름으로, 두 인스턴스를 가져오고 동일성을 검사 합니다.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> is less than zero or greater than 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <summary>Returns the encoding associated with the specified code page name.</summary>
        <returns>The encoding  associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대체 (fallback) 처리기의 인코딩 형식에 따라 달라 집니다 `name`합니다. 경우 `name` 코드 페이지 또는 더블 바이트 문자 집합 (DBCS) 인코딩을, 최적 맞춤된 대체 (fallback) 처리기가 사용 됩니다. 그렇지 않은 경우 대체 하는 대체 (fallback) 처리기가 사용 됩니다. 이러한 대체 (fallback) 처리기를 앱에 대 한 적절 한 수 있습니다. 으로 지정 된 인코딩을 사용 하는 대체 (fallback) 처리기를 지정 하려면 `name`를 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 오버 로드 합니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하기 위해 기본 플랫폼에 의존 합니다. 그러나.NET Framework는 기본적으로 일부 인코딩을 지원 합니다. 목록이 코드 페이지에 대 한 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져올 메서드를 <xref:System.Text.EncodingInfo> 모든 인코딩에 대 한 정보를 포함 하는 개체입니다. 
  
 기본적으로 특정 플랫폼 버전의.NET Framework에서 지원 되는 인코딩은 외에 <xref:System.Text.Encoding.GetEncoding%2A> 메서드를 등록 하 여 사용할 수 있는 모든 추가 인코딩을 반환는 <xref:System.Text.EncodingProvider> 개체입니다. 인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체의 경우이 메서드가 등록 마지막 하나를 반환 합니다.  
   
> [!NOTE]
>  ANSI 코드 페이지는 서로 다른 컴퓨터에 서로 다를 수 또는 데이터가 손상, 단일 컴퓨터에 대 한 변경할 수 있습니다. 가장 일관 된 결과 대 한 특정 코드 페이지 대신 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고와 같은 유니코드를 사용 해야 합니다.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정으로 캐시 된 인스턴스를 반환합니다. 다른 설정을 사용 하 여 인스턴스를 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어는 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  
  
## Examples  
 다음 예제에서는 같은 인코딩 (코드 페이지에서 하나) 및 다른 이름으로, 두 인스턴스를 가져오고 동일성을 검사 합니다.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid code page name.  
  
 -or-  
  
 The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.  
  
 -or-  
  
 0 (zero), to use the default encoding.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  일부 지원 되지 않는 코드 페이지는 예외를 발생 시킬 <xref:System.ArgumentException> throw 될 다른 반면 <xref:System.NotSupportedException>합니다. 따라서 코드 모든 catch 해야 예외 섹션에 표시 된 예외입니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하기 위해 기본 플랫폼에 의존 합니다. 그러나.NET Framework는 기본적으로 일부 인코딩을 지원 합니다. 목록이 코드 페이지에 대 한 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncodings%2A> 모든 인코딩 목록을 가져오려면 Windows 바탕 화면에서 전체.NET Framework에서 메서드.   
  
 기본적으로 특정 플랫폼 버전의.NET Framework에서 지원 되는 인코딩은 외에 <xref:System.Text.Encoding.GetEncoding%2A> 메서드를 등록 하 여 사용할 수 있는 모든 추가 인코딩을 반환는 <xref:System.Text.EncodingProvider> 개체입니다.  인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체의 경우이 메서드가 등록 마지막 하나를 반환 합니다.  

0에 대 한 값을 제공할 수도 있습니다는 `codepage` 인수입니다. 정확한 동작은 해당 여부 모든 인코딩 적용 된 사용 가능한 등록 하 여에 따라 프로그램 <xref:System.Text.EncodingProvider> 개체:

- 하나 이상의 인코딩 공급자를 등록 한 경우 마지막으로 인코딩 시기를 반환 하도록 선택 했습니다 등록 된 공급자의 인코딩을 반환 된 <xref:System.Text.Encoding.GetEncoding%2A> 메서드에 전달 됩니다는 `codepage` 0의 인수입니다.     

- .NET Framework에서 인코딩 없이 경우 공급자가 등록을 하는 경우는 <xref:System.Text.CodePagesEncodingProvider> 등록 된 인코딩 공급자가 등록 된 인코딩 공급자가 없습니다 처리 하는 경우 또는 `codepage` 값 현재 코드 페이지 0을 반환 합니다.

- .NET Core를 인코딩 공급자가 등록 또는 등록 된 없는 인코딩 공급자를 처리 하는 경우에 없는 경우에 `codepage` 값 0을 반환 된 <xref:System.Text.UTF8Encoding> 인코딩.

> [!NOTE]
>  ANSI 코드 페이지에는 서로 다른 컴퓨터에서 서로 다를 수와 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다. 이 경우 현재 코드 페이지는 ANSI 코드 페이지 인코딩 및 디코딩하는 기본 코드 페이지를 사용 하 여 데이터 반환 `Encoding.GetEncoding(0)` 권장 되지 않습니다. 가장 일관 된 결과 대 한 특정 코드 페이지 대신 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고와 같은 유니코드를 사용 해야 합니다. 
  
 현재 코드 페이지와 관련 된 인코딩을 얻기 위해 제공할 수 있습니다 하거나 값 0에 대 한는 `codepage` 인수 또는 Windows 바탕 화면에서 전체.NET Framework에서 코드를 실행 하는 경우의 값을 검색 합니다.는 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 속성입니다. 현재 활성 코드 페이지를 확인 하려면 Windows 호출 [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows 바탕 화면에서.NET Framework에서 함수입니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정으로 캐시 된 인스턴스를 반환합니다. 다른 설정을 사용 하 여 인스턴스를 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어는 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> is less than zero or greater than 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하기 위해 기본 플랫폼에 의존 합니다. 그러나.NET Framework는 기본적으로 일부 인코딩을 지원 합니다.  
  
 기본적으로 특정 플랫폼 버전의.NET Framework에서 지원 되는 인코딩은 외에 <xref:System.Text.Encoding.GetEncoding%2A> 메서드를 등록 하 여 사용할 수 있는 모든 추가 인코딩을 반환는 <xref:System.Text.EncodingProvider> 개체입니다. 인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체의 경우이 메서드가 등록 마지막 하나를 반환 합니다. 
  
> [!NOTE]
>  ANSI 코드 페이지에는 서로 다른 컴퓨터에서 서로 다를 수와 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다. 가장 일관 된 결과 유니코드 인코딩인 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고와 같은 특정 코드 페이지 대신 사용 해야 합니다.  
  
 목록이 코드 페이지에 대 한 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncodings%2A> 모든 인코딩 목록을 가져오려면 Windows 바탕 화면에서 전체.NET Framework에서 메서드.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정으로 캐시 된 인스턴스를 반환합니다. 다른 설정을 사용 하 여 인스턴스를 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어는 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid code page name.  
  
 -or-  
  
 The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array that contains all encodings.</summary>
        <returns>An array that contains all encodings.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코드 페이지에 의해 고유 하 게 구분 하는 지원 되는 인코딩 목록을 반환 합니다. 지원 되는 인코딩 나열 하는 테이블에 대 한 참조는 <xref:System.Text.Encoding> 클래스 항목입니다.  
  
> [!NOTE]
>  반환 된 지원 되는 인코딩 목록은 <xref:System.Text.Encoding.GetEncodings%2A> 메서드는 사용할 수 있는 모든 추가 모든 인코딩을 포함 하지 <xref:System.Text.EncodingProvider> 를 호출 하 여 등록 된 구현이 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드.  
  
 인코딩 50220과 50222는 "iso-2022-jp", name과 관련 된 모두 있지만 같지는있지 않습니다. 인코딩 50220 전자 가타카나 문자를 가타카나 문자를 변환, 인코딩 50222 반면 반자 가타카나 문자를 인코딩하는 데 시프트 인/시프트 아웃 시퀀스를 사용 합니다. 50222 인코딩에 대 한 표시 이름은 "일본어 (Jis-allow 1 byte Kana-따라서 / SI)" 인코딩에서 구분 하기 위해 50220가 표시 이름을 "일본어 (JIS)"입니다.  
  
 요청 된 인코딩 이름 "iso-2022-jp", 인코딩 50220.NET Framework 반환 합니다. 그러나 응용 프로그램에 적합 한 인코딩을에 따라 다름 반자 가타카나 문자 기본 처리  
  
 특정 인코딩의 가져오려면 사용할지는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> 경우에 따라 사용자 파일에 인코딩 목록을 표시 하는 데 사용은 **다른 이름으로 저장** 대화 상자. 그러나 많은 비유니코드 인코딩에서 하나 불완전 한 많은 문자를 및 "?", 또는 서로 다른 플랫폼에서 약간 다른 동작을 내포 합니다. 기본값으로 utf-8 또는 u t F-16을 사용 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩의 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current instance.</summary>
        <returns>The hash code for the current instance.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</summary>
        <returns>The maximum number of bytes produced by encoding the specified number of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount` 매개 변수 개수를 실제로 지정 <xref:System.Char> .NET Framework 유니코드 문자를 나타내기 위해 u t F-16을 내부적으로 사용 하기 때문에 인코딩할 유니코드 문자를 나타내는 개체입니다. 대부분의 유니코드 문자를 1 씩 나타낼 수 따라서 <xref:System.Char> 개체가 아니라 예를 들어 서로게이트 쌍으로 표시 되는 유니코드 문자는 두 개가 필요 <xref:System.Char> 개체입니다.  
  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하기 위해 사용 해야는 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 현재 선택 된 최악의 경우를 포함 하 여 최악의 수를 검색 <xref:System.Text.EncoderFallback>합니다. 잠재적으로 큰 문자열로 대체를 선택한 경우 <xref:System.Text.Encoding.GetMaxByteCount%2A> 있는 최악의 경우 인코딩을 하는 것에 대 한 전환 해야 하는 모든 문자에 대 한 모드의 경우에 특히 큰 값을 검색 합니다. 예를 들어 ISO-2022-JP에 대 한이 발생할 수 있습니다. 자세한 내용은 블로그 항목을 참조 하십시오. "[Encoding.GetMaxByteCount() 및 Encoding.GetMaxCharCount() 이란?](http://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 대부분의 경우가이 메서드는 작은 문자열에 대 한 적절 한 값을 검색합니다. 큰 문자열에 대 한 매우 큰 버퍼를 사용 하 여 보다 적절 한 크기의 버퍼가 너무 작아서 드문 경우에서 오류를 catch 및 중 하나를 선택 해야 합니다. 사용 하 여 다른 접근 방식을 고려해 야 할 수도 있습니다 <xref:System.Text.Encoding.GetByteCount%2A> 또는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>합니다.  
  
 사용 하는 경우 <xref:System.Text.Encoding.GetMaxByteCount%2A>입력된 버퍼의 최대 크기에 따라 출력 버퍼를 할당 해야 합니다. 출력 버퍼는 크기가 제한 하는 경우 사용할 수 있습니다는 <xref:System.Text.Encoding.Convert%2A> 메서드.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 디코더 이전 작업에서 잠재적인 남겨진 서로게이트를 고려 합니다. 디코더를 때문에 인코딩에 대해 2 개의 바이트를 ASCII와 같은 검색 값이 1 메서드에 전달 합니다. 사용 해야는 <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> 이 정보는 필요한 경우 속성을 사용 합니다.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 와 같은 값은 반드시 `N* GetMaxByteCount(1)`합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>모든 <see cref="T:System.Text.Encoding" /> 버퍼 오버플로 예외가 발생 하지 않는지 버퍼는이 메서드의 계산 결과 따라 크기가 결정 하는 경우 구현 보장 해야 합니다.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</summary>
        <returns>The maximum number of characters produced by decoding the specified number of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하기 위해 사용 해야는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 현재 선택 된 최악의 경우를 포함 하 여 최악의 수를 검색 <xref:System.Text.DecoderFallback>합니다. 잠재적으로 큰 문자열로 대체를 선택한 경우 <xref:System.Text.Encoding.GetMaxCharCount%2A> 큰 값을 검색 합니다.  
  
 대부분의 경우가이 메서드는 작은 문자열에 대해 적합 한 숫자를 검색합니다. 큰 문자열에 대 한 매우 큰 버퍼를 사용 하 여 보다 적절 한 크기의 버퍼가 너무 작아서 드문 경우 오류를 catch 및 중 하나를 선택 해야 합니다. 사용 하 여 다른 접근 방식을 고려해 야 할 수도 있습니다 <xref:System.Text.Encoding.GetCharCount%2A> 또는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 관계가 없으며 <xref:System.Text.Encoding.GetBytes%2A>합니다. 비슷한 기능을 사용 해야 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>를 사용 해야 <xref:System.Text.Encoding.GetMaxByteCount%2A>합니다.  
  
 사용 하는 경우 <xref:System.Text.Encoding.GetMaxCharCount%2A>입력된 버퍼의 최대 크기에 따라 출력 버퍼를 할당 해야 합니다. 출력 버퍼는 크기가 제한 하는 경우 사용할 수 있습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 이전 인코더 작업에서 남은 바이트에 대 한 최악의 경우를 고려 합니다. 대부분의 코드 페이지에 대 한 값을 1 보다 크거나 검색 값이 0이이 메서드에 전달 합니다.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 와 같은 값은 반드시 `N* GetMaxCharCount(1)`합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열, 바이트의 배열에 인코딩한 다음 바이트 문자 배열을 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>모든 <see cref="T:System.Text.Encoding" /> 버퍼 오버플로 예외가 발생 하지 않는지 버퍼는이 메서드의 계산 결과 따라 크기가 결정 하는 경우 구현 보장 해야 합니다.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</summary>
        <returns>A byte array containing a sequence of bytes that specifies the encoding used.  
  
 -or-  
  
 A byte array of length zero, if a preamble is not required.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요에 따라는 <xref:System.Text.Encoding> 개체 인코딩 프로세스에서 발생 하는 바이트 시퀀스에 접두어로 추가 될 수 있는 바이트 배열 프리앰블을 제공 합니다. 프리앰블 (유니코드 코드 포인트 U + FEFF)에서 바이트 순서 표시를 디코더에서 바이트 순서 및 변환 형식 또는 u t F를 결정 하는 데 도움이 됩니다.  
  
 유니코드 바이트 순서 표시 (BOM) (16 진수)에서 다음과 같이 serialize 됩니다.  
  
-   U T F-8: EF BB BF  
  
-   Utf-16 big endian 바이트 순서: FE FF  
  
-   Utf-16 little endian 바이트 순서: FF FE  
  
-   U t F-32 big endian 바이트 순서: 00 00 FE FF  
  
-   U t F-32 little endian 바이트 순서: FF FE 00 00  
  
 파일에는 다른 방법에 대 한 참조를 손실 했는 인코딩 특정 식별 거의 제공 하기 때문에 BOM을 사용 해야는 <xref:System.Text.Encoding> 개체 예를 들어 태그 없음 또는 웹 데이터 태그가 잘못 지정 되었거나 또는 임의 텍스트 파일 때 비즈니스 저장 하지 않았습니다. 국제 문제 또는 기타 데이터를가지고 있습니다. 데이터 일관 되 고 적절히 태그가 지정 됩니다, 가급적 utf-8 또는 u t F-16에서 종종 사용자 문제를 방지할 수 있는 합니다.  
  
 인코딩 형식을 제공 하는 표준, BOM은 중복 되는 부분이입니다. 그러나 올바른 인코딩 헤더를 보낼 서버를 사용할 수 있습니다. 또는 사용할 수 있습니다는 대체 방식으로 인코딩이 그렇지 않은 경우 손실 된 경우.  
  
 BOM을 사용 하 여 몇 가지 단점이 있습니다. 예를 들어 BOM을 사용 하는 데이터베이스 필드를 제한 하는 방법을 알아 두어야 어려울 수 있습니다. 파일의 연결 문제가 될 수 또한 예를 들어 파일을 병합 될 때 데이터 중간에 불필요 한 문자가 포함 될 수 있도록 합니다. 그러나 몇 가지 단점 있음에도 불구 하 고 BOM 사용 하는 가장 좋습니다.  
  
 바이트 순서 및 바이트 순서 표시에 대 한 자세한 내용은 유니코드 표준을 참조는 [유니코드 홈페이지](http://go.microsoft.com/fwlink/?LinkId=37123)합니다.  
  
> [!CAUTION]
>  인코딩된 바이트 제대로 디코딩을 보장 하려면 인코딩된 바이트가 고 프리앰블이 붙여야 합니다. 그러나 대부분의 인코딩 프리앰블이 제공 하지 않습니다. 인코딩된 바이트 제대로 디코딩, 사용할지 유니코드 인코딩을 즉, 않도록 하기 위해 <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, 또는 <xref:System.Text.UTF32Encoding>, 앞에 프리앰블을 합니다.  
  
   
  
## Examples  
 다음 예제에서는 프리앰블에 따라 인코딩과 바이트 순서를 결정 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, decodes a sequence of bytes into a string.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 에서 반환 된 개체는 <xref:System.Text.Encoding.GetDecoder%2A> 는 deri 메서드 ved 클래스입니다.  
  
 설명 섹션을 참조는 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 내용은 대 한 참조 항목입니다.  
  
 정확한 동작은 <xref:System.Text.Encoding.GetString%2A> 특정 메서드 <xref:System.Text.Encoding> 구현 하는 대해 정의 된 대체 (fallback) 전략에 따라 달라 집니다 <xref:System.Text.Encoding> 개체입니다. 자세한 내용은의 "대체 (fallback) 전략 선택" 섹션을 참조 하십시오.는 [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 항목입니다.  
  
   
  
## Examples  
 다음 예제에서는 u t F-8로 인코딩된 문자열을 나타내는 이진 파일에서 읽습니다는 <xref:System.IO.FileStream> 개체입니다. 2, 048 바이트 보다 작은 파일을 호출 하는 바이트 배열에는 전체 파일의 내용을 읽습니다는 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> 메서드 디코딩을 수행 하도록 합니다. 더 큰 파일에 대 한 바이트를 읽습니다 2, 048 한 번에 호출 바이트 배열로 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자 개수를 확인 하는 배열에 포함 되 고 다음 호출에서 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 디코딩을 수행 하는 메서드.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 이 예제에서는 Utf8Example.txt 라는 u t F-8로 인코딩된 파일을 저장 해야 하는 다음 텍스트를 사용 합니다.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The byte array contains invalid Unicode code points.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to a byte array.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> 메서드는 네이티브 포인터는 바이트 배열에 있는 경우 성능을 최적화 하기 위해 디자인 되었습니다. 관리 되는 바이트 배열을 만든 다음 암호를 인코딩한 하는 대신 중간 개체를 만들지 않고 대신이 메서드를 호출할 수 있습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 에서 반환 된 개체는 <xref:System.Text.Encoding.GetDecoder%2A> 는 deri 메서드 ved 클래스입니다.  
  
 설명 섹션을 참조는 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 내용은 대 한 참조 항목입니다.  
  
 정확한 동작은 <xref:System.Text.Encoding.GetString%2A> 특정 메서드 <xref:System.Text.Encoding> 구현 하는 대해 정의 된 대체 (fallback) 전략에 따라 달라 집니다 <xref:System.Text.Encoding> 개체입니다. 자세한 내용은의 "대체 (fallback) 전략 선택" 섹션을 참조 하십시오.는 [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 항목입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is a null pointer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A   fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 되는 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 설명 섹션을 참조는 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 내용은 대 한 참조 항목입니다.  
  
   
  
## Examples  
 다음 예제에서는 u t F-8로 인코딩된 문자열을 나타내는 이진 파일에서 읽습니다는 <xref:System.IO.FileStream> 개체입니다. 2, 048 바이트 보다 작은 파일을 호출 하는 바이트 배열에는 전체 파일의 내용을 읽습니다는 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 디코딩을 수행 하도록 합니다. 더 큰 파일에 대 한 바이트를 읽습니다 2, 048 한 번에 호출 바이트 배열로 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자 개수를 확인 하는 배열에 포함 되 고 다음 호출에서 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 디코딩을 수행 하는 메서드.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 이 예제에서는 Utf8Example.txt 라는 u t F-8로 인코딩된 파일을 저장 해야 하는 다음 텍스트를 사용 합니다.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The byte array contains invalid Unicode code points.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
 -or-  
  
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  
  
 -and-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</summary>
        <value>메일 에이전트 헤더 태그에 사용할 현재 <see cref="T:System.Text.Encoding" />의 이름입니다.  
  
 또는  
  
 현재 <see cref="T:System.Text.Encoding" />을 사용할 수 없으면 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 헤더 이름에 대 한 인코딩을 해야 하는 경우 호출 해야는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 <xref:System.Text.Encoding.HeaderName%2A> 속성입니다. 종종 메서드 호출에 제공 된 테스트 인코딩과에서 다른 인코딩을 검색 합니다. 일반적으로 전자 메일 응용 프로그램만 그러한 인코딩을 검색 해야 합니다.  
  
 일부 경우의 값에는 <xref:System.Text.Encoding.BodyName%2A> 속성은 해당 인코딩을 정의 하는 국제 표준에 해당 합니다. 표준에 포함 하 여 전체에서 구현 따르는지 하는 것은 아닙니다.  
  
 <xref:System.Text.Encoding.WebName%2A> 인코딩을 설명 하는 데 이름을 반환 합니다. <xref:System.Text.Encoding.HeaderName%2A> 더 적합할 수 있는 전자 메일 응용 프로그램에 대 한 예를 들어 다른 인코딩을 속성을 정의 합니다. 그러나 인코딩을 정의 하는 속성의 사용은 권장 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 대 한 서로 다른 이름을 검색 하 고 다른 하나 이상의 이름의 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 하지만 것과 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a value indicating whether the current encoding is always normalized.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</summary>
        <returns>
          <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 정규화 형식을 <xref:System.Text.NormalizationForm.FormC>, 변수로 바뀐 기본 합성을 사용 하 여 시퀀스의 다음 가능한 경우 완전 한 정규 분해를 사용 하 여 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">One of the <see cref="T:System.Text.NormalizationForm" /> values.</param>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</summary>
        <returns>
          <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 정규화 형식을 <xref:System.Text.NormalizationForm.FormC>, 변수로 바뀐 기본 합성을 사용 하 여 시퀀스의 다음 가능한 경우 완전 한 정규 분해를 사용 하 여 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</summary>
        <value>
          현재 <see langword="true" />을 브라우저 클라이언트가 내용을 표시하는 데 사용할 수 있으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩의 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</summary>
        <value>
          현재 <see langword="true" />을 브라우저 클라이언트가 내용을 저장하는 데 사용할 수 있으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩의 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</summary>
        <value>
          현재 <see langword="true" />을 메일 및 뉴스 클라이언트가 내용을 표시하는 데 사용할 수 있으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩의 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</summary>
        <value>
          현재 <see langword="true" />을 메일 및 뉴스 클라이언트가 내용을 저장하는 데 사용할 수 있으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩의 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</summary>
        <value>
          현재 <see langword="true" />가 읽기 전용이면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</summary>
        <value>
          현재 <see langword="true" />이 단일 바이트 코드 포인트를 사용하면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 단일 바이트에 대 한 인코딩, 예를 들어 <xref:System.Text.ASCIIEncoding>,이 속성을 검색 `true`합니다.  
  
> [!CAUTION]
>  응용 프로그램에 대 한 값으로 수행 하는 작업에 주의 해야 <xref:System.Text.Encoding.IsSingleByte%2A>합니다. 인코딩 됩니다 진행 하는 방법을 이라는 가정을 잘못 일 수 있습니다. 예를 들어 windows-1252 값을이 `true` 에 대 한 <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, 하지만 Encoding.GetMaxByteCount(1) 2를 반환 합니다. 메서드가 이전 디코더 작업에서 남겨진 서로게이트를 잠재적으로 간주 하기 때문입니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩의 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</param>
        <summary>Registers an encoding provider.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A> 방법에서 파생 된 클래스를 등록할 수 있도록 <xref:System.Text.EncodingProvider> 는 그렇지 않은 경우 지원 되지 않는 플랫폼에서 사용할 수 있는 인코딩 문자는 합니다. 지원 되는 인코딩은 하나를 호출 하 여 검색할 수 인코딩 공급자 등록 되 면 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 오버 로드 합니다. 여러 인코딩 공급자가 하는 경우는 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 메서드 가장 최근에 등록부터 각 공급자에서 지정 된 인코딩을 검색 하려고 시도 합니다.

인코딩 공급자를 사용 하 여 등록는 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드도의 동작을 수정 하는 [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) 및 [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) 메서드 인수 전달 될 때 `0`:

- 등록 된 공급자가는 <xref:System.Text.CodePagesEncodingProvider>, 메서드는 Windows 운영 체제에서 실행할 때 시스템 활성 코드 페이지와 일치 하는 인코딩을 반환 합니다.

- 사용자 지정 인코딩 공급자 때 반환 되도록 인코딩을 선택할 수 이러한 <xref:System.Text.Encoding.GetEncoding%2A> 의 인수를 전달 하는 메서드 오버 로드는 `0`합니다. 공급자 함으로써 인코딩을 반환 되지 않도록 선택할 수도 <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> 메서드 반환 `null`합니다. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] 하나의 인코딩 공급자가 포함 되어 <xref:System.Text.CodePagesEncodingProvider>, 사용할 수 있는 전체.NET Framework에 있는 하지만에서 사용할 수 없는 인코딩 지도록 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]합니다. 기본적으로 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] 유니코드 인코딩, ASCII, 및 코드 페이지 28591 지원 합니다.  
  
 동일한 인코딩 공급자에 대 한 여러 호출에 사용 되 면는 <xref:System.Text.Encoding.RegisterProvider%2A> 공급자를 등록 하는 메서드를 첫 번째 메서드 호출 합니다. 후속 호출은 무시 됩니다.  
  
 경우는 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드 같은 인코딩을 처리 하는 여러 공급자를 등록 하는, 마지막으로 등록 된 공급자는 모든 인코딩 및 디코딩 작업에 대 한 사용 합니다. 이전에 등록 된 공급자는 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-16 format using the little endian byte order.</summary>
        <value>little-endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework와 인코딩을 사용 하는 유니코드에 대 한 내용은에서 지 원하는 인코딩에 대 한 정보를 참조 하십시오. [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
 <xref:System.Text.UnicodeEncoding> 이 속성에서 반환 되는 개체는 응용 프로그램에 대 한 적절 한 동작을 없을 수 있습니다. 교체 대체 (fallback)를 사용 하 여 인코딩할 수 없는 각 문자열과 디코딩할 수 없는 각 바이트를 물음표로 바꿉니다 ("?") 문자. 대신, 호출 수는 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 를 little endian 인스턴스화하는 생성자 <xref:System.Text.UnicodeEncoding> 하나 대체가 개체는 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-32 format using the little endian byte order.</summary>
        <value>little-endian 바이트 순서를 사용하는 UTF-32 형식에 대한 인코딩 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> 이 속성에서 반환 되는 개체는 응용 프로그램에 대 한 적절 한 동작을 없을 수 있습니다. 교체 대체 (fallback)를 사용 하 여 유니코드 REPLACEMENT CHARACTER (U + FFFE)으로 인코딩할 수 없는 각 문자열과 디코딩할 수 없는 각 바이트를 대체 합니다. 대신, 호출 수는 <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 를 인스턴스화하는 생성자는 <xref:System.Text.UTF32Encoding> 하나 대체가 개체는 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Little endian 바이트 순서의 논의 알려면는 <xref:System.Text.Encoding> 클래스 항목입니다.  
  
 .NET Framework와 인코딩을 사용 하는 유니코드에 대 한 내용은에서 지 원하는 인코딩에 대 한 정보를 참조 하십시오. [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-7 format.</summary>
        <value>UTF-7 형식에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utf-7 인코딩은 지금까지 제한 한 NNTP 같은 7 비트와 일부 전자 메일 응용 프로그램에는 환경에서 주로 사용 됩니다. 안정성 및 보안 문제 때문에 사용 하지 않아야 UTF7 8 비트 환경에서 인코딩 utf-8 인코딩을 사용 될 수 있는 대신 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 하 고 문자를 인코딩한 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-8 format.</summary>
        <value>UTF-8 형식에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 된 <xref:System.Text.UTF8Encoding> 문자당 1-4 바이트의 시퀀스를 유니코드 문자 (u t F-16으로 인코딩된) 인코딩한 유니코드 문자 (u t F-16으로 인코딩된)에 u t F-8로 인코딩된 바이트 배열을 디코딩합니다 하는 개체입니다. .NET Framework 및 인코딩을 사용 하는 유니코드에 대 한 내용은 지 원하는 문자 인코딩의 대 한 정보를 참조 하십시오. [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
 <xref:System.Text.UTF8Encoding> 이 속성에서 반환 되는 개체는 응용 프로그램에 대 한 적절 한 동작을 없을 수 있습니다.  
  
-   반환 된 <xref:System.Text.UTF8Encoding> (BOM) 유니코드 바이트 순서 표시를 제공 하는 개체입니다. BOM을 제공 되지 않는 UTF8 인코딩를 인스턴스화하고 호출의 오버 로드는 <xref:System.Text.UTF8Encoding.%23ctor%2A> 생성자입니다.  
  
-   반환 된 <xref:System.Text.UTF8Encoding> 교체 대체 (fallback)를 사용 하 여 물음표로 인코딩할 수 없는 각 문자열과 디코딩할 수 없는 각 바이트를 대체 하는 개체 ("?") 문자. 대신, 호출 수는 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 를 인스턴스화하는 생성자는 <xref:System.Text.UTF8Encoding> 하나 대체가 개체는 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이 합니다.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 다음 예제에서는 다음 문자로 구성 된 배열을 정의 합니다.  
  
-   라틴어 소문자 Z (U + 007A)  
  
-   라틴어 소문자 문자는 (U + 0061)  
  
-   결합 리브 (U + 0306)  
  
-   예 (U + 01FD)와 영문 소문자 AE  
  
-   그리스어 소문자 베타 (U + 03B2)  
  
-   서로게이트 쌍 (U + d 800부터 U + DD54) 그리스어 ACROPHONIC ATTIC 한 천 STATERS (U + 10154)을 형성 하 합니다.  
  
 각 문자의 utf-16 코드 단위를 표시 하 고 u t F-8 인코더에 의해 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 합니다. 다음 문자는 인코딩하고 결과 u t F-8로 인코딩된 바이트 수를 표시 합니다.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />에 대한 IANA 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A> 속성은 동일는 <xref:System.Text.EncodingInfo.Name%2A> 속성입니다.  
  
 <xref:System.Text.Encoding.WebName%2A> 인코딩의 IANA에 등록 된 이름을 반환 합니다. 해당 값은 표준의 이름, 인코딩 구현 표준에 대 한 전체에서 따르지 않을 수도 있습니다. <xref:System.Text.Encoding.HeaderName%2A> 전자 메일 헤더에 더 적합할 수 있는 다른 인코딩을 속성을 정의 합니다. 그러나 대부분의 응용 프로그램을 사용 해야 <xref:System.Text.Encoding.WebName%2A> 대신 합니다.  
  
 IANA에 자세한 내용은 [www.iana.org](https://www.iana.org/)합니다.  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> 동일는 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 반환한 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>합니다. 웹 이름 중 일부는 중복 되었습니다. 에 대 한 설명을 참조 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> 자세한 정보에 대 한 합니다.  
  
   
  
## Examples  
 다음 예제에서는 포함 된 <xref:System.Text.Encoding.WebName%2A> HTML 헤더에서입니다.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 다음 예제에서는 각 인코딩에 대 한 서로 다른 이름을 검색 하 고 다른 하나 이상의 이름의 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 하지만 것과 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />과 가장 비슷한 Windows 운영 체제 코드 페이지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 제공 Windows 다국어 (MLang) Api와의 호환성에 대 한 예를 들어 글꼴 패밀리를 결정 합니다. 전역화, 유니코드 인코딩 중 하나를 사용 하는 대신. 사용 하는 것이 좋습니다 또한 <xref:System.Text.Encoding.WebName%2A> 대신 <xref:System.Text.Encoding.WindowsCodePage%2A> 코드 페이지를 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 해당 하는 가장 근접 하는 Windows 코드 페이지를 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>