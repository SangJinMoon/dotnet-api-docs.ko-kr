<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cbfbcc77256bd34443df230f42cc12dddc55633e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30399677" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>운영 체제 프로세스 스레드를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.ProcessThread> 시스템에서 현재 실행 중인 스레드에 대 한 정보를 얻을 수 있습니다. 이렇게 스레드의 성능 특성을 모니터링 하려면 예를 들어 하면 수 있습니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 스레드는 프로그램을 통해 실행 경로입니다. Win32 일정을 예약 하는 실행의 가장 작은 단위입니다. CPU 레지스터와 시스템 스케줄러의 실행 목록에 있는 항목의 상태는 스택을 구성 됩니다.  
  
 하나 이상의 스레드가 및 코드, 데이터 및 메모리에 있는 프로그램의 다른 리소스의 프로세스 구성 됩니다. 일반적인 프로그램 리소스가 열려 있는 파일, 세마포 및 동적으로 할당 된 메모리입니다. 프로세스의 스레드가 있는 모든 프로세스의 각 리소스를 공유 합니다.  
  
 시스템 스케줄러 프로그램의 스레드 중 하나에 실행 제어를 제공 하면 프로그램이 실행 됩니다. 스케줄러 스레드를 실행할지를 결정 및 시기. 우선 순위가 낮은 스레드가 태스크를 완료 하는 우선 순위가 높은 스레드에서 얼마 동안 대기 하도록 강제할 수 있습니다. 다중 프로세서 컴퓨터에서 스케줄러 수 개별 스레드를 이동 서로 다른 프로세서를 따라서 CPU 부하를 분산 합니다.  
  
 기본 스레드에서으로 알려진 단일 스레드와 각 프로세스가 시작 됩니다. 모든 스레드가 추가 스레드를 만들 수 있습니다. 프로세스 내에서 모든 스레드는 해당 프로세스의 주소 공간을 공유 합니다.  
  
 기본 스레드 컬렉션에서 첫 번째 인덱스에 있는 반드시 않습니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0 이상에서는 다른 컴퓨터에서 성능 카운터 데이터를 참조 하는 기능 대부분의.NET Framework 메서드 및 속성에 대 한 제거 되었습니다. 성능을 향상 하 고 관리자가 아닌 사용자도 사용할 수 있도록이 변경 내용은 <xref:System.Diagnostics.ProcessThread> 클래스입니다. 결과적으로, 이전 버전의.NET Framework에서 예외를 발생 하지 않는 일부 응용 프로그램 이제 받을 수 있습니다는 <xref:System.NotSupportedException>합니다. 메서드 및 영향을 받는 속성이 너무 많아서 여기에 나열 되지만 예외 정보에 영향을 받는 멤버 항목 추가 되었습니다.  
  
 프로세스의 스레드는 개별적으로 실행 하며으로 만들지 않으면 서로 보이지 서로 인식 되지 않습니다. 그러나 공용 리소스를 공유 하는 스레드가 세마포 또는 프로세스 간 통신의 기타 방법을 사용 하 여 작업을 조정 해야 합니다.  
  
 모든 컬렉션을 가져옵니다는 <xref:System.Diagnostics.ProcessThread> 현재 프로세스와 관련 된 개체 가져오기는 <xref:System.Diagnostics.Process.Threads%2A> 속성은 <xref:System.Diagnostics.Process> 인스턴스.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드의 기본 우선 순위를 가져옵니다.</summary>
        <value>프로세스 우선 순위 클래스와 관련 스레드의 우선 순위 수준을 결합하여 계산되는 스레드의 기본 우선 순위입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.BasePriority%2A> 프로세스 스레드에 대 한 시작 우선 순위입니다. 시스템 모니터의 기본 우선 순위 카운터를 통해 기본 우선 순위에 대 한 정보를 볼 수 있습니다.  
  
 운영 체제 프로세스의 우선 순위 클래스에서 스레드의 우선 순위 수준 범위 결합 하 여 스레드의 기본 우선 순위를 계산 합니다. 프로세스의 설정할 수 있습니다 <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> 속성의 값 중 하나에 <xref:System.Diagnostics.ProcessPriorityClass> 열거형 <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>합니다. 스레드를 설정할 수 있습니다 <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> 경계 스레드의 기본 우선 순위를 지정 된 값의 범위는 속성입니다. Win32 클래스당 7 개 기본 우선 순위 수준을 4 개의 우선 순위 클래스를 사용합니다.  
  
 스레드의 현재 우선 순위는 기본 우선 순위에서 벗어날 수 있습니다. 예를 들어, 운영 체제 변경할 수는 <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> 경과 된 시간에 따라 속성 또는 다른 상승이 때 프로세스를 설정 해야 다른 사용자에 미리 액세스에 대 한 프로세서에 있습니다. 또한 설정할 수 있습니다는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 시스템 프로세스가 대기 상태에서 제거 됩니다. 때마다 스레드의 우선 순위를 일시적으로 향상 시킬 속성입니다. 우선 순위에는 프로세스가 대기 상태를 반환할 때 다시 설정 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드의 현재 우선 순위를 가져옵니다.</summary>
        <value>운영 체제에서 스레드를 예약하는 방법에 따라 기본 우선 순위에서 벗어날 수도 있는 스레드의 현재 우선 순위입니다. 활성 스레드의 경우 우선 순위가 일시적으로 높아질 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드의 현재 우선 순위는 기본 우선 순위에서 벗어날 수 있습니다. 예를 들어, 운영 체제 변경할 수는 <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> 경과 시간에 따라 속성 또는 때 프로세스 다른 상승이 설정 해야 다른 사용자에 미리 액세스에 대 한 프로세서에 있습니다. 또한 설정할 수 있습니다는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 시스템 프로세스가 대기 상태에서 제거 됩니다. 때마다 스레드의 우선 순위를 일시적으로 향상 시킬 속성입니다. 우선 순위에는 프로세스가 대기 상태를 반환할 때 다시 설정 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드의 고유 식별자를 가져옵니다.</summary>
        <value>특정 스레드와 관련된 고유 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 운영 체제 스레드 수명 동안에 식별 하는 스레드 id 번호를 다시 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 스레드가 실행될 기본 설정 프로세서를 설정합니다.</summary>
        <value>스레드를 실행할 프로세서를 결정하기 위해 시스템에서 스레드를 예약할 때 사용하는 스레드의 기본 설정 프로세서입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> 값은 0부터 시작 합니다.  즉, 첫 번째 프로세서에 대 한 스레드 선호도 설정 하려면 속성을 0으로 설정 합니다.  
  
 시스템에서 가능 하면 항상 기본 설정된 프로세서 스레드를 예약 합니다.  
  
 프로세스 스레드가 프로세서 캐시 다시 로드 하는 각 마이그레이션을 사용 하 여 프로세서에서 마이그레이션할 수 있습니다. 스레드에 대 한 프로세서를 지정 하 프로세서 캐시 다시 로드 되는 횟수를 줄여 시스템 로드가 성능을 향상 시킬 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> 메모장의 인스턴스를 첫 번째 프로세서에 대 한 속성입니다.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">지정한 프로세스에서 스레드가 시작되도록 설정할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드 프로세스의 주 창이 포커스를 받을 때마다 운영 체제에서 관련 스레드의 우선 순위를 일시적으로 높여야 하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          프로세스의 인터페이스와 상호 작용할 때 스레드의 우선 순위를 높이려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 은 `true`, 시스템 스레드의 우선 순위를 관련된 프로세스가 대기 상태에서 제거 됩니다. 때마다 일시적으로 상승 시킵니다. 이렇게 하면 다른 프로세스에서 현재 스레드의 처리를 중단 합니다. <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 프로세스에서 만든 모든 스레드에 뿐만 아니라 기존 스레드가 모두 설정은 영향을 줍니다. 일반 동작을 복원 하려면 설정는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 속성을 `false`합니다.  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 스레드가 있는 프로세스에서 실행 중인 경우에 효과가 <xref:System.Diagnostics.Process.PriorityClass%2A> 동적 우선 순위 열거형 값 중 하나로 설정 됩니다 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).  
  
> [!NOTE]
>  우선 순위를 너무 승격 중요 한 운영 체제 및 네트워크 기능 리소스를 드레이닝 할 수 있습니다. 다른 운영 체제 작업과 문제가 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">우선 순위 높임 정보를 검색할 수 없는 경우  
  
 또는  
  
 우선 순위 높임 정보를 설정할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드의 우선 순위 수준을 가져오거나 설정합니다.</summary>
        <value>스레드의 우선 순위를 한정하는 범위를 지정하는 <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 단일 값이 아니라 값의 범위 보다 우선 순위 수준이 되지 않습니다. 운영 체제는 프로세스를 사용 하 여 스레드의 기본 우선 순위를 계산 <xref:System.Diagnostics.Process.PriorityClass%2A> 에 지정 된 범위에서 값을 선택 하 고 <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">스레드 우선 순위 수준 정보를 검색할 수 없는 경우  
  
 또는  
  
 스레드 우선 순위 수준을 설정할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드가 운영 체제 코어 내부에서 코드를 실행하는데 사용한 시간을 가져옵니다.</summary>
        <value>스레드가 운영 체제 코어 내부에서 코드를 실행하는데 사용한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 가지 보호 메커니즘을 사용 하 여 창과 모두의 루트에는 사용자 모드와 특권된 모드 간에 차이가 있습니다. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> 응용 프로그램이 운영 체제 코어 내부 특권된 모드에서 실행 되는 데 소비한 시간에 해당 합니다. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> 속성 소비한 시간을 응용 프로그램 시스템 코어 외부의 사용자 모드에서 실행 중인 코드의 양을 나타냅니다.  
  
 사용자 모드에서 중요 한 두 가지 응용 프로그램을 제한합니다. 첫째, 응용 프로그램은 주변 장치에 직접 액세스할 수 없으므로 하지만 대신 가져오거나 주변 장치 데이터를 설정 하려면 운영 체제 코어를 호출 해야 합니다. 운영 체제 이렇게 하 한 응용 프로그램 주변 필요한 데이터를 다른를 제거 하지 않습니다. 둘째, 응용 프로그램 읽거나 운영 체제 자체 유지 관리 하는 데이터를 변경할 수 없습니다. 이 제한은 실수로 또는 의도적으로 손상 핵심 응용 프로그램을 방지 합니다. 작업을 수행 하는 운영 체제는 응용 프로그램을 경우 시스템의 루틴 중 하나를 호출 합니다. 권한 있는 모드로 전환 작업을 수행 하 고 원활 하 게 사용자 모드로 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">스레드 시간을 검색할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>관련 스레드가 실행될 수 있는 프로세서를 설정합니다.</summary>
        <value>비트 집합을 가리키는 <see cref="T:System.IntPtr" />입니다. 각각의 비트는 스레드가 실행될 수 있는 프로세서를 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세서 선호도의 스레드는 집합에 대 한 관계 된 프로세서입니다. 즉, 해당 it에서 실행 되도록 예약할 수 있습니다.  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> 각 프로세서를 약간으로 나타냅니다. 비트 0은 프로세서 1, 1 비트 프로세서 2, 및 등을 나타냅니다. 다음 표에서 가능한의 하위 집합 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> 프로세서가 4 개인 시스템에 대 한 합니다.  
  
|속성 값 (16 진수)|유효한 프로세서|  
|---------------------------------------|----------------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 또는 2|  
|0x0004|3|  
|0x0005|1 또는 3|  
|0x0007|1, 2 또는 3|  
|0x000F|1, 2, 3 또는 4|  
  
 설정 하 여 스레드에 대 한 단일 기본 설정된 프로세서를 지정할 수도 있습니다는 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> 속성입니다. 프로세스 스레드가 프로세서 캐시 다시 로드 하는 각 마이그레이션을 사용 하 여 프로세서에서 마이그레이션할 수 있습니다. 스레드에 대 한 프로세서를 지정 하 프로세서 캐시 다시 로드 되는 횟수를 줄여 시스템 로드가 성능을 향상 시킬 수 있습니다.  
  
   
  
## Examples  
 설정 하는 방법을 보여 주는 다음 예제는 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> 메모장의 인스턴스를 첫 번째 프로세서에 대 한 속성입니다.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">프로세서 선호도를 설정할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 스레드의 최적 프로세서를 다시 설정하여 단일 최적 프로세서가 없음을 나타냅니다. 다시 말해서 모든 프로세서가 최적 프로세서가 되도록 다시 설정합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">최적 프로세서를 다시 설정할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 스레드를 시작한 운영 체제가 호출한 함수의 메모리 주소를 가져옵니다.</summary>
        <value>스레드가 실행하는 응용 프로그램 정의 함수를 가리키는 스레드의 시작 주소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 스레드에서으로 알려진 단일 스레드와 각 프로세스가 시작 됩니다. 모든 스레드가 추가 스레드를 만들 수 있습니다.  
  
 프로세스 가상 주소 공간, 실행 코드, 데이터, 개체 핸들, 환경 변수, 기본 우선 순위 및 최소 및 최대 작업 집합 크기에 있습니다. 모든 스레드는 프로세스의 가상 주소 공간 및 시스템 리소스를 공유합니다. 또한 각 스레드는 예외 처리기, 일정 예약 우선 순위 및 일련의 구조는 시스템 저장 스레드 컨텍스트를 예약할 수는 스레드가 대기 하는 동안 유지 관리 합니다. 스레드 컨텍스트는 스레드 프로세스의 주소 공간에서 컴퓨터 레지스터, 커널 스택, 스레드 환경 블록 및 사용자 스택을의 스레드의 집합을 포함합니다.  
  
 모든 Windows 스레드는 실제로 응용 프로그램에서 제공 하는 기능이 아니라는 시스템에서 제공한 함수에서 실행을 시작 합니다. 시작 주소를 기본 스레드는, 따라서 동일 (시스템 제공 함수의 주소를 나타내는) 시스템의 모든 Windows 프로세스에 대 한 합니다. 그러나는 <xref:System.Diagnostics.ProcessThread.StartAddress%2A> 속성을 사용 하면 응용 프로그램에 적용 되는 시작 함수 주소를 가져올 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>운영 체제가 스레드를 시작한 시간을 가져옵니다.</summary>
        <value>운영 체제가 스레드를 시작했을 때의 시스템 시간을 나타내는 <see cref="T:System.DateTime" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">스레드 시간을 검색할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 스레드의 현재 상태를 가져옵니다.</summary>
        <value>실행, 대기, 종료 등 스레드의 실행을 나타내는 <see cref="T:System.Diagnostics.ThreadState" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> 속성 값은 경우에만 유효는 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> 값은 <xref:System.Diagnostics.ThreadState.Wait>합니다. 따라서 확인는 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> 도달 하기 전에 값은 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 스레드가 프로세서를 사용하는데 소비한 총 시간을 가져옵니다.</summary>
        <value>스레드가 프로세서의 제어를 받고 있던 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> 속성 시스템에 스레드가 대기 상태에서 제외 되 고 모든 프로세서에서 우선 순위가 지정 시간의 전체 크기를 나타냅니다. 다중 프로세서 시스템에서이 값 스레드가 둘 이상의 프로세서를 사용 하는 경우 각 프로세서에 소요 된 시간을 포함 합니다.  
  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> 속성은의 합계는 <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> 및 <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">스레드 시간을 검색할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>관련 스레드가 응용 프로그램 내부에서 코드를 실행하는데 사용한 시간을 가져옵니다.</summary>
        <value>운영 체제 코어 내부와 반대로 스레드가 응용 프로그램 내부에서 코드를 실행하는데 사용한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT 여러 가지 보호 메커니즘을 사용 하 여 및 모두의 루트에는 사용자 모드와 특권된 모드 간에 차이가 있습니다. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> 응용 프로그램이 운영 체제 코어 외부의 사용자 모드에서 실행 되는 데 소비한 시간에 해당 합니다. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> 된 응용 프로그램이 실행 중인 코드 체제 코어 내부 특권된 모드에서 소비한 시간에 해당 합니다.  
  
 사용자 모드에서 중요 한 두 가지 응용 프로그램을 제한합니다. 첫째, 응용 프로그램은 주변 장치에 직접 액세스할 수 없으므로 하지만 대신 가져오거나 주변 장치 데이터를 설정 하려면 운영 체제 코어를 호출 해야 합니다. 운영 체제 이렇게 하 한 응용 프로그램 주변 필요한 데이터를 다른를 제거 하지 않습니다. 둘째, 응용 프로그램 읽거나 운영 체제 자체 유지 관리 하는 데이터를 변경할 수 없습니다. 이 제한은 실수로 또는 의도적으로 손상 핵심 응용 프로그램을 방지 합니다. 작업을 수행 하는 운영 체제는 응용 프로그램을 경우 시스템의 루틴 중 하나를 호출 합니다. 권한 있는 모드로 전환 작업을 수행 하 고 원활 하 게 사용자 모드로 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">스레드 시간을 검색할 수 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드가 대기 상태에 있는 이유를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Diagnostics.ThreadWaitReason" />은 스레드가 대기 상태에 있는 이유를 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> 속성은 경우에만 유효는 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> 은 <xref:System.Diagnostics.ThreadState.Wait>합니다. 따라서 확인는 <xref:System.Diagnostics.ProcessThread.ThreadState%2A> 도달 하기 전에 값은 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">스레드가 대기 상태에 있지 않은 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이 Windows 98 또는 Windows Millennium Edition인 경우</exception>
        <exception cref="T:System.NotSupportedException">프로세스가 원격 컴퓨터에 있는 경우</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>