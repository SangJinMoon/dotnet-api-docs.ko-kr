<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5ac353c2085884d08c90d09fe4bb6c90bda8893f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="12013-101">로컬 및 원격 프로세스에 대한 액세스를 제공하고 로컬 시스템 프로세스를 시작하고 중지할 수 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="12013-101">Provides access to local and remote processes and enables you to start and stop local system processes.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-102">A <xref:System.Diagnostics.Process> 구성 요소는 컴퓨터에서 실행 중인 프로세스에 대 한 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-102">A <xref:System.Diagnostics.Process> component provides access to a process that is running on a computer.</span></span> <span data-ttu-id="12013-103">간단히 말해에서는 프로세스를 실행 중인 앱입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-103">A process, in the simplest terms, is a running app.</span></span> <span data-ttu-id="12013-104">스레드는 운영 체제에 있는 프로세서 시간을 할당 하는 기본 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-104">A thread is the basic unit to which the operating system allocates processor time.</span></span> <span data-ttu-id="12013-105">스레드가 다른 스레드에 의해 현재 실행 되 고 파트를 포함 하는 프로세스의 코드의 모든 부분을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-105">A thread can execute any part of the code of the process, including parts currently being executed by another thread.</span></span>  
  
 <span data-ttu-id="12013-106"><xref:System.Diagnostics.Process> 구성 요소는 시작, 중지, 제어 및 응용 프로그램 모니터링에 대 한 유용한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-106">The <xref:System.Diagnostics.Process> component is a useful tool for starting, stopping, controlling, and monitoring apps.</span></span> <span data-ttu-id="12013-107">사용할 수는 <xref:System.Diagnostics.Process> 있습니다 또는 구성 요소가 실행 되는 프로세스의 목록을 가져올 수는 새 프로세스를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-107">You can use the <xref:System.Diagnostics.Process> component, to obtain a list of the processes that are running, or you can start a new process.</span></span> <span data-ttu-id="12013-108">A <xref:System.Diagnostics.Process> 시스템 프로세스를 액세스 하려면 구성 요소를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-108">A <xref:System.Diagnostics.Process> component is used to access system processes.</span></span> <span data-ttu-id="12013-109">이후에 <xref:System.Diagnostics.Process> 구성 요소가 초기화 된, 실행 중인 프로세스에 대 한 정보를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-109">After a <xref:System.Diagnostics.Process> component has been initialized, it can be used to obtain information about the running process.</span></span> <span data-ttu-id="12013-110">프로세스 메모리의 양과 같은 성능 정보를 사용 하 여 및 이러한 정보에 로드 된 모듈 (.dll 및.exe 파일), 스레드 집합이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-110">Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.</span></span>  
  
 <span data-ttu-id="12013-111">이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-111">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="12013-112">형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-112">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="12013-113">직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-113">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="12013-114">작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-114">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="12013-115">자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-115">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-116">32 비트 프로세스가 64 비트 프로세스의 모듈에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-116">32-bit processes cannot access the modules of a 64-bit process.</span></span> <span data-ttu-id="12013-117">32 비트 프로세스에서 64 비트 프로세스에 대 한 정보를 가져올 하려는 경우는 <xref:System.ComponentModel.Win32Exception> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-117">If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception.</span></span> <span data-ttu-id="12013-118">반면에 64 비트 프로세스를 32 비트 프로세스의 모듈을 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-118">A 64-bit process, on the other hand, can access the modules of a 32-bit process.</span></span>  
  
 <span data-ttu-id="12013-119">프로세스 구성 요소 속성의 그룹에 대 한 정보를 한 번에 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="12013-119">The process component obtains information about a group of properties all at once.</span></span> <span data-ttu-id="12013-120">이후에 <xref:System.Diagnostics.Process> 구성 요소는 모든 그룹의 멤버 중 하나에 대 한 정보를 확보 하는, 해당 그룹의 다른 속성에 대 한 값을 캐시 하 고 호출할 때까지 그룹의 다른 멤버에 대 한 새 정보를 가져올는 <xref:System.Diagnostics.Process.Refresh%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-120">After the <xref:System.Diagnostics.Process> component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="12013-121">따라서 속성 값을 반드시를 마지막으로 호출한 보다 같을 수는 <xref:System.Diagnostics.Process.Refresh%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-121">Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="12013-122">그룹 명세는 운영 체제에 종속적입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-122">The group breakdowns are operating-system dependent.</span></span>  
  
 <span data-ttu-id="12013-123">따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-123">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="12013-124">그렇지 않으면 시스템 경로 찾지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-124">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="12013-125">예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-125">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
 <span data-ttu-id="12013-126">시스템 프로세스를 해당 프로세스 id 시스템에 고유 하 게 식별 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-126">A system process is uniquely identified on the system by its process identifier.</span></span> <span data-ttu-id="12013-127">많은 Windows 리소스와 마찬가지로 프로세스도 해당 컴퓨터에서 고유 않을 수도 있는 해당 핸들로 식별 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-127">Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer.</span></span> <span data-ttu-id="12013-128">핸들은 리소스의 식별자에 대 한 일반 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-128">A handle is the generic term for an identifier of a resource.</span></span> <span data-ttu-id="12013-129">운영 체제를 통해 액세스할 수 있는 프로세스 핸들 계속 되 면는 <xref:System.Diagnostics.Process.Handle%2A> 의 속성은 <xref:System.Diagnostics.Process> 프로세스가 종료 하는 경우에 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-129">The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the <xref:System.Diagnostics.Process> component, even when the process has exited.</span></span> <span data-ttu-id="12013-130">따라서 같은 정보를 관리 하는 프로세스의를 읽을 수는 <xref:System.Diagnostics.Process.ExitCode%2A> (일반적으로 하거나 0의 성공 또는 0이 아닌 오류 코드)와 <xref:System.Diagnostics.Process.ExitTime%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-130">Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>.</span></span> <span data-ttu-id="12013-131">핸들 핸들 누수가 메모리 누수 보다 더 심각 이므로 매우 중요 한 리소스를은입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-131">Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-132">이 클래스는 모든 멤버에 적용 되는 클래스 수준에 상속 요청과 링크 요청을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-132">This class contains a link demand and an inheritance demand at the class level that applies to all members.</span></span> <span data-ttu-id="12013-133">A <xref:System.Security.SecurityException> 직접 실행 호출자 또는 파생된 클래스 중 하나에 완전 신뢰 권한이 없는 경우에 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-133">A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission.</span></span> <span data-ttu-id="12013-134">보안 요청에 대 한 세부 정보를 참조 하십시오. [링크 요청](~/docs/framework/misc/link-demands.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-134">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md).</span></span>  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)]<span data-ttu-id="12013-135"> 참고 사항</span><span class="sxs-lookup"><span data-stu-id="12013-135"> Notes</span></span>  
 <span data-ttu-id="12013-136">.NET framework에서는 <xref:System.Diagnostics.Process> 클래스를 사용 하 여 기본 여 <xref:System.Console> 일반적으로 인코딩 코드 페이지 인코딩 입력, 출력 및 오류 스트림에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-136">In the .NET Framework, the <xref:System.Diagnostics.Process> class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams.</span></span> <span data-ttu-id="12013-137">예를 들어 코드, 문화권이 영어 (미국) 인 시스템에서 코드 페이지 437는 기본에 대 한 인코딩을 <xref:System.Console> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-137">For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class.</span></span> <span data-ttu-id="12013-138">그러나 [!INCLUDE[net_core](~/includes/net-core-md.md)] 이러한 인코딩은의 제한 된 하위 집합만 사용할 수 있게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-138">However, [!INCLUDE[net_core](~/includes/net-core-md.md)] may make only a limited subset of these encodings available.</span></span> <span data-ttu-id="12013-139">사용 하 여이 경우가 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 을 기본 인코딩으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-139">If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> as the default encoding.</span></span>  
  
 <span data-ttu-id="12013-140">경우는 <xref:System.Diagnostics.Process> 개체가 특정 코드 페이지 인코딩에 종속, 있습니다 수 여전히 사용할 수 있도록 다음을 수행 하 여 *전에* 호출 하면 <xref:System.Diagnostics.Process> 메서드:</span><span class="sxs-lookup"><span data-stu-id="12013-140">If a <xref:System.Diagnostics.Process> object depends on specific code page encodings, you can still make them available by doing the following *before* you call any <xref:System.Diagnostics.Process> methods:</span></span>  
  
1.  <span data-ttu-id="12013-141">프로젝트에 System.Text.Encoding.CodePages.dll 어셈블리에 대 한 참조를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-141">Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.</span></span>  
  
2.  <span data-ttu-id="12013-142">검색 된 <xref:System.Text.EncodingProvider> 에서 개체는 <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-142">Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> property.</span></span>  
  
3.  <span data-ttu-id="12013-143">전달 된 <xref:System.Text.EncodingProvider> 개체를 <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> 메서드를 사용할 수 있는 인코딩 공급자에서 지 원하는 추가 인코딩을 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-143">Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> method to make the additional encodings supported by the encoding provider available.</span></span>  
  
 <span data-ttu-id="12013-144"><xref:System.Diagnostics.Process> 클래스 다음 자동으로 사용 합니다, UTF8 아닌 기본 시스템 인코딩과를 호출 하기 전에 인코딩 공급자를 등록 한 <xref:System.Diagnostics.Process> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-144">The <xref:System.Diagnostics.Process> class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any <xref:System.Diagnostics.Process> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-145">다음 예제에서 사용 하는 <xref:System.Diagnostics.Process> 클래스는 프로세스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-145">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 <span data-ttu-id="12013-146">다음 예제에서는 <xref:System.Diagnostics.Process> 클래스 자체와 정적 <xref:System.Diagnostics.Process.Start%2A> 메서드 프로세스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-146">The following example uses the <xref:System.Diagnostics.Process> class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 <span data-ttu-id="12013-147">다음 F # 예제에서는 정의 `runProc` 함수는 프로세스를 시작 하는 모든 출력 및 오류 정보를 캡처하고 프로세스를 실행 하는 시간 (밀리초)의 수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-147">The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.</span></span>  <span data-ttu-id="12013-148">`runProc` 함수에 세 개의 매개 변수가: 응용 프로그램의 시작 디렉터리를 제공 하는 인수를 시작 하려면 응용 프로그램의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-148">The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.</span></span>  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 <span data-ttu-id="12013-149">에 대 한 코드는 `runProc` 함수에 의해 작성 되었으므로 [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) 사용할 수는 [Microsoft Public License](http://opensource.org/licenses/ms-pl)합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-149">The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl).</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
      <span data-ttu-id="12013-150">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="12013-150">for full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="12013-151">이 클래스는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="12013-151">This class cannot be used by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="12013-152">상속자에 대 한 완전 신뢰 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="12013-152">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="12013-153">부분적으로 신뢰할 수 있는 코드에서이 클래스는 상속 될 수 없습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="12013-153">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-154">
            <see cref="T:System.Diagnostics.Process" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-154">Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-155">지정 하지 않는 경우는 <xref:System.Diagnostics.Process.MachineName%2A> 속성, 기본값은 로컬 컴퓨터 (".").</span><span class="sxs-lookup"><span data-stu-id="12013-155">If you do not specify the <xref:System.Diagnostics.Process.MachineName%2A> property, the default is the local computer, (".").</span></span>  
  
 <span data-ttu-id="12013-156">새 연결에 대 한 두 가지 옵션이 <xref:System.Diagnostics.Process> 컴퓨터에 있는 프로세스와 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-156">You have two options for associating a new <xref:System.Diagnostics.Process> component with a process on the computer.</span></span> <span data-ttu-id="12013-157">첫 번째 옵션은 만들려는 생성자를 사용 하는 <xref:System.Diagnostics.Process> 의 적절 한 멤버를 설정 하는 구성 요소는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 연결 하는 <xref:System.Diagnostics.Process> 를 새로운 시스템 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-157">The first option is to use the constructor to create the <xref:System.Diagnostics.Process> component, set the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and call <xref:System.Diagnostics.Process.Start%2A> to associate the <xref:System.Diagnostics.Process> with a new system process.</span></span> <span data-ttu-id="12013-158">두 번째 방법은 연결 하는 <xref:System.Diagnostics.Process> 를 사용 하 여 실행 중인 시스템 프로세스와 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 중 하나는 <xref:System.Diagnostics.Process.GetProcesses%2A> 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-158">The second option is to associate the <xref:System.Diagnostics.Process> with a running system process by using <xref:System.Diagnostics.Process.GetProcessById%2A> or one of the <xref:System.Diagnostics.Process.GetProcesses%2A> return values.</span></span>  
  
 <span data-ttu-id="12013-159">사용 하는 경우는 `static` 오버 로드는 <xref:System.Diagnostics.Process.Start%2A> 메서드는 새 시스템 프로세스를 시작 하는 메서드를 새로 만듭니다. <xref:System.Diagnostics.Process> 구성 요소는 프로세스와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-159">If you use a `static` overload of the <xref:System.Diagnostics.Process.Start%2A> method to start a new system process, the method creates a new <xref:System.Diagnostics.Process> component and associates it with the process.</span></span>  
  
 <span data-ttu-id="12013-160">경우는 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 속성이 해당 기본값으로 설정 되어 `true`를 사용 하 여 유사한 방식으로 응용 프로그램 및 문서를 시작할 수 있습니다는 `Run` Windows의 대화 상자 `Start` 메뉴.</span><span class="sxs-lookup"><span data-stu-id="12013-160">When the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> property is set to its default value, `true`, you can start applications and documents in a way that is similar to using the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="12013-161">때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 은 `false`, 실행 파일만 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-161">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> is `false`, you can start only executables.</span></span>  
  
 <span data-ttu-id="12013-162">명령줄에서 호출할 수 있는 모든 실행 파일을 두 가지 방법 중 하나로 시작할 수 있습니다:의 적절 한 멤버를 설정 하 여는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출은 <xref:System.Diagnostics.Process.Start%2A> 메서드 매개 변수 없이 또는 적절 한 매개 변수를 전달 하 여는 `static` <xref:System.Diagnostics.Process.Start%2A> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-162">Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and calling the <xref:System.Diagnostics.Process.Start%2A> method with no parameters, or by passing the appropriate parameter to the `static`<xref:System.Diagnostics.Process.Start%2A> member.</span></span>  
  
 <span data-ttu-id="12013-163">만들 수는 <xref:System.Diagnostics.Process> 생성자는 정적 중 하나를 사용 하 여 구성 요소 <xref:System.Diagnostics.Process.Start%2A> 오버 로드, 또는 중 하나는 <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-163">You can create a <xref:System.Diagnostics.Process> component by using the constructor, one of the static <xref:System.Diagnostics.Process.Start%2A> overloads, or any of the <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, or <xref:System.Diagnostics.Process.GetProcessesByName%2A> methods.</span></span> <span data-ttu-id="12013-164">그렇게 않은 후에 연결된 된 프로세스에 대 한 뷰를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-164">After you have done so, you have a view into the associated process.</span></span> <span data-ttu-id="12013-165">메모리에서 프로세스 속성이 변경 될 때 자동으로 업데이트 하는 동적 뷰 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="12013-165">This is not a dynamic view that updates itself automatically when the process properties have changed in memory.</span></span> <span data-ttu-id="12013-166">대신, 호출 해야 <xref:System.Diagnostics.Process.Refresh%2A> 업데이트할 구성 요소에 대 한는 <xref:System.Diagnostics.Process> 응용 프로그램에서 속성 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-166">Instead, you must call <xref:System.Diagnostics.Process.Refresh%2A> for the component to update the <xref:System.Diagnostics.Process> property information in your application.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-167">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-167">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-168">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-168">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-169">연결된 프로세스의 기본 우선 순위를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-169">Gets the base priority of the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-170">연결된 프로세스의 <see cref="P:System.Diagnostics.Process.PriorityClass" />에서 계산되는 기본 우선 순위입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-170">The base priority, which is computed from the <see cref="P:System.Diagnostics.Process.PriorityClass" /> of the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-171"><xref:System.Diagnostics.Process.BasePriority%2A> 프로세스의 연결된 된 프로세스 내에서 만든 스레드에 대 한 시작 우선 순위입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-171">The <xref:System.Diagnostics.Process.BasePriority%2A> of the process is the starting priority for threads created within the associated process.</span></span> <span data-ttu-id="12013-172">시스템 모니터의 기본 우선 순위 카운터를 통해 기본 우선 순위에 대 한 정보를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-172">You can view information about the base priority through the System Monitor's Priority Base counter.</span></span>  
  
 <span data-ttu-id="12013-173">시간 경과 또는 다른 운영 체제 상승이 앞 다른 프로세스에 배치 되어야 하는 경우 기본 우선 순위를 변경할 수 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-173">Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</span></span>  
  
 <span data-ttu-id="12013-174"><xref:System.Diagnostics.Process.BasePriority%2A> 속성을 사용 하면 프로세스에 할당 된 우선 순위를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-174">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority assigned to a process.</span></span> <span data-ttu-id="12013-175">그러나 읽기 전용 이므로 사용할 수 없습니다는 <xref:System.Diagnostics.Process.BasePriority%2A> 프로세스의 우선 순위를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-175">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> to set the priority of the process.</span></span> <span data-ttu-id="12013-176">우선 순위를 변경 하려면 사용 하 여는 <xref:System.Diagnostics.Process.PriorityClass%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-176">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property.</span></span> <span data-ttu-id="12013-177"><xref:System.Diagnostics.Process.BasePriority%2A> 을 볼 수 있습니다 하지만 시스템 모니터를 사용 하는 <xref:System.Diagnostics.Process.PriorityClass%2A> 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-177">The <xref:System.Diagnostics.Process.BasePriority%2A> is viewable using the System Monitor, while the <xref:System.Diagnostics.Process.PriorityClass%2A> is not.</span></span> <span data-ttu-id="12013-178">둘 다는 <xref:System.Diagnostics.Process.BasePriority%2A> 및 <xref:System.Diagnostics.Process.PriorityClass%2A> 프로그래밍 방식으로 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-178">Both the <xref:System.Diagnostics.Process.BasePriority%2A> and the <xref:System.Diagnostics.Process.PriorityClass%2A> can be viewed programmatically.</span></span> <span data-ttu-id="12013-179">다음 표에서 간의 관계를 보여 줍니다. <xref:System.Diagnostics.Process.BasePriority%2A> 값 및 <xref:System.Diagnostics.Process.PriorityClass%2A> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-179">The following table shows the relationship between <xref:System.Diagnostics.Process.BasePriority%2A> values and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="12013-180">BasePriority</span><span class="sxs-lookup"><span data-stu-id="12013-180">BasePriority</span></span>|<span data-ttu-id="12013-181">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="12013-181">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="12013-182">4</span><span class="sxs-lookup"><span data-stu-id="12013-182">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="12013-183">8</span><span class="sxs-lookup"><span data-stu-id="12013-183">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="12013-184">13</span><span class="sxs-lookup"><span data-stu-id="12013-184">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="12013-185">24</span><span class="sxs-lookup"><span data-stu-id="12013-185">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="12013-186">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-186">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-187">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-187">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-188">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-188">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-189">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-189">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-190">프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-190">The process has exited.</span>
          </span>
          <span data-ttu-id="12013-191">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-191">-or-</span>
          </span>
          <span data-ttu-id="12013-192">프로세스가 시작되지 않아서 프로세스 ID가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-192">The process has not started, so there is no process ID.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-193">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-193">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-194">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-194">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-195">응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에 대해 비동기 읽기 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-195">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-196"><xref:System.Diagnostics.Process.StandardError%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-196">The <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="12013-197">와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 오류 출력 스트림에서 동기 읽기 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-197">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="12013-198">이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트리밍하거나 스트림을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-198">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="12013-199">반면, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-199">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="12013-200">이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-200">This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="12013-201">비동기 읽기 작업을 수행 하려면 다음이 단계에 따라 <xref:System.Diagnostics.Process.StandardError%2A> 에 대 한는 <xref:System.Diagnostics.Process> :</span><span class="sxs-lookup"><span data-stu-id="12013-201">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="12013-202"><xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-202">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="12013-203"><xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>를 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-203">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="12013-204">이벤트 처리기를 추가 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-204">Add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event.</span></span> <span data-ttu-id="12013-205">이벤트 처리기와 일치 해야 합니다는 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 대리자 서명입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-205">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="12013-206">시작 된 <xref:System.Diagnostics.Process>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-206">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="12013-207">호출 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-207">Call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="12013-208">이 호출에서 비동기 읽기 작업을 시작 <xref:System.Diagnostics.Process.StandardError%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-208">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span>  
  
 <span data-ttu-id="12013-209">연결 된 사용자가 비동기 읽기 작업을 시작, 이벤트 처리기가 호출 될 때 <xref:System.Diagnostics.Process> 텍스트의 줄을 쓰는 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-209">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-210">호출 하 여 비동기 읽기 작업을 취소할 수 있습니다 <xref:System.Diagnostics.Process.CancelErrorRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-210">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span> <span data-ttu-id="12013-211">호출자에 의해 또는 이벤트 처리기에서 읽기 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-211">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="12013-212">취소 후 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 비동기 읽기 작업을 다시 시작을 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-212">After canceling, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-213">리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-213">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="12013-214">리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-214">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="12013-215">예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 또는 그 반대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-215">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="12013-216">그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-216">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="12013-217">예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-217">For example, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-218">다음 예제에서는 `net view` 명령을 원격 컴퓨터에서 사용 가능한 네트워크 리소스를 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-218">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="12013-219">사용자가 대상 컴퓨터 이름 명령줄 인수로 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-219">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="12013-220">사용자 오류 출력에 대 한 파일 이름을 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-220">The user can also supply a file name for error output.</span></span> <span data-ttu-id="12013-221">이 예제에서는 net 명령, 프로세스가 끝날 때까지 및 다음 쓰기 출력 결과 콘솔에 대 한 대기 작업의 출력을 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-221">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="12013-222">필요에 따라 오류 파일의 사용자가 제공 하는 경우이 예제에서는 파일에 오류를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-222">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-223">
            <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 속성은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-223">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12013-224">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-224">\- or -</span>
          </span>
          <span data-ttu-id="12013-225">
            <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에서 비동기 읽기 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-225">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span>
          </span>
          <span data-ttu-id="12013-226">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-226">\- or -</span>
          </span>
          <span data-ttu-id="12013-227">
            <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림이 동기적 읽기 작업에 사용되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-227">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-228">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-228">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-229">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-229">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-230">응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에 대해 비동기 읽기 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-230">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-231"><xref:System.Diagnostics.Process.StandardOutput%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-231">The <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="12013-232">와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 출력 스트림에서 동기 읽기 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-232">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="12013-233">이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트리밍하거나 스트림을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-233">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="12013-234">반면, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-234">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-235">이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-235">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="12013-236">비동기 읽기 작업을 수행 하려면 다음이 단계에 따라 <xref:System.Diagnostics.Process.StandardOutput%2A> 에 대 한는 <xref:System.Diagnostics.Process> :</span><span class="sxs-lookup"><span data-stu-id="12013-236">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="12013-237"><xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-237">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="12013-238"><xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>를 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-238">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="12013-239">이벤트 처리기를 추가 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-239">Add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="12013-240">이벤트 처리기와 일치 해야 합니다는 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 대리자 서명입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-240">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="12013-241">시작 된 <xref:System.Diagnostics.Process>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-241">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="12013-242">호출 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-242">Call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="12013-243">이 호출에서 비동기 읽기 작업을 시작 <xref:System.Diagnostics.Process.StandardOutput%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-243">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span>  
  
 <span data-ttu-id="12013-244">연결 된 사용자가 비동기 읽기 작업을 시작, 이벤트 처리기가 호출 될 때 <xref:System.Diagnostics.Process> 텍스트의 줄을 쓰는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-244">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-245">호출 하 여 비동기 읽기 작업을 취소할 수 있습니다 <xref:System.Diagnostics.Process.CancelOutputRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-245">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span> <span data-ttu-id="12013-246">호출자에 의해 또는 이벤트 처리기에서 읽기 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-246">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="12013-247">취소 후 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 비동기 읽기 작업을 다시 시작을 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-247">After canceling, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-248">리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-248">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="12013-249">리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-249">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="12013-250">예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 또는 그 반대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-250">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="12013-251">그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-251">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="12013-252">예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-252">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-253">다음 예제에서는 리디렉션된에 대해 비동기 읽기 작업을 수행 하는 방법을 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 `sort` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-253">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command.</span></span> <span data-ttu-id="12013-254">`sort` 명령 읽고 텍스트 입력을 정렬 하는 콘솔 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-254">The `sort` command is a console application that reads and sorts text input.</span></span>  
  
 <span data-ttu-id="12013-255">이 예에서는 대 한 이벤트 대리자를 만듭니다는 `SortOutputHandler` 이벤트 처리기에 연결 된 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-255">The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="12013-256">이벤트 처리기는 리디렉션된 텍스트 줄을 받아서 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림에 텍스트의 서식을 지정 하 고 화면에 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-256">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-257">
            <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 속성은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-257">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12013-258">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-258">\- or -</span>
          </span>
          <span data-ttu-id="12013-259">
            <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에서 비동기 읽기 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-259">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span>
          </span>
          <span data-ttu-id="12013-260">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-260">\- or -</span>
          </span>
          <span data-ttu-id="12013-261">
            <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림이 동기적 읽기 작업에 사용되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-261">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-262">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-262">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-263">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-263">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-264">응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에 대해 비동기 읽기 작업을 취소합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-264">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-265"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작에 비동기 읽기 작업의 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-265"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="12013-266"><xref:System.Diagnostics.Process.CancelErrorRead%2A> 끝 비동기 읽기 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-266"><xref:System.Diagnostics.Process.CancelErrorRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="12013-267">취소 후 호출 하 여 비동기 읽기 작업을 재개할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-267">After canceling, you can resume the asynchronous read operation by calling <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="12013-268">호출 하는 경우 <xref:System.Diagnostics.Process.CancelErrorRead%2A>모든 진행 중인 읽기 작업에 대 한 <xref:System.Diagnostics.Process.StandardError%2A> 완료 된 이벤트 처리기를 사용할 수 없는 다음 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-268">When you call <xref:System.Diagnostics.Process.CancelErrorRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardError%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="12013-269">이후의 모든 리디렉션된 출력을 <xref:System.Diagnostics.Process.StandardError%2A> 버퍼에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-269">All further redirected output to <xref:System.Diagnostics.Process.StandardError%2A> is saved in a buffer.</span></span> <span data-ttu-id="12013-270">이벤트 처리기에 대 한 호출으로 다시 설정 하는 경우 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, 이벤트 처리기에 저장 된 출력은 전송 및 비동기 읽기 작업을 다시 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-270">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="12013-271">비동기 읽기 작업을 다시 시작 하기 전에 이벤트 처리기를 변경 하려는 경우 새 이벤트 처리기를 추가 하기 전에 기존 이벤트 처리기를 제거 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-271">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="12013-272">리디렉션된에서 비동기 및 동기 읽기 작업을 혼합할 수 없습니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-272">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="12013-273">리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-273">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="12013-274">취소 하는 경우 비동기 읽기 작업에 <xref:System.Diagnostics.Process.StandardError%2A> 다음 사용 해야 듯이 스트림에서 읽은 해야 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 비동기 읽기 작업을 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-274">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardError%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="12013-275">수행 하지 않도록 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 동기에 대 한 호출의 메서드를 읽을 <xref:System.Diagnostics.Process.StandardError%2A> 같은 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 또는 <xref:System.IO.StreamReader.ReadToEnd%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-275">Do not follow <xref:System.Diagnostics.Process.CancelErrorRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardError%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-276">다음 예제에서는 시작는 `nmake` 사용자를 사용 하 여 명령을 제공 된 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-276">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="12013-277">오류 및 출력 스트림은 비동기적으로 읽는 수집 된 텍스트 줄은 콘솔에 표시으로 로그 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-277">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="12013-278">명령 출력에서 지정 된 개수의 줄을 초과할 경우 비동기 읽기 작업이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-278">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-279">
            <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림을 비동기 읽기 작업용으로 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-279">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-280">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-280">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-281">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-281">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-282">응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에 대해 비동기 읽기 작업을 취소합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-282">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-283"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작에 비동기 읽기 작업의 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-283"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-284"><xref:System.Diagnostics.Process.CancelOutputRead%2A> 끝 비동기 읽기 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-284"><xref:System.Diagnostics.Process.CancelOutputRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="12013-285">취소 후 다시 시작할 수 있습니다 비동기 읽기 작업을 호출 하 여 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-285">After canceling, you can resume asynchronous read operations by calling <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="12013-286">호출 하는 경우 <xref:System.Diagnostics.Process.CancelOutputRead%2A>모든 진행 중인 읽기 작업에 대 한 <xref:System.Diagnostics.Process.StandardOutput%2A> 완료 된 이벤트 처리기를 사용할 수 없는 다음 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-286">When you call <xref:System.Diagnostics.Process.CancelOutputRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardOutput%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="12013-287">이후의 모든 리디렉션된 출력을 <xref:System.Diagnostics.Process.StandardOutput%2A> 버퍼에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-287">All further redirected output to <xref:System.Diagnostics.Process.StandardOutput%2A> is saved in a buffer.</span></span> <span data-ttu-id="12013-288">이벤트 처리기에 대 한 호출으로 다시 설정 하는 경우 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, 이벤트 처리기에 저장 된 출력은 전송 및 비동기 읽기 작업을 다시 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-288">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="12013-289">비동기 읽기 작업을 다시 시작 하기 전에 이벤트 처리기를 변경 하려는 경우 새 이벤트 처리기를 추가 하기 전에 기존 이벤트 처리기를 제거 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-289">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="12013-290">리디렉션된에서 비동기 및 동기 읽기 작업을 혼합할 수 없습니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-290">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-291">리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-291">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="12013-292">취소 하는 경우 비동기 읽기 작업에 <xref:System.Diagnostics.Process.StandardOutput%2A> 다음 사용 해야 듯이 스트림에서 읽은 해야 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 비동기 읽기 작업을 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-292">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardOutput%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="12013-293">수행 하지 않도록 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 동기에 대 한 호출의 메서드를 읽을 <xref:System.Diagnostics.Process.StandardOutput%2A> 같은 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 또는 <xref:System.IO.StreamReader.ReadToEnd%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-293">Do not follow <xref:System.Diagnostics.Process.CancelOutputRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardOutput%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-294">다음 예제에서는 시작는 `nmake` 사용자를 사용 하 여 명령을 제공 된 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-294">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="12013-295">오류 및 출력 스트림은 비동기적으로 읽는 수집 된 텍스트 줄은 콘솔에 표시으로 로그 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-295">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="12013-296">명령 출력에서 지정 된 개수의 줄을 초과할 경우 비동기 읽기 작업이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-296">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-297">
            <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림을 비동기 읽기 작업용으로 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-297">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-298">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-298">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-299">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-299">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-300">해당 구성 요소에 연결된 리소스를 모두 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-300">Frees all the resources that are associated with this component.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-301"><xref:System.Diagnostics.Process.Close%2A> 메서드를 사용 하면 프로세스 종료, 대기 프로세스 핸들을 닫고를 프로세스 관련 속성을 지웁니다에 대 한 대기를 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-301">The <xref:System.Diagnostics.Process.Close%2A> method causes the process to stop waiting for exit if it was waiting, closes the process handle, and clears process-specific properties.</span></span> <span data-ttu-id="12013-302"><xref:System.Diagnostics.Process.Close%2A> 닫히지 않습니다 표준 출력, 입력 및 오류 판독기와 작성기 외부에서 참조 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="12013-302"><xref:System.Diagnostics.Process.Close%2A> does not close the standard output, input, and error readers and writers in case they are being referenced externally.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-303"><xref:System.Diagnostics.Process.Dispose%2A> 메서드는 <xref:System.Diagnostics.Process.Close%2A>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-303">The <xref:System.Diagnostics.Process.Dispose%2A> method calls <xref:System.Diagnostics.Process.Close%2A>.</span></span> <span data-ttu-id="12013-304">배치는 <xref:System.Diagnostics.Process> 개체는 `using` 블록 리소스를 호출할 필요 없이 삭제 <xref:System.Diagnostics.Process.Close%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-304">Placing the <xref:System.Diagnostics.Process> object in a `using` block disposes of resources without the need to call <xref:System.Diagnostics.Process.Close%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-305">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-305">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-306">최대 10 초에 대 한 2 초 간격으로 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-306">It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="12013-307">이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-307">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="12013-308">이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-308">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-309">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-309">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-310">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-310">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-311">주 창에 닫기 메시지를 보내 사용자 인터페이스가 있는 프로세스를 닫습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-311">Closes a process that has a user interface by sending a close message to its main window.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-312">닫기 메시지를 보낸 경우에는 <see langword="true" />이고 연결된 프로세스에 주 창이 없거나 모달 대화 상자가 표시된 때 같이 주 창을 사용할 수 없는 경우에는 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-312">
              <see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-313">프로세스를 실행할 때 해당 메시지 루프는 대기 상태에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-313">When a process is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="12013-314">운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다 메시지 루프를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-314">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="12013-315">호출 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 는 잘 구성 된 응용 프로그램에서 자식 창을 닫고 응용 프로그램에 대 한 실행 중인 모든 메시지 루프를 취소 주 창에 근접 하는 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-315">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="12013-316">요청을 호출 하 여 프로세스를 종료 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 응용 프로그램 종료을 강제로 적용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-316">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="12013-317">응용 프로그램을 종료 하기 전에 사용자 확인을 위해 묻거나 종료를 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-317">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="12013-318">응용 프로그램을 종료 하려면을 사용 하 여는 <xref:System.Diagnostics.Process.Kill%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-318">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="12013-319">동작은 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 시스템 메뉴를 사용 하 여 응용 프로그램의 주 창을 닫을 수 있는 사용자와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-319">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="12013-320">따라서 주 창을 닫아 프로세스를 종료를 요청 응용 프로그램이 즉시 종료 강제로 적용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-320">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
 <span data-ttu-id="12013-321">프로세스에 의해 편집 하는 데이터 또는 프로세스에 할당 된 리소스 손실 될 수 있습니다를 호출 하면 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-321">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-322"><xref:System.Diagnostics.Process.Kill%2A> 비정상 프로세스 종료를 사용 하면 필요한 경우에 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-322"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination, and should be used only when necessary.</span></span> <span data-ttu-id="12013-323"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 프로세스의 순차적 종료가 가능 하 고 인터페이스와 함께 응용 프로그램에 대 한 것 이므로 모든 창을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-323"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="12013-324">경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 실패 하면 צ ְ ײ <xref:System.Diagnostics.Process.Kill%2A> 으 프로세스를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-324">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="12013-325"><xref:System.Diagnostics.Process.Kill%2A> 그래픽 인터페이스를 갖지 않는 프로세스를 종료 하는 유일한 방법이입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-325"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="12013-326">호출할 수 있습니다 <xref:System.Diagnostics.Process.Kill%2A> 및 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 로컬 컴퓨터에서 실행 중인 프로세스에 대해서만 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-326">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="12013-327">종료 하려면 원격 컴퓨터에서 프로세스 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-327">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="12013-328">만 원격 컴퓨터에서 실행 중인 프로세스에 대 한 정보를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-328">You can only view information for processes running on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-329">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-329">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-330">최대 10 초 동안 2 초 간격 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-330">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="12013-331">이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-331">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="12013-332">이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-332">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-333">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-333">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-334">프로세스가 이미 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-334">The process has already exited.</span>
          </span>
          <span data-ttu-id="12013-335">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-335">-or-</span>
          </span>
          <span data-ttu-id="12013-336">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-336">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-337">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-337">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-338">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-338">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="12013-339">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-339">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-340">이 프로세스에서 사용하는 리소스를 모두 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-340">Release all resources used by this process.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-341">프로세스가 종료될 때 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트를 발생시켜야 하는지를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-341">Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-342">종료 명령 또는 <see cref="M:System.Diagnostics.Process.Kill" /> 호출을 통해 연결된 프로세스가 종료될 때 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트가 발생해야 한다면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-342">
              <see langword="true" /> if the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the associated process is terminated (through either an exit or a call to <see cref="M:System.Diagnostics.Process.Kill" />); otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12013-343">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-343">The default is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12013-344">
            <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트는 경우에 값 <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> 은 <see langword="false" /> 하는 동안 프로세스가 종료 될 때 또는 사용자가을 수행 하기 전에 <see cref="P:System.Diagnostics.Process.HasExited" /> 확인 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-344">Note that the <see cref="E:System.Diagnostics.Process.Exited" /> event is raised even if the value of <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> is <see langword="false" /> when the process exits during or before the user performs a <see cref="P:System.Diagnostics.Process.HasExited" /> check.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="12013-345"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성에 운영 체제 프로세스를 종료 하는 경우 구성 요소가 알림을 받을지 여부를 제안 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-345">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property suggests whether the component should be notified when the operating system has shut down a process.</span></span> <span data-ttu-id="12013-346"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성은 프로세스의 종료 하는 응용 프로그램에 알리기 위해 비동기 처리에 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-346">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is used in asynchronous processing to notify your application that a process has exited.</span></span> <span data-ttu-id="12013-347">동기식으로 대기 (종료 이벤트가 발생할 때까지 응용 프로그램의 프로세스를 중단)이 표시 되는 종료 이벤트에 대 한 응용 프로그램을 강제로 사용 합니다.는 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-347">To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the <xref:System.Diagnostics.Process.WaitForExit%2A> method.</span></span>

> [!NOTE]
> <span data-ttu-id="12013-348">Visual Studio를 사용 중이 고 두 번 클릭 하는 경우는 <xref:System.Diagnostics.Process> 프로젝트의 구성 요소는 <xref:System.Diagnostics.Process.Exited> 이벤트 대리자와 이벤트 처리기는 자동으로 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-348">If you're using Visual Studio and double-click a <xref:System.Diagnostics.Process> component in your project, an <xref:System.Diagnostics.Process.Exited> event delegate and event handler are automatically generated.</span></span> <span data-ttu-id="12013-349">추가 코드 집합은 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성을 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-349">Additional code sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to `false`.</span></span> <span data-ttu-id="12013-350">이 속성을 변경 해야 `true` 때 실행할 이벤트 처리기가 연결된 된 프로세스가 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-350">You must change this property to `true` for your event handler to execute when the associated process exits.</span></span>

<span data-ttu-id="12013-351">하는 경우 구성 요소의 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 값은 `true`, 되거나 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 은 `false` 및 <xref:System.Diagnostics.Process.HasExited%2A> 검사 구성 요소에 의해 호출 되 면 구성 요소 상태로 남아 있는 연결된 된 프로세스에 대 한 관리 정보에 액세스할 수 운영 체제에 의해 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-351">If the component's <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> value is `true`, or when <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `false` and a <xref:System.Diagnostics.Process.HasExited%2A> check is invoked by the component, the component can access the administrative information for the associated process, which remains stored by the operating system.</span></span> <span data-ttu-id="12013-352">이러한 정보에 포함 됩니다는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.ExitCode%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-352">Such information includes the <xref:System.Diagnostics.Process.ExitTime%2A> and the <xref:System.Diagnostics.Process.ExitCode%2A>.</span></span>

<span data-ttu-id="12013-353">연결된 된 프로세스가 종료 된 후, <xref:System.Diagnostics.Process.Handle%2A> 의 구성 요소는 기존 프로세스 리소스에 더 이상 가리키지 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-353">After the associated process exits, the <xref:System.Diagnostics.Process.Handle%2A> of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="12013-354">대신,만 사용할 수 있습니다 프로세스 리소스에 대 한 운영 체제의 정보에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-354">Instead, it can only be used to access the operating system's information about the process resource.</span></span> <span data-ttu-id="12013-355">운영 체제는 의해 해제 하지 않은 종료 된 프로세스에 대 한 핸들 사항이 <xref:System.Diagnostics.Process> 유지할 수 있도록 구성 요소는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 메모리에 있는 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-355">The operating system is aware that there are handles to exited processes that haven't been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory.</span></span>

<span data-ttu-id="12013-356">프로세스 종료를 감시 하는 비용이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="12013-356">There's a cost associated with watching for a process to exit.</span></span> <span data-ttu-id="12013-357">경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 은 `true`, <xref:System.Diagnostics.Process.Exited> 이벤트는 연결된 된 프로세스가 종료 될 때 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-357">If <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `true`, the <xref:System.Diagnostics.Process.Exited> event is raised when the associated process terminates.</span></span> <span data-ttu-id="12013-358">에 대 한 프로시저는 <xref:System.Diagnostics.Process.Exited> 당시에 실행 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-358">Your procedures for the <xref:System.Diagnostics.Process.Exited> event run at that time.</span></span>

<span data-ttu-id="12013-359">경우에 따라 응용 프로그램 프로세스를 시작 하지만 종료 되는 대 한 알림이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-359">Sometimes, your application starts a process but doesn't require notification of its closure.</span></span> <span data-ttu-id="12013-360">예를 들어 응용 프로그램 사용자가 텍스트 편집을 수행 하지만 더 이상 하 게 메모장 응용 프로그램의 사용을 허용 하려면 메모장을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-360">For example, your application can start Notepad to allow the user to perform text editing but make no further use of the Notepad application.</span></span> <span data-ttu-id="12013-361">관련 응용 프로그램의 지속적인된 작동에 없기 때문에 프로세스가 종료 될 때 알림을 방지 하기 위해 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-361">You can choose to avoid notification when the process exits because it's not relevant to the continued operation of your application.</span></span> <span data-ttu-id="12013-362">설정 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 를 `false` 시스템 리소스를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-362">Setting <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> to `false` can save system resources.</span></span>

## Examples  
<span data-ttu-id="12013-363">다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-363">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="12013-364">설정의 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성을 발생 시키는 프로세스는 <xref:System.Diagnostics.Process.Exited> 종료 될 때 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-364">It sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits.</span></span> <span data-ttu-id="12013-365"><xref:System.Diagnostics.Process.Exited> 이벤트 처리기 프로세스 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-365">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-366">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-366">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-367">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-367">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-368">현재 스레드에서 네이티브 속성 <see langword="SeDebugPrivilege" />를 활성화하여 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 특수 모드에서 실행되는 운영 체제 프로세스와 상호 작용하는 상태로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-368">Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-369">일부 운영 체제 프로세스를 특수 모드에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-369">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="12013-370">속성을 읽거나 이러한 프로세스에 연결할 수 없으면 호출 하지 않는 한 <xref:System.Diagnostics.Process.EnterDebugMode%2A> 구성 요소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-370">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="12013-371">호출 <xref:System.Diagnostics.Process.LeaveDebugMode%2A> 특수 모드에서 실행 되는 이러한 프로세스에 대 한 액세스를 더 이상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-371">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-372">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-372">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-373">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-373">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-374">응용 프로그램이 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에 쓸 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-374">Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-375"><xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트가 리디렉션된 연결된 된 프로세스에 기록 나타냅니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-375">The <xref:System.Diagnostics.Process.ErrorDataReceived> event indicates that the associated process has written to its redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-376">이벤트는 런타임에만 발생 비동기 읽기 작업 중에 <xref:System.Diagnostics.Process.StandardError%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-376">The event only occurs during asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span> <span data-ttu-id="12013-377">비동기 읽기 작업을 시작 하려면 리디렉션해야는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림을 <xref:System.Diagnostics.Process>, 이벤트 처리기에 추가 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트 및 호출 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-377">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardError%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event, and call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</span></span> <span data-ttu-id="12013-378">그런 다음는 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트 신호 프로세스 리디렉션된 쓸 때마다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림, 프로세스 종료 또는 호출 될 때까지 <xref:System.Diagnostics.Process.CancelErrorRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-378">Thereafter, the <xref:System.Diagnostics.Process.ErrorDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-379">비동기 출력을 처리 하는 응용 프로그램은 <xref:System.Diagnostics.Process.WaitForExit> 메서드를 출력 버퍼 플러시 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-379">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit> method to ensure that the output buffer has been flushed.</span></span> <span data-ttu-id="12013-380">사용 하 여를 지정 시간 초과 <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> 오버 로드는 *하지* 출력 버퍼 플러시 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-380">Note that specifying a timeout by using the <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> overload does *not* ensure the output buffer has been flushed.</span></span>
  
   
  
## Examples  
 <span data-ttu-id="12013-381">다음 예제에서는 `net view` 명령을 원격 컴퓨터에서 사용 가능한 네트워크 리소스를 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-381">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="12013-382">사용자가 대상 컴퓨터 이름 명령줄 인수로 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-382">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="12013-383">사용자 오류 출력에 대 한 파일 이름을 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-383">The user can also supply a file name for error output.</span></span> <span data-ttu-id="12013-384">이 예제에서는 net 명령, 프로세스가 끝날 때까지 및 다음 쓰기 출력 결과 콘솔에 대 한 대기 작업의 출력을 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-384">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="12013-385">필요에 따라 오류 파일의 사용자가 제공 하는 경우이 예제에서는 파일에 오류를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-385">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-386">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-386">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-387">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-387">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-388">연결된 프로세스가 종료될 때 연결된 프로세스에서 지정한 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-388">Gets the value that the associated process specified when it terminated.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-389">연결된 프로세스가 종료될 때 연결된 프로세스에서 지정한 코드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-389">The code that the associated process specified when it terminated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-390">사용 하 여 <xref:System.Diagnostics.Process.ExitCode%2A> 시스템 프로세스 종료 될 때 반환 되는 상태를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-390">Use <xref:System.Diagnostics.Process.ExitCode%2A> to get the status that the system process returned when it exited.</span></span> <span data-ttu-id="12013-391">정수 값을 반환할 처럼 종료 코드를 훨씬 사용할 수 있습니다는 `main()` 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-391">You can use the exit code much like an integer return value from a `main()` procedure.</span></span>  
  
 <span data-ttu-id="12013-392"><xref:System.Diagnostics.Process.ExitCode%2A> 해당 프로세스에 대 한 응용 프로그램 개발자가 구현한 특정 규칙을 반영 하는 프로세스에 대 한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-392">The <xref:System.Diagnostics.Process.ExitCode%2A> value for a process reflects the specific convention implemented by the application developer for that process.</span></span> <span data-ttu-id="12013-393">결정을 내릴 코드에서 종료 코드 값을 사용 하는 경우 응용 프로그램 프로세스에서 사용 하는 종료 코드 규칙을 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-393">If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</span></span>  
  
 <span data-ttu-id="12013-394">개발자는 일반적으로 하 여 성공적인 종료를 나타내고는 <xref:System.Diagnostics.Process.ExitCode%2A> 0이 고 지정 된 오류 값을 호출 하는 메서드에서 프로세스가 비정상적 종료의 원인을 확인 하는 데 사용할 수 있는 0이 아닌 값으로.</span><span class="sxs-lookup"><span data-stu-id="12013-394">Developers usually indicate a successful exit by an <xref:System.Diagnostics.Process.ExitCode%2A> value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination.</span></span> <span data-ttu-id="12013-395">다음이 지침을 따르는 필요는 없지만 규칙입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-395">It is not necessary to follow these guidelines, but they are the convention.</span></span>  
  
 <span data-ttu-id="12013-396">얻으려고 시도 하는 경우는 <xref:System.Diagnostics.Process.ExitCode%2A> 프로세스가 종료 되기 전에 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-396">If you try to get the <xref:System.Diagnostics.Process.ExitCode%2A> before the process has exited, the attempt throws an exception.</span></span> <span data-ttu-id="12013-397">검사는 <xref:System.Diagnostics.Process.HasExited%2A> 먼저 연결된 된 프로세스가 종료 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-397">Examine the <xref:System.Diagnostics.Process.HasExited%2A> property first to verify whether the associated process has terminated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-398">비동기 이벤트 처리기로 표준 출력이 리디렉션된, 경우에 출력 프로세스가 완료 되지 않을 때 가능한 <xref:System.Diagnostics.Process.HasExited%2A> 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-398">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when <xref:System.Diagnostics.Process.HasExited%2A> returns `true`.</span></span> <span data-ttu-id="12013-399">비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출는 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드를 확인 하기 전에 매개 변수를 취하지 <xref:System.Diagnostics.Process.HasExited%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-399">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
 <span data-ttu-id="12013-400">사용할 수는 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A> 메서드를 연결 된 프로세스를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-400">You can use the <xref:System.Diagnostics.Process.CloseMainWindow%2A> or the <xref:System.Diagnostics.Process.Kill%2A> method to cause an associated process to exit.</span></span>  
  
 <span data-ttu-id="12013-401">두 가지 방법으로 연결된 된 프로세스가 종료 될 때 알려진 시점: 동기적 및 비동기적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-401">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="12013-402">동기식 알림에서는 호출에는 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드를 연결 된 구성 요소가 종료 될 때까지 응용 프로그램의 처리를 일시 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-402">Synchronous notification relies on calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to pause the processing of your application until the associated component exits.</span></span> <span data-ttu-id="12013-403">비동기식 알림은 <xref:System.Diagnostics.Process.Exited> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-403">Asynchronous notification relies on the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="12013-404">비동기 알림을 사용 하는 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 으로 설정 되어 있어야 `true` 에 대 한는 <xref:System.Diagnostics.Process> 프로세스 종료 되었다는 알림을 받을 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-404">When using asynchronous notification, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the <xref:System.Diagnostics.Process> component to receive notification that the process has exited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-405">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-405">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-406">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-406">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-407">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-407">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-408">프로세스가 끝나지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-408">The process has not exited.</span>
          </span>
          <span data-ttu-id="12013-409">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-409">-or-</span>
          </span>
          <span data-ttu-id="12013-410">프로세스 <see cref="P:System.Diagnostics.Process.Handle" />이 유효하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-410">The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-411">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.ExitCode" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-411">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-412">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-412">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-413">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-413">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-414">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-414">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-415">프로세스가 종료될 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-415">Occurs when a process exits.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-416"><xref:System.Diagnostics.Process.Exited> 이벤트는 연결된 된 프로세스가 종료 되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-416">The <xref:System.Diagnostics.Process.Exited> event indicates that the associated process exited.</span></span> <span data-ttu-id="12013-417">이 항목 것을 의미 하는 프로세스 종료 (중단) 되었거나 닫힌 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-417">This occurrence means either that the process terminated (aborted) or successfully closed.</span></span> <span data-ttu-id="12013-418">이 이벤트는 경우에 발생할 수의 값은 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-418">This event can occur only if the value of the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="12013-419">두 가지 방법으로 연결된 된 프로세스가 종료 될 때 알려진 시점: 동기적 및 비동기적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-419">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="12013-420">동기 알림 호출을 의미는 <xref:System.Diagnostics.Process.WaitForExit%2A> 프로세스가 종료 될 때까지 현재 스레드를 차단 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-420">Synchronous notification means calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to block the current thread until the process exits.</span></span> <span data-ttu-id="12013-421">비동기 알림이 사용 하 여 <xref:System.Diagnostics.Process.Exited> 그 동안에 실행을 계속 호출 스레드를 허용 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-421">Asynchronous notification uses the <xref:System.Diagnostics.Process.Exited> event, which allows the calling thread to continue execution in the meantime.</span></span> <span data-ttu-id="12013-422">후자의 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 으로 설정 되어 있어야 `true` Exited 이벤트를 받기 위해 호출 응용 프로그램에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-422">In the latter case, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the calling application to receive the Exited event.</span></span>  
  
 <span data-ttu-id="12013-423">운영 체제 프로세스를 종료할 때 Exited 이벤트에 대 한 처리기를 등록 한 다른 모든 프로세스를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="12013-423">When the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event.</span></span> <span data-ttu-id="12013-424">이때 방금 전에 종료 하는 프로세스의 핸들 데 사용할 수와 같은 일부 속성을 액세스 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.HasExited%2A> 이 핸들을 완전히 해제 될 때까지 운영 체제에서 유지 관리 하는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-424">At this time, the handle of the process that just exited can be used to access some properties such as  <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.HasExited%2A> that the operating system maintains until it releases that handle completely.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-425">호출할 수 없습니다 종료 된 프로세스에 대 한 핸들, 있는 경우에 <xref:System.Diagnostics.Process.Start%2A> 다시 동일한 프로세스에 연결 하려면.</span><span class="sxs-lookup"><span data-stu-id="12013-425">Even if you have a handle to an exited process, you cannot call <xref:System.Diagnostics.Process.Start%2A> again to reconnect to the same process.</span></span> <span data-ttu-id="12013-426">호출 <xref:System.Diagnostics.Process.Start%2A> 자동으로 연결된 된 프로세스를 해제 하 고 동일한 파일 이지만 완전히 새로운 프로세스에 연결 <xref:System.Diagnostics.Process.Handle%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-426">Calling <xref:System.Diagnostics.Process.Start%2A> automatically releases the associated process and connects to a process with the same file but an entirely new <xref:System.Diagnostics.Process.Handle%2A>.</span></span>  
  
 <span data-ttu-id="12013-427">사용에 대 한 자세한 내용은 <xref:System.Diagnostics.Process.Exited> Windows Forms 응용 프로그램에서 이벤트 참조는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-427">For more information about the use of the <xref:System.Diagnostics.Process.Exited> event in Windows Forms applications, see the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-428">다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-428">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="12013-429">발생 시킵니다는 <xref:System.Diagnostics.Process.Exited> 때문에 프로세스가 종료 될 때 이벤트는 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 프로세스를 만들 때 속성이 설정 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-429">It raises the <xref:System.Diagnostics.Process.Exited> event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created.</span></span> <span data-ttu-id="12013-430"><xref:System.Diagnostics.Process.Exited> 이벤트 처리기 프로세스 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-430">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-431">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-431">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-432">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-432">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-433">연결된 프로세스가 종료된 시간을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-433">Gets the time that the associated process exited.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-434">연결된 프로세스가 종료된 시간을 나타내는 <see cref="T:System.DateTime" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-434">A <see cref="T:System.DateTime" /> that indicates when the associated process was terminated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-435">검색을 시도 하는 프로세스가 종료 되지 않은 경우는 <xref:System.Diagnostics.Process.ExitTime%2A> 속성 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-435">If the process has not terminated, attempting to retrieve the <xref:System.Diagnostics.Process.ExitTime%2A> property throws an exception.</span></span> <span data-ttu-id="12013-436">사용 하 여 <xref:System.Diagnostics.Process.HasExited%2A> 을 가져오기 전에 <xref:System.Diagnostics.Process.ExitTime%2A> 속성을 연결된 된 프로세스가 종료 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-436">Use <xref:System.Diagnostics.Process.HasExited%2A> before getting the <xref:System.Diagnostics.Process.ExitTime%2A> property to determine whether the associated process has terminated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-437">다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-437">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="12013-438">프로세스가 발생 시키는 <xref:System.Diagnostics.Process.Exited> 종료 될 때 이벤트 및 이벤트 처리기 표시는 <xref:System.Diagnostics.Process.ExitTime%2A> 속성 오류 코드 및 기타 정보를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-438">The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the <xref:System.Diagnostics.Process.ExitTime%2A> property and other process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-439">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-439">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-440">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.ExitTime" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-440">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-441">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-441">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-442">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-442">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-443">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-443">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-444">새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 가져온 후 현재 활성화되어 있는 프로세스에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-444">Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-445">호출하는 응용 프로그램에서 실행 중인 프로세스 리소스에 연결된 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-445">A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-446">이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 인스턴스 및 로컬 컴퓨터에서 프로세스 리소스와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-446">Use this method to create a new <xref:System.Diagnostics.Process> instance and associate it with the process resource on the local computer.</span></span>  
  
 <span data-ttu-id="12013-447">마찬가지로 <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, 및 <xref:System.Diagnostics.Process.GetProcesses%2A> 메서드 <xref:System.Diagnostics.Process.GetCurrentProcess%2A> 기존 리소스를 새 연결 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-447">Like the similar <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, and <xref:System.Diagnostics.Process.GetProcesses%2A> methods, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associates an existing resource with a new <xref:System.Diagnostics.Process> component.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-448">다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-448">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="12013-449">다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-449">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-450">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-450">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-451">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-451">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="12013-452">새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 만들어 사용자가 지정한 기존 프로세스 리소스에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-452">Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">
          <span data-ttu-id="12013-453">프로세스 리소스의 시스템 고유 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-453">The system-unique identifier of a process resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-454">로컬 컴퓨터의 프로세서에 대한 식별자가 주어지면 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-454">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-455">
            <paramref name="processId" /> 매개 변수에 의해 식별되는 로컬 프로세스 리소스에 연결된 <see cref="T:System.Diagnostics.Process" /> 구성 요소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-455">A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-456">이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 구성 요소는 로컬 컴퓨터에 프로세스 리소스와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-456">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on the local computer.</span></span> <span data-ttu-id="12013-457">프로세스 리소스 때문에 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 시스템 리소스를 만들지 않고 응용 프로그램에서 생성 된는 리소스를 연결 하지만 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-457">The process resource must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="12013-458">프로세스 <xref:System.Diagnostics.Process.Id%2A> 컴퓨터에서 현재 실행 중인 프로세스에만 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-458">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="12013-459">프로세스가 종료 된 후 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 만료 된 식별자를 전달 하는 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-459">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="12013-460">프로세스의 식별자는 모든 컴퓨터에서 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-460">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="12013-461"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 최대 하나의 프로세스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-461"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> returns one process at most.</span></span> <span data-ttu-id="12013-462">사용 하 여 특정 응용 프로그램을 실행 중인 모든 프로세스를 가져올 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-462">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="12013-463">여러 프로세스는 지정된 된 응용 프로그램을 실행 하는 컴퓨터에 있는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-463">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="12013-464">이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-464">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="12013-465">프로세스 식별자를 볼 수 있습니다는 `Processes` Windows 작업 관리자의 패널입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-465">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="12013-466">`PID` 프로세스에 할당 된 프로세스 식별자 열에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-466">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-467">다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-467">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="12013-468">다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-468">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12013-469">
            <paramref name="processId" /> 매개 변수로 지정된 프로세스가 실행되고 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-469">The process specified by the <paramref name="processId" /> parameter is not running.</span>
          </span>
          <span data-ttu-id="12013-470">식별자가 만료되었을 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-470">The identifier might be expired.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-471">프로세스가 이 개체에 의해 시작되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-471">The process was not started by this object.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-472">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-472">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-473">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-473">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">
          <span data-ttu-id="12013-474">프로세스 리소스의 시스템 고유 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-474">The system-unique identifier of a process resource.</span>
          </span>
        </param>
        <param name="machineName">
          <span data-ttu-id="12013-475">네트워크에 있는 컴퓨터 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-475">The name of a computer on the network.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-476">프로세스 식별자 및 네트워크에 있는 컴퓨터의 이름이 주어지면 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-476">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-477">
            <paramref name="processId" /> 매개 변수에 의해 식별되는 원격 프로세스 리소스에 연결된 <see cref="T:System.Diagnostics.Process" /> 구성 요소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-477">A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-478">이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 구성 요소는 네트워크에서 원격 컴퓨터에서 프로세스 리소스와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-478">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on a remote computer on the network.</span></span> <span data-ttu-id="12013-479">프로세스 리소스 때문에 지정된 된 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 시스템 리소스를 만들지 않고 응용 프로그램에서 생성 된는 리소스를 연결 하지만 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-479">The process resource must already exist on the specified computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="12013-480">프로세스 <xref:System.Diagnostics.Process.Id%2A> 컴퓨터에서 현재 실행 중인 프로세스에만 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-480">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="12013-481">프로세스가 종료 된 후 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 만료 된 식별자를 전달 하는 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-481">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="12013-482">프로세스의 식별자는 모든 컴퓨터에서 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-482">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="12013-483"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 최대 하나의 프로세스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-483"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> returns one process at most.</span></span> <span data-ttu-id="12013-484">사용 하 여 특정 응용 프로그램을 실행 중인 모든 프로세스를 가져올 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-484">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="12013-485">여러 프로세스는 지정된 된 응용 프로그램을 실행 하는 컴퓨터에 있는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-485">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="12013-486">이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-486">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="12013-487">프로세스 식별자를 볼 수 있습니다는 `Processes` Windows 작업 관리자의 패널입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-487">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="12013-488">`PID` 프로세스에 할당 된 프로세스 식별자 열에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-488">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="12013-489">지정 하지 않는 경우는 `machineName`, 로컬 컴퓨터가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-489">If you do not specify a `machineName`, the local computer is used.</span></span> <span data-ttu-id="12013-490">또는 설정 하 여 로컬 컴퓨터를 지정할 수 있습니다 `machineName` 값에 "." 또는 빈 문자열 ("").</span><span class="sxs-lookup"><span data-stu-id="12013-490">Alternatively, you can specify the local computer by setting `machineName` to the value "." or to an empty string ("").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-491">다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-491">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="12013-492">다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-492">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12013-493">
            <paramref name="processId" /> 매개 변수로 지정된 프로세스가 실행되고 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-493">The process specified by the <paramref name="processId" /> parameter is not running.</span>
          </span>
          <span data-ttu-id="12013-494">식별자가 만료되었을 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-494">The identifier might be expired.</span>
          </span>
          <span data-ttu-id="12013-495">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-495">-or-</span>
          </span>
          <span data-ttu-id="12013-496">
            <paramref name="machineName" /> 매개 변수 구문이 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-496">The <paramref name="machineName" /> parameter syntax is invalid.</span>
          </span>
          <span data-ttu-id="12013-497">이름의 길이가 0일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-497">The name might have length zero (0).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="12013-498">
            <paramref name="machineName" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-498">The <paramref name="machineName" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-499">프로세스가 이 개체에 의해 시작되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-499">The process was not started by this object.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-500">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-500">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-501">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-501">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="12013-502">새 <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 배열을 만들어 기존 프로세스 리소스에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-502">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-503">로컬 컴퓨터의 각 프로세스 리소스에 대해 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-503">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-504">로컬 컴퓨터에서 실행 중인 모든 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-504">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-505">이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소는 로컬 컴퓨터에 있는 모든 프로세스 리소스와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-505">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the local computer.</span></span> <span data-ttu-id="12013-506">프로세스 리소스 때문에 로컬 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcesses%2A> 아니라 응용 프로그램에서 생성 된 리소스에 연결 하지만 시스템 리소스를 만들지 않습니다 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-506">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="12013-507">백그라운드 프로세스를 실행 하는 운영 체제 자체에서는 때문에이 배열은 비어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-507">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="12013-508">모든 컴퓨터에서 실행 중인 프로세스를 검색 하지 않을 경우 사용 하 여의 수를 제한할 수 있습니다는 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-508">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="12013-509"><xref:System.Diagnostics.Process.GetProcessById%2A> 만듭니다는 <xref:System.Diagnostics.Process> 메서드에 전달 하는 프로세스 식별자에 의해 시스템에 식별 되는 프로세스와 연결 된 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-509"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="12013-510"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 이루어진 배열을 만들어 <xref:System.Diagnostics.Process> 메서드에 전달할 연결된 된 프로세스 자원이 실행 파일을 공유 하는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-510"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-511">서비스 호스트 프로세스 (svchost.exe)의 동일한 인스턴스 내에서 여러 Windows 서비스를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-511">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="12013-512">GetProcesses 개별 서비스를 식별 하지 않습니다. 이 위해 참조 <xref:System.ServiceProcess.ServiceController.GetServices%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-512">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-513">다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-513">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="12013-514">다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-514">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-515">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-515">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-516">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-516">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">
          <span data-ttu-id="12013-517">프로세스 목록을 읽어 올 컴퓨터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-517">The computer from which to read the list of processes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-518">지정한 컴퓨터의 각 프로세스 리소스에 대해 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-518">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-519">지정된 컴퓨터에서 실행 중인 모든 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-519">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-520">이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소 (일반적으로 원격) 지정한 컴퓨터에 있는 모든 프로세스 리소스와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-520">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the specified (usually remote) computer.</span></span> <span data-ttu-id="12013-521">프로세스 리소스 때문에 로컬 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcesses%2A> 아니라 응용 프로그램에서 생성 된 리소스에 연결 하지만 시스템 리소스를 만들지 않습니다 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-521">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="12013-522">백그라운드 프로세스를 실행 하는 운영 체제 자체에서는 때문에이 배열은 비어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-522">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="12013-523">모든 컴퓨터에서 실행 중인 프로세스를 검색 하지 않을 경우 사용 하 여의 수를 제한할 수 있습니다는 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-523">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="12013-524"><xref:System.Diagnostics.Process.GetProcessById%2A> 만듭니다는 <xref:System.Diagnostics.Process> 메서드에 전달 하는 프로세스 식별자에 의해 시스템에 식별 되는 프로세스와 연결 된 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-524"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="12013-525"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 이루어진 배열을 만들어 <xref:System.Diagnostics.Process> 메서드에 전달할 연결된 된 프로세스 자원이 실행 파일을 공유 하는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-525"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
 <span data-ttu-id="12013-526">이 오버 로드는 <xref:System.Diagnostics.Process.GetProcesses%2A> 메서드는 네트워크의 원격 컴퓨터에서 실행 중인 프로세스 리소스의 목록을 검색 하려면 일반적으로 사용 되지만 전달 하 여 로컬 컴퓨터를 지정할 수 있습니다 "."입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-526">This overload of the <xref:System.Diagnostics.Process.GetProcesses%2A> method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing ".".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-527">서비스 호스트 프로세스 (svchost.exe)의 동일한 인스턴스 내에서 여러 Windows 서비스를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-527">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="12013-528">GetProcesses 개별 서비스를 식별 하지 않습니다. 이 위해 참조 <xref:System.ServiceProcess.ServiceController.GetServices%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-528">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-529">다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-529">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="12013-530">다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-530">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12013-531">
            <paramref name="machineName" /> 매개 변수 구문이 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-531">The <paramref name="machineName" /> parameter syntax is invalid.</span>
          </span>
          <span data-ttu-id="12013-532">길이가 0일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-532">It might have length zero (0).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="12013-533">
            <paramref name="machineName" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-533">The <paramref name="machineName" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-534">운영 체제 플랫폼이 원격 컴퓨터에서 이 작업을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-534">The operating system platform does not support this operation on remote computers.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-535">프로세스 정보를 가져오는 데 사용되는  성능 카운터 API에 액세스하는 데 문제가 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-535">There are problems accessing the performance counter API's used to get process information.</span>
          </span>
          <span data-ttu-id="12013-536">이 예외는 Windows NT, Windows 2000 및 Windows XP에 해당됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-536">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-537">내부 시스템 API에 액세스하는 동안 문제가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-537">A problem occurred accessing an underlying system API.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-538">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-538">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-539">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-539">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="12013-540">
            <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 새 배열을 만들어 지정한 프로세스 이름을 공유하는 모든 기존 프로세스 리소스에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-540">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">
          <span data-ttu-id="12013-541">프로세스의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-541">The friendly name of the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-542">
            <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 새 배열을 만들어 지정한 프로세스 이름을 공유하는 로컬 컴퓨터의 모든 프로세스 리소스에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-542">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-543">지정한 응용 프로그램 또는 파일을 실행 중인 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-543">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-544">이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소는 로컬 컴퓨터에서 동일한 실행 파일을 실행 하는 모든 프로세스 리소스와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-544">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the local computer.</span></span> <span data-ttu-id="12013-545">프로세스 리소스 때문에 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 시스템 리소스를 만들지 않습니다 되지만 아니라 응용 프로그램에서 생성 된 연결 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-545">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="12013-546">A `processName` 메서드가 반환한 배열이 비워 둘 수 있으므로 로컬 컴퓨터에서 현재 실행 하지 않는 실행 파일에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-546">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="12013-547">프로세스 이름은 예: Outlook에서 확장명이.exe 또는 경로 포함 하지 않는 프로세스에 대 한는 친숙 한 이름이입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-547">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="12013-548"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 가져오고 동일한 실행 파일에 연관 된 모든 프로세스를 조작 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-548"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="12013-549">예를 들어 실행 파일 이름으로 전달할 수 있습니다는 `processName` 해당 실행 파일의 모든 실행 중인 인스턴스를 종료 하기 위해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-549">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="12013-550">하지만 프로세스 <xref:System.Diagnostics.Process.Id%2A> 은 시스템에 단일 프로세스 리소스를 고유 로컬 컴퓨터에서 여러 프로세스가 실행 될 수 있습니다 하 여 지정 된 응용 프로그램은 `processName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-550">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="12013-551">따라서 <xref:System.Diagnostics.Process.GetProcessById%2A> 많아야 한 프로세스를 반환 하지만 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-551">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="12013-552">표준 API 호출을 사용 하는 프로세스를 조작 해야 하는 경우 이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-552">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="12013-553">프로세스 이름만 통해 표시 되지만의 배열을 검색 했으면 프로세스 리소스에 액세스할 수 <xref:System.Diagnostics.Process> 연관 된 구성 요소 프로세스 리소스 있습니다 수 시작, 종료 및 시스템 리소스를 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-553">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-554">다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-554">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="12013-555">다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-555">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-556">프로세스 정보를 가져오는 데 사용되는  성능 카운터 API에 액세스하는 데 문제가 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-556">There are problems accessing the performance counter API's used to get process information.</span>
          </span>
          <span data-ttu-id="12013-557">이 예외는 Windows NT, Windows 2000 및 Windows XP에 해당됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-557">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-558">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-558">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-559">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-559">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">
          <span data-ttu-id="12013-560">프로세스의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-560">The friendly name of the process.</span>
          </span>
        </param>
        <param name="machineName">
          <span data-ttu-id="12013-561">네트워크에 있는 컴퓨터 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-561">The name of a computer on the network.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-562">
            <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 새 배열을 만들어 지정한 프로세스 이름을 공유하는 원격 컴퓨터에 있는 모든 프로세스 리소스에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-562">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-563">지정한 응용 프로그램 또는 파일을 실행 중인 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-563">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-564">이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소와 지정된 된 컴퓨터에서 동일한 실행 파일을 실행 하는 모든 프로세스 리소스를 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-564">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the specified computer.</span></span> <span data-ttu-id="12013-565">프로세스 리소스 때문에 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 시스템 리소스를 만들지 않습니다 되지만 아니라 응용 프로그램에서 생성 된 연결 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-565">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="12013-566">A `processName` 메서드가 반환한 배열이 비워 둘 수 있으므로 로컬 컴퓨터에서 현재 실행 하지 않는 실행 파일에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-566">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="12013-567">프로세스 이름은 예: Outlook에서 확장명이.exe 또는 경로 포함 하지 않는 프로세스에 대 한는 친숙 한 이름이입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-567">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="12013-568"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 가져오고 동일한 실행 파일에 연관 된 모든 프로세스를 조작 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-568"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="12013-569">예를 들어 실행 파일 이름으로 전달할 수 있습니다는 `processName` 해당 실행 파일의 모든 실행 중인 인스턴스를 종료 하기 위해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-569">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="12013-570">하지만 프로세스 <xref:System.Diagnostics.Process.Id%2A> 은 시스템에 단일 프로세스 리소스를 고유 로컬 컴퓨터에서 여러 프로세스가 실행 될 수 있습니다 하 여 지정 된 응용 프로그램은 `processName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-570">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="12013-571">따라서 <xref:System.Diagnostics.Process.GetProcessById%2A> 많아야 한 프로세스를 반환 하지만 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-571">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="12013-572">표준 API 호출을 사용 하는 프로세스를 조작 해야 하는 경우 이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-572">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="12013-573">프로세스 이름만 통해 표시 되지만의 배열을 검색 했으면 프로세스 리소스에 액세스할 수 <xref:System.Diagnostics.Process> 연관 된 구성 요소 프로세스 리소스 있습니다 수 시작, 종료 및 시스템 리소스를 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-573">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
 <span data-ttu-id="12013-574">프로세스를 가져올 원격 컴퓨터 모두 로컬 컴퓨터에이 오버 로드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-574">You can use this overload to get processes on the local computer as well as on a remote computer.</span></span> <span data-ttu-id="12013-575">사용 하 여 "." 로컬 컴퓨터를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-575">Use "." to specify the local computer.</span></span> <span data-ttu-id="12013-576">다른 오버 로드를 존재 하는 기본적으로 로컬 컴퓨터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-576">Another overload exists that uses the local computer by default.</span></span>  
  
 <span data-ttu-id="12013-577">프로세스 통계와 같은 프로세스에 대 한 정보를 보려면에 원격 컴퓨터에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-577">You can access processes on remote computers only to view information, such as statistics, about the processes.</span></span> <span data-ttu-id="12013-578">닫기, 종료할 수 없습니다 (사용 하 여 <xref:System.Diagnostics.Process.Kill%2A>), 또는 원격 컴퓨터에서 프로세스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-578">You cannot close, terminate (using <xref:System.Diagnostics.Process.Kill%2A>), or start processes on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-579">다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-579">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="12013-580">다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-580">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12013-581">
            <paramref name="machineName" /> 매개 변수 구문이 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-581">The <paramref name="machineName" /> parameter syntax is invalid.</span>
          </span>
          <span data-ttu-id="12013-582">길이가 0일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-582">It might have length zero (0).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="12013-583">
            <paramref name="machineName" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-583">The <paramref name="machineName" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-584">운영 체제 플랫폼이 원격 컴퓨터에서 이 작업을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-584">The operating system platform does not support this operation on remote computers.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-585">프로세스 정보를 가져오는 데 사용되는  성능 카운터 API에 액세스하는 데 문제가 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-585">There are problems accessing the performance counter API's used to get process information.</span>
          </span>
          <span data-ttu-id="12013-586">이 예외는 Windows NT, Windows 2000 및 Windows XP에 해당됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-586">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-587">내부 시스템 API에 액세스하는 동안 문제가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-587">A problem occurred accessing an underlying system API.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-588">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-588">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-589">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-589">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="12013-590">비관리 코드를 호출 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-590">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="12013-591">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-591">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-592">연결된 프로세스의 기본 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-592">Gets the native handle of the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-593">연결된 프로세스가 시작될 때 운영 체제에서 해당 프로세스에 할당한 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-593">The handle that the operating system assigned to the associated process when the process was started.</span>
          </span>
          <span data-ttu-id="12013-594">시스템에서는 이 핸들을 사용하여 프로세스 특성을 추적합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-594">The system uses this handle to keep track of process attributes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-595">응용 프로그램 여러 프로세스 정보 및 제어 기능에 대 한 매개 변수로 사용할 수 있는 프로세스에 대 한 핸들을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-595">An application can obtain a handle to a process that can be used as a parameter to many process-information and control functions.</span></span> <span data-ttu-id="12013-596">이 핸들을 사용 하 여 초기화는 <xref:System.Threading.WaitHandle> 하거나 플랫폼 네이티브 메서드를 호출를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-596">You can use this handle to initialize a <xref:System.Threading.WaitHandle> or to call native methods with platform invoke.</span></span>  
  
 <span data-ttu-id="12013-597">이 프로세스 핸들은 개인 응용 프로그램에 즉, 프로세스를 공유할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-597">This process handle is private to an application--in other words, process handles cannot be shared.</span></span> <span data-ttu-id="12013-598">프로세스는 또한 프로세스에 <xref:System.Diagnostics.Process.Id%2A> 는 달리는 <xref:System.Diagnostics.Process.Handle%2A>, 고유한 그리고이 시스템 전체에서 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-598">A process also has a process <xref:System.Diagnostics.Process.Id%2A> which, unlike the <xref:System.Diagnostics.Process.Handle%2A>, is unique and, therefore, valid throughout the system.</span></span>  
  
 <span data-ttu-id="12013-599">호출을 통해 시작 되는 프로세스만 <xref:System.Diagnostics.Process.Start%2A> 설정는 <xref:System.Diagnostics.Process.Handle%2A> 해당 속성 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-599">Only processes started through a call to <xref:System.Diagnostics.Process.Start%2A> set the <xref:System.Diagnostics.Process.Handle%2A> property of the corresponding <xref:System.Diagnostics.Process> instances.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-600">프로세스가 시작되지 않았거나 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-600">The process has not been started or has exited.</span>
          </span>
          <span data-ttu-id="12013-601">이 <see cref="P:System.Diagnostics.Process.Handle" /> 인스턴스에 연결된 프로세스가 없으므로 <see cref="T:System.Diagnostics.Process" /> 속성을 읽을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-601">The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.</span>
          </span>
          <span data-ttu-id="12013-602">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-602">-or-</span>
          </span>
          <span data-ttu-id="12013-603">
            <see cref="T:System.Diagnostics.Process" /> 인스턴스가 실행 프로세스에 연결되었지만 모든 액세스 권한을 가진 핸들을 가져오는 데 필요한 사용 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-603">The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-604">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.Handle" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-604">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-605">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-605">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-606">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-606">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-607">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-607">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-608">프로세스에서 연 핸들 수를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-608">Gets the number of handles opened by the process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-609">프로세스에서 연 운영 체제 핸들의 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-609">The number of operating system handles the process has opened.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-610">핸들은 프로세스 개체를 참조할 수 있는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-610">Handles provide a way for a process to refer to objects.</span></span> <span data-ttu-id="12013-611">프로세스는 파일, 리소스, 메시지 큐, 및 기타 여러 운영 체제 개체에 대 한 핸들을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-611">A process can obtain handles to files, resources, message queues, and many other operating system objects.</span></span> <span data-ttu-id="12013-612">운영 체제 프로세스에 연결 된 핸들 수 0 일 경우에 메모리를 회수 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-612">The operating system reclaims the memory associated with the process only when the handle count is zero.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-613">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-613">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-614">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-614">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-615">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-615">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-616">연결된 프로세스가 종료되었는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-616">Gets a value indicating whether the associated process has been terminated.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-617">
            <see cref="T:System.Diagnostics.Process" /> 구성 요소가 참조하는 운영 체제 프로세스가 종료되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-617">
              <see langword="true" /> if the operating system process referenced by the <see cref="T:System.Diagnostics.Process" /> component has terminated; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-618">값이 `true` 에 대 한 <xref:System.Diagnostics.Process.HasExited%2A> 연결된 된 프로세스가 종료 되었음을 나타냅니다, 정상 또는 비정상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-618">A value of `true` for <xref:System.Diagnostics.Process.HasExited%2A> indicates that the associated process has terminated, either normally or abnormally.</span></span> <span data-ttu-id="12013-619">요청 하거나 강제로 연결된 된 프로세스를 호출 하 여 종료 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-619">You can request or force the associated process to exit by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-620">프로세스에 열려 있는 핸들이 없으면 프로세스는 종료 되었으므로 하지만 핸들, 종료 코드 및 종료 시간과 같은 프로세스에 대 한 관리 정보는 유지 하는 경우 운영 체제 프로세스 메모리를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-620">If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time.</span></span> <span data-ttu-id="12013-621">이 정보를 얻으려면 사용할 수 있습니다는 <xref:System.Diagnostics.Process.ExitCode%2A> 및 <xref:System.Diagnostics.Process.ExitTime%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-621">To get this information, you can use the <xref:System.Diagnostics.Process.ExitCode%2A> and <xref:System.Diagnostics.Process.ExitTime%2A> properties.</span></span> <span data-ttu-id="12013-622">이러한 속성은이 구성 요소에 의해 시작 된 프로세스에 대 한 자동으로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="12013-622">These properties are populated automatically for processes that were started by this component.</span></span> <span data-ttu-id="12013-623">관리 정보를 놓을 때 모든는 <xref:System.Diagnostics.Process> 시스템 프로세스와 관련 된 구성 요소 소멸 되 고 종료 된 프로세스에 핸들이 더 이상 없을 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-623">The administrative information is released when all the <xref:System.Diagnostics.Process> components that are associated with the system process are destroyed and hold no more handles to the exited process.</span></span>  
  
 <span data-ttu-id="12013-624">코드와는 별개로 프로세스를 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-624">A process can terminate independently of your code.</span></span> <span data-ttu-id="12013-625">이 구성 요소를 사용 하 여 프로세스를 시작한 경우 시스템의 값을 업데이트 <xref:System.Diagnostics.Process.HasExited%2A> 자동으로 연결된 된 프로세스가 종료 되지 독립적으로 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-625">If you started the process using this component, the system updates the value of <xref:System.Diagnostics.Process.HasExited%2A> automatically, even if the associated process exits independently.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-626">비동기 이벤트 처리기로 표준 출력이 리디렉션된 때 마일스 톤을 출력 프로세스가 완료 되지 않을 때이 속성은 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-626">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns `true`.</span></span> <span data-ttu-id="12013-627">비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출는 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드를 확인 하기 전에 매개 변수를 취하지 <xref:System.Diagnostics.Process.HasExited%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-627">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-628">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-628">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-629">최대 10 초 동안 2 초 간격 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-629">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="12013-630">이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-630">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="12013-631">이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-631">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-632">개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-632">There is no process associated with the object.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-633">프로세스의 종료 코드를 검색할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-633">The exit code for the process could not be retrieved.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-634">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-634">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-635">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-635">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-636">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-636">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-637">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-637">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-638">연결된 프로세스의 고유 식별자를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-638">Gets the unique identifier for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-639">이 <see cref="T:System.Diagnostics.Process" /> 인스턴스에서 참조하는 프로세스의 고유 식별자입니다. 이 식별자는 시스템에서 생성됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-639">The system-generated unique identifier of the process that is referenced by this <see cref="T:System.Diagnostics.Process" /> instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-640">프로세스 <xref:System.Diagnostics.Process.Id%2A> 연결된 된 프로세스가 실행 되지 않는 경우에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-640">The process <xref:System.Diagnostics.Process.Id%2A> is not valid if the associated process is not running.</span></span> <span data-ttu-id="12013-641">검색 하기 전에 프로세스가 실행 되 고 있는지 확인 해야 따라서는 <xref:System.Diagnostics.Process.Id%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-641">Therefore, you should ensure that the process is running before attempting to retrieve the <xref:System.Diagnostics.Process.Id%2A> property.</span></span> <span data-ttu-id="12013-642">프로세스가 종료 될 때까지 프로세스 식별자가 시스템에서 프로세스를 고유 하 게 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-642">Until the process terminates, the process identifier uniquely identifies the process throughout the system.</span></span>  
  
 <span data-ttu-id="12013-643">새 로컬 또는 원격 컴퓨터에서 실행 중인 프로세스에 연결할 수 있습니다 <xref:System.Diagnostics.Process> 프로세스 식별자를 전달 하 여 인스턴스는 <xref:System.Diagnostics.Process.GetProcessById%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-643">You can connect a process that is running on a local or remote computer to a new <xref:System.Diagnostics.Process> instance by passing the process identifier to the <xref:System.Diagnostics.Process.GetProcessById%2A> method.</span></span> <span data-ttu-id="12013-644"><xref:System.Diagnostics.Process.GetProcessById%2A> `static` 새 구성 요소를 만드는 메서드를 설정 하 고는 <xref:System.Diagnostics.Process.Id%2A> 새 속성 <xref:System.Diagnostics.Process> 자동으로 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-644"><xref:System.Diagnostics.Process.GetProcessById%2A> is a `static` method that creates a new component and sets the <xref:System.Diagnostics.Process.Id%2A> property for the new <xref:System.Diagnostics.Process> instance automatically.</span></span>  
  
 <span data-ttu-id="12013-645">시스템 프로세스 식별자를 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-645">Process identifiers can be reused by the system.</span></span> <span data-ttu-id="12013-646"><xref:System.Diagnostics.Process.Id%2A> 연결된 프로세스가 실행 중인 동안에 속성 값이 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-646">The <xref:System.Diagnostics.Process.Id%2A> property value is unique only while the associated process is running.</span></span> <span data-ttu-id="12013-647">시스템 프로세스 작업이 종료 된 후 다시 사용할 수는 <xref:System.Diagnostics.Process.Id%2A> 관련 되지 않은 프로세스에 대 한 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-647">After the process has terminated, the system can reuse the <xref:System.Diagnostics.Process.Id%2A> property value for an unrelated process.</span></span>  
  
 <span data-ttu-id="12013-648">시스템에서 고유 식별자 이므로 전달할 수 있습니다 다른 스레드에 전달 하는 대신 한 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-648">Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-649">이 작업 시스템 리소스를 절약 하면서 프로세스가 올바르게 확인 되더라도 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-649">This action can save system resources yet guarantee that the process is correctly identified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-650">다음 예제를 가져오는 방법을 <xref:System.Diagnostics.Process.Id%2A> 모든 응용 프로그램의 인스턴스를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-650">The following example demonstrates how to obtain the <xref:System.Diagnostics.Process.Id%2A> for all running instances of an application.</span></span> <span data-ttu-id="12013-651">코드 메모장의 새 인스턴스를 만들고 메모장의 모든 인스턴스를 나열 하 고 사용자를 입력할 수 있도록 합니다는 <xref:System.Diagnostics.Process.Id%2A> 특정 인스턴스를 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-651">The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the <xref:System.Diagnostics.Process.Id%2A> number to remove a specific instance.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-652">프로세스의 <see cref="P:System.Diagnostics.Process.Id" /> 속성이 설정되어 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-652">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.</span>
          </span>
          <span data-ttu-id="12013-653">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-653">-or-</span>
          </span>
          <span data-ttu-id="12013-654">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-654">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-655">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-655">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-656">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-656">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-657">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-657">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-658">연결된 프로세스를 즉시 중지합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-658">Immediately stops the associated process.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-659"><xref:System.Diagnostics.Process.Kill%2A> 프로세스의 종료를 강제로 수행 하는 동안 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 만 종료를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-659"><xref:System.Diagnostics.Process.Kill%2A> forces a termination of the process, while <xref:System.Diagnostics.Process.CloseMainWindow%2A> only requests a termination.</span></span> <span data-ttu-id="12013-660">그래픽 인터페이스를 사용 하 여 프로세스를 실행할 때 해당 메시지 루프는 대기 상태에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-660">When a process with a graphical interface is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="12013-661">운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다 메시지 루프를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-661">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="12013-662">호출 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 는 잘 구성 된 응용 프로그램에서 자식 창을 닫고 응용 프로그램에 대 한 실행 중인 모든 메시지 루프를 취소 주 창에 근접 하는 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-662">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="12013-663">요청을 호출 하 여 프로세스를 종료 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 응용 프로그램 종료을 강제로 적용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-663">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="12013-664">응용 프로그램을 종료 하기 전에 사용자 확인을 위해 묻거나 종료를 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-664">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="12013-665">응용 프로그램을 종료 하려면을 사용 하 여는 <xref:System.Diagnostics.Process.Kill%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-665">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="12013-666">동작은 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 시스템 메뉴를 사용 하 여 응용 프로그램의 주 창을 닫을 수 있는 사용자와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-666">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="12013-667">따라서 주 창을 닫아 프로세스를 종료를 요청 응용 프로그램이 즉시 종료 강제로 적용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-667">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-668"><xref:System.Diagnostics.Process.Kill%2A> 메서드가 비동기적으로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-668">The <xref:System.Diagnostics.Process.Kill%2A> method executes asynchronously.</span></span> <span data-ttu-id="12013-669">호출한 후의 <xref:System.Diagnostics.Process.Kill%2A> 메서드를 호출은 <xref:System.Diagnostics.Process.WaitForExit%2A> 검사를 종료 하려면 프로세스를 대기 하는 메서드는 <xref:System.Diagnostics.Process.HasExited%2A> 속성을 확인 하는 경우 프로세스가 종료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-669">After calling the <xref:System.Diagnostics.Process.Kill%2A> method, call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to wait for the process to exit, or check the <xref:System.Diagnostics.Process.HasExited%2A> property to determine if the process has exited.</span></span>  
  
 <span data-ttu-id="12013-670">프로세스에 의해 편집 하는 데이터 또는 프로세스에 할당 된 리소스 손실 될 수 있습니다를 호출 하면 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-670">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-671"><xref:System.Diagnostics.Process.Kill%2A> 비정상적인 프로세스 종료를 사용 하면 필요한 경우에 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-671"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination and should be used only when necessary.</span></span> <span data-ttu-id="12013-672"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 프로세스의 순차적 종료가 가능 하 고 인터페이스와 함께 응용 프로그램에 대 한 것 이므로 모든 창을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-672"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="12013-673">경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 실패 하면 צ ְ ײ <xref:System.Diagnostics.Process.Kill%2A> 으 프로세스를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-673">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="12013-674"><xref:System.Diagnostics.Process.Kill%2A> 그래픽 인터페이스를 갖지 않는 프로세스를 종료 하는 유일한 방법이입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-674"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="12013-675">호출할 수 있습니다 <xref:System.Diagnostics.Process.Kill%2A> 및 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 로컬 컴퓨터에서 실행 중인 프로세스에 대해서만 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-675">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="12013-676">종료 하려면 원격 컴퓨터에서 프로세스 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-676">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="12013-677">만 원격 컴퓨터에서 실행 중인 프로세스에 대 한 정보를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-677">You can only view information for processes running on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-678">경우에 대 한 호출은 <xref:System.Diagnostics.Process.Kill%2A> 메서드는 프로세스를 종료 하는 동안 구성 됩니다는 <xref:System.ComponentModel.Win32Exception> 액세스가 거부에 대해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-678">If the call to the <xref:System.Diagnostics.Process.Kill%2A> method is made while the process is currently terminating, a <xref:System.ComponentModel.Win32Exception> is thrown for Access Denied.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-679">연결된 프로세스를 종료할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-679">The associated process could not be terminated.</span>
          </span>
          <span data-ttu-id="12013-680">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-680">-or-</span>
          </span>
          <span data-ttu-id="12013-681">프로세스가 종료됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-681">The process is terminating.</span>
          </span>
          <span data-ttu-id="12013-682">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-682">-or-</span>
          </span>
          <span data-ttu-id="12013-683">연결된 프로세스가 Win16 실행 파일입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-683">The associated process is a Win16 executable.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-684">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="M:System.Diagnostics.Process.Kill" />를 호출하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-684">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-685">이 메서드는 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-685">The method is available only for processes running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-686">프로세스가 이미 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-686">The process has already exited.</span>
          </span>
          <span data-ttu-id="12013-687">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-687">-or-</span>
          </span>
          <span data-ttu-id="12013-688">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-688">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-689">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-689">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-690">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-690">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-691">
            <see cref="T:System.Diagnostics.Process" /> 구성 요소를 특수 모드에서 실행되는 운영 체제 프로세스와 상호 작용할 수 없는 상태로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-691">Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-692">일부 운영 체제 프로세스를 특수 모드에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-692">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="12013-693">속성을 읽거나 이러한 프로세스에 연결할 수 없으면 호출 하지 않는 한 <xref:System.Diagnostics.Process.EnterDebugMode%2A> 구성 요소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-693">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="12013-694">호출 <xref:System.Diagnostics.Process.LeaveDebugMode%2A> 특수 모드에서 실행 되는 이러한 프로세스에 대 한 액세스를 더 이상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-694">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-695">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-695">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-696">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-696">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-697">연결된 프로세스가 실행 중인 컴퓨터 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-697">Gets the name of the computer the associated process is running on.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-698">연결된 프로세스가 실행 중인 컴퓨터 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-698">The name of the computer that the associated process is running on.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-699">호출할 수 없습니다. 하지만 원격 컴퓨터에서 실행 중인 프로세스에 대 한 프로세스 정보 및 통계 데이터를 볼 수 있습니다 <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, 또는 <xref:System.Diagnostics.Process.Kill%2A> 원격 컴퓨터에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-699">You can view statistical data and process information for processes running on remote computers but you cannot call <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, or <xref:System.Diagnostics.Process.Kill%2A> on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-700">연결된 된 프로세스를 로컬 컴퓨터에서 실행할 때이 속성은 마침표 반환 (".") 컴퓨터 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-700">When the associated process is executing on the local machine, this property returns a period (".") for the machine name.</span></span> <span data-ttu-id="12013-701">사용 해야는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 올바른 컴퓨터 이름을 가져올 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-701">You should use the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to get the correct machine name.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-702">사용 먼저 다음 예제에서는 원격 컴퓨터에서 메모장의 인스턴스를 하나 이상 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-702">To use the following example you must first start at least one instance of Notepad on a remote computer.</span></span> <span data-ttu-id="12013-703">이 예제에서는 요청 메모장 실행 되 고 해당을 표시 하는 원격 컴퓨터의 이름을 <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, 및 <xref:System.Diagnostics.Process.MachineName%2A> 각 인스턴스에 대 한 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-703">The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and <xref:System.Diagnostics.Process.MachineName%2A> properties for each instance.</span></span>  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-704">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-704">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-705">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-705">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-706">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-706">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-707">연결된 프로세스의 주 모듈을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-707">Gets the main module for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-708">프로세스를 시작하는 데 사용된 <see cref="T:System.Diagnostics.ProcessModule" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-708">The <see cref="T:System.Diagnostics.ProcessModule" /> that was used to start the process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-709">프로세스 모듈 특정 프로세스에 로드 되는.dll 또는.exe 파일을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-709">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="12013-710"><xref:System.Diagnostics.Process.MainModule%2A> 속성을 사용 하면 모듈 이름, 파일 이름 및 모듈 메모리 정보를 포함 하 여 프로세스를 시작 하는 데 사용 되는 실행 파일에 대 한 정보를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-710">The <xref:System.Diagnostics.Process.MainModule%2A> property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-711">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MainModule" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-711">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-712">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-712">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-713">32비트 프로세스가 64비트 프로세스의 모듈에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-713">A 32-bit process is trying to access the modules of a 64-bit process.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-714">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-714">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-715">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-715">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span>
          </span>
          <span data-ttu-id="12013-716">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-716">-or-</span>
          </span>
          <span data-ttu-id="12013-717">프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-717">The process has exited.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-718">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-718">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-719">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-719">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-720">연결된 프로세스의 주 창에 대한 창 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-720">Gets the window handle of the main window of the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-721">연결된 프로세스의 주 창에 대한 창 핸들입니다. 이 창 핸들은 시스템에서 생성됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-721">The system-generated window handle of the main window of the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-722">주 현재 포커스가 있는 프로세스에서 연 창입니다 (의 <xref:System.Windows.Forms.Form.TopLevel%2A> 양식).</span><span class="sxs-lookup"><span data-stu-id="12013-722">The main window is the window opened by the process that currently has the focus (the <xref:System.Windows.Forms.Form.TopLevel%2A> form).</span></span> <span data-ttu-id="12013-723">사용 해야 합니다는 <xref:System.Diagnostics.Process.Refresh%2A> 를 새로 고치려면 메서드는 <xref:System.Diagnostics.Process> 변경 된 경우 현재 주 창 핸들을 가져올 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-723">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span> <span data-ttu-id="12013-724">창 핸들은 캐시 되므로 일반적으로 사용 <xref:System.Diagnostics.Process.Refresh%2A> 현재 핸들 검색을 보장 하기 위해 사전에 미리 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-724">In general, because the window handle is cached, use <xref:System.Diagnostics.Process.Refresh%2A> beforehand to guarantee that you’ll retrieve the current handle.</span></span>  
  
 <span data-ttu-id="12013-725">가져올 수는 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 로컬 컴퓨터에서 실행 되는 프로세스에 대해서만 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-725">You can get the <xref:System.Diagnostics.Process.MainWindowHandle%2A> property only for processes that are running on the local computer.</span></span> <span data-ttu-id="12013-726"><xref:System.Diagnostics.Process.MainWindowHandle%2A> 속성은 고유 하 게 식별 하는 프로세스와 연결 된 창은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-726">The <xref:System.Diagnostics.Process.MainWindowHandle%2A> property is a value that uniquely identifies the window that is associated with the process.</span></span>  
  
 <span data-ttu-id="12013-727">프로세스에 연결 된 프로세스에 그래픽 인터페이스 하는 경우에 주 창.</span><span class="sxs-lookup"><span data-stu-id="12013-727">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="12013-728">연결된 된 프로세스에는 주 창, 없는 경우는 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-728">If the associated process does not have a main window, the <xref:System.Diagnostics.Process.MainWindowHandle%2A> value is zero.</span></span> <span data-ttu-id="12013-729">값 0이 숨겨져 있는 프로세스에 대 한 즉, 작업 표시줄에 표시 되지 않는 처리 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-729">The value is also zero for processes that have been hidden, that is, processes that are not visible in the taskbar.</span></span> <span data-ttu-id="12013-730">이 작업 표시줄의 맨 오른쪽 알림 영역에서 아이콘으로 표시 되는 프로세스에 대 한 사례 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-730">This can be the case for processes that appear as icons in the notification area, at the far right of the taskbar.</span></span>  
  
 <span data-ttu-id="12013-731">사용 하 여 방금 시작한 프로세스의 주 창 핸들을 사용할 경우 고려해는 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 메서드 시작이 완료 하는 프로세스의 주 창 핸들이 만들어졌는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-731">If you have just started a process and want to use its main window handle, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="12013-732">그렇지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-732">Otherwise, an exception will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-733">프로세스가 종료되어 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />이 정의되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-733">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-734">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-734">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-735">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-735">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-736">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-736">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-737">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-737">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-738">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-738">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-739">프로세스의 주 창에 대한 캡션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-739">Gets the caption of the main window of the process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-740">프로세스의 주 창 제목입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-740">The main window title of the process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-741">프로세스에 연결 된 프로세스에 그래픽 인터페이스 하는 경우에 주 창.</span><span class="sxs-lookup"><span data-stu-id="12013-741">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="12013-742">연결된 된 프로세스에 주 창이 없는 경우 (있도록 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 0), <xref:System.Diagnostics.Process.MainWindowTitle%2A> 은 빈 문자열 ("").</span><span class="sxs-lookup"><span data-stu-id="12013-742">If the associated process does not have a main window (so that <xref:System.Diagnostics.Process.MainWindowHandle%2A> is zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> is an empty string ("").</span></span> <span data-ttu-id="12013-743">사용 하 여 방금 시작한 프로세스의 주 창 제목에 사용 하려는 하는 경우 고려는 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 메서드 시작이 완료 하는 프로세스의 주 창 핸들이 만들어졌는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-743">If you have just started a process and want to use its main window title, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="12013-744">그렇지 않으면 시스템에서 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-744">Otherwise, the system throws an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-745">현재 포커스가 있는; 창인지 주 창 프로세스에 대 한 기본 창 되지 않을 수 있습니다이 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-745">The main window is the window that currently has the focus; note that this might not be the primary window for the process.</span></span> <span data-ttu-id="12013-746">사용 해야 합니다는 <xref:System.Diagnostics.Process.Refresh%2A> 를 새로 고치려면 메서드는 <xref:System.Diagnostics.Process> 변경 된 경우 현재 주 창 핸들을 가져올 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-746">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-747">다음 예제에서는 메모장의 인스턴스를 시작 하 고 프로세스의 주 창의 캡션을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-747">The following example starts an instance of Notepad and retrieves the caption of the main window of the process.</span></span>  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-748">프로세스가 종료되어 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 속성이 정의되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-748">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-749">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-749">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-750">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-750">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-751">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-751">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-752">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-752">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-753">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-753">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-754">연결된 프로세스에 대한 최대 허용 작업 집합 크기(바이트)를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-754">Gets or sets the maximum allowable working set size, in bytes, for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-755">프로세스에 대해 메모리에서 허용된 작업 집합의 최대 크기(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-755">The maximum working set size that is allowed in memory for the process, in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-756">프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합.</span><span class="sxs-lookup"><span data-stu-id="12013-756">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="12013-757">이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-757">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="12013-758">작업 집합에는 공유 및 개인 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-758">The working set includes both shared and private data.</span></span> <span data-ttu-id="12013-759">공유 데이터에는.dll 파일, system.dll 파일에서 페이지를 포함 하 여 응용 프로그램을 실행 하는 모든 명령이 들어 있는 페이지가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-759">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="12013-760">작업 집합의 증가 하는 크기, 메모리 수요가 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-760">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="12013-761">프로세스에 최대 및 최소 작업 집합 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-761">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="12013-762">프로세스 리소스를 만들 때마다 시스템의 최소 작업 집합 크기는 프로세스를 같은 메모리 용량을 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-762">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="12013-763">가상 메모리 관리자 유지 하려고 이상 최소 메모리 양을 상주 하는 프로세스 활성화 되어 있지만 최대 크기 보다 유지 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-763">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="12013-764">작업 집합 크기 기본을 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-764">The system sets the default working set sizes.</span></span> <span data-ttu-id="12013-765">사용 하 여 이러한 크기를 수정할 수는 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 및 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-765">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="12013-766">그러나 이러한 값을 설정할 보장 하지 않습니다 예약 되거나 상주 하는 메모리 한 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="12013-766">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-767">프로세스의 작업 집합 크기를 늘리면 수행한 실제 메모리를 시스템의 나머지 가져오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-767">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="12013-768">최소 또는 최대 작업 집합 크기 시스템 성능이 저하 수 때문에 너무 커서를 요청 하지 않으면 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-768">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12013-769">최대 작업 집합 크기가 잘못 되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-769">The maximum working set size is invalid.</span>
          </span>
          <span data-ttu-id="12013-770">최소 작업 집합 크기보다 크거나 같아야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-770">It must be greater than or equal to the minimum working set size.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-771">작업 집합 정보를 연결된 프로세스 리소스에서 검색할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-771">Working set information cannot be retrieved from the associated process resource.</span>
          </span>
          <span data-ttu-id="12013-772">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-772">-or-</span>
          </span>
          <span data-ttu-id="12013-773">프로세스가 시작되지 않아서 프로세스 식별자 또는 프로세스 핸들이 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-773">The process identifier or process handle is zero because the process has not been started.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-774">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-774">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-775">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-775">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-776">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-776">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span>
          </span>
          <span data-ttu-id="12013-777">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-777">-or-</span>
          </span>
          <span data-ttu-id="12013-778">프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-778">The process has exited.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-779">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-779">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-780">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-780">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-781">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-781">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-782">연결된 프로세스에 대해 허용되는 작업 집합의 최소 크기(바이트)를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-782">Gets or sets the minimum allowable working set size, in bytes, for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-783">프로세스에 대해 메모리에서 필요로 하는 작업 집합의 최소 크기(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-783">The minimum working set size that is required in memory for the process, in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-784">프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합.</span><span class="sxs-lookup"><span data-stu-id="12013-784">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="12013-785">이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-785">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="12013-786">작업 집합에는 공유 및 개인 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-786">The working set includes both shared and private data.</span></span> <span data-ttu-id="12013-787">공유 데이터에는.dll 파일, system.dll 파일에서 페이지를 포함 하 여 응용 프로그램을 실행 하는 모든 명령이 들어 있는 페이지가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-787">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="12013-788">작업 집합의 증가 하는 크기, 메모리 수요가 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-788">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="12013-789">프로세스에 최대 및 최소 작업 집합 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-789">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="12013-790">프로세스 리소스를 만들 때마다 시스템의 최소 작업 집합 크기는 프로세스를 같은 메모리 용량을 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-790">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="12013-791">가상 메모리 관리자 유지 하려고 이상 최소 메모리 양을 상주 하는 프로세스 활성화 되어 있지만 최대 크기 보다 유지 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-791">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="12013-792">작업 집합 크기 기본을 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-792">The system sets the default working set sizes.</span></span> <span data-ttu-id="12013-793">사용 하 여 이러한 크기를 수정할 수는 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 및 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-793">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="12013-794">그러나 이러한 값을 설정할 보장 하지 않습니다 예약 되거나 상주 하는 메모리 한 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="12013-794">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-795">프로세스의 작업 집합 크기를 늘리면 수행한 실제 메모리를 시스템의 나머지 가져오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-795">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="12013-796">최소 또는 최대 작업 집합 크기 시스템 성능이 저하 수 때문에 너무 커서를 요청 하지 않으면 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-796">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12013-797">최소 작업 집합 크기가 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-797">The minimum working set size is invalid.</span>
          </span>
          <span data-ttu-id="12013-798">최대 작업 집합 크기와 작거나 같아야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-798">It must be less than or equal to the maximum working set size.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-799">작업 집합 정보를 연결된 프로세스 리소스에서 검색할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-799">Working set information cannot be retrieved from the associated process resource.</span>
          </span>
          <span data-ttu-id="12013-800">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-800">-or-</span>
          </span>
          <span data-ttu-id="12013-801">프로세스가 시작되지 않아서 프로세스 식별자 또는 프로세스 핸들이 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-801">The process identifier or process handle is zero because the process has not been started.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-802">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-802">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-803">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-803">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-804">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-804">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span>
          </span>
          <span data-ttu-id="12013-805">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-805">-or-</span>
          </span>
          <span data-ttu-id="12013-806">프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-806">The process has exited.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-807">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-807">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-808">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-808">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-809">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-809">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-810">연결된 프로세스에 의해 로드된 모듈을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-810">Gets the modules that have been loaded by the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-811">연결된 프로세스에 의해 로드된 모듈을 나타내는 <see cref="T:System.Diagnostics.ProcessModule" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-811">An array of type <see cref="T:System.Diagnostics.ProcessModule" /> that represents the modules that have been loaded by the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-812">프로세스 모듈 특정 프로세스에 로드 되는.dll 또는.exe 파일을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-812">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="12013-813">A <xref:System.Diagnostics.ProcessModule> 인스턴스 모듈 이름, 파일 이름 및 모듈 메모리 정보를 포함 하 여 모듈에 대 한 정보를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-813">A <xref:System.Diagnostics.ProcessModule> instance lets you view information about a module, including the module name, file name, and module memory details.</span></span>  
  
 <span data-ttu-id="12013-814">프로세스는 메모리에 여러 모듈을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-814">A process can load multiple modules into memory.</span></span> <span data-ttu-id="12013-815">예를 들어 추가.dll 파일을 로드 하는.exe 파일에 여러 개의 모듈이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-815">For example,.exe files that load additional .dll files have multiple modules.</span></span>  
  
 <span data-ttu-id="12013-816">프로세스를 시작한 후 시스템에서 프로세스를 로드할 때까지이 컬렉션은 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-816">After starting the process, this collection is empty until the system has loaded the process.</span></span> <span data-ttu-id="12013-817">프로세스에 주 창이 경우 호출할 수 있습니다 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 목록을 컬렉션에 비어 있지 않은 경우를 위해이 속성을 검색 하기 전에 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="12013-817">If the process has a main window, you can call <xref:System.Diagnostics.Process.WaitForInputIdle%2A> before retrieving this property to ensure that the collection is nonempty when you get the list.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-818">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.Modules" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-818">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-819">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-819">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-820">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-820">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-821">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-821">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-822">시스템 프로세스 또는 유휴 프로세스에 대한 <see cref="P:System.Diagnostics.Process.Modules" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-822">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process.</span>
          </span>
          <span data-ttu-id="12013-823">이러한 프로세스에 모듈이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-823">These processes do not have modules.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-824">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-824">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-825">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-825">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-826">연결된 프로세스에 할당된 비페이징 시스템 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-826">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-827">가상 메모리 페이징 파일에 쓸 수 없는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-827">The amount of memory, in bytes, the system has allocated for the associated process that cannot be written to the virtual memory paging file.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-828">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-828">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-829">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-829">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-830">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-830">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-831">연결된 프로세스에 할당된 비페이징 시스템 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-831">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-832">가상 메모리 페이징 파일에 쓸 수 없는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-832">The amount of system memory, in bytes, allocated for the associated process that cannot be written to the virtual memory paging file.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-833">이 속성에서 반환 되는 값 (바이트)에서 프로세스에서 사용 된 비페이징된 시스템 메모리의 현재 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-833">The value returned by this property represents the current size of nonpaged system memory used by the process, in bytes.</span></span> <span data-ttu-id="12013-834">시스템 메모리는 운영 체제에서 사용 하는 실제 메모리와 페이지 단위 및 비페이징 풀 나뉘어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-834">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="12013-835">비페이징된 메모리 할당 시스템 메모리에 유지 되 고 가상 메모리 페이징 파일에 페이지 아웃 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-835">Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</span></span>  
  
 <span data-ttu-id="12013-836">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-836">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-837">속성 값은 해당 하는 **Pool Nonpaged Bytes** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-837">The property value is equivalent to the **Pool Nonpaged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-838">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-838">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-839">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-839">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-840">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-840">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-841">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-841">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-842">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-842">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-843">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-843">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-844">
            <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-844">Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-845"><xref:System.Diagnostics.Process.OnExited%2A> 발생 시키는 API 메서드는는 <xref:System.Diagnostics.Process.Exited> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-845"><xref:System.Diagnostics.Process.OnExited%2A> is the API method that raises the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="12013-846">호출 <xref:System.Diagnostics.Process.OnExited%2A> 하면는 <xref:System.Diagnostics.Process.Exited> 이벤트를 발생 및 사용 하 여 이벤트를 발생 하는 유일한 방법은 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-846">Calling <xref:System.Diagnostics.Process.OnExited%2A> causes the <xref:System.Diagnostics.Process.Exited> event to occur and is the only way to raise the event using the <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="12013-847"><xref:System.Diagnostics.Process.OnExited%2A> 이 구성 요소에서 클래스를 파생할 때 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-847"><xref:System.Diagnostics.Process.OnExited%2A> is primarily used when deriving classes from the component.</span></span>  
  
 <span data-ttu-id="12013-848">대신 <xref:System.Diagnostics.Process.OnExited%2A>, 이벤트 처리기를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-848">As an alternative to <xref:System.Diagnostics.Process.OnExited%2A>, you can write your own event handler.</span></span> <span data-ttu-id="12013-849">사용자 고유의 이벤트 처리기 대리자 및 사용자 고유의 이벤트 처리 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="12013-849">You create your own event handler delegate and your own event-handling method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-850">Visual Studio 환경을 사용 하는 경우 이벤트 처리기 대리자 (AddOnExited) 및 이벤트 처리 메서드 (Process1_Exited) 만들어집니다 끌면는 <xref:System.Diagnostics.Process> 구성 요소를 폼의 아이콘을 두 번 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-850">If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a <xref:System.Diagnostics.Process> component onto a form and double-click the icon.</span></span> <span data-ttu-id="12013-851">만들 때 실행할 코드는 <xref:System.Diagnostics.Process.Exited> Process1_Exited 프로시저에 입력 된 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-851">The code you create to run when the <xref:System.Diagnostics.Process.Exited> event occurs is entered into the Process1_Exited procedure.</span></span> <span data-ttu-id="12013-852">만들 필요가 없습니다는 <xref:System.Diagnostics.Process.OnExited%2A> 멤버, 사용자에 대 한 구현 되기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-852">You do not need to create the <xref:System.Diagnostics.Process.OnExited%2A> member, because it is implemented for you.</span></span>  
  
 <span data-ttu-id="12013-853">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-853">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="12013-854">에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-854">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-855">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Diagnostics.Process.OnExited%2A> 파생된 클래스에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-855">The following example shows how to use the <xref:System.Diagnostics.Process.OnExited%2A> method in a derived class.</span></span>  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-856">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-856">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-857">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-857">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-858">응용 프로그램이 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에 쓸 때마다 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-858">Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-859"><xref:System.Diagnostics.Process.OutputDataReceived> 이벤트는 연결 된 <xref:System.Diagnostics.Process> 리디렉션된 줄 바꿈 문자로 종료 줄 입력 된 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-859">The <xref:System.Diagnostics.Process.OutputDataReceived> event indicates that the associated <xref:System.Diagnostics.Process> has written a line, terminating with a newline character, to its redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-860">이벤트를 사용할지 비동기 읽기 작업 동안 <xref:System.Diagnostics.Process.StandardOutput%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-860">The event is enabled during asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span> <span data-ttu-id="12013-861">비동기 읽기 작업을 시작 하려면 리디렉션해야는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 <xref:System.Diagnostics.Process>, 이벤트 처리기에 추가 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트 및 호출 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-861">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardOutput%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event, and call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</span></span> <span data-ttu-id="12013-862">그런 다음는 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트 신호 프로세스 리디렉션된 쓸 때마다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림, 프로세스 종료 또는 호출 될 때까지 <xref:System.Diagnostics.Process.CancelOutputRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-862">Thereafter, the <xref:System.Diagnostics.Process.OutputDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-863">비동기 출력을 처리 하는 응용 프로그램은 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드를 출력 버퍼 플러시 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-863">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to ensure that the output buffer has been flushed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-864">다음 예제에서는 리디렉션된에 대해 비동기 읽기 작업을 수행 하는 방법을 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 `ipconfig` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-864">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.</span></span>  
  
 <span data-ttu-id="12013-865">이 예에서는 대 한 이벤트 대리자를 만듭니다는 `OutputHandler` 이벤트 처리기에 연결 된 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-865">The example creates an event delegate for the `OutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="12013-866">이벤트 처리기는 리디렉션된 텍스트 줄을 받아서 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림에 텍스트의 서식을 지정 하 고 나중 예에 나오는 콘솔 창에 표시 되는 출력 문자열에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-866">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-867">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-867">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-868">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-868">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-869">연결된 프로세스에 할당된 페이징 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-869">Gets the amount of paged memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-870">가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 의해 할당된 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-870">The amount of memory, in bytes, allocated by the associated process that can be written to the virtual memory paging file.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-871">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-871">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-872">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-872">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-873">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-873">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-874">연결된 프로세스에 할당된 페이징 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-874">Gets the amount of paged memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-875">연결된 프로세스의 가상 메모리 페이징 파일에 할당된 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-875">The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-876">이 속성에서 반환 되는 값 (바이트)는 프로세스에서 사용 하는 가상 메모리 페이징 파일에 있는 메모리의 현재 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-876">The value returned by this property represents the current size of memory in the virtual memory paging file used by the process, in bytes.</span></span> <span data-ttu-id="12013-877">운영 체제를 사용 하 여 함께에서 가상 메모리 페이징 파일 실제 메모리와 각 프로세스에 대 한 가상 주소 공간을 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-877">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="12013-878">사용 중인 페이징 가능한 메모리 없는 경우 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-878">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="12013-879">프로세스에 대 한 운영 체제에서 사용 되는 메모리의 크기를 가져오려면는 <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-879">To obtain the size of memory used by the operating system for the process, use the <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="12013-880">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-880">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-881">속성 값은 해당 하는 **페이지 파일 바이트** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-881">The property value is equivalent to the **Page File Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-882">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 하 고 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-882">The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-883">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-883">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-884">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-884">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-885">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-885">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-886">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-886">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-887">연결된 프로세스에 할당된 페이징할 수 있는 시스템 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-887">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-888">가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-888">The amount of memory, in bytes, the system has allocated for the associated process that can be written to the virtual memory paging file.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-889">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-889">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-890">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-890">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-891">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-891">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-892">연결된 프로세스에 할당된 페이징할 수 있는 시스템 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-892">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-893">가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 대해 할당된 시스템 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-893">The amount of system memory, in bytes, allocated for the associated process that can be written to the virtual memory paging file.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-894">이 속성에서 반환 되는 값 (바이트)에서 프로세스에 의해 사용 되는 페이징할 수 있는 시스템 메모리의 현재 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-894">The value returned by this property value represents the current size of pageable system memory used by the process, in bytes.</span></span> <span data-ttu-id="12013-895">시스템 메모리는 운영 체제에서 사용 하는 실제 메모리와 페이지 단위 및 비페이징 풀 나뉘어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-895">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="12013-896">사용 중인 페이징 가능한 메모리 없는 경우 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-896">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="12013-897">프로세스에서 사용 되는 응용 프로그램 메모리의 크기를 가져오려면는 <xref:System.Diagnostics.Process.PagedMemorySize64%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-897">To obtain the size of the application memory used by the process, use the <xref:System.Diagnostics.Process.PagedMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="12013-898">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-898">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-899">속성 값은 해당 하는 **Pool Paged Bytes** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-899">The property value is equivalent to the **Pool Paged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-900">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-900">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-901">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-901">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-902">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-902">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-903">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-903">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-904">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-904">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-905">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-905">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-906">연결된 프로세스에서 사용하는 가상 메모리 페이징 파일의 최대 메모리 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-906">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-907">가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 의해 할당된 메모리의 최대 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-907">The maximum amount of memory, in bytes, allocated by the associated process that could be written to the virtual memory paging file.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-908">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-908">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-909">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-909">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-910">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-910">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-911">연결된 프로세스에서 사용하는 가상 메모리 페이징 파일의 최대 메모리 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-911">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-912">연결된 프로세스가 시작된 이후 연결된 프로세스의 가상 메모리 페이징 파일에 할당된 메모리의 최대 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-912">The maximum amount of memory, in bytes, allocated in the virtual memory paging file for the associated process since it was started.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-913">이 속성에서 반환 되는 값 (바이트)에서 시작 된 이후 프로세스에서 사용 되는 가상 메모리 페이징 파일에는 메모리의 최대 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-913">The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started, in bytes.</span></span> <span data-ttu-id="12013-914">운영 체제를 사용 하 여 함께에서 가상 메모리 페이징 파일 실제 메모리와 각 프로세스에 대 한 가상 주소 공간을 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-914">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="12013-915">사용 중인 페이징 가능한 메모리 없는 경우 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-915">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="12013-916">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-916">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-917">속성 값은 해당 하는 **페이지 파일 바이트 피크** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-917">The property value is equivalent to the **Page File Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-918">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-918">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-919">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-919">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-920">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-920">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-921">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-921">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-922">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-922">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-923">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-923">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-924">연결된 프로세스에서 사용되는 가상 메모리의 최대 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-924">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-925">연결된 프로세스에서 요청한 가상 메모리의 최대 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-925">The maximum amount of virtual memory, in bytes, that the associated process has requested.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-926">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-926">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-927">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-927">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-928">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-928">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-929">연결된 프로세스에서 사용되는 가상 메모리의 최대 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-929">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-930">연결된 프로세스가 시작된 이후 해당 프로세스에 할당된 가상 메모리의 최대 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-930">The maximum amount of virtual memory, in bytes, allocated for the associated process since it was started.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-931">이 속성에서 반환 되는 값 (바이트)에서 시작 된 이후 프로세스에서 사용 하는 가상 메모리의 최대 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-931">The value returned by this property represents the maximum size of virtual memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="12013-932">운영 체제 디스크에 있는 가상 메모리 페이징 파일에 저장 된 페이지 또는 실제 메모리에 로드 하는 페이지에 각 프로세스에 대 한 가상 주소 공간을 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-932">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="12013-933">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-933">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-934">속성 값은 해당 하는 **가상 바이트 피크** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-934">The property value is equivalent to the **Virtual Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-935">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-935">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-936">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-936">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-937">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-937">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-938">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-938">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-939">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-939">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-940">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-940">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-941">연결된 프로세스의 최대 작업 집합 크기(바이트)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-941">Gets the peak working set size for the associated process, in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-942">연결된 프로세스에서 한 번에 요청한 실제 메모리의 최대 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-942">The maximum amount of physical memory that the associated process has required all at once, in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-943">프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합.</span><span class="sxs-lookup"><span data-stu-id="12013-943">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="12013-944">이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-944">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="12013-945">작업 집합에는 공유 및 개인 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-945">The working set includes both shared and private data.</span></span> <span data-ttu-id="12013-946">공유 데이터에는 프로세스는 실행 프로세스 모듈와 시스템 라이브러리를 포함 하는 모든 명령이 포함 된 페이지가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-946">The shared data includes the pages that contain all the instructions that the process executes, including process modules and the system libraries.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-947">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-947">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-948">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-948">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-949">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-949">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-950">연결된 프로세스에서 사용되는 실제 메모리의 최대 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-950">Gets the maximum amount of physical memory, in bytes, used by the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-951">연결된 프로세스가 시작된 이후 해당 프로세스에 할당된 실제 메모리의 최대 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-951">The maximum amount of physical memory, in bytes, allocated for the associated process since it was started.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-952">이 속성에서 반환 되는 값의 작업 집합 메모리 바이트에서 시작 된 이후 프로세스에서 사용 되는 최대 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-952">The value returned by this property represents the maximum size of working set memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="12013-953">프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합.</span><span class="sxs-lookup"><span data-stu-id="12013-953">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="12013-954">이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-954">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="12013-955">작업 집합에는 공유 및 개인 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-955">The working set includes both shared and private data.</span></span> <span data-ttu-id="12013-956">공유 데이터에는 프로세스는 실행 프로세스 모듈와 시스템 라이브러리의 지침을 포함 하는 모든 명령이 포함 된 페이지가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-956">The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="12013-957">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-957">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-958">속성 값은 해당 하는 **Working Set Peak** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-958">The property value is equivalent to the **Working Set Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-959">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-959">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-960">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-960">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-961">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-961">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-962">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-962">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-963">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-963">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-964">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-964">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-965">포커스가 주 창에 있을 때 운영 체제가 연결된 프로세스의 우선 순위를 일시적으로 높일지를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-965">Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-966">프로세스가 대기 상태에서 빠져 나올 때 프로세스의 우선 순위를 동적으로 높여야 하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-966">
              <see langword="true" /> if dynamic boosting of the process priority should take place for a process when it is taken out of the wait state; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12013-967">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-967">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-968">프로세스 우선 순위 클래스에 있는 동적 우선 순위 열거형 값 중 하나에서 스레드가 실행 하는 경우 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), 시스템 스레드의 우선 순위를 대기 상태에서 나올 때 일시적으로 상승 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="12013-968">When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), the system temporarily boosts the thread's priority when it is taken out of a wait state.</span></span> <span data-ttu-id="12013-969">이렇게 하면 다른 프로세스에서 현재 스레드의 처리를 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-969">This action prevents other processes from interrupting the processing of the current thread.</span></span> <span data-ttu-id="12013-970"><xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 설정은 모든 기존 스레드 및 프로세스에서 만든 모든 스레드에 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-970">The <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> setting affects all the existing threads and any threads subsequently created by the process.</span></span> <span data-ttu-id="12013-971">일반 동작을 복원 하려면 설정는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 속성을 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-971">To restore normal behavior, set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-972">우선 순위를 너무 승격 중요 한 운영 체제 및 네트워크 기능을 다른 운영 체제 작업에 문제가 발생 리소스를 드레이닝 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-972">Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-973">연결된 프로세스 리소스에서 우선순위 높임 정보를 검색할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-973">Priority boost information could not be retrieved from the associated process resource.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-974">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-974">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
          <span data-ttu-id="12013-975">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-975">-or-</span>
          </span>
          <span data-ttu-id="12013-976">프로세스 식별자 또는 프로세스 핸들이 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-976">The process identifier or process handle is zero.</span>
          </span>
          <span data-ttu-id="12013-977">(프로세스가 시작되지 않았습니다.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-977">(The process has not been started.)</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-978">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-978">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-979">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-979">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-980">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-980">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-981">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-981">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-982">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-982">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-983">연결된 프로세스에 대한 전체 우선 순위 범주를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-983">Gets or sets the overall priority category for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-984">연결된 프로세스에 대한 우선 순위 범주입니다. 이를 통해 해당 프로세스의 <see cref="P:System.Diagnostics.Process.BasePriority" />를 계산할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-984">The priority category for the associated process, from which the <see cref="P:System.Diagnostics.Process.BasePriority" /> of the process is calculated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-985">프로세스 우선 순위 클래스 스레드 우선 순위 수준의 범위를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-985">A process priority class encompasses a range of thread priority levels.</span></span> <span data-ttu-id="12013-986">프로세스에서 실행 되는 우선 순위가 서로 다른 스레드는 프로세스의 우선 순위 클래스를 기준으로 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-986">Threads with different priorities that are running in the process run relative to the priority class of the process.</span></span> <span data-ttu-id="12013-987">Win32 클래스당 7 개 기본 우선 순위 수준을 4 개의 우선 순위 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-987">Win32 uses four priority classes with seven base priority levels per class.</span></span> <span data-ttu-id="12013-988">이러한 프로세스 우선 순위 클래스에 기록 되는 <xref:System.Diagnostics.ProcessPriorityClass> 프로세스 우선 순위를 설정 하는 수 있는 열거형 <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-988">These process priority classes are captured in the <xref:System.Diagnostics.ProcessPriorityClass> enumeration, which lets you set the process priority to <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>.</span></span> <span data-ttu-id="12013-989">시간 경과 또는 기타 상승이, 기본 우선 순위 수준을 프로세스 프로세서에 대 한 액세스에 대 한 다른 미리 설정 해야 하는 경우 운영 체제에서 변경할 수 있습니다 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-989">Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor.</span></span> <span data-ttu-id="12013-990">또한 설정할 수 있습니다는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 일시적으로 높일 대기 상태에서 가져온 스레드의 우선 순위 수준에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-990">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> to temporarily boost the priority level of threads that have been taken out of the wait state.</span></span> <span data-ttu-id="12013-991">우선 순위에는 프로세스가 대기 상태를 반환할 때 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-991">The priority is reset when the process returns to the wait state.</span></span>  
  
 <span data-ttu-id="12013-992"><xref:System.Diagnostics.Process.BasePriority%2A> 속성을 사용 하면 프로세스에 할당 된 우선 순위를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-992">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority that is assigned to a process.</span></span> <span data-ttu-id="12013-993">그러나 읽기 전용 이므로 사용할 수 없습니다는 <xref:System.Diagnostics.Process.BasePriority%2A> 속성을 프로세스의 우선 순위를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-993">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> property to set the priority of a process.</span></span> <span data-ttu-id="12013-994">우선 순위를 변경 하려면 사용 하 여는 <xref:System.Diagnostics.Process.PriorityClass%2A> 프로세스에 대 한 전체 우선 순위 범주를 가져오거나 설정 합니다.이 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-994">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property, which gets or sets the overall priority category for the process.</span></span>  
  
 <span data-ttu-id="12013-995">시스템 모니터를 사용 하 여 우선 순위 클래스를 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-995">The priority class cannot be viewed using System Monitor.</span></span> <span data-ttu-id="12013-996">다음 표에서 간의 관계를 보여 줍니다.는 <xref:System.Diagnostics.Process.BasePriority%2A> 및 <xref:System.Diagnostics.Process.PriorityClass%2A> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-996">The following table shows the relationship between the <xref:System.Diagnostics.Process.BasePriority%2A> and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="12013-997">BasePriority</span><span class="sxs-lookup"><span data-stu-id="12013-997">BasePriority</span></span>|<span data-ttu-id="12013-998">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="12013-998">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="12013-999">4</span><span class="sxs-lookup"><span data-stu-id="12013-999">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="12013-1000">8</span><span class="sxs-lookup"><span data-stu-id="12013-1000">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="12013-1001">13</span><span class="sxs-lookup"><span data-stu-id="12013-1001">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="12013-1002">24</span><span class="sxs-lookup"><span data-stu-id="12013-1002">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="12013-1003">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1003">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1004">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1004">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1005">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1005">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1006">프로세스 우선 순위 정보를 연결된 프로세스 리소스에서 설정하거나 검색할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1006">Process priority information could not be set or retrieved from the associated process resource.</span>
          </span>
          <span data-ttu-id="12013-1007">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1007">-or-</span>
          </span>
          <span data-ttu-id="12013-1008">프로세스 식별자 또는 프로세스 핸들이 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1008">The process identifier or process handle is zero.</span>
          </span>
          <span data-ttu-id="12013-1009">(프로세스가 시작되지 않았습니다.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1009">(The process has not been started.)</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1010">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1010">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1011">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1011">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1012">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1012">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1013">Windows 98 또는 Windows Me(Millennium Edition)를 사용하는 경우 <see cref="P:System.Diagnostics.Process.PriorityClass" />를 <see langword="AboveNormal" /> 또는 <see langword="BelowNormal" />로 설정했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1013">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me).</span>
          </span>
          <span data-ttu-id="12013-1014">이러한 플랫폼에서는 우선 순위 클래스에 대한 이러한 값을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1014">These platforms do not support those values for the priority class.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="12013-1015">
            <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 열거형에 정의된 유효한 값이 사용되지 않으므로 우선 순위 클래스를 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1015">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1016">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1016">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1017">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1017">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1018">연결된 프로세스에 할당된 전용 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1018">Gets the amount of private memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1019">연결된 프로세스에서 할당하여 다른 프로세스에서는 공유할 수 없는 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1019">The number of bytes allocated by the associated process that cannot be shared with other processes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1020">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1020">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1021">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1021">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1022">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1022">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1023">연결된 프로세스에 할당된 전용 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1023">Gets the amount of private memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1024">연결된 프로세스에 할당되어 다른 프로세스와는 공유할 수 없는 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1024">The amount of memory, in bytes, allocated for the associated process that cannot be shared with other processes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1025">이 속성에서 반환 되는 값 (바이트)를 다른 프로세스와 공유할 수 없는 프로세스에서 사용 되는 메모리의 현재 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1025">The value returned by this property represents the current size of memory used by the process, in bytes, that cannot be shared with other processes.</span></span>  
  
 <span data-ttu-id="12013-1026">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1026">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-1027">속성 값은 해당 하는 **전용 바이트** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1027">The property value is equivalent to the **Private Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1028">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1028">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-1029">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1029">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1030">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1030">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1031">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1031">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1032">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1032">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1033">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1033">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1034">해당 프로세스의 권한 있는 프로세서 시간을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1034">Gets the privileged processor time for this process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1035">프로세스가 운영 체제 코어 내부에서 코드를 실행하는 데 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1035">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the process has spent running code inside the operating system core.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="12013-1036">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1036">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1037">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1037">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1038">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1038">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1039">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1039">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1040">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1040">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1041">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1041">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1042">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1042">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1043">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1043">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1044">프로세스의 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1044">Gets the name of the process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1045">사용자가 프로세스를 식별할 수 있도록 시스템에서 사용하는 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1045">The name that the system uses to identify the process to the user.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1046"><xref:System.Diagnostics.Process.ProcessName%2A> .exe 확장명 또는 경로 포함 하지 않는 Outlook과 같은 실행 파일 이름, 속성에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1046">The <xref:System.Diagnostics.Process.ProcessName%2A> property holds an executable file name, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="12013-1047">가져오기 및 동일한 실행 파일에 연관 된 모든 프로세스를 조작 하기 위한 것이 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1047">It is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1048">[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 운영 체제는 <xref:System.Diagnostics.Process.ProcessName%2A> 프로세스 모듈 정보를 가져올 수 없으면 15 자로 속성 잘릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1048">On [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] operating systems, the <xref:System.Diagnostics.Process.ProcessName%2A> property may be truncated to 15 characters if the process module information cannot be obtained.</span></span>  
  
 <span data-ttu-id="12013-1049">호출할 수 있습니다 <xref:System.Diagnostics.Process.GetProcessesByName%2A>, 지정된 된 컴퓨터에서 실행 중인 모든 인스턴스를 포함 하는 배열을 검색 하는 실행 파일 이름을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1049">You can call <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer.</span></span> <span data-ttu-id="12013-1050">실행 파일의 모든 실행 중인 인스턴스를 종료 하려면 예를 들어이 배열에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1050">You can use this array, for example, to shut down all the running instances of the executable file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1051">프로세스에 식별자가 없거나 <see cref="T:System.Diagnostics.Process" />와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1051">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.</span>
          </span>
          <span data-ttu-id="12013-1052">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1052">-or-</span>
          </span>
          <span data-ttu-id="12013-1053">연결된 프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1053">The associated process has exited.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1054">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1054">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1055">이 컴퓨터에서 진행되는 프로세스가 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1055">The process is not on this computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1056">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1056">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1057">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1057">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1058">이 프로세스에 포함된 스레드의 실행을 예약할 수 있는 프로세서를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1058">Gets or sets the processors on which the threads in this process can be scheduled to run.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1059">연결된 프로세스의 스레드가 실행될 수 있는 프로세서를 나타내는 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1059">A bitmask representing the processors that the threads in the associated process can run on.</span>
          </span>
          <span data-ttu-id="12013-1060">기본값은 컴퓨터의 프로세서 수에 따라 다릅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1060">The default depends on the number of processors on the computer.</span>
          </span>
          <span data-ttu-id="12013-1061">기본값은 2 <sup>n</sup> -1로, 여기서 n은 프로세서의 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1061">The default value is 2 <sup>n</sup> -1, where n is the number of processors.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1062">Windows 2000 이상 버전에서는 프로세스에서 스레드 프로세서 캐시 다시 로드 하는 각 마이그레이션을 사용 하 여 프로세서에서 마이그레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1062">In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="12013-1063">시스템 로드가 특정 스레드를 실행 해야 하는 프로세서를 지정 하 수 줄여서 성능을 향상 시킬 수 있는 프로세서 캐시 다시 로드 되는 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1063">Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded.</span></span> <span data-ttu-id="12013-1064">프로세서 및 스레드 간의 연결을 프로세서 선호도 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1064">The association between a processor and a thread is called the processor affinity.</span></span>  
  
 <span data-ttu-id="12013-1065">각 프로세서 약간으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1065">Each processor is represented as a bit.</span></span> <span data-ttu-id="12013-1066">비트 0은 프로세서 1, 1 비트가 프로세서 2, 등입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1066">Bit 0 is processor one, bit 1 is processor two, and so forth.</span></span> <span data-ttu-id="12013-1067">값 1 약간 설정 하면 해당 하는 프로세서가 스레드 할당에 대해 선택 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1067">If you set a bit to the value 1, the corresponding processor is selected for thread assignment.</span></span> <span data-ttu-id="12013-1068">설정 하는 경우는 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 값을 0으로 운영 체제의 예약 알고리즘 집합 스레드의 선호도입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1068">When you set the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value to zero, the operating system's scheduling algorithms set the thread's affinity.</span></span> <span data-ttu-id="12013-1069">경우는 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 값이 0이 아닌 값으로 설정, 값은 선택 가능한 프로세서를 지정 하는 비트 마스크로 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1069">When the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</span></span>  
  
 <span data-ttu-id="12013-1070">다음 표에서 다양 한 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 프로세서가 8 개인 시스템에 대 한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1070">The following table shows a selection of <xref:System.Diagnostics.Process.ProcessorAffinity%2A> values for an eight-processor system.</span></span>  
  
|<span data-ttu-id="12013-1071">비트 마스크</span><span class="sxs-lookup"><span data-stu-id="12013-1071">Bitmask</span></span>|<span data-ttu-id="12013-1072">이진 값</span><span class="sxs-lookup"><span data-stu-id="12013-1072">Binary value</span></span>|<span data-ttu-id="12013-1073">사용할 수 있는 프로세서</span><span class="sxs-lookup"><span data-stu-id="12013-1073">Eligible processors</span></span>|  
|-------------|------------------|-------------------------|  
|<span data-ttu-id="12013-1074">0x0001</span><span class="sxs-lookup"><span data-stu-id="12013-1074">0x0001</span></span>|<span data-ttu-id="12013-1075">00000000 00000001</span><span class="sxs-lookup"><span data-stu-id="12013-1075">00000000 00000001</span></span>|<span data-ttu-id="12013-1076">1</span><span class="sxs-lookup"><span data-stu-id="12013-1076">1</span></span>|  
|<span data-ttu-id="12013-1077">0x0003</span><span class="sxs-lookup"><span data-stu-id="12013-1077">0x0003</span></span>|<span data-ttu-id="12013-1078">00000000 00000011</span><span class="sxs-lookup"><span data-stu-id="12013-1078">00000000 00000011</span></span>|<span data-ttu-id="12013-1079">1과 2</span><span class="sxs-lookup"><span data-stu-id="12013-1079">1 and 2</span></span>|  
|<span data-ttu-id="12013-1080">0x0007</span><span class="sxs-lookup"><span data-stu-id="12013-1080">0x0007</span></span>|<span data-ttu-id="12013-1081">00000000 00000111</span><span class="sxs-lookup"><span data-stu-id="12013-1081">00000000 00000111</span></span>|<span data-ttu-id="12013-1082">1, 2 및 3</span><span class="sxs-lookup"><span data-stu-id="12013-1082">1, 2 and 3</span></span>|  
|<span data-ttu-id="12013-1083">0x0009</span><span class="sxs-lookup"><span data-stu-id="12013-1083">0x0009</span></span>|<span data-ttu-id="12013-1084">00000000 00001001</span><span class="sxs-lookup"><span data-stu-id="12013-1084">00000000 00001001</span></span>|<span data-ttu-id="12013-1085">1에서 4</span><span class="sxs-lookup"><span data-stu-id="12013-1085">1 and 4</span></span>|  
|<span data-ttu-id="12013-1086">0x007F</span><span class="sxs-lookup"><span data-stu-id="12013-1086">0x007F</span></span>|<span data-ttu-id="12013-1087">00000000 01111111</span><span class="sxs-lookup"><span data-stu-id="12013-1087">00000000 01111111</span></span>|<span data-ttu-id="12013-1088">1, 2, 3, 4, 5, 6 및 7</span><span class="sxs-lookup"><span data-stu-id="12013-1088">1, 2, 3, 4, 5, 6 and 7</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1089">
            <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 정보를 연결된 프로세스 리소스에서 설정하거나 검색할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1089">
              <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.</span>
          </span>
          <span data-ttu-id="12013-1090">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1090">-or-</span>
          </span>
          <span data-ttu-id="12013-1091">프로세스 식별자 또는 프로세스 핸들이 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1091">The process identifier or process handle is zero.</span>
          </span>
          <span data-ttu-id="12013-1092">(프로세스가 시작되지 않았습니다.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1092">(The process has not been started.)</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1093">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1093">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1094">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1094">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1095">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1095">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.</span>
          </span>
          <span data-ttu-id="12013-1096">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1096">-or-</span>
          </span>
          <span data-ttu-id="12013-1097">프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1097">The process has exited.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1098">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1098">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1099">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1099">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-1100">프로세스 구성 요소 내에 캐시되어 있는 연결된 프로세스 정보를 모두 삭제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1100">Discards any information about the associated process that has been cached inside the process component.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1101">후 <xref:System.Diagnostics.Process.Refresh%2A> 호출 되는 첫 번째 요청 각 속성에 대 한 내용은 하면 연결된 된 프로세스에서 새 값을 가져올 프로세스 구성 요소에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1101">After <xref:System.Diagnostics.Process.Refresh%2A> is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</span></span>  
  
 <span data-ttu-id="12013-1102">경우는 <xref:System.Diagnostics.Process> 구성 요소는 연결 된 프로세스 리소스의 속성 값은 <xref:System.Diagnostics.Process> 즉시 연결된 된 프로세스의 상태에 따라 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1102">When a <xref:System.Diagnostics.Process> component is associated with a process resource, the property values of the <xref:System.Diagnostics.Process> are immediately populated according to the status of the associated process.</span></span> <span data-ttu-id="12013-1103">에 연결된 된 프로세스에 대 한 정보는 이후에 변경 되 면 해당 변경 내용이 반영 되지 않습니다는 <xref:System.Diagnostics.Process> 구성 요소의 값을 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1103">If the information about the associated process subsequently changes, those changes are not reflected in the <xref:System.Diagnostics.Process> component's cached values.</span></span> <span data-ttu-id="12013-1104"><xref:System.Diagnostics.Process> 구성 요소는 연결 된 시간에 프로세스 리소스의 스냅숏입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1104">The <xref:System.Diagnostics.Process> component is a snapshot of the process resource at the time they are associated.</span></span> <span data-ttu-id="12013-1105">연결된 된 프로세스에 대 한 현재 값을 보려면 호출에서 <xref:System.Diagnostics.Process.Refresh%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1105">To view the current values for the associated process, call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1106">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1106">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1107">최대 10 초 동안 2 초 간격 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1107">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="12013-1108">이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1108">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="12013-1109">이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1109">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1110">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1110">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1111">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1111">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1112">프로세스의 사용자 인터페이스가 응답하는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1112">Gets a value indicating whether the user interface of the process is responding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1113">연결된 프로세스의 사용자 인터페이스가 시스템에 응답하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1113">
              <see langword="true" /> if the user interface of the associated process is responding to the system; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1114">에 사용자 인터페이스가 있는 프로세스는 <xref:System.Diagnostics.Process.Responding%2A> 프로세스 사용자 입력에 응답 하는지 여부를 확인 하는 사용자 인터페이스를 연결 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1114">If a process has a user interface, the <xref:System.Diagnostics.Process.Responding%2A> property contacts the user interface to determine whether the process is responding to user input.</span></span> <span data-ttu-id="12013-1115">인터페이스에 즉시 응답 하지 않는 경우는 <xref:System.Diagnostics.Process.Responding%2A> 속성에서 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1115">If the interface does not respond immediately, the <xref:System.Diagnostics.Process.Responding%2A> property returns `false`.</span></span> <span data-ttu-id="12013-1116">연결된 된 프로세스의 인터페이스의 응답이 중지 하는지 여부를 확인 하려면이 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1116">Use this property to determine whether the interface of the associated process has stopped responding.</span></span>  
  
 <span data-ttu-id="12013-1117">프로세스에 없는 경우는 <xref:System.Diagnostics.Process.MainWindowHandle%2A>,이 속성은 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1117">If the process does not have a <xref:System.Diagnostics.Process.MainWindowHandle%2A>, this property returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1118">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1118">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1119">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1119">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1120">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1120">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1121">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1121">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1122">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1122">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1123">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.Responding" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1123">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1124">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1124">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1125">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1125">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1126">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1126">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1127">이 프로세스에 대한 기본 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1127">Gets the native handle to this process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1128">이 프로세스에 대한 기본 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1128">The native handle to this process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1129">핸들은만 호출 하는 구성 요소는 프로세스를 시작 하는 경우에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1129">The handle is only available if the calling component started the process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1130">연결된 프로세스의 터미널 서비스 세션 식별자를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1130">Gets the Terminal Services session identifier for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1131">연결된 프로세스의 터미널 서비스 세션 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1131">The Terminal Services session identifier for the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1132"><xref:System.Diagnostics.Process.SessionId%2A> 속성 응용 프로그램이 현재 실행 중인 세션을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1132">The <xref:System.Diagnostics.Process.SessionId%2A> property identifies the session in which the application is currently running.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="12013-1133">이 프로세스에 연결된 세션이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1133">There is no session associated with this process.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1134">이 세션 식별자와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1134">There is no process associated with this session identifier.</span>
          </span>
          <span data-ttu-id="12013-1135">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1135">-or-</span>
          </span>
          <span data-ttu-id="12013-1136">연결된 프로세스가 이 컴퓨터에 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1136">The associated process is not on this machine.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1137">
            <see cref="P:System.Diagnostics.Process.SessionId" /> 속성은 Windows 98에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1137">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1138">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1138">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1139">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1139">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1140">응용 프로그램의 오류 출력을 읽는 데 사용되는 스트림을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1140">Gets a stream used to read the error output of the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1141">응용 프로그램의 표준 오류 스트림을 읽는 데 사용할 수 있는 <see cref="T:System.IO.StreamReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1141">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard error stream of the application.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1142">경우는 <xref:System.Diagnostics.Process> 표준 오류 스트림에 텍스트를 쓰는 해당 텍스트는 일반적으로 콘솔에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1142">When a <xref:System.Diagnostics.Process> writes text to its standard error stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="12013-1143">리디렉션하여는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림을 조작 하거나 프로세스의 오류 출력을 표시 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1143">By redirecting the <xref:System.Diagnostics.Process.StandardError%2A> stream, you can manipulate or suppress the error output of a process.</span></span> <span data-ttu-id="12013-1144">예를 들어 텍스트를 필터링 다르게 형식을 지정 하거나 콘솔 및 지정 된 로그 파일 모두에 출력을 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1144">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1145">사용 하려면 <xref:System.Diagnostics.Process.StandardError%2A>, 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 를 `false`, 설정 해야 하 고 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> 를 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1145">To use <xref:System.Diagnostics.Process.StandardError%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="12013-1146">그렇지 않은 경우에서 읽기는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1146">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="12013-1147">리디렉션된 <xref:System.Diagnostics.Process.StandardError%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1147">The redirected <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="12013-1148">와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 오류 출력 스트림에서 동기 읽기 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1148">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="12013-1149">이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트리밍하거나 스트림을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1149">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="12013-1150">반면, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1150">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="12013-1151">이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1151">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="12013-1152">동기 작업에서 읽는 호출자 간의 종속성을 유발 읽기는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림과 자식 해당 스트림에 쓰기를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1152">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="12013-1153">이러한 종속성은 교착 상태 조건이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1153">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="12013-1154">호출자에 게 자식 프로세스의 리디렉션된 스트림에서 읽으면 자식에 종속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1154">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="12013-1155">호출자에 게 자식 스트림에 쓰거나 스트림을 닫고 때까지 읽기 작업을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1155">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="12013-1156">리디렉션된 스트림을 맞게 충분 한 데이터를 기록 하는 자식 프로세스를 부모에 종속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1156">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="12013-1157">자식 프로세스 부모 전체 스트림을 읽기 / 스트림의 닫을 때까지 다음 쓰기 작업에서 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1157">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="12013-1158">호출자와 자식 프로세스는 작업을 완료 하려면 서로 대기 하 고 아무 작업도 처리할 수 하는 경우 교착 상태가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1158">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="12013-1159">호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1159">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="12013-1160">예를 들어 다음 C# 코드에는 리디렉션된 스트림에서 읽은 하 고 자식 프로세스가 종료 될 때까지 대기 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1160">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 <span data-ttu-id="12013-1161">호출 하 여 교착 상태를 방지 하는 코드 예제에서는 `p.StandardError.ReadToEnd` 전에 `p.WaitForExit`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1161">The code example avoids a deadlock condition by calling `p.StandardError.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="12013-1162">부모 호출을 처리 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 전에 `p.StandardError.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1162">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardError.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="12013-1163">부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1163">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="12013-1164">자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1164">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-1165">표준 출력과 표준 오류 스트림 모두에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1165">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="12013-1166">예를 들어 다음 C# 코드에서는 두 스트림이 읽기 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1166">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="12013-1167">비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1167">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-1168">부모 호출을 처리 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 이어서 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1168">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="12013-1169">부모 프로세스는 자식 프로세스를 닫으려면 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1169">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-1170">자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1170">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-1171">이러한 종속성과 교착 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1171">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="12013-1172">또는 두 개의 스레드를 만들고 각 스트림에서 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1172">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1173">리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1173">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="12013-1174">리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1174">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="12013-1175">예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 또는 그 반대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1175">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="12013-1176">그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1176">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="12013-1177">예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1177">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1178">다음 예제에서는 `net use` 명령을 사용자와 함께 네트워크 리소스를 매핑할 수는 인수를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1178">The following example uses the `net use` command together with a user supplied argument to map a network resource.</span></span> <span data-ttu-id="12013-1179">그런 다음 net 명령의 표준 오류 스트림을 읽고 콘솔에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1179">It then reads the standard error stream of the net command and writes it to console.</span></span>  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1180">
            <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림이 리디렉션에 대해 정의되지 않았습니다. <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />가 <see langword="true" />로 설정되고 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />가 <see langword="false" />로 설정되어 있는지 확인하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1180">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12013-1181">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1181">\- or -</span>
          </span>
          <span data-ttu-id="12013-1182">
            <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림이 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />을 사용한 비동기 읽기 작업을 위해 열려 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1182">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1183">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1183">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1184">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1184">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1185">응용 프로그램의 입력을 쓰는 데 사용되는 스트림을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1185">Gets a stream used to write the input of the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1186">응용 프로그램의 표준 입력 스트림을 쓰는 데 사용할 수 있는 <see cref="T:System.IO.StreamWriter" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1186">A <see cref="T:System.IO.StreamWriter" /> that can be used to write the standard input stream of the application.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1187">A <xref:System.Diagnostics.Process> 는 표준 입력된 스트림 일반적으로 키보드에서에서 입력된 텍스트를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1187">A <xref:System.Diagnostics.Process> can read input text from its standard input stream, typically the keyboard.</span></span> <span data-ttu-id="12013-1188">리디렉션하여는 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 입력을 프로그래밍 방식으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1188">By redirecting the <xref:System.Diagnostics.Process.StandardInput%2A> stream, you can programmatically specify the input.</span></span> <span data-ttu-id="12013-1189">예를 들어, 키보드 입력을 사용 하는 대신 지정 된 파일의 내용에서 텍스트 또는 다른 응용 프로그램에서 출력을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1189">For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1190">사용 하려면 <xref:System.Diagnostics.Process.StandardInput%2A>, 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 를 `false`, 설정 해야 하 고 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> 를 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1190">To use <xref:System.Diagnostics.Process.StandardInput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="12013-1191">그렇지 않은 경우에 쓰기는 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1191">Otherwise, writing to the <xref:System.Diagnostics.Process.StandardInput%2A> stream throws an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1192">리디렉션하는 방법을 보여 주는 다음 예제는 <xref:System.Diagnostics.Process.StandardInput%2A> 프로세스의 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1192">The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process.</span></span> <span data-ttu-id="12013-1193">이 예제에서는 시작는 `sort` 명령이 리디렉션된 입력을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1193">The example starts the `sort` command with redirected input.</span></span> <span data-ttu-id="12013-1194">그런 다음 텍스트에 대 한 사용자 요청에 해당 전달 하 고는 `sort` 리디렉션된를 사용 하 여 프로세스 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1194">It then prompts the user for text, and passes that to the `sort` process by means of the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream.</span></span> <span data-ttu-id="12013-1195">`sort` 결과가 콘솔에 사용자에 게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1195">The `sort` results are displayed to the user on the console.</span></span>  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1196">
            <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />이 <see langword="false" />로 설정되어 있어서 <see cref="P:System.Diagnostics.Process.StandardInput" /> 스트림이 정의되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1196">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1197">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1197">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1198">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1198">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1199">응용 프로그램의 텍스트 출력을 읽는 데 사용되는 스트림을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1199">Gets a stream used to read the textual output of the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1200">응용 프로그램의 표준 출력 스트림을 읽는 데 사용할 수 있는 <see cref="T:System.IO.StreamReader" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1200">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard output stream of the application.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1201">경우는 <xref:System.Diagnostics.Process> 해당 텍스트는 일반적으로 콘솔에 표시 됩니다 텍스트를 표준 스트림에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1201">When a <xref:System.Diagnostics.Process> writes text to its standard stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="12013-1202">리디렉션하여는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 조작 하거나 프로세스의 출력을 표시 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1202">By redirecting the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, you can manipulate or suppress the output of a process.</span></span> <span data-ttu-id="12013-1203">예를 들어 텍스트를 필터링 다르게 형식을 지정 하거나 콘솔 및 지정 된 로그 파일 모두에 출력을 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1203">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1204">사용 하려면 <xref:System.Diagnostics.Process.StandardOutput%2A>, 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 를 `false`, 설정 해야 하 고 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> 를 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1204">To use <xref:System.Diagnostics.Process.StandardOutput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="12013-1205">그렇지 않은 경우에서 읽기는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1205">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="12013-1206">리디렉션된 <xref:System.Diagnostics.Process.StandardOutput%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1206">The redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="12013-1207">와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 출력 스트림에서 동기 읽기 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1207">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="12013-1208">이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트리밍하거나 스트림을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1208">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="12013-1209">반면, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1209">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-1210">이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1210">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="12013-1211">동기 작업에서 읽는 호출자 간의 종속성을 유발 읽기는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림과 자식 해당 스트림에 쓰기를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1211">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="12013-1212">이러한 종속성은 교착 상태 조건이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1212">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="12013-1213">호출자에 게 자식 프로세스의 리디렉션된 스트림에서 읽으면 자식에 종속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1213">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="12013-1214">호출자에 게 자식 스트림에 쓰거나 스트림을 닫고 때까지 읽기 작업을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1214">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="12013-1215">리디렉션된 스트림을 맞게 충분 한 데이터를 기록 하는 자식 프로세스를 부모에 종속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1215">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="12013-1216">자식 프로세스 부모 전체 스트림을 읽기 / 스트림의 닫을 때까지 다음 쓰기 작업에서 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1216">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="12013-1217">호출자와 자식 프로세스는 작업을 완료 하려면 서로 대기 하 고 아무 작업도 처리할 수 하는 경우 교착 상태가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1217">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="12013-1218">호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1218">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="12013-1219">예를 들어 다음 C# 코드에는 리디렉션된 스트림에서 읽은 하 고 자식 프로세스가 종료 될 때까지 대기 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1219">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="12013-1220">호출 하 여 교착 상태를 방지 하는 코드 예제에서는 `p.StandardOutput.ReadToEnd` 전에 `p.WaitForExit`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1220">The code example avoids a deadlock condition by calling `p.StandardOutput.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="12013-1221">부모 호출을 처리 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 전에 `p.StandardOutput.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1221">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardOutput.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="12013-1222">부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1222">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="12013-1223">자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1223">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-1224">표준 출력과 표준 오류 스트림 모두에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1224">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="12013-1225">예를 들어 다음 C# 코드에서는 두 스트림이 읽기 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1225">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="12013-1226">비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1226">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-1227">부모 호출을 처리 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 이어서 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1227">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="12013-1228">부모 프로세스는 자식 프로세스를 닫으려면 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1228">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="12013-1229">자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1229">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="12013-1230">이러한 종속성과 교착 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1230">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="12013-1231">또는 두 개의 스레드를 만들고 각 스트림에서 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1231">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1232">리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1232">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="12013-1233">리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1233">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="12013-1234">예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 또는 그 반대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1234">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="12013-1235">그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1235">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="12013-1236">예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1236">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1237">다음 예제에서는 ipconfig.exe 명령을 실행 하 고 예에 나오는 콘솔 창에는 표준 출력을 리디렉션합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1237">The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.</span></span>  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1238">
            <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림이 리디렉션에 대해 정의되지 않았습니다. <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />가 <see langword="true" />로 설정되고 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />가 <see langword="false" />로 설정되어 있는지 확인하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1238">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12013-1239">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1239">\- or -</span>
          </span>
          <span data-ttu-id="12013-1240">
            <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림이 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />을 사용한 비동기 읽기 작업을 위해 열려 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1240">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1241">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1241">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1242">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1242">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1243">프로세스 리소스를 시작한 후 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1243">Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-1244">이 <see cref="P:System.Diagnostics.Process.StartInfo" /> 구성 요소의 <see cref="T:System.Diagnostics.Process" /> 속성으로 지정된 프로세스 리소스를 시작하거나 다시 사용하여 구성 요소에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1244">Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1245">프로세스 리소스가 시작된 경우에는 <see langword="true" />이고 기존 프로세스를 다시 사용한 경우처럼 새 프로세스 리소스가 시작되지 않은 경우에는 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1245">
              <see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1246">이 오버 로드를 사용 하 여 프로세스 리소스를 시작 하 여 현재 연결 <xref:System.Diagnostics.Process> 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1246">Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="12013-1247">반환 값은 `true` 는 새 프로세스 리소스가 시작 되었다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1247">The return value `true` indicates that a new process resource was started.</span></span> <span data-ttu-id="12013-1248">변수로 지정 된 프로세스 리소스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성은 컴퓨터에서 이미 실행 중, 추가 프로세스 리소스가 시작 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1248">If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started.</span></span> <span data-ttu-id="12013-1249">대신, 실행 중인 프로세스 리소스를 다시 사용 및 `false` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1249">Instead, the running process resource is reused and `false` is returned.</span></span>  
  
 <span data-ttu-id="12013-1250">처음 설치한 응용 프로그램 (예를 들어 웹 주소) 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1250">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="12013-1251">하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1251">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1252">Visual Studio의이 오버 로드를 사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 메서드는 끌어 놓고 코드에 삽입 하는 <xref:System.Diagnostics.Process> 디자이너 구성 요소를 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1252">If you are using Visual Studio, this overload of the <xref:System.Diagnostics.Process.Start%2A> method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer.</span></span> <span data-ttu-id="12013-1253">사용 하 여는 `Properties` 창이 확장 된 `StartInfo` 범주에 적절 한 값을 작성 하 고는 `FileName` 속성.</span><span class="sxs-lookup"><span data-stu-id="12013-1253">Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property.</span></span> <span data-ttu-id="12013-1254">폼의 변경 내용은 나타납니다 `InitializeComponent` 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1254">Your changes will appear in the form's `InitializeComponent` procedure.</span></span>  
  
 <span data-ttu-id="12013-1255">이 오버 로드의 <xref:System.Diagnostics.Process.Start%2A> 않습니다는 `static` 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1255">This overload of <xref:System.Diagnostics.Process.Start%2A> is not a `static` method.</span></span> <span data-ttu-id="12013-1256">인스턴스에서 호출 해야는 <xref:System.Diagnostics.Process> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1256">You must call it from an instance of the <xref:System.Diagnostics.Process> class.</span></span> <span data-ttu-id="12013-1257">호출 하기 전에 <xref:System.Diagnostics.Process.Start%2A>를 먼저 지정 해야 <xref:System.Diagnostics.Process.StartInfo%2A> 이 대 한 속성 정보 <xref:System.Diagnostics.Process> 정보가 사용 되는 시작 된 프로세스 리소스를 확인 하려면 않았기 때문에 인스턴스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1257">Before calling <xref:System.Diagnostics.Process.Start%2A>, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.</span></span>  
  
 <span data-ttu-id="12013-1258">다른 오버 로드는 <xref:System.Diagnostics.Process.Start%2A> 메서드가 `static` 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1258">The other overloads of the <xref:System.Diagnostics.Process.Start%2A> method are `static` members.</span></span> <span data-ttu-id="12013-1259">인스턴스를 만들 필요가 없습니다는 <xref:System.Diagnostics.Process> 메서드의 이러한 오버 로드를 호출 하기 전에 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1259">You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method.</span></span> <span data-ttu-id="12013-1260">대신, 호출 수 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 클래스 자체 및 새 <xref:System.Diagnostics.Process> 프로세스가 시작 된 경우 구성 요소가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1260">Instead, you can call <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started.</span></span> <span data-ttu-id="12013-1261">또는, `null` 프로세스를 다시 사용 하는 경우 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1261">Or, `null` is returned if a process was reused.</span></span> <span data-ttu-id="12013-1262">프로세스 리소스를 자동으로 연결 된 새 <xref:System.Diagnostics.Process> 에서 반환 되는 구성 요소는 <xref:System.Diagnostics.Process.Start%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1262">The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the <xref:System.Diagnostics.Process.Start%2A> method.</span></span>  
  
 <span data-ttu-id="12013-1263"><xref:System.Diagnostics.Process.StartInfo%2A> 의 기능을 복제 하는 멤버를 사용할 수는 `Run` 대화 상자는 창의 `Start` 메뉴.</span><span class="sxs-lookup"><span data-stu-id="12013-1263">The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="12013-1264">명령줄에 입력할 수 있는 모든 항목에서 적절 한 값을 설정 하 여 시작할 수 있습니다는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1264">Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="12013-1265">유일한 <xref:System.Diagnostics.Process.StartInfo%2A> 설정 해야 하는 속성은는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1265">The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="12013-1266"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 실행 파일 일 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1266">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file.</span></span> <span data-ttu-id="12013-1267">확장 시스템에 설치 된 응용 프로그램에 연결 된 파일 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1267">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="12013-1268">예를 들어는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 편집기, 메모장과 같은 텍스트 파일에 연결 했는지 또는.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우.doc 확장명을 가질 수 있습니다 하는 경우.txt 확장명을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1268">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="12013-1269">명령줄에서 특정 형식의 파일에 대해 수행할 동작을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1269">In the command line, you can specify actions to take for certain types of files.</span></span> <span data-ttu-id="12013-1270">예를 들어 문서를 인쇄 하거나 텍스트 파일을 편집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1270">For example, you can print documents or edit text files.</span></span> <span data-ttu-id="12013-1271">사용 하 여 이러한 동작을 지정 된 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1271">Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="12013-1272">다른 형식의 파일에 대해 지정할 수에서 파일을 시작할 때 명령줄 인수는 `Run` 대화 상자.</span><span class="sxs-lookup"><span data-stu-id="12013-1272">For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box.</span></span> <span data-ttu-id="12013-1273">예를 들어 전달할 수 있습니다는 URL을 인수로으로 브라우저를 지정 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1273">For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</span></span> <span data-ttu-id="12013-1274">이 인수에 지정할 수는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성의 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1274">These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.</span></span>  
  
 <span data-ttu-id="12013-1275">따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1275">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="12013-1276">그렇지 않으면 시스템 경로 찾지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1276">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="12013-1277">예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1277">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1278">ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1278">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="12013-1279">사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1279">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="12013-1280">프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1280">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="12013-1281">사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1281">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="12013-1282">사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1282">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-1283">프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1283">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="12013-1284">관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1284">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="12013-1285">때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 프로세스 구성 요소에 대해 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1285">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="12013-1286">그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1286">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="12013-1287">일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1287">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="12013-1288">기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1288">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="12013-1289">그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1289">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1290">다음 예제에서 사용 하는 <xref:System.Diagnostics.Process> 클래스는 프로세스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1290">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1291">
            <see cref="T:System.Diagnostics.Process" /> 구성 요소의 <see cref="P:System.Diagnostics.Process.StartInfo" />에 파일 이름이 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1291">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.</span>
          </span>
          <span data-ttu-id="12013-1292">또는 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 또는 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />가 <see langword="true" />인 동안 <see cref="P:System.Diagnostics.Process.StartInfo" /> 속성의 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 멤버는 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1292">-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1293">연결된 파일을 여는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1293">There was an error in opening the associated file.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="12013-1294">프로세스 개체가 이미 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1294">The process object has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1295">메서드는 Nano Server와 같은 셸 지원 없이 운영 체제에서 지원되지 않습니다(.NET Core에만 해당).</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1295">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1296">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1296">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1297">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1297">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <span data-ttu-id="12013-1298">파일 이름 및 모든 명령줄 인수를 포함하여 프로세스를 시작하는 데 사용되는 정보가 들어 있는 <see cref="T:System.Diagnostics.ProcessStartInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1298">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-1299">시작할 프로세스의 파일 이름 같은 프로세스 시작 정보가 포함된 매개 변수에 의해 지정된 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1299">Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1300">프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1300">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span>
          </span>
          <span data-ttu-id="12013-1301">같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1301">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span>
          </span>
          <span data-ttu-id="12013-1302">뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1302">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span>
          </span>
          <span data-ttu-id="12013-1303">이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1303">In this case, the started process may have activated an existing instance of itself and then exited.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1304">이 오버 로드를 사용 하 여 지정 하 여 프로세스 리소스를 시작 하는 <xref:System.Diagnostics.ProcessStartInfo> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1304">Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span> <span data-ttu-id="12013-1305">오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1305">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1306">시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1306">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="12013-1307">이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1307">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1308">있는이 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.ProcessStartInfo> 매개 변수는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스를 해당 <xref:System.Diagnostics.Process.StartInfo%2A> 속성 및 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1308">Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="12013-1309">사용 하는 <xref:System.Diagnostics.ProcessStartInfo> 매개 변수를 사용 하면 호출 인스턴스 <xref:System.Diagnostics.Process.Start%2A> 가장 전달 프로세스를 시작 하는 호출에 대해 제어 권한이 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1309">Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process.</span></span> <span data-ttu-id="12013-1310">새로 만들 필요가 없다는 묶은 파일 이름 또는 파일 이름 및 인수를 전달 해야 하는 경우 <xref:System.Diagnostics.ProcessStartInfo> 옵션은 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1310">If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option.</span></span> <span data-ttu-id="12013-1311">유일한 <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> 설정 해야 하는 속성은는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1311">The only <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="12013-1312"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성이 실행 파일을 나타내는 데 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1312">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="12013-1313">확장 시스템에 설치 된 응용 프로그램에 연결 된 파일 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1313">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="12013-1314">예를 들어는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 편집기, 메모장과 같은 텍스트 파일에 연결 했는지 또는.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우.doc 확장명을 가질 수 있습니다 하는 경우.txt 확장명을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1314">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="12013-1315">처음 설치한 응용 프로그램 (예를 들어 웹 주소) 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1315">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="12013-1316">하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1316">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="12013-1317">경우는 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 및 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 의 속성은 <xref:System.Diagnostics.Process.StartInfo%2A> 인스턴스 설정 된 관리 되지 않는 `CreateProcessWithLogonW` 함수가 호출 됩니다는 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> 속성 값이 `true` 또는 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> 속성 값은 <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1317">If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>.</span></span> <span data-ttu-id="12013-1318">경우는 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> 속성은 `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 속성 UPN 형식 이어야 합니다 *사용자*@*DNS_domain_name*합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1318">If the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> property is `null`, the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> property must be in UPN format, *user*@*DNS_domain_name*.</span></span>   
  
 <span data-ttu-id="12013-1319">다른 오버 로드를 오버 로드와는 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 않습니다는 `static` 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1319">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="12013-1320">이미 만든 경우 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.Process> 인스턴스, 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1320">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1321">중 하나를 사용 하 여는 `static` 새 하려는 경우 overloads <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1321">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="12013-1322">이 오버 로드와 매개 변수가 없는 오버 로드를 사용 하면 사용 하 여 프로세스 리소스에 대 한 시작 정보를 지정할 수는 <xref:System.Diagnostics.ProcessStartInfo> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1322">Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span>  
  
 <span data-ttu-id="12013-1323">따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1323">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="12013-1324">그렇지 않으면 시스템 경로 찾지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1324">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="12013-1325">예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1325">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1326">ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1326">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="12013-1327">사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1327">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="12013-1328">프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1328">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="12013-1329">사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1329">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="12013-1330">사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1330">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-1331">프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1331">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="12013-1332">관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1332">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="12013-1333">때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 에 `startInfo` 매개 변수를 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1333">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="12013-1334">그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1334">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="12013-1335">일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1335">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="12013-1336">기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1336">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="12013-1337">그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1337">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1338">먼저 다음 예제에서는 Internet Explorer의 인스턴스를 생성 하 고 브라우저의 즐겨찾기 폴더의 내용을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1338">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="12013-1339">그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지 또는 사이트를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1339">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="12013-1340">마지막으로 특정 사이트를 탐색 하는 동안 최소화 된 상태로 창으로 Internet Explorer를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1340">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 <span data-ttu-id="12013-1341">이 방법의 다른 사용의 또 다른 예에 대 한 참조의 각 속성에는 <xref:System.Diagnostics.ProcessStartInfo> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1341">For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1342">
            <paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 속성에 파일 이름이 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1342">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.</span>
          </span>
          <span data-ttu-id="12013-1343">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1343">-or-</span>
          </span>
          <span data-ttu-id="12013-1344">
            <paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성이 <see langword="true" /> 및 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />이고, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 또는 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 속성 또한 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1344">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.</span>
          </span>
          <span data-ttu-id="12013-1345">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1345">-or-</span>
          </span>
          <span data-ttu-id="12013-1346">
            <paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성이 <see langword="true" />이고 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 속성이 <see langword="null" /> 또는 비어 있거나 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 속성이 <see langword="null" />이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1346">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="12013-1347">
            <paramref name="startInfo" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1347">The <paramref name="startInfo" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="12013-1348">프로세스 개체가 이미 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1348">The process object has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="12013-1349">
            <paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 속성에 지정된 파일을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1349">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1350">연결된 파일을 열 때 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1350">An error occurred when opening the associated file.</span>
          </span>
          <span data-ttu-id="12013-1351">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1351">-or-</span>
          </span>
          <span data-ttu-id="12013-1352">인수의 길이와 프로세스에 대한 전체 경로 길이를 합하면 2080을 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1352">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span>
          </span>
          <span data-ttu-id="12013-1353">이 예외와 관련된 오류 메시지는 다음 중 하나일 수 있습니다. "시스템 호출에 전달된 데이터 영역이 너무 작습니다."</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1353">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span>
          </span>
          <span data-ttu-id="12013-1354">또는 “액세스가 거부되었습니다.”</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1354">or "Access is denied."</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1355">메서드는 Nano Server와 같은 셸 지원 없이 운영 체제에서 지원되지 않습니다(.NET Core에만 해당).</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1355">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1356">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1356">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1357">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1357">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="12013-1358">프로세스에서 실행될 문서 또는 응용 프로그램 파일의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1358">The name of a document or application file to run in the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-1359">문서 또는 응용 프로그램 파일 이름을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1359">Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1360">프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1360">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span>
          </span>
          <span data-ttu-id="12013-1361">같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1361">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span>
          </span>
          <span data-ttu-id="12013-1362">뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1362">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span>
          </span>
          <span data-ttu-id="12013-1363">이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1363">In this case, the started process may have activated an existing instance of itself and then exited.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1364">이 오버 로드를 사용 하 여 해당 파일 이름을 지정 하 여 프로세스 리소스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1364">Use this overload to start a process resource by specifying its file name.</span></span> <span data-ttu-id="12013-1365">오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1365">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1366">시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1366">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="12013-1367">이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1367">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1368">오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1368">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="12013-1369">설정 하 여 ClickOnce 응용 프로그램을 시작할 수는 `fileName` 위치 (예를 들어 웹 주소)를 처음 설치한 응용 프로그램에 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1369">You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="12013-1370">하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1370">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="12013-1371">해당 파일 이름을 지정 하는 프로세스를 시작 하는 것은에 정보를 입력 비슷합니다는 `Run` 대화 상자는 창의 `Start` 메뉴.</span><span class="sxs-lookup"><span data-stu-id="12013-1371">Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="12013-1372">따라서 파일 이름이 실행 파일을 나타내는 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1372">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="12013-1373">모든 형식의 파일을 확장에 연결 된 시스템에 설치 된 응용 프로그램 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1373">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="12013-1374">예를 들어.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우에 확장명이.doc를 가질 수 있습니다 또는 텍스트 파일을 메모장과 같은 편집기에 연결한 경우 파일 이름은.txt 확장명을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1374">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="12013-1375">동일한 방식으로 `Run` .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1375">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="12013-1376">예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1376">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="12013-1377">이 오버 로드 하는 프로세스에 대 한 명령줄 인수를 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1377">This overload does not allow command-line arguments for the process.</span></span> <span data-ttu-id="12013-1378">프로세스에 대 한 하나 이상의 명령줄 인수를 지정 해야 할 경우 사용 된 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> 또는 <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1378">If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overloads.</span></span>  
  
 <span data-ttu-id="12013-1379">다른 오버 로드를 오버 로드와는 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 않습니다는 `static` 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1379">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="12013-1380">이미 만든 경우 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.Process> 인스턴스, 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1380">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1381">중 하나를 사용 하 여는 `static` 새 하려는 경우 overloads <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1381">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="12013-1382">이 오버 로드와 매개 변수가 없는 오버 로드 시작할 프로세스 리소스의 파일 이름을 지정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1382">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.</span></span>  
  
 <span data-ttu-id="12013-1383">따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1383">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="12013-1384">그렇지 않으면 시스템 경로 찾지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1384">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="12013-1385">예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1385">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1386">ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1386">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="12013-1387">사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1387">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="12013-1388">프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1388">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="12013-1389">사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1389">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="12013-1390">사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1390">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-1391">프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1391">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="12013-1392">관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1392">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="12013-1393">때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 프로세스 구성 요소에 대해 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1393">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="12013-1394">그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1394">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="12013-1395">일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1395">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="12013-1396">기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1396">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="12013-1397">그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1397">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1398">먼저 다음 예제에서는 Internet Explorer의 인스턴스를 생성 하 고 브라우저의 즐겨찾기 폴더의 내용을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1398">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="12013-1399">그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지 또는 사이트를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1399">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="12013-1400">마지막으로 특정 사이트를 탐색 하는 동안 최소화 된 상태로 창으로 Internet Explorer를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1400">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1401">연결된 파일을 열 때 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1401">An error occurred when opening the associated file.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="12013-1402">프로세스 개체가 이미 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1402">The process object has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="12013-1403">PATH 환경 변수에 따옴표를 포함하는 문자열이 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1403">The PATH environment variable has a string containing quotes.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1404">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1404">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1405">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1405">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="12013-1406">프로세스에서 실행될 응용 프로그램 파일 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1406">The name of an application file to run in the process.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="12013-1407">프로세스를 시작할 때 전달할 명령줄 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1407">Command-line arguments to pass when starting the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-1408">응용 프로그램 이름 및 명령줄 인수 집합을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1408">Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1409">프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1409">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span>
          </span>
          <span data-ttu-id="12013-1410">같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1410">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span>
          </span>
          <span data-ttu-id="12013-1411">뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1411">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span>
          </span>
          <span data-ttu-id="12013-1412">이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1412">In this case, the started process may have activated an existing instance of itself and then exited.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1413">이 오버 로드를 사용 하 여 파일 이름 및 명령줄 인수를 지정 하 여 프로세스 리소스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1413">Use this overload to start a process resource by specifying its file name and command-line arguments.</span></span> <span data-ttu-id="12013-1414">오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1414">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1415">시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1415">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="12013-1416">이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1416">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1417">오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 및 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1417">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="12013-1418">파일 이름 및 인수를 지정 하 여 프로세스를 시작 하는 것은 파일 이름 및 명령줄 인수에서 입력 비슷합니다는 `Run` 대화 상자는 창의 `Start` 메뉴.</span><span class="sxs-lookup"><span data-stu-id="12013-1418">Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="12013-1419">따라서 파일 이름이 실행 파일을 나타내는 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1419">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="12013-1420">모든 형식의 파일을 확장에 연결 된 시스템에 설치 된 응용 프로그램 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1420">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="12013-1421">예를 들어.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우에 확장명이.doc를 가질 수 있습니다 또는 텍스트 파일을 메모장과 같은 편집기에 연결한 경우 파일 이름은.txt 확장명을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1421">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="12013-1422">동일한 방식으로 `Run` .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1422">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="12013-1423">예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1423">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="12013-1424">경우는 `fileName` 매개 변수는 실행 파일로 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1424">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span> <span data-ttu-id="12013-1425">경우는 `fileName` 매개 변수는 명령 파일 (.cmd)을 나타냅니다는 `arguments` 매개 변수 하나를 포함 해야는 "`/c`"또는"`/k`" 인수를 명령 창 종료 또는 완료 된 후 남아 있는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1425">If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a "`/c`" or "`/k`" argument to specify whether the command window exits or remains after completion.</span></span>  
  
 <span data-ttu-id="12013-1426">다른 오버 로드를 오버 로드와는 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 않습니다는 `static` 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1426">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="12013-1427">이미 만든 경우 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.Process> 인스턴스, 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1427">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1428">중 하나를 사용 하 여는 `static` 새 하려는 경우 overloads <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1428">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="12013-1429">이 오버 로드와 매개 변수가 없는 오버 로드 프로세스 리소스를 시작 및 전달할 명령줄 인수 파일 이름을 지정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1429">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.</span></span>  
  
 <span data-ttu-id="12013-1430">따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1430">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="12013-1431">그렇지 않으면 시스템 경로 찾지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1431">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="12013-1432">예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1432">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1433">ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1433">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="12013-1434">사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1434">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="12013-1435">프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1435">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="12013-1436">사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1436">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="12013-1437">사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1437">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-1438">프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성...</span><span class="sxs-lookup"><span data-stu-id="12013-1438">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
 <span data-ttu-id="12013-1439">관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1439">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="12013-1440">때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 프로세스 구성 요소에 대해 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1440">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="12013-1441">그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1441">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="12013-1442">일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1442">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="12013-1443">기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1443">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="12013-1444">그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1444">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1445">먼저 다음 예제에서는 Internet Explorer의 인스턴스를 생성 하 고 브라우저의 즐겨찾기 폴더의 내용을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1445">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="12013-1446">그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지 또는 사이트를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1446">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="12013-1447">마지막으로 특정 사이트를 탐색 하는 동안 최소화 된 상태로 창으로 Internet Explorer를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1447">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1448">
            <paramref name="fileName" /> 또는 <paramref name="arguments" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1448">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1449">연결된 파일을 열 때 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1449">An error occurred when opening the associated file.</span>
          </span>
          <span data-ttu-id="12013-1450">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1450">-or-</span>
          </span>
          <span data-ttu-id="12013-1451">인수의 길이와 프로세스에 대한 전체 경로 길이를 합하면 2080을 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1451">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span>
          </span>
          <span data-ttu-id="12013-1452">이 예외와 관련된 오류 메시지는 다음 중 하나일 수 있습니다. "시스템 호출에 전달된 데이터 영역이 너무 작습니다."</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1452">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span>
          </span>
          <span data-ttu-id="12013-1453">또는 “액세스가 거부되었습니다.”</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1453">or "Access is denied."</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="12013-1454">프로세스 개체가 이미 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1454">The process object has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="12013-1455">PATH 환경 변수에 따옴표를 포함하는 문자열이 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1455">The PATH environment variable has a string containing quotes.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1456">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1456">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1457">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1457">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="12013-1458">프로세스에서 실행될 응용 프로그램 파일 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1458">The name of an application file to run in the process.</span>
          </span>
        </param>
        <param name="userName">
          <span data-ttu-id="12013-1459">프로세스를 시작할 때 사용할 사용자 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1459">The user name to use when starting the process.</span>
          </span>
        </param>
        <param name="password">
          <span data-ttu-id="12013-1460">프로세스를 시작할 때 사용할 암호가 포함된 <see cref="T:System.Security.SecureString" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1460">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span>
          </span>
        </param>
        <param name="domain">
          <span data-ttu-id="12013-1461">프로세스를 시작할 때 사용할 도메인입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1461">The domain to use when starting the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-1462">응용 프로그램 이름, 사용자 이름, 암호 및 도메인을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1462">Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1463">프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1463">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span>
          </span>
          <span data-ttu-id="12013-1464">같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1464">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span>
          </span>
          <span data-ttu-id="12013-1465">뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1465">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span>
          </span>
          <span data-ttu-id="12013-1466">이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1466">In this case, the started process may have activated an existing instance of itself and then exited.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1467">이 오버 로드를 사용 하 여 해당 파일 이름, 사용자 이름, 암호 및 도메인을 지정 하 여 새 프로세스와 해당 주 스레드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1467">Use this overload to create a new process and its primary thread by specifying its file name, user name, password, and domain.</span></span> <span data-ttu-id="12013-1468">새 프로세스는 다음 지정 된 자격 증명 (사용자, 도메인 및 암호)의 보안 컨텍스트에서 지정된 된 실행 파일을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1468">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1469">실행 파일을 원격 드라이브에 있는 경우 연결 된 드라이브 문자가 아닌 uniform resource identifier (URI)를 사용 하 여 네트워크 공유를 식별 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1469">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1470">시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1470">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="12013-1471">이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1471">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1472">오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, 및 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 의 속성은 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1472">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="12013-1473">동일한 방식으로 **실행** .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1473">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="12013-1474">예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1474">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="12013-1475">경우는 `fileName` 매개 변수는 실행 파일로 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1475">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1476">파일 이름에는 실행 파일을 나타내야 합니다는 <xref:System.Diagnostics.Process.Start%2A> 오버 로드의 `userName`, `password`, 및 `domain` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1476">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="12013-1477">사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1477">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="12013-1478">사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1478">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-1479">프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성...</span><span class="sxs-lookup"><span data-stu-id="12013-1479">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1480">다음 코드 예제에서는이 오버 로드를 실행 파일로 시작의 사용법을 보여줍니다 및에서는의 <xref:System.ComponentModel.Win32Exception> 파일과와 연결 된 응용 프로그램을 시작 하려고 할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1480">The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1481">파일 이름을 지정하지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1481">No file name was specified.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1482">연결된 파일을 여는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1482">There was an error in opening the associated file.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="12013-1483">프로세스 개체가 이미 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1483">The process object has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1484">메서드는 Linux 또는 macOS에서 지원되지 않습니다(.NET Core에만 해당).</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1484">Method not supported on Linux or macOS (.NET Core only).</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1485">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1485">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1486">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1486">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="12013-1487">프로세스에서 실행될 응용 프로그램 파일 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1487">The name of an application file to run in the process.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="12013-1488">프로세스를 시작할 때 전달할 명령줄 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1488">Command-line arguments to pass when starting the process.</span>
          </span>
        </param>
        <param name="userName">
          <span data-ttu-id="12013-1489">프로세스를 시작할 때 사용할 사용자 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1489">The user name to use when starting the process.</span>
          </span>
        </param>
        <param name="password">
          <span data-ttu-id="12013-1490">프로세스를 시작할 때 사용할 암호가 포함된 <see cref="T:System.Security.SecureString" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1490">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span>
          </span>
        </param>
        <param name="domain">
          <span data-ttu-id="12013-1491">프로세스를 시작할 때 사용할 도메인입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1491">The domain to use when starting the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-1492">응용 프로그램 이름, 명령줄 인수 집합, 사용자 이름, 암호 및 도메인을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1492">Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1493">프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1493">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span>
          </span>
          <span data-ttu-id="12013-1494">같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1494">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span>
          </span>
          <span data-ttu-id="12013-1495">뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1495">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span>
          </span>
          <span data-ttu-id="12013-1496">이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1496">In this case, the started process may have activated an existing instance of itself and then exited.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1497">이 오버 로드를 사용 하 여 파일 이름, 명령줄 인수, 사용자 이름, 암호 및 도메인을 지정 하 여 새 프로세스와 해당 주 스레드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1497">Use this overload to create a new process and its primary thread by specifying its file name, command-line arguments, user name, password, and domain.</span></span> <span data-ttu-id="12013-1498">새 프로세스는 다음 지정 된 자격 증명 (사용자, 도메인 및 암호)의 보안 컨텍스트에서 지정된 된 실행 파일을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1498">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1499">실행 파일을 원격 드라이브에 있는 경우 연결 된 드라이브 문자가 아닌 uniform resource identifier (URI)를 사용 하 여 네트워크 공유를 식별 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1499">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1500">시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1500">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="12013-1501">이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1501">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="12013-1502">오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, 및 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 의 속성은 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="12013-1502">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="12013-1503">동일한 방식으로 **실행** .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1503">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="12013-1504">예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1504">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="12013-1505">경우는 `fileName` 매개 변수는 실행 파일로 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1505">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1506">파일 이름에는 실행 파일을 나타내야 합니다는 <xref:System.Diagnostics.Process.Start%2A> 오버 로드의 `userName`, `password`, 및 `domain` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1506">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="12013-1507">사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1507">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="12013-1508">사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1508">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="12013-1509">프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성...</span><span class="sxs-lookup"><span data-stu-id="12013-1509">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1510">파일 이름을 지정하지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1510">No file name was specified.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1511">연결된 파일을 열 때 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1511">An error occurred when opening the associated file.</span>
          </span>
          <span data-ttu-id="12013-1512">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1512">-or-</span>
          </span>
          <span data-ttu-id="12013-1513">인수의 길이와 연결된 파일의 전체 경로 길이를 합하면 2080을 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1513">The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080.</span>
          </span>
          <span data-ttu-id="12013-1514">이 예외와 관련된 오류 메시지는 다음 중 하나일 수 있습니다. "시스템 호출에 전달된 데이터 영역이 너무 작습니다."</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1514">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span>
          </span>
          <span data-ttu-id="12013-1515">또는 “액세스가 거부되었습니다.”</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1515">or "Access is denied."</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="12013-1516">프로세스 개체가 이미 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1516">The process object has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1517">메서드는 Linux 또는 macOS에서 지원되지 않습니다(.NET Core에만 해당).</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1517">Method not supported on Linux or macOS (.NET Core only).</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1518">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1518">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1519">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1519">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1520">
            <see cref="M:System.Diagnostics.Process.Start" />의 <see cref="T:System.Diagnostics.Process" /> 메서드에 전달할 속성을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1520">Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1521">프로세스를 시작하는 데 사용된 데이터를 나타내는 <see cref="T:System.Diagnostics.ProcessStartInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1521">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that represents the data with which to start the process.</span>
          </span>
          <span data-ttu-id="12013-1522">이러한 인수에는 프로세스를 시작하는 데 사용된 실행 파일이나 문서 이름이 포함됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1522">These arguments include the name of the executable file or document used to start the process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1523"><xref:System.Diagnostics.Process.StartInfo%2A> 프로세스를 시작 하는 데 매개 변수 집합을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1523"><xref:System.Diagnostics.Process.StartInfo%2A> represents the set of parameters to use to start a process.</span></span> <span data-ttu-id="12013-1524">때 <xref:System.Diagnostics.Process.Start%2A> 호출 되는 <xref:System.Diagnostics.Process.StartInfo%2A> 프로세스가 시작 되도록 지정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1524">When <xref:System.Diagnostics.Process.Start%2A> is called, the <xref:System.Diagnostics.Process.StartInfo%2A> is used to specify the process to start.</span></span> <span data-ttu-id="12013-1525">유일한 필수 <xref:System.Diagnostics.Process.StartInfo%2A> 설정 하는 멤버는는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1525">The only necessary <xref:System.Diagnostics.Process.StartInfo%2A> member to set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="12013-1526">지정 하 여 프로세스를 시작는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성에 정보를 입력 하는 것과 비슷합니다는 **실행** 대화 상자는 창의 **시작** 메뉴.</span><span class="sxs-lookup"><span data-stu-id="12013-1526">Starting a process by specifying the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property is similar to typing the information in the **Run** dialog box of the Windows **Start** menu.</span></span> <span data-ttu-id="12013-1527">따라서는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성이 실행 파일을 나타내는 데 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1527">Therefore, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="12013-1528">모든 형식의 파일을 확장에 연결 된 시스템에 설치 된 응용 프로그램 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1528">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="12013-1529">예를 들어는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 편집기, 메모장과 같은 텍스트 파일에 연결 했는지 또는.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우에 확장명이.doc를 가질 수 있습니다 하는 경우.txt 확장명을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1529">For example the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="12013-1530">동일한 방식으로 **실행** .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1530">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="12013-1531">예를 들어, 설정할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성을 "Notepad.exe" 또는 "Notepad" 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1531">For example, you can set the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="12013-1532">설정 하 여 ClickOnce 응용 프로그램을 시작할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성을 원래 응용 프로그램 설치 위치 (예를 들어 웹 주소).</span><span class="sxs-lookup"><span data-stu-id="12013-1532">You can start a ClickOnce application by setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="12013-1533">하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1533">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="12013-1534">파일 이름 예:.doc 파일 파일과 포함 되는 경우에 파일에 수행할 동작을 지정 하는 동사를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1534">If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file.</span></span> <span data-ttu-id="12013-1535">예를 들어 설정할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> .doc 확장명으로 끝나는 파일에 대 한 "print"입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1535">For example, you could set the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> to "Print" for a file ending in the .doc extension.</span></span> <span data-ttu-id="12013-1536">지정 된 파일 이름이 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성에 대 한 값을 수동으로 입력 하는 경우 확장명을 가질 필요가 없습니다는 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1536">The file name specified in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to have an extension if you manually enter a value for the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> property.</span></span> <span data-ttu-id="12013-1537">그러나 사용 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> 동사를 확인 하려면 속성을 사용할 수 있는 확장을 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1537">However, if you use the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property to determine what verbs are available, you must include the extension.</span></span>  
  
 <span data-ttu-id="12013-1538">에 지정 된 매개 변수를 변경할 수는 <xref:System.Diagnostics.Process.StartInfo%2A> 호출 전까지 속성은 <xref:System.Diagnostics.Process.Start%2A> 프로세스에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="12013-1538">You can change the parameters specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property up to the time that you call the <xref:System.Diagnostics.Process.Start%2A> method on the process.</span></span> <span data-ttu-id="12013-1539">프로세스를 시작 하면 변경 된 <xref:System.Diagnostics.Process.StartInfo%2A> 값에 영향을 하거나 연결된 된 프로세스를 다시 시작 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1539">After you start the process, changing the <xref:System.Diagnostics.Process.StartInfo%2A> values does not affect or restart the associated process.</span></span> <span data-ttu-id="12013-1540">호출 하는 경우는 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> 메서드는 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 및 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 속성 집합, 관리 되지 않는 `CreateProcessWithLogonW` 함수가 호출 되는 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> 속성 값이 `true` 또는 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> 속성 값은 <xref:System.Diagnostics.ProcessWindowStyle.Hidden>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1540">If you call the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> method with the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.</span></span>  
  
 <span data-ttu-id="12013-1541">사용 하지 않은 경우는 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하는 메서드는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성 매개 변수는 프로세스를 시작 하는 데 사용 되지는지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1541">If you did not use the <xref:System.Diagnostics.Process.Start%2A> method to start a process, the <xref:System.Diagnostics.Process.StartInfo%2A> property does not reflect the parameters used to start the process.</span></span> <span data-ttu-id="12013-1542">예를 들어, 사용 하는 경우 <xref:System.Diagnostics.Process.GetProcesses%2A> 컴퓨터에서 실행 중인 프로세스의 배열을 가져올 수는 <xref:System.Diagnostics.Process.StartInfo%2A> 각 속성 <xref:System.Diagnostics.Process> 원래 파일 이름 또는 프로세스를 시작 하는 데 사용 되는 인수를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1542">For example, if you use <xref:System.Diagnostics.Process.GetProcesses%2A> to get an array of processes running on the computer, the <xref:System.Diagnostics.Process.StartInfo%2A> property of each <xref:System.Diagnostics.Process> does not contain the original file name or arguments used to start the process.</span></span>  
  
 <span data-ttu-id="12013-1543">파일 이름 (읽기 전용) 정보를 표시 하는 파일은 프로세스가 시작 되 면 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1543">When the process is started, the file name is the file that populates the (read-only) <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="12013-1544">프로세스가 시작 된 후 프로세스와 연결 된 실행 파일을 검색, 사용 하려는 경우는 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1544">If you want to retrieve the executable file that is associated with the process after the process has started, use the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="12013-1545">실행 파일을 설정 하려는 경우는 <xref:System.Diagnostics.Process> 있는 연결된 된 프로세스가 시작 되지 않은 대 한 인스턴스를 사용 하 여는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성의 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1545">If you want to set the executable file of a <xref:System.Diagnostics.Process> instance for which an associated process has not been started, use the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="12013-1546">때문에의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성에 전달 되는 인수는는 <xref:System.Diagnostics.Process.Start%2A> 변경 하는 프로세스의 메서드는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 연결된 된 프로세스가 시작 된 후 다시 설정 되지 것입니다는 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1546">Because the members of the <xref:System.Diagnostics.Process.StartInfo%2A> property are arguments that are passed to the <xref:System.Diagnostics.Process.Start%2A> method of a process, changing the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property after the associated process has started will not reset the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="12013-1547">이러한 속성은 연결된 된 프로세스 초기화에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1547">These properties are used only to initialize the associated process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1548">다음 예제에서는 한 <xref:System.Diagnostics.Process.StartInfo%2A> 실행 파일에 대해 수행 된 작업 및 사용자 인터페이스를 표시 해야 하는지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1548">The following example populates a <xref:System.Diagnostics.Process.StartInfo%2A> with the file to execute, the action performed on it and whether it should displays a user interface.</span></span> <span data-ttu-id="12013-1549">다른 예제를 보려면 참조 페이지의 속성에 대 한 참조는 <xref:System.Diagnostics.ProcessStartInfo> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1549">For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="12013-1550">
            <see cref="P:System.Diagnostics.Process.StartInfo" />를 지정하는 값이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1550">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1551">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1551">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1552">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1552">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1553">연결된 프로세스가 시작된 시간을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1553">Gets the time that the associated process was started.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1554">해당 프로세스가 시작된 시간을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1554">An object  that indicates when the process started.</span>
          </span>
          <span data-ttu-id="12013-1555">프로세스가 실행되고 있지 않으면 예외가 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1555">An exception is thrown if the process is not running.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1556">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1556">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1557">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.StartTime" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1557">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1558">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1558">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1559">프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1559">The process has exited.</span>
          </span>
          <span data-ttu-id="12013-1560">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1560">-or-</span>
          </span>
          <span data-ttu-id="12013-1561">프로세스가 시작되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1561">The process has not been started.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1562">Windows 함수 호출 시 오류가 발생 했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1562">An error occurred in the call to the Windows function.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1563">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1563">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1564">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1564">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1565">프로세스 종료 이벤트의 결과로 발생하는 이벤트 처리기 호출을 마샬링하는 데 사용되는 개체를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1565">Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1566">프로세스에서 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트의 결과로 발생하는 이벤트 처리기 호출을 마샬링하는 데 사용되는 <see cref="T:System.ComponentModel.ISynchronizeInvoke" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1566">The <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> used to marshal event handler calls that are issued as a result of an <see cref="E:System.Diagnostics.Process.Exited" /> event on the process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1567">때 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 은 `null`를 처리 하는 메서드는 <xref:System.Diagnostics.Process.Exited> 시스템 스레드 풀의 스레드라도에서 이벤트를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1567">When <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> is `null`, methods that handle the <xref:System.Diagnostics.Process.Exited> event are called on a thread from the system thread pool.</span></span> <span data-ttu-id="12013-1568">시스템 스레드 풀에 대 한 자세한 내용은 참조 하십시오. <xref:System.Threading.ThreadPool>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1568">For more information about system thread pools, see <xref:System.Threading.ThreadPool>.</span></span>  
  
 <span data-ttu-id="12013-1569">때는 <xref:System.Diagnostics.Process.Exited> 이벤트가 같은 visual Windows Forms 구성 요소에 의해 처리 되는 <xref:System.Windows.Forms.Button>, 작동 하지 않을 수 시스템 스레드 풀을 통해 구성 요소를 액세스 하거나 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1569">When the <xref:System.Diagnostics.Process.Exited> event is handled by a visual Windows Forms component, such as a <xref:System.Windows.Forms.Button>, accessing the component through the system thread pool might not work, or might result in an exception.</span></span> <span data-ttu-id="12013-1570">설정 하 여이 문제를 방지 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 처리 하는 메서드가 때문에 Windows Forms 구성 요소에는 <xref:System.Diagnostics.Process.Exited> 구성 요소를 만든 동일한 스레드에서 호출 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1570">Avoid this by setting <xref:System.Diagnostics.Process.SynchronizingObject%2A> to a Windows Forms component, which causes the methods handling the <xref:System.Diagnostics.Process.Exited> event to be called on the same thread on which the component was created.</span></span>  
  
 <span data-ttu-id="12013-1571">경우는 <xref:System.Diagnostics.Process> 안에서 사용 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Windows Forms 디자이너에서 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 포함 하는 컨트롤에 자동으로 설정 됩니다는 <xref:System.Diagnostics.Process>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1571">If the <xref:System.Diagnostics.Process> is used inside [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in a Windows Forms designer, <xref:System.Diagnostics.Process.SynchronizingObject%2A> is automatically set to the control that contains the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="12013-1572">예를 들어, 배치 하는 경우는 <xref:System.Diagnostics.Process> 에 대 한 디자이너에서 `Form1` (에서 상속 되 <xref:System.Windows.Forms.Form>)는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성 <xref:System.Diagnostics.Process> 인스턴스의로 설정 된 `Form1`:</span><span class="sxs-lookup"><span data-stu-id="12013-1572">For example, if you place a <xref:System.Diagnostics.Process> on a designer for `Form1` (which inherits from <xref:System.Windows.Forms.Form>) the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property of <xref:System.Diagnostics.Process> is set to the instance of `Form1`:</span></span>  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 <span data-ttu-id="12013-1573">일반적으로 이러한 구성 요소는 특정 스레드에 바인딩되어 있기 때문에 구성 요소 컨트롤 또는 폼에 배치 된 경우이 속성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1573">Typically, this property is set when the component is placed inside a control or form, because those components are bound to a specific thread.</span></span>  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1574">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1574">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1575">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1575">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1576">연결된 프로세스에서 실행 중인 스레드를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1576">Gets the set of threads that are running in the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1577">연결된 프로세스에서 현재 실행 중인 운영 체제 스레드를 나타내는 <see cref="T:System.Diagnostics.ProcessThread" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1577">An array of type <see cref="T:System.Diagnostics.ProcessThread" /> representing the operating system threads currently running in the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1578">스레드는 프로세스의 코드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1578">A thread executes code in a process.</span></span> <span data-ttu-id="12013-1579">각 프로세스는 단일 스레드로 기본 스레드도 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1579">Each process is started with a single thread, its primary thread.</span></span> <span data-ttu-id="12013-1580">모든 스레드가 추가 스레드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1580">Any thread can create additional threads.</span></span> <span data-ttu-id="12013-1581">프로세스 내에서 스레드 프로세스의 주소 공간을 공유 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1581">Threads within a process share the address space of the process.</span></span>  
  
 <span data-ttu-id="12013-1582">사용 하 여 <xref:System.Diagnostics.ProcessThread> 현재 프로세스와 관련 된 모든 스레드를 가져오려면 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1582">Use <xref:System.Diagnostics.ProcessThread> to get all the threads associated with the current process.</span></span> <span data-ttu-id="12013-1583">주 스레드를 반드시 배열의 인덱스 0에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1583">The primary thread is not necessarily at index zero in the array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="12013-1584">프로세스에 <see cref="P:System.Diagnostics.Process.Id" />가 없거나 <see cref="T:System.Diagnostics.Process" /> 인스턴스와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1584">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.</span>
          </span>
          <span data-ttu-id="12013-1585">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1585">-or-</span>
          </span>
          <span data-ttu-id="12013-1586">연결된 프로세스가 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1586">The associated process has exited.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1587">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1587">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1588">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1588">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1589">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1589">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-1590">가능한 경우 부모 구성 요소 형식을 결합하여 프로세스 이름을 문자열로 서식화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1590">Formats the process's name as a string, combined with the parent component type, if applicable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1591">기본 구성 요소의 <see cref="P:System.Diagnostics.Process.ProcessName" /> 반환 값과 결합된 <see cref="M:System.Object.ToString" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1591">The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="12013-1592">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1592">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1593">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1593">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1594">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1594">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1595">
            <see cref="M:System.Diagnostics.Process.ToString" />은 Windows 98에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1595">
              <see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1596">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1596">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1597">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1597">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1598">이 프로세스의 총 프로세서 시간을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1598">Gets the total processor time for this process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1599">연결된 프로세스에서 CPU를 사용해 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1599">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent utilizing the CPU.</span>
          </span>
          <span data-ttu-id="12013-1600">이 값은 <see cref="P:System.Diagnostics.Process.UserProcessorTime" />과 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />의 합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1600">This value is the sum of the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> and the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="12013-1601">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1601">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1602">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1602">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1603">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1603">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1604">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1604">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1605">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1605">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1606">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1606">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1607">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1607">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1608">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1608">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1609">이 프로세스의 사용자 프로세서 시간을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1609">Gets the user processor time for this process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1610">연결된 프로세스가 운영 체제 코어 내부가 아닌 프로세스의 응용 프로그램 부분 내부에서 코드를 실행하는 데 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1610">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent running code inside the application portion of the process (not inside the operating system core).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="12013-1611">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1611">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1612">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1612">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1613">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1613">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1614">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1614">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="12013-1615">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 속성에 액세스하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1615">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1616">이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1616">This property is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1617">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1617">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1618">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1618">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1619">프로세스의 가상 메모리 크기(바이트)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1619">Gets the size of the process's virtual memory, in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1620">연결된 프로세스에서 요청한 가상 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1620">The amount of virtual memory, in bytes, that the associated process has requested.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1621">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1621">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1622">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1622">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1623">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1623">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1624">연결된 프로세스에 할당된 가상 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1624">Gets the amount of the virtual memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1625">연결된 프로세스에 할당된 가상 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1625">The amount of virtual memory, in bytes, allocated for the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1626">이 속성에서 반환 되는 값 (바이트)에서 프로세스에 의해 사용 되는 가상 메모리의 현재 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1626">The value returned by this property represents the current size of virtual memory used by the process, in bytes.</span></span> <span data-ttu-id="12013-1627">운영 체제 디스크에 있는 가상 메모리 페이징 파일에 저장 된 페이지 또는 실제 메모리에 로드 하는 페이지에 각 프로세스에 대 한 가상 주소 공간을 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1627">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="12013-1628">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1628">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-1629">속성 값은 해당 하는 **가상 바이트** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1629">The property value is equivalent to the **Virtual Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1630">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1630">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-1631">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1631">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1632">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1632">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1633">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1633">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1634">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1634">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1635">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1635">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1636">연결된 프로세스가 종료될 때까지 대기하는 시간을 설정하고, 시간이 경과하거나 프로세스가 종료될 때까지 현재 실행의 스레드를 차단합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1636">Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited.</span>
          </span>
          <span data-ttu-id="12013-1637">현재 스레드가 차단되는 것을 방지하려면 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트를 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1637">To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span>
          </span>
          <span data-ttu-id="12013-1638">코드 예제는 <see cref="P:System.Diagnostics.Process.StandardError" /> 및 <see cref="P:System.Diagnostics.Process.ExitCode" /> 속성 참조 페이지를 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1638">For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-1639">연결된 프로세스가 종료될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 무기한 대기하게 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1639">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1640"><xref:System.Diagnostics.Process.WaitForExit> 연결된 된 프로세스가 종료 될 때까지 대기 하는 현재 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1640"><xref:System.Diagnostics.Process.WaitForExit> makes the current thread wait until the associated process terminates.</span></span>  <span data-ttu-id="12013-1641">프로세스에서 다른 모든 메서드를 호출 후에 호출 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1641">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="12013-1642">현재 스레드가 차단되는 것을 방지하려면 <xref:System.Diagnostics.Process.Exited> 이벤트를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1642">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="12013-1643">이 메서드는 <xref:System.Diagnostics.Process> 구성 요소를 종료 하려면 프로세스 및 이벤트 처리기에 대 한 시간을 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1643">This method instructs the <xref:System.Diagnostics.Process> component to wait an infinite amount of time for the process and event handlers to exit.</span></span> <span data-ttu-id="12013-1644">이 인해 응답 하지 응용 프로그램이 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1644">This can cause an application to stop responding.</span></span> <span data-ttu-id="12013-1645">예를 들어, 호출 하는 경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 사용자 인터페이스가 있는 프로세스에 대해 연결된 된 프로세스를 종료 하는 운영 체제에 요청 수 처리할 수 없는 입력 하지 않는 것의 메시지 루프를 작성 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="12013-1645">For example, if you call <xref:System.Diagnostics.Process.CloseMainWindow%2A> for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1646">에 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 및 이전 버전의 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드에 대 한 대기 <xref:System.Int32.MaxValue> 밀리초 (약 24 일), not 무기한 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1646">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, the <xref:System.Diagnostics.Process.WaitForExit> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span> <span data-ttu-id="12013-1647">또한 이전 버전 기다리지 않고 이벤트 처리기를 끝낼 전체 <xref:System.Int32.MaxValue> 시간에 도달 했습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1647">Also, previous versions did not wait for the event handlers to exit if the full <xref:System.Int32.MaxValue> time was reached.</span></span>  
  
 <span data-ttu-id="12013-1648">이 오버 로드는 모든 처리가 완료 되었음을 나타내는, 리디렉션된 표준 출력에 대 한 비동기 이벤트 처리를 포함 하 여 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1648">This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output.</span></span> <span data-ttu-id="12013-1649">호출한 후이 오버 로드를 사용 해야는 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 비동기 이벤트 처리기로 표준 출력이 리디렉션된 경우 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1649">You should use this overload after a call to the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload when standard output has been redirected to asynchronous event handlers.</span></span>  
  
 <span data-ttu-id="12013-1650">시스템 프로세스에 대 한 관리 정보를 저장 하 고이 호출한 하는 구성 요소를 반환 (즉, 것 종료 될 때 운영 체제의 정상 또는 비정상 종료에서) 연결된 된 프로세스가 종료 될 때 <xref:System.Diagnostics.Process.WaitForExit>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1650">When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit>.</span></span> <span data-ttu-id="12013-1651"><xref:System.Diagnostics.Process> 구성 요소에 포함 된 정보를 액세스할 수는 <xref:System.Diagnostics.Process.ExitTime%2A>, 사용 하 여는 <xref:System.Diagnostics.Process.Handle%2A> 종료 프로세스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1651">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="12013-1652">연결된 된 프로세스가 종료 되었으므로 <xref:System.Diagnostics.Process.Handle%2A> 의 구성 요소 속성은 더 이상 기존 프로세스 리소스를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1652">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="12013-1653">대신, 핸들 프로세스 리소스에 대 한 운영 체제의 정보를 액세스할 때만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1653">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="12013-1654">시스템에서 인식 하 여 해제 되지 않은 종료 된 프로세스에 대 한 핸들의 <xref:System.Diagnostics.Process> 유지할 수 있도록 구성 요소는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 될 때까지 메모리에 대 한 정보는 <xref:System.Diagnostics.Process> 구성 요소 리소스를 해제할 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1654">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="12013-1655">이러한 이유로 든 지 호출할 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스를 호출 <xref:System.Diagnostics.Process.Close%2A> 때 연결된 된 프로세스가 종료 하 고 항목에 대 한 관리 정보는 더 이상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1655">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="12013-1656"><xref:System.Diagnostics.Process.Close%2A> 종료 프로세스에 할당 된 메모리를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1656"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1657">설명 섹션을 참조는 <xref:System.Diagnostics.Process.StandardError%2A> 속성 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1657">See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1658">대기 설정에 액세스할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1658">The wait setting could not be accessed.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="12013-1659">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스가 설정되지 않았으며, <see cref="P:System.Diagnostics.Process.Id" /> 속성을 파악할 수 있는 <see cref="P:System.Diagnostics.Process.Handle" />이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1659">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span>
          </span>
          <span data-ttu-id="12013-1660">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1660">-or-</span>
          </span>
          <span data-ttu-id="12013-1661">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1661">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
          <span data-ttu-id="12013-1662">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1662">-or-</span>
          </span>
          <span data-ttu-id="12013-1663">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="M:System.Diagnostics.Process.WaitForExit" />를 호출하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1663">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1664">이 메서드는 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1664">This method is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1665">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1665">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1666">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1666">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">
          <span data-ttu-id="12013-1667">연결된 프로세스가 종료될 때까지 대기하는 시간(밀리초)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1667">The amount of time, in milliseconds, to wait for the associated process to exit.</span>
          </span>
          <span data-ttu-id="12013-1668">최대값은 사용 가능한 가장 큰 32비트 정수 값이며, 이는 운영 체제에서 사실상 무기한 대기한다는 것을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1668">The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-1669">연결된 프로세스가 종료되도록 지정한 밀리초 동안 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 대기하게 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1669">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1670">연결된 프로세스가 종료된 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1670">
              <see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1671"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 연결된 된 프로세스가 종료 될 때까지 대기 하는 현재 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1671"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> makes the current thread wait until the associated process terminates.</span></span> <span data-ttu-id="12013-1672">프로세스에서 다른 모든 메서드를 호출 후에 호출 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1672">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="12013-1673">현재 스레드가 차단되는 것을 방지하려면 <xref:System.Diagnostics.Process.Exited> 이벤트를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1673">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="12013-1674">이 메서드는 <xref:System.Diagnostics.Process> 구성 요소를 종료 하려면 프로세스에 대 한 유한 기간 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1674">This method instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to exit.</span></span> <span data-ttu-id="12013-1675">연결된 된 프로세스가 종료 요청이 거부 되었기 때문에 간격의 끝에서 종료 되지 않은 경우 `false` 호출 하는 프로시저로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1675">If the associated process does not exit by the end of the interval because the request to terminate is denied, `false` is returned to the calling procedure.</span></span> <span data-ttu-id="12013-1676">지정할 수 있습니다 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대 한 `milliseconds`, 및 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> 동작이 동일는 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1676">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for `milliseconds`, and <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> will behave the same as the <xref:System.Diagnostics.Process.WaitForExit> overload.</span></span> <span data-ttu-id="12013-1677">반환 하는 경우에 0 (영) 메서드에 전달, `true` 프로세스가 이미 종료 되었습니다; 경우에 이렇게 하지 않으면 즉시 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1677">If you pass 0 (zero) to the method, it returns `true` only if the process has already exited; otherwise, it immediately returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12013-1678">에 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 및 이전 버전 경우 `milliseconds` 가-1는 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 오버 로드에 대 한 대기 <xref:System.Int32.MaxValue> 밀리초 (약 24 일), not 무기한 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1678">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, if `milliseconds` was -1, the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span>  
  
 <span data-ttu-id="12013-1679">비동기 이벤트 처리기로 표준 출력이 리디렉션된, 경우에 출력 프로세스가 완료 되지 않을이 메서드가 반환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1679">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns.</span></span> <span data-ttu-id="12013-1680">비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출는 <xref:System.Diagnostics.Process.WaitForExit> 수신 후 없는 매개 변수를 사용 하는 오버 로드는 `true` 이 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1680">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter after receiving a `true` from this overload.</span></span> <span data-ttu-id="12013-1681">않도록 하기 위한는 <xref:System.Diagnostics.Process.Exited> 설정, Windows Forms 응용 프로그램에서 이벤트를 올바르게 처리는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1681">To help ensure that the <xref:System.Diagnostics.Process.Exited> event is handled correctly in Windows Forms applications, set the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
 <span data-ttu-id="12013-1682">연결된 된 프로세스가 종료 되는 경우 (종료 된 운영 체제의 정상 또는 비정상 종료에서) 시스템의 프로세스에 대 한 관리 정보를 저장 하 고 마치 호출 하는 구성 요소에 반환 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1682">When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>.</span></span> <span data-ttu-id="12013-1683"><xref:System.Diagnostics.Process> 구성 요소에 포함 된 정보를 액세스할 수는 <xref:System.Diagnostics.Process.ExitTime%2A>, 사용 하 여는 <xref:System.Diagnostics.Process.Handle%2A> 종료 프로세스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1683">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="12013-1684">연결된 된 프로세스가 종료 되었으므로 <xref:System.Diagnostics.Process.Handle%2A> 의 구성 요소 속성은 더 이상 기존 프로세스 리소스를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1684">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="12013-1685">대신, 핸들 프로세스 리소스에 대 한 운영 체제의 정보를 액세스할 때만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1685">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="12013-1686">시스템에서 인식 하 여 해제 되지 않은 종료 된 프로세스에 대 한 핸들의 <xref:System.Diagnostics.Process> 유지할 수 있도록 구성 요소는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 될 때까지 메모리에 대 한 정보는 <xref:System.Diagnostics.Process> 구성 요소 리소스를 해제할 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1686">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="12013-1687">이러한 이유로 든 지 호출할 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스를 호출 <xref:System.Diagnostics.Process.Close%2A> 때 연결된 된 프로세스가 종료 하 고 항목에 대 한 관리 정보는 더 이상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1687">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="12013-1688"><xref:System.Diagnostics.Process.Close%2A> 종료 프로세스에 할당 된 메모리를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1688"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1689">에 대 한 코드 예제를 보려면는 <xref:System.Diagnostics.Process.ExitCode%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1689">See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="12013-1690">대기 설정에 액세스할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1690">The wait setting could not be accessed.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="12013-1691">
            <see cref="P:System.Diagnostics.Process.Id" /> 프로세스가 설정되지 않았으며, <see cref="P:System.Diagnostics.Process.Id" /> 속성을 파악할 수 있는 <see cref="P:System.Diagnostics.Process.Handle" />이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1691">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span>
          </span>
          <span data-ttu-id="12013-1692">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1692">-or-</span>
          </span>
          <span data-ttu-id="12013-1693">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1693">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
          <span data-ttu-id="12013-1694">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1694">-or-</span>
          </span>
          <span data-ttu-id="12013-1695">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />를 호출하려고 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1695">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer.</span>
          </span>
          <span data-ttu-id="12013-1696">이 메서드는 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1696">This method is available only for processes that are running on the local computer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="12013-1697">
            <paramref name="milliseconds" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1697">
              <paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1698">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1698">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1699">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1699">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1700">연결된 프로세스가 유휴 상태가 될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 대기하게 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1700">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12013-1701">연결된 프로세스가 유휴 상태가 될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 무기한 대기하도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1701">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state.</span>
          </span>
          <span data-ttu-id="12013-1702">이 오버로드는 사용자 인터페이스가 있는, 즉 메시지 루프가 있는 프로세스에만 적용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1702">This overload applies only to processes with a user interface and, therefore, a message loop.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1703">연결된 프로세스가 유휴 상태가 된 경우 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1703">
              <see langword="true" /> if the associated process has reached an idle state.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1704">사용 하 여 <xref:System.Diagnostics.Process.WaitForInputIdle> 메시지 루프에 유휴 상태로 반환 될 때까지 대기 하는 응용 프로그램의 처리 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1704">Use <xref:System.Diagnostics.Process.WaitForInputIdle> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="12013-1705">사용자 인터페이스를 사용 하 여 프로세스를 실행할 때 운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다의 메시지 루프를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1705">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="12013-1706">프로세스는 다음 메시지 루프를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1706">The process then returns to the message loop.</span></span> <span data-ttu-id="12013-1707">메시지 루프 내에서 메시지를 대기 하 고 유휴 상태에 있는 것으로 프로세스 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1707">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="12013-1708">이 상태는 응용 프로그램에 응용 프로그램이 해당 창와 통신 하기 전에 주 창을 만들기를 완료 프로세스를 시작 하는 대기 해야 하는 경우 예를 들어 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1708">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="12013-1709">프로세스에 메시지 루프에 없는 경우 <xref:System.Diagnostics.Process.WaitForInputIdle> throw는 <xref:System.InvalidOperationException>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1709">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="12013-1710"><xref:System.Diagnostics.Process.WaitForInputIdle> 오버 로드는 <xref:System.Diagnostics.Process> 구성 요소를 메시지 루프에서 유휴 상태가 프로세스에 대 한 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1710">The <xref:System.Diagnostics.Process.WaitForInputIdle> overload instructs the <xref:System.Diagnostics.Process> component to wait indefinitely for the process to become idle in the message loop.</span></span> <span data-ttu-id="12013-1711">이 명령에 응답을 중지 하도록 응용 프로그램 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1711">This instruction can cause an application to stop responding.</span></span> <span data-ttu-id="12013-1712">예를 들어 프로세스에 항상 기록 하는 경우의 메시지 루프 즉시 종료 코드 조각에서와 같이 `while(true)`합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1712">For example, if the process is written to always exit its message loop immediately, as in the code fragment `while(true)`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1713">프로세스에 그래픽 인터페이스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1713">The process does not have a graphical interface.</span>
          </span>
          <span data-ttu-id="12013-1714">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1714">-or-</span>
          </span>
          <span data-ttu-id="12013-1715">알 수 없는 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1715">An unknown error occurred.</span>
          </span>
          <span data-ttu-id="12013-1716">프로세스가 유휴 상태로 전환하지 못했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1716">The process failed to enter an idle state.</span>
          </span>
          <span data-ttu-id="12013-1717">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1717">-or-</span>
          </span>
          <span data-ttu-id="12013-1718">프로세스가 이미 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1718">The process has already exited.</span>
          </span>
          <span data-ttu-id="12013-1719">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1719">-or-</span>
          </span>
          <span data-ttu-id="12013-1720">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1720">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1721">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1721">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1722">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1722">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">
          <span data-ttu-id="12013-1723">
            <see cref="F:System.Int32.MaxValue" />에 대한 값 1은 연결된 프로세스가 유휴 상태가 될 때까지 대기하는 시간(밀리초)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1723">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle.</span>
          </span>
          <span data-ttu-id="12013-1724">값이 0이면 즉시 반환이 이루어지고, 값이 -1이면 무기한 대기하게 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1724">A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12013-1725">연결된 프로세스가 유휴 상태가 될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 지정한 시간(밀리초) 동안 대기하도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1725">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state.</span>
          </span>
          <span data-ttu-id="12013-1726">이 오버로드는 사용자 인터페이스가 있는, 즉 메시지 루프가 있는 프로세스에만 적용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1726">This overload applies only to processes with a user interface and, therefore, a message loop.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="12013-1727">연결된 프로세스가 유휴 상태에 도달한 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1727">
              <see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1728">사용 하 여 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 메시지 루프에 유휴 상태로 반환 될 때까지 대기 하는 응용 프로그램의 처리 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1728">Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="12013-1729">사용자 인터페이스를 사용 하 여 프로세스를 실행할 때 운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다의 메시지 루프를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1729">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="12013-1730">프로세스는 다음 메시지 루프를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1730">The process then returns to the message loop.</span></span> <span data-ttu-id="12013-1731">메시지 루프 내에서 메시지를 대기 하 고 유휴 상태에 있는 것으로 프로세스 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1731">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="12013-1732">이 상태는 응용 프로그램에 응용 프로그램이 해당 창와 통신 하기 전에 주 창을 만들기를 완료 프로세스를 시작 하는 대기 해야 하는 경우 예를 들어 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1732">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="12013-1733">프로세스에 메시지 루프에 없는 경우 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throw는 <xref:System.InvalidOperationException>합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1733">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="12013-1734"><xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 오버 로드는 <xref:System.Diagnostics.Process> 구성 요소를 제한 된 양의 메시지 루프에서 유휴 상태가 프로세스 시간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1734">The <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> overload instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to become idle in the message loop.</span></span> <span data-ttu-id="12013-1735">루프에서 계속 메시지를 처리 하므로 연결된 된 프로세스에 간격의 끝에서 유휴 상태가 되지 경우 `false` 호출 하는 프로시저로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1735">If the associated process has not become idle by the end of the interval because the loop is still processing messages, `false` is returned to the calling procedure.</span></span>  
  
 <span data-ttu-id="12013-1736">이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1736">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12013-1737">프로세스에 그래픽 인터페이스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1737">The process does not have a graphical interface.</span>
          </span>
          <span data-ttu-id="12013-1738">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1738">-or-</span>
          </span>
          <span data-ttu-id="12013-1739">알 수 없는 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1739">An unknown error occurred.</span>
          </span>
          <span data-ttu-id="12013-1740">프로세스가 유휴 상태로 전환하지 못했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1740">The process failed to enter an idle state.</span>
          </span>
          <span data-ttu-id="12013-1741">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1741">-or-</span>
          </span>
          <span data-ttu-id="12013-1742">프로세스가 이미 종료되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1742">The process has already exited.</span>
          </span>
          <span data-ttu-id="12013-1743">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1743">-or-</span>
          </span>
          <span data-ttu-id="12013-1744">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1744">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1745">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1745">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1746">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1746">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1747">연결된 프로세스의 실제 메모리 사용량(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1747">Gets the associated process's physical memory usage, in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1748">연결된 프로세스에서 사용 중인 실제 메모리의 총 크기(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1748">The total amount of physical memory the associated process is using, in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1749">이 속성에서 반환 되는 값 (바이트)에서, 프로세스에서 사용한 작업 집합 메모리의 현재 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1749">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="12013-1750">프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합.</span><span class="sxs-lookup"><span data-stu-id="12013-1750">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="12013-1751">이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1751">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="12013-1752">작업 집합에는 공유 및 개인 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1752">The working set includes both shared and private data.</span></span> <span data-ttu-id="12013-1753">공유 데이터에는 프로세스는 실행 프로세스 모듈와 시스템 라이브러리를 포함 하는 모든 명령이 포함 된 페이지가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1753">The shared data includes the pages that contain all the instructions that the process executes, including the process modules and the system libraries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1754">다음 예제에서는 메모장의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1754">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="12013-1755">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1755">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1756">예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1756">The example detects when the process exits, and displays the process' exit code.</span></span>  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1757">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1757">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1758">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1758">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1759">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1759">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12013-1760">연결된 프로세스에 할당된 실제 메모리의 양(바이트)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1760">Gets the amount of physical memory, in bytes, allocated for the associated process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12013-1761">연결된 프로세스에 할당된 실제 메모리의 양(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1761">The amount of physical memory, in bytes, allocated for the associated process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12013-1762">이 속성에서 반환 되는 값 (바이트)에서, 프로세스에서 사용한 작업 집합 메모리의 현재 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1762">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="12013-1763">프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합.</span><span class="sxs-lookup"><span data-stu-id="12013-1763">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="12013-1764">이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1764">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="12013-1765">작업 집합에는 공유 및 개인 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1765">The working set includes both shared and private data.</span></span> <span data-ttu-id="12013-1766">공유 데이터에는 시스템 라이브러리 및 프로세스 모듈의 명령을 포함 하 여 프로세스에서 실행 하는 모든 명령이 포함 된 페이지가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1766">The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="12013-1767">프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1767">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="12013-1768">속성 값은 해당 하는 **작업 집합** 프로세스에 대 한 성능 카운터입니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1768">The property value is equivalent to the **Working Set** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12013-1769">다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1769">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="12013-1770">검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1770">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="12013-1771">예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12013-1771">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="12013-1772">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1772">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="12013-1773">직접 실행 호출자에 대 한 완전 신뢰 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1773">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="12013-1774">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="12013-1774">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>