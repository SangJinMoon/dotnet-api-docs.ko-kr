<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58cf5f02c19c3c52ac8d26e1ed52e28a450d7b17" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36676170" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to local and remote processes and enables you to start and stop local system processes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.Process> 구성 요소는 컴퓨터에서 실행 중인 프로세스에 대 한 액세스를 제공 합니다. 간단히 말해에서는 프로세스를 실행 중인 앱입니다. 스레드는 운영 체제에 있는 프로세서 시간을 할당 하는 기본 단위입니다. 스레드가 다른 스레드에 의해 현재 실행 되 고 파트를 포함 하는 프로세스의 코드의 모든 부분을 실행할 수 있습니다.  
  
 <xref:System.Diagnostics.Process> 구성 요소는 시작, 중지, 제어 및 응용 프로그램 모니터링에 대 한 유용한 정보를 제공 합니다. 사용할 수는 <xref:System.Diagnostics.Process> 있습니다 또는 구성 요소가 실행 되는 프로세스의 목록을 가져올 수는 새 프로세스를 시작할 수 있습니다. A <xref:System.Diagnostics.Process> 시스템 프로세스를 액세스 하려면 구성 요소를 사용 합니다. 이후에 <xref:System.Diagnostics.Process> 구성 요소가 초기화 된, 실행 중인 프로세스에 대 한 정보를 사용할 수 있습니다. 프로세스 메모리의 양과 같은 성능 정보를 사용 하 여 및 이러한 정보에 로드 된 모듈 (.dll 및.exe 파일), 스레드 집합이 포함 됩니다.  
  
 이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
> [!NOTE]
>  32 비트 프로세스가 64 비트 프로세스의 모듈에 액세스할 수 없습니다. 32 비트 프로세스에서 64 비트 프로세스에 대 한 정보를 가져올 하려는 경우는 <xref:System.ComponentModel.Win32Exception> 예외입니다. 반면에 64 비트 프로세스를 32 비트 프로세스의 모듈을 액세스할 수 있습니다.  
  
 프로세스 구성 요소 속성의 그룹에 대 한 정보를 한 번에 가져옵니다. 이후에 <xref:System.Diagnostics.Process> 구성 요소는 모든 그룹의 멤버 중 하나에 대 한 정보를 확보 하는, 해당 그룹의 다른 속성에 대 한 값을 캐시 하 고 호출할 때까지 그룹의 다른 멤버에 대 한 새 정보를 가져올는 <xref:System.Diagnostics.Process.Refresh%2A> 메서드. 따라서 속성 값을 반드시를 마지막으로 호출한 보다 같을 수는 <xref:System.Diagnostics.Process.Refresh%2A> 메서드. 그룹 명세는 운영 체제에 종속적입니다.  
  
 따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.  
  
 시스템 프로세스를 해당 프로세스 id 시스템에 고유 하 게 식별 됩니다. 많은 Windows 리소스와 마찬가지로 프로세스도 해당 컴퓨터에서 고유 않을 수도 있는 해당 핸들로 식별 됩니다. 핸들은 리소스의 식별자에 대 한 일반 용어입니다. 운영 체제를 통해 액세스할 수 있는 프로세스 핸들 계속 되 면는 <xref:System.Diagnostics.Process.Handle%2A> 의 속성은 <xref:System.Diagnostics.Process> 프로세스가 종료 하는 경우에 구성 요소입니다. 따라서 같은 정보를 관리 하는 프로세스의를 읽을 수는 <xref:System.Diagnostics.Process.ExitCode%2A> (일반적으로 하거나 0의 성공 또는 0이 아닌 오류 코드)와 <xref:System.Diagnostics.Process.ExitTime%2A>합니다. 핸들 핸들 누수가 메모리 누수 보다 더 심각 이므로 매우 중요 한 리소스를은입니다.  
  
> [!NOTE]
>  이 클래스는 모든 멤버에 적용 되는 클래스 수준에 상속 요청과 링크 요청을 포함 합니다. A <xref:System.Security.SecurityException> 직접 실행 호출자 또는 파생된 클래스 중 하나에 완전 신뢰 권한이 없는 경우에 throw 됩니다. 보안 요청에 대 한 세부 정보를 참조 하십시오. [링크 요청](~/docs/framework/misc/link-demands.md)합니다.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] 참고 사항  
 .NET framework에서는 <xref:System.Diagnostics.Process> 클래스를 사용 하 여 기본 여 <xref:System.Console> 일반적으로 인코딩 코드 페이지 인코딩 입력, 출력 및 오류 스트림에 대 한 합니다. 예를 들어 코드, 문화권이 영어 (미국) 인 시스템에서 코드 페이지 437는 기본에 대 한 인코딩을 <xref:System.Console> 클래스입니다. 그러나 [!INCLUDE[net_core](~/includes/net-core-md.md)] 이러한 인코딩은의 제한 된 하위 집합만 사용할 수 있게 될 수 있습니다. 사용 하 여이 경우가 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 을 기본 인코딩으로 합니다.  
  
 경우는 <xref:System.Diagnostics.Process> 개체가 특정 코드 페이지 인코딩에 종속, 있습니다 수 여전히 사용할 수 있도록 다음을 수행 하 여 *전에* 호출 하면 <xref:System.Diagnostics.Process> 메서드:  
  
1.  프로젝트에 System.Text.Encoding.CodePages.dll 어셈블리에 대 한 참조를 추가 합니다.  
  
2.  검색 된 <xref:System.Text.EncodingProvider> 에서 개체는 <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> 속성입니다.  
  
3.  전달 된 <xref:System.Text.EncodingProvider> 개체를 <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> 메서드를 사용할 수 있는 인코딩 공급자에서 지 원하는 추가 인코딩을 합니다.  
  
 <xref:System.Diagnostics.Process> 클래스 다음 자동으로 사용 합니다, UTF8 아닌 기본 시스템 인코딩과를 호출 하기 전에 인코딩 공급자를 등록 한 <xref:System.Diagnostics.Process> 메서드.  
  
   
  
## Examples  
 다음 예제에서 사용 하는 <xref:System.Diagnostics.Process> 클래스는 프로세스를 시작 합니다.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 다음 예제에서는 <xref:System.Diagnostics.Process> 클래스 자체와 정적 <xref:System.Diagnostics.Process.Start%2A> 메서드 프로세스를 시작 합니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 다음 F # 예제에서는 정의 `runProc` 함수는 프로세스를 시작 하는 모든 출력 및 오류 정보를 캡처하고 프로세스를 실행 하는 시간 (밀리초)의 수를 기록 합니다.  `runProc` 함수에 세 개의 매개 변수가: 응용 프로그램의 시작 디렉터리를 제공 하는 인수를 시작 하려면 응용 프로그램의 이름입니다.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 에 대 한 코드는 `runProc` 함수에 의해 작성 되었으므로 [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) 사용할 수는 [Microsoft Public License](https://opensource.org/licenses/ms-pl)합니다.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 클래스는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">상속자에 대 한 완전 신뢰 합니다. 부분적으로 신뢰할 수 있는 코드에서이 클래스는 상속 될 수 없습니다.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하지 않는 경우는 <xref:System.Diagnostics.Process.MachineName%2A> 속성, 기본값은 로컬 컴퓨터 (".").  
  
 새 연결에 대 한 두 가지 옵션이 <xref:System.Diagnostics.Process> 컴퓨터에 있는 프로세스와 구성 요소입니다. 첫 번째 옵션은 만들려는 생성자를 사용 하는 <xref:System.Diagnostics.Process> 의 적절 한 멤버를 설정 하는 구성 요소는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 연결 하는 <xref:System.Diagnostics.Process> 를 새로운 시스템 프로세스입니다. 두 번째 방법은 연결 하는 <xref:System.Diagnostics.Process> 를 사용 하 여 실행 중인 시스템 프로세스와 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 중 하나는 <xref:System.Diagnostics.Process.GetProcesses%2A> 값을 반환 합니다.  
  
 사용 하는 경우는 `static` 오버 로드는 <xref:System.Diagnostics.Process.Start%2A> 메서드는 새 시스템 프로세스를 시작 하는 메서드를 새로 만듭니다. <xref:System.Diagnostics.Process> 구성 요소는 프로세스와 연결 합니다.  
  
 경우는 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 속성이 해당 기본값으로 설정 되어 `true`를 사용 하 여 유사한 방식으로 응용 프로그램 및 문서를 시작할 수 있습니다는 `Run` Windows의 대화 상자 `Start` 메뉴. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 은 `false`, 실행 파일만 시작할 수 있습니다.  
  
 명령줄에서 호출할 수 있는 모든 실행 파일을 두 가지 방법 중 하나로 시작할 수 있습니다:의 적절 한 멤버를 설정 하 여는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출은 <xref:System.Diagnostics.Process.Start%2A> 메서드 매개 변수 없이 또는 적절 한 매개 변수를 전달 하 여는 `static` <xref:System.Diagnostics.Process.Start%2A> 멤버입니다.  
  
 만들 수는 <xref:System.Diagnostics.Process> 생성자는 정적 중 하나를 사용 하 여 구성 요소 <xref:System.Diagnostics.Process.Start%2A> 오버 로드, 또는 중 하나는 <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드. 그렇게 않은 후에 연결된 된 프로세스에 대 한 뷰를 수 있습니다. 메모리에서 프로세스 속성이 변경 될 때 자동으로 업데이트 하는 동적 뷰 아닙니다. 대신, 호출 해야 <xref:System.Diagnostics.Process.Refresh%2A> 업데이트할 구성 요소에 대 한는 <xref:System.Diagnostics.Process> 응용 프로그램에서 속성 정보입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base priority of the associated process.</summary>
        <value>연결된 프로세스의 <see cref="P:System.Diagnostics.Process.PriorityClass" />에서 계산되는 기본 우선 순위입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> 프로세스의 연결된 된 프로세스 내에서 만든 스레드에 대 한 시작 우선 순위입니다. 시스템 모니터의 기본 우선 순위 카운터를 통해 기본 우선 순위에 대 한 정보를 볼 수 있습니다.  
  
 시간 경과 또는 다른 운영 체제 상승이 앞 다른 프로세스에 배치 되어야 하는 경우 기본 우선 순위를 변경할 수 기반으로 합니다.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> 속성을 사용 하면 프로세스에 할당 된 우선 순위를 볼 수 있습니다. 그러나 읽기 전용 이므로 사용할 수 없습니다는 <xref:System.Diagnostics.Process.BasePriority%2A> 프로세스의 우선 순위를 설정 합니다. 우선 순위를 변경 하려면 사용 하 여는 <xref:System.Diagnostics.Process.PriorityClass%2A> 속성입니다. <xref:System.Diagnostics.Process.BasePriority%2A> 을 볼 수 있습니다 하지만 시스템 모니터를 사용 하는 <xref:System.Diagnostics.Process.PriorityClass%2A> 않습니다. 둘 다는 <xref:System.Diagnostics.Process.BasePriority%2A> 및 <xref:System.Diagnostics.Process.PriorityClass%2A> 프로그래밍 방식으로 볼 수 있습니다. 다음 표에서 간의 관계를 보여 줍니다. <xref:System.Diagnostics.Process.BasePriority%2A> 값 및 <xref:System.Diagnostics.Process.PriorityClass%2A> 값입니다.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not started, so there is no process ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다. 와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 오류 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반면, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. 이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 비동기 읽기 작업을 수행 하려면 다음이 단계에 따라 <xref:System.Diagnostics.Process.StandardError%2A> 에 대 한는 <xref:System.Diagnostics.Process> :  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false`로 설정합니다.  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>를 `true`로 설정합니다.  
  
3.  이벤트 처리기를 추가 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트입니다. 이벤트 처리기와 일치 해야 합니다는 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 대리자 서명입니다.  
  
4.  시작 된 <xref:System.Diagnostics.Process>합니다.  
  
5.  호출 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process>합니다. 이 호출에서 비동기 읽기 작업을 시작 <xref:System.Diagnostics.Process.StandardError%2A>합니다.  
  
 연결 된 사용자가 비동기 읽기 작업을 시작, 이벤트 처리기가 호출 될 때 <xref:System.Diagnostics.Process> 텍스트의 줄을 쓰는 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 호출 하 여 비동기 읽기 작업을 취소할 수 있습니다 <xref:System.Diagnostics.Process.CancelErrorRead%2A>합니다. 호출자에 의해 또는 이벤트 처리기에서 읽기 작업을 취소할 수 있습니다. 취소 후 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 비동기 읽기 작업을 다시 시작을 다시 합니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다. 예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `net view` 명령을 원격 컴퓨터에서 사용 가능한 네트워크 리소스를 나열 합니다. 사용자가 대상 컴퓨터 이름 명령줄 인수로 제공 합니다. 사용자 오류 출력에 대 한 파일 이름을 제공할 수도 있습니다. 이 예제에서는 net 명령, 프로세스가 끝날 때까지 및 다음 쓰기 출력 결과 콘솔에 대 한 대기 작업의 출력을 수집 합니다. 필요에 따라 오류 파일의 사용자가 제공 하는 경우이 예제에서는 파일에 오류를 씁니다.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다. 와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반면, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 비동기 읽기 작업을 수행 하려면 다음이 단계에 따라 <xref:System.Diagnostics.Process.StandardOutput%2A> 에 대 한는 <xref:System.Diagnostics.Process> :  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false`로 설정합니다.  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>를 `true`로 설정합니다.  
  
3.  이벤트 처리기를 추가 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트입니다. 이벤트 처리기와 일치 해야 합니다는 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 대리자 서명입니다.  
  
4.  시작 된 <xref:System.Diagnostics.Process>합니다.  
  
5.  호출 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process>합니다. 이 호출에서 비동기 읽기 작업을 시작 <xref:System.Diagnostics.Process.StandardOutput%2A>합니다.  
  
 연결 된 사용자가 비동기 읽기 작업을 시작, 이벤트 처리기가 호출 될 때 <xref:System.Diagnostics.Process> 텍스트의 줄을 쓰는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
 호출 하 여 비동기 읽기 작업을 취소할 수 있습니다 <xref:System.Diagnostics.Process.CancelOutputRead%2A>합니다. 호출자에 의해 또는 이벤트 처리기에서 읽기 작업을 취소할 수 있습니다. 취소 후 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 비동기 읽기 작업을 다시 시작을 다시 합니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다. 예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 리디렉션된에 대해 비동기 읽기 작업을 수행 하는 방법을 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 `sort` 명령입니다. `sort` 명령 읽고 텍스트 입력을 정렬 하는 콘솔 응용 프로그램입니다.  
  
 이 예에서는 대 한 이벤트 대리자를 만듭니다는 `SortOutputHandler` 이벤트 처리기에 연결 된 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트입니다. 이벤트 처리기는 리디렉션된 텍스트 줄을 받아서 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림에 텍스트의 서식을 지정 하 고 화면에 텍스트를 씁니다.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작에 비동기 읽기 작업의 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. <xref:System.Diagnostics.Process.CancelErrorRead%2A> 끝 비동기 읽기 작업입니다.  
  
 취소 후 호출 하 여 비동기 읽기 작업을 재개할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 다시 합니다.  
  
 호출 하는 경우 <xref:System.Diagnostics.Process.CancelErrorRead%2A>모든 진행 중인 읽기 작업에 대 한 <xref:System.Diagnostics.Process.StandardError%2A> 완료 된 이벤트 처리기를 사용할 수 없는 다음 합니다. 이후의 모든 리디렉션된 출력을 <xref:System.Diagnostics.Process.StandardError%2A> 버퍼에 저장 합니다. 이벤트 처리기에 대 한 호출으로 다시 설정 하는 경우 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, 이벤트 처리기에 저장 된 출력은 전송 및 비동기 읽기 작업을 다시 시작 합니다. 비동기 읽기 작업을 다시 시작 하기 전에 이벤트 처리기를 변경 하려는 경우 새 이벤트 처리기를 추가 하기 전에 기존 이벤트 처리기를 제거 해야 합니다.  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  리디렉션된에서 비동기 및 동기 읽기 작업을 혼합할 수 없습니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. 리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다. 취소 하는 경우 비동기 읽기 작업에 <xref:System.Diagnostics.Process.StandardError%2A> 다음 사용 해야 듯이 스트림에서 읽은 해야 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 비동기 읽기 작업을 다시 시작할 수 있습니다. 수행 하지 않도록 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 동기에 대 한 호출의 메서드를 읽을 <xref:System.Diagnostics.Process.StandardError%2A> 같은 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 또는 <xref:System.IO.StreamReader.ReadToEnd%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 시작는 `nmake` 사용자를 사용 하 여 명령을 제공 된 인수입니다. 오류 및 출력 스트림은 비동기적으로 읽는 수집 된 텍스트 줄은 콘솔에 표시으로 로그 파일에 기록 됩니다. 명령 출력에서 지정 된 개수의 줄을 초과할 경우 비동기 읽기 작업이 취소 됩니다.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작에 비동기 읽기 작업의 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. <xref:System.Diagnostics.Process.CancelOutputRead%2A> 끝 비동기 읽기 작업입니다.  
  
 취소 후 다시 시작할 수 있습니다 비동기 읽기 작업을 호출 하 여 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 다시 합니다.  
  
 호출 하는 경우 <xref:System.Diagnostics.Process.CancelOutputRead%2A>모든 진행 중인 읽기 작업에 대 한 <xref:System.Diagnostics.Process.StandardOutput%2A> 완료 된 이벤트 처리기를 사용할 수 없는 다음 합니다. 이후의 모든 리디렉션된 출력을 <xref:System.Diagnostics.Process.StandardOutput%2A> 버퍼에 저장 합니다. 이벤트 처리기에 대 한 호출으로 다시 설정 하는 경우 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, 이벤트 처리기에 저장 된 출력은 전송 및 비동기 읽기 작업을 다시 시작 합니다. 비동기 읽기 작업을 다시 시작 하기 전에 이벤트 처리기를 변경 하려는 경우 새 이벤트 처리기를 추가 하기 전에 기존 이벤트 처리기를 제거 해야 합니다.  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  리디렉션된에서 비동기 및 동기 읽기 작업을 혼합할 수 없습니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다. 취소 하는 경우 비동기 읽기 작업에 <xref:System.Diagnostics.Process.StandardOutput%2A> 다음 사용 해야 듯이 스트림에서 읽은 해야 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 비동기 읽기 작업을 다시 시작할 수 있습니다. 수행 하지 않도록 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 동기에 대 한 호출의 메서드를 읽을 <xref:System.Diagnostics.Process.StandardOutput%2A> 같은 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 또는 <xref:System.IO.StreamReader.ReadToEnd%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 시작는 `nmake` 사용자를 사용 하 여 명령을 제공 된 인수입니다. 오류 및 출력 스트림은 비동기적으로 읽는 수집 된 텍스트 줄은 콘솔에 표시으로 로그 파일에 기록 됩니다. 명령 출력에서 지정 된 개수의 줄을 초과할 경우 비동기 읽기 작업이 취소 됩니다.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees all the resources that are associated with this component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> 메서드를 사용 하면 프로세스 종료, 대기 프로세스 핸들을 닫고를 프로세스 관련 속성을 지웁니다에 대 한 대기를 중지 합니다. <xref:System.Diagnostics.Process.Close%2A> 닫히지 않습니다 표준 출력, 입력 및 오류 판독기와 작성기 외부에서 참조 하는 경우.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> 메서드는 <xref:System.Diagnostics.Process.Close%2A>를 호출합니다. 배치는 <xref:System.Diagnostics.Process> 개체는 `using` 블록 리소스를 호출할 필요 없이 삭제 <xref:System.Diagnostics.Process.Close%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 최대 10 초에 대 한 2 초 간격으로 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다. 이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes a process that has a user interface by sending a close message to its main window.</summary>
        <returns>
          <see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스를 실행할 때 해당 메시지 루프는 대기 상태에 있습니다. 운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다 메시지 루프를 실행 합니다. 호출 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 는 잘 구성 된 응용 프로그램에서 자식 창을 닫고 응용 프로그램에 대 한 실행 중인 모든 메시지 루프를 취소 주 창에 근접 하는 요청을 보냅니다. 요청을 호출 하 여 프로세스를 종료 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 응용 프로그램 종료을 강제로 적용 하지 않습니다. 응용 프로그램을 종료 하기 전에 사용자 확인을 위해 묻거나 종료를 거부할 수 있습니다. 응용 프로그램을 종료 하려면을 사용 하 여는 <xref:System.Diagnostics.Process.Kill%2A> 메서드. 동작은 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 시스템 메뉴를 사용 하 여 응용 프로그램의 주 창을 닫을 수 있는 사용자와 동일 합니다. 따라서 주 창을 닫아 프로세스를 종료를 요청 응용 프로그램이 즉시 종료 강제로 적용 하지 않습니다.  
  
 프로세스에 의해 편집 하는 데이터 또는 프로세스에 할당 된 리소스 손실 될 수 있습니다를 호출 하면 <xref:System.Diagnostics.Process.Kill%2A>합니다. <xref:System.Diagnostics.Process.Kill%2A> 비정상 프로세스 종료를 사용 하면 필요한 경우에 사용 해야 합니다. <xref:System.Diagnostics.Process.CloseMainWindow%2A> 프로세스의 순차적 종료가 가능 하 고 인터페이스와 함께 응용 프로그램에 대 한 것 이므로 모든 창을 닫습니다. 경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 실패 하면 צ ְ ײ <xref:System.Diagnostics.Process.Kill%2A> 으 프로세스를 종료 합니다. <xref:System.Diagnostics.Process.Kill%2A> 그래픽 인터페이스를 갖지 않는 프로세스를 종료 하는 유일한 방법이입니다.  
  
 호출할 수 있습니다 <xref:System.Diagnostics.Process.Kill%2A> 및 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 로컬 컴퓨터에서 실행 중인 프로세스에 대해서만 합니다. 종료 하려면 원격 컴퓨터에서 프로세스 할 수 없습니다. 만 원격 컴퓨터에서 실행 중인 프로세스에 대 한 정보를 볼 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 최대 10 초 동안 2 초 간격 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다. 이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Release all resources used by this process.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</summary>
        <value>종료 명령 또는 <see cref="M:System.Diagnostics.Process.Kill" /> 호출을 통해 연결된 프로세스가 종료될 때 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트가 발생해야 한다면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다. <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트는 경우에 값 <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> 은 <see langword="false" /> 하는 동안 프로세스가 종료 될 때 또는 사용자가을 수행 하기 전에 <see cref="P:System.Diagnostics.Process.HasExited" /> 확인 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성에 운영 체제 프로세스를 종료 하는 경우 구성 요소가 알림을 받을지 여부를 제안 합니다. <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성은 프로세스의 종료 하는 응용 프로그램에 알리기 위해 비동기 처리에 사용 합니다. 동기식으로 대기 (종료 이벤트가 발생할 때까지 응용 프로그램의 프로세스를 중단)이 표시 되는 종료 이벤트에 대 한 응용 프로그램을 강제로 사용 합니다.는 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드.

> [!NOTE]
> Visual Studio를 사용 중이 고 두 번 클릭 하는 경우는 <xref:System.Diagnostics.Process> 프로젝트의 구성 요소는 <xref:System.Diagnostics.Process.Exited> 이벤트 대리자와 이벤트 처리기는 자동으로 생성 합니다. 추가 코드 집합은 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성을 `false`합니다. 이 속성을 변경 해야 `true` 때 실행할 이벤트 처리기가 연결된 된 프로세스가 종료 됩니다.

하는 경우 구성 요소의 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 값은 `true`, 되거나 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 은 `false` 및 <xref:System.Diagnostics.Process.HasExited%2A> 검사 구성 요소에 의해 호출 되 면 구성 요소 상태로 남아 있는 연결된 된 프로세스에 대 한 관리 정보에 액세스할 수 운영 체제에 의해 저장 합니다. 이러한 정보에 포함 됩니다는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.ExitCode%2A>합니다.

연결된 된 프로세스가 종료 된 후, <xref:System.Diagnostics.Process.Handle%2A> 의 구성 요소는 기존 프로세스 리소스에 더 이상 가리키지 합니다. 대신,만 사용할 수 있습니다 프로세스 리소스에 대 한 운영 체제의 정보에 액세스할 수 있습니다. 운영 체제는 의해 해제 하지 않은 종료 된 프로세스에 대 한 핸들 사항이 <xref:System.Diagnostics.Process> 유지할 수 있도록 구성 요소는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 메모리에 있는 정보입니다.

프로세스 종료를 감시 하는 비용이 듭니다. 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 은 `true`, <xref:System.Diagnostics.Process.Exited> 이벤트는 연결된 된 프로세스가 종료 될 때 발생 합니다. 에 대 한 프로시저는 <xref:System.Diagnostics.Process.Exited> 당시에 실행 하는 이벤트입니다.

경우에 따라 응용 프로그램 프로세스를 시작 하지만 종료 되는 대 한 알림이 필요 하지 않습니다. 예를 들어 응용 프로그램 사용자가 텍스트 편집을 수행 하지만 더 이상 하 게 메모장 응용 프로그램의 사용을 허용 하려면 메모장을 시작할 수 있습니다. 관련 응용 프로그램의 지속적인된 작동에 없기 때문에 프로세스가 종료 될 때 알림을 방지 하기 위해 선택할 수 있습니다. 설정 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 를 `false` 시스템 리소스를 저장할 수 있습니다.

## Examples  
다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 생성 합니다. 설정의 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성을 발생 시키는 프로세스는 <xref:System.Diagnostics.Process.Exited> 종료 될 때 이벤트입니다. <xref:System.Diagnostics.Process.Exited> 이벤트 처리기 프로세스 정보를 표시 합니다.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 운영 체제 프로세스를 특수 모드에서 실행 됩니다. 속성을 읽거나 이러한 프로세스에 연결할 수 없으면 호출 하지 않는 한 <xref:System.Diagnostics.Process.EnterDebugMode%2A> 구성 요소에 있습니다. 호출 <xref:System.Diagnostics.Process.LeaveDebugMode%2A> 특수 모드에서 실행 되는 이러한 프로세스에 대 한 액세스를 더 이상 필요 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트가 리디렉션된 연결된 된 프로세스에 기록 나타냅니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 이벤트는 런타임에만 발생 비동기 읽기 작업 중에 <xref:System.Diagnostics.Process.StandardError%2A>합니다. 비동기 읽기 작업을 시작 하려면 리디렉션해야는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림을 <xref:System.Diagnostics.Process>, 이벤트 처리기에 추가 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트 및 호출 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>합니다. 그런 다음는 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트 신호 프로세스 리디렉션된 쓸 때마다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림, 프로세스 종료 또는 호출 될 때까지 <xref:System.Diagnostics.Process.CancelErrorRead%2A>합니다.  
  
> [!NOTE]
>  비동기 출력을 처리 하는 응용 프로그램은 <xref:System.Diagnostics.Process.WaitForExit> 메서드를 출력 버퍼 플러시 되었습니다. 사용 하 여를 지정 시간 초과 <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> 오버 로드는 *하지* 출력 버퍼 플러시 되었습니다.
  
   
  
## Examples  
 다음 예제에서는 `net view` 명령을 원격 컴퓨터에서 사용 가능한 네트워크 리소스를 나열 합니다. 사용자가 대상 컴퓨터 이름 명령줄 인수로 제공 합니다. 사용자 오류 출력에 대 한 파일 이름을 제공할 수도 있습니다. 이 예제에서는 net 명령, 프로세스가 끝날 때까지 및 다음 쓰기 출력 결과 콘솔에 대 한 대기 작업의 출력을 수집 합니다. 필요에 따라 오류 파일의 사용자가 제공 하는 경우이 예제에서는 파일에 오류를 씁니다.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value that the associated process specified when it terminated.</summary>
        <value>연결된 프로세스가 종료될 때 연결된 프로세스에서 지정한 코드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.Process.ExitCode%2A> 시스템 프로세스 종료 될 때 반환 되는 상태를 가져올 수 있습니다. 정수 값을 반환할 처럼 종료 코드를 훨씬 사용할 수 있습니다는 `main()` 프로시저입니다.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> 해당 프로세스에 대 한 응용 프로그램 개발자가 구현한 특정 규칙을 반영 하는 프로세스에 대 한 값입니다. 결정을 내릴 코드에서 종료 코드 값을 사용 하는 경우 응용 프로그램 프로세스에서 사용 하는 종료 코드 규칙을 확인 해야 합니다.  
  
 개발자는 일반적으로 하 여 성공적인 종료를 나타내고는 <xref:System.Diagnostics.Process.ExitCode%2A> 0이 고 지정 된 오류 값을 호출 하는 메서드에서 프로세스가 비정상적 종료의 원인을 확인 하는 데 사용할 수 있는 0이 아닌 값으로. 다음이 지침을 따르는 필요는 없지만 규칙입니다.  
  
 얻으려고 시도 하는 경우는 <xref:System.Diagnostics.Process.ExitCode%2A> 프로세스가 종료 되기 전에 예외가 throw 됩니다. 검사는 <xref:System.Diagnostics.Process.HasExited%2A> 먼저 연결된 된 프로세스가 종료 여부를 확인 합니다.  
  
> [!NOTE]
>  비동기 이벤트 처리기로 표준 출력이 리디렉션된, 경우에 출력 프로세스가 완료 되지 않을 때 가능한 <xref:System.Diagnostics.Process.HasExited%2A> 반환 `true`합니다. 비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출는 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드를 확인 하기 전에 매개 변수를 취하지 <xref:System.Diagnostics.Process.HasExited%2A>합니다.  
  
 사용할 수는 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A> 메서드를 연결 된 프로세스를 종료 합니다.  
  
 두 가지 방법으로 연결된 된 프로세스가 종료 될 때 알려진 시점: 동기적 및 비동기적으로 합니다. 동기식 알림에서는 호출에는 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드를 연결 된 구성 요소가 종료 될 때까지 응용 프로그램의 처리를 일시 중지 합니다. 비동기식 알림은 <xref:System.Diagnostics.Process.Exited> 이벤트입니다. 비동기 알림을 사용 하는 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 으로 설정 되어 있어야 `true` 에 대 한는 <xref:System.Diagnostics.Process> 프로세스 종료 되었다는 알림을 받을 구성 요소입니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not exited.  -or-  The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a process exits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> 이벤트는 연결된 된 프로세스가 종료 되었음을 나타냅니다. 이 항목 것을 의미 하는 프로세스 종료 (중단) 되었거나 닫힌 합니다. 이 이벤트는 경우에 발생할 수의 값은 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성은 `true`합니다.  
  
 두 가지 방법으로 연결된 된 프로세스가 종료 될 때 알려진 시점: 동기적 및 비동기적으로 합니다. 동기 알림 호출을 의미는 <xref:System.Diagnostics.Process.WaitForExit%2A> 프로세스가 종료 될 때까지 현재 스레드를 차단 하는 메서드. 비동기 알림이 사용 하 여 <xref:System.Diagnostics.Process.Exited> 그 동안에 실행을 계속 호출 스레드를 허용 하는 이벤트입니다. 후자의 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 으로 설정 되어 있어야 `true` Exited 이벤트를 받기 위해 호출 응용 프로그램에 대 한 합니다.  
  
 운영 체제 프로세스를 종료할 때 Exited 이벤트에 대 한 처리기를 등록 한 다른 모든 프로세스를 알립니다. 이때 방금 전에 종료 하는 프로세스의 핸들 데 사용할 수와 같은 일부 속성을 액세스 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.HasExited%2A> 이 핸들을 완전히 해제 될 때까지 운영 체제에서 유지 관리 하는지 합니다.  
  
> [!NOTE]
>  호출할 수 없습니다 종료 된 프로세스에 대 한 핸들, 있는 경우에 <xref:System.Diagnostics.Process.Start%2A> 다시 동일한 프로세스에 연결 하려면. 호출 <xref:System.Diagnostics.Process.Start%2A> 자동으로 연결된 된 프로세스를 해제 하 고 동일한 파일 이지만 완전히 새로운 프로세스에 연결 <xref:System.Diagnostics.Process.Handle%2A>합니다.  
  
 사용에 대 한 자세한 내용은 <xref:System.Diagnostics.Process.Exited> Windows Forms 응용 프로그램에서 이벤트 참조는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 생성 합니다. 발생 시킵니다는 <xref:System.Diagnostics.Process.Exited> 때문에 프로세스가 종료 될 때 이벤트는 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 프로세스를 만들 때 속성이 설정 되었습니다. <xref:System.Diagnostics.Process.Exited> 이벤트 처리기 프로세스 정보를 표시 합니다.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process exited.</summary>
        <value>연결된 프로세스가 종료된 시간을 나타내는 <see cref="T:System.DateTime" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색을 시도 하는 프로세스가 종료 되지 않은 경우는 <xref:System.Diagnostics.Process.ExitTime%2A> 속성 예외를 throw 합니다. 사용 하 여 <xref:System.Diagnostics.Process.HasExited%2A> 을 가져오기 전에 <xref:System.Diagnostics.Process.ExitTime%2A> 속성을 연결된 된 프로세스가 종료 여부를 확인 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 생성 합니다. 프로세스가 발생 시키는 <xref:System.Diagnostics.Process.Exited> 종료 될 때 이벤트 및 이벤트 처리기 표시는 <xref:System.Diagnostics.Process.ExitTime%2A> 속성 오류 코드 및 기타 정보를 처리 합니다.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 인스턴스 및 로컬 컴퓨터에서 프로세스 리소스와 연결 합니다.  
  
 마찬가지로 <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, 및 <xref:System.Diagnostics.Process.GetProcesses%2A> 메서드 <xref:System.Diagnostics.Process.GetCurrentProcess%2A> 기존 리소스를 새 연결 <xref:System.Diagnostics.Process> 구성 요소입니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 구성 요소는 로컬 컴퓨터에 프로세스 리소스와 연결 합니다. 프로세스 리소스 때문에 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 시스템 리소스를 만들지 않고 응용 프로그램에서 생성 된는 리소스를 연결 하지만 <xref:System.Diagnostics.Process> 구성 요소입니다. 프로세스 <xref:System.Diagnostics.Process.Id%2A> 컴퓨터에서 현재 실행 중인 프로세스에만 검색할 수 있습니다. 프로세스가 종료 된 후 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 만료 된 식별자를 전달 하는 경우 예외를 throw 합니다.  
  
 프로세스의 식별자는 모든 컴퓨터에서 고유 합니다. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 최대 하나의 프로세스를 반환합니다. 사용 하 여 특정 응용 프로그램을 실행 중인 모든 프로세스를 가져올 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>합니다. 여러 프로세스는 지정된 된 응용 프로그램을 실행 하는 컴퓨터에 있는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다. 이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다. 프로세스 식별자를 볼 수 있습니다는 `Processes` Windows 작업 관리자의 패널입니다. `PID` 프로세스에 할당 된 프로세스 식별자 열에 표시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 구성 요소는 네트워크에서 원격 컴퓨터에서 프로세스 리소스와 연결 합니다. 프로세스 리소스 때문에 지정된 된 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 시스템 리소스를 만들지 않고 응용 프로그램에서 생성 된는 리소스를 연결 하지만 <xref:System.Diagnostics.Process> 구성 요소입니다. 프로세스 <xref:System.Diagnostics.Process.Id%2A> 컴퓨터에서 현재 실행 중인 프로세스에만 검색할 수 있습니다. 프로세스가 종료 된 후 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 만료 된 식별자를 전달 하는 경우 예외를 throw 합니다.  
  
 프로세스의 식별자는 모든 컴퓨터에서 고유 합니다. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 최대 하나의 프로세스를 반환합니다. 사용 하 여 특정 응용 프로그램을 실행 중인 모든 프로세스를 가져올 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>합니다. 여러 프로세스는 지정된 된 응용 프로그램을 실행 하는 컴퓨터에 있는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다. 이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다. 프로세스 식별자를 볼 수 있습니다는 `Processes` Windows 작업 관리자의 패널입니다. `PID` 프로세스에 할당 된 프로세스 식별자 열에 표시 됩니다.  
  
 지정 하지 않는 경우는 `machineName`, 로컬 컴퓨터가 사용 됩니다. 또는 설정 하 여 로컬 컴퓨터를 지정할 수 있습니다 `machineName` 값에 "." 또는 빈 문자열 ("").  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.  -or-  The <paramref name="machineName" /> parameter syntax is invalid. The name might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소는 로컬 컴퓨터에 있는 모든 프로세스 리소스와 연결 합니다. 프로세스 리소스 때문에 로컬 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcesses%2A> 아니라 응용 프로그램에서 생성 된 리소스에 연결 하지만 시스템 리소스를 만들지 않습니다 <xref:System.Diagnostics.Process> 구성 요소입니다. 백그라운드 프로세스를 실행 하는 운영 체제 자체에서는 때문에이 배열은 비어 있지 않습니다.  
  
 모든 컴퓨터에서 실행 중인 프로세스를 검색 하지 않을 경우 사용 하 여의 수를 제한할 수 있습니다는 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드. <xref:System.Diagnostics.Process.GetProcessById%2A> 만듭니다는 <xref:System.Diagnostics.Process> 메서드에 전달 하는 프로세스 식별자에 의해 시스템에 식별 되는 프로세스와 연결 된 구성 요소입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 이루어진 배열을 만들어 <xref:System.Diagnostics.Process> 메서드에 전달할 연결된 된 프로세스 자원이 실행 파일을 공유 하는 구성 요소입니다.  
  
> [!NOTE]
>  서비스 호스트 프로세스 (svchost.exe)의 동일한 인스턴스 내에서 여러 Windows 서비스를 로드할 수 있습니다. GetProcesses 개별 서비스를 식별 하지 않습니다. 이 위해 참조 <xref:System.ServiceProcess.ServiceController.GetServices%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer from which to read the list of processes.</param>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소 (일반적으로 원격) 지정한 컴퓨터에 있는 모든 프로세스 리소스와 연결 합니다. 프로세스 리소스 때문에 로컬 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcesses%2A> 아니라 응용 프로그램에서 생성 된 리소스에 연결 하지만 시스템 리소스를 만들지 않습니다 <xref:System.Diagnostics.Process> 구성 요소입니다. 백그라운드 프로세스를 실행 하는 운영 체제 자체에서는 때문에이 배열은 비어 있지 않습니다.  
  
 모든 컴퓨터에서 실행 중인 프로세스를 검색 하지 않을 경우 사용 하 여의 수를 제한할 수 있습니다는 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드. <xref:System.Diagnostics.Process.GetProcessById%2A> 만듭니다는 <xref:System.Diagnostics.Process> 메서드에 전달 하는 프로세스 식별자에 의해 시스템에 식별 되는 프로세스와 연결 된 구성 요소입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 이루어진 배열을 만들어 <xref:System.Diagnostics.Process> 메서드에 전달할 연결된 된 프로세스 자원이 실행 파일을 공유 하는 구성 요소입니다.  
  
 이 오버 로드는 <xref:System.Diagnostics.Process.GetProcesses%2A> 메서드는 네트워크의 원격 컴퓨터에서 실행 중인 프로세스 리소스의 목록을 검색 하려면 일반적으로 사용 되지만 전달 하 여 로컬 컴퓨터를 지정할 수 있습니다 "."입니다.  
  
> [!NOTE]
>  서비스 호스트 프로세스 (svchost.exe)의 동일한 인스턴스 내에서 여러 Windows 서비스를 로드할 수 있습니다. GetProcesses 개별 서비스를 식별 하지 않습니다. 이 위해 참조 <xref:System.ServiceProcess.ServiceController.GetServices%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소는 로컬 컴퓨터에서 동일한 실행 파일을 실행 하는 모든 프로세스 리소스와 연결 합니다. 프로세스 리소스 때문에 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 시스템 리소스를 만들지 않습니다 되지만 아니라 응용 프로그램에서 생성 된 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. A `processName` 메서드가 반환한 배열이 비워 둘 수 있으므로 로컬 컴퓨터에서 현재 실행 하지 않는 실행 파일에 지정할 수 있습니다.  
  
 프로세스 이름은 예: Outlook에서 확장명이.exe 또는 경로 포함 하지 않는 프로세스에 대 한는 친숙 한 이름이입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 가져오고 동일한 실행 파일에 연관 된 모든 프로세스를 조작 하는 데 도움이 됩니다. 예를 들어 실행 파일 이름으로 전달할 수 있습니다는 `processName` 해당 실행 파일의 모든 실행 중인 인스턴스를 종료 하기 위해 매개 변수입니다.  
  
 하지만 프로세스 <xref:System.Diagnostics.Process.Id%2A> 은 시스템에 단일 프로세스 리소스를 고유 로컬 컴퓨터에서 여러 프로세스가 실행 될 수 있습니다 하 여 지정 된 응용 프로그램은 `processName` 매개 변수입니다. 따라서 <xref:System.Diagnostics.Process.GetProcessById%2A> 많아야 한 프로세스를 반환 하지만 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다. 표준 API 호출을 사용 하는 프로세스를 조작 해야 하는 경우 이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다. 프로세스 이름만 통해 표시 되지만의 배열을 검색 했으면 프로세스 리소스에 액세스할 수 <xref:System.Diagnostics.Process> 연관 된 구성 요소 프로세스 리소스 있습니다 수 시작, 종료 및 시스템 리소스를 조작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새로의 배열을 만드는 <xref:System.Diagnostics.Process> 구성 요소와 지정된 된 컴퓨터에서 동일한 실행 파일을 실행 하는 모든 프로세스 리소스를 연결 합니다. 프로세스 리소스 때문에 컴퓨터에 이미 있어야 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 시스템 리소스를 만들지 않습니다 되지만 아니라 응용 프로그램에서 생성 된 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. A `processName` 메서드가 반환한 배열이 비워 둘 수 있으므로 로컬 컴퓨터에서 현재 실행 하지 않는 실행 파일에 지정할 수 있습니다.  
  
 프로세스 이름은 예: Outlook에서 확장명이.exe 또는 경로 포함 하지 않는 프로세스에 대 한는 친숙 한 이름이입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 가져오고 동일한 실행 파일에 연관 된 모든 프로세스를 조작 하는 데 도움이 됩니다. 예를 들어 실행 파일 이름으로 전달할 수 있습니다는 `processName` 해당 실행 파일의 모든 실행 중인 인스턴스를 종료 하기 위해 매개 변수입니다.  
  
 하지만 프로세스 <xref:System.Diagnostics.Process.Id%2A> 은 시스템에 단일 프로세스 리소스를 고유 로컬 컴퓨터에서 여러 프로세스가 실행 될 수 있습니다 하 여 지정 된 응용 프로그램은 `processName` 매개 변수입니다. 따라서 <xref:System.Diagnostics.Process.GetProcessById%2A> 많아야 한 프로세스를 반환 하지만 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 은 연결 된 모든 프로세스가 포함 된 배열을 반환 합니다. 표준 API 호출을 사용 하는 프로세스를 조작 해야 하는 경우 이러한 각 프로세스 식별자에 대 한 다시 쿼리할 수 있습니다. 프로세스 이름만 통해 표시 되지만의 배열을 검색 했으면 프로세스 리소스에 액세스할 수 <xref:System.Diagnostics.Process> 연관 된 구성 요소 프로세스 리소스 있습니다 수 시작, 종료 및 시스템 리소스를 조작 합니다.  
  
 프로세스를 가져올 원격 컴퓨터 모두 로컬 컴퓨터에이 오버 로드를 사용할 수 있습니다. 사용 하 여 "." 로컬 컴퓨터를 지정 합니다. 다른 오버 로드를 존재 하는 기본적으로 로컬 컴퓨터를 사용 합니다.  
  
 프로세스 통계와 같은 프로세스에 대 한 정보를 보려면에 원격 컴퓨터에서 액세스할 수 있습니다. 닫기, 종료할 수 없습니다 (사용 하 여 <xref:System.Diagnostics.Process.Kill%2A>), 또는 원격 컴퓨터에서 프로세스를 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터와 로컬 컴퓨터에서 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스는 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle of the associated process.</summary>
        <value>연결된 프로세스가 시작될 때 운영 체제에서 해당 프로세스에 할당한 핸들입니다. 시스템에서는 이 핸들을 사용하여 프로세스 특성을 추적합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 여러 프로세스 정보 및 제어 기능에 대 한 매개 변수로 사용할 수 있는 프로세스에 대 한 핸들을 가져올 수 있습니다. 이 핸들을 사용 하 여 초기화는 <xref:System.Threading.WaitHandle> 하거나 플랫폼 네이티브 메서드를 호출를 호출 합니다.  
  
 이 프로세스 핸들은 개인 응용 프로그램에 즉, 프로세스를 공유할 수 없습니다. 프로세스는 또한 프로세스에 <xref:System.Diagnostics.Process.Id%2A> 는 달리는 <xref:System.Diagnostics.Process.Handle%2A>, 고유한 그리고이 시스템 전체에서 유효 합니다.  
  
 호출을 통해 시작 되는 프로세스만 <xref:System.Diagnostics.Process.Start%2A> 설정는 <xref:System.Diagnostics.Process.Handle%2A> 해당 속성 <xref:System.Diagnostics.Process> 인스턴스.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not been started or has exited. The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of handles opened by the process.</summary>
        <value>프로세스에서 연 운영 체제 핸들의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은 프로세스 개체를 참조할 수 있는 방법을 제공 합니다. 프로세스는 파일, 리소스, 메시지 큐, 및 기타 여러 운영 체제 개체에 대 한 핸들을 가져올 수 있습니다. 운영 체제 프로세스에 연결 된 핸들 수 0 일 경우에 메모리를 회수 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the associated process has been terminated.</summary>
        <value>
          <see cref="T:System.Diagnostics.Process" /> 구성 요소가 참조하는 운영 체제 프로세스가 종료되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값이 `true` 에 대 한 <xref:System.Diagnostics.Process.HasExited%2A> 연결된 된 프로세스가 종료 되었음을 나타냅니다, 정상 또는 비정상으로 합니다. 요청 하거나 강제로 연결된 된 프로세스를 호출 하 여 종료 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스에 열려 있는 핸들이 없으면 프로세스는 종료 되었으므로 하지만 핸들, 종료 코드 및 종료 시간과 같은 프로세스에 대 한 관리 정보는 유지 하는 경우 운영 체제 프로세스 메모리를 해제 합니다. 이 정보를 얻으려면 사용할 수 있습니다는 <xref:System.Diagnostics.Process.ExitCode%2A> 및 <xref:System.Diagnostics.Process.ExitTime%2A> 속성입니다. 이러한 속성은이 구성 요소에 의해 시작 된 프로세스에 대 한 자동으로 채워집니다. 관리 정보를 놓을 때 모든는 <xref:System.Diagnostics.Process> 시스템 프로세스와 관련 된 구성 요소 소멸 되 고 종료 된 프로세스에 핸들이 더 이상 없을 합니다.  
  
 코드와는 별개로 프로세스를 종료할 수 있습니다. 이 구성 요소를 사용 하 여 프로세스를 시작한 경우 시스템의 값을 업데이트 <xref:System.Diagnostics.Process.HasExited%2A> 자동으로 연결된 된 프로세스가 종료 되지 독립적으로 하는 경우에 합니다.  
  
> [!NOTE]
>  비동기 이벤트 처리기로 표준 출력이 리디렉션된 때 마일스 톤을 출력 프로세스가 완료 되지 않을 때이 속성은 반환 `true`합니다. 비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출는 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드를 확인 하기 전에 매개 변수를 취하지 <xref:System.Diagnostics.Process.HasExited%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 최대 10 초 동안 2 초 간격 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다. 이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with the object.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The exit code for the process could not be retrieved.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier for the associated process.</summary>
        <value>이 <see cref="T:System.Diagnostics.Process" /> 인스턴스에서 참조하는 프로세스의 고유 식별자입니다. 이 식별자는 시스템에서 생성됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 <xref:System.Diagnostics.Process.Id%2A> 연결된 된 프로세스가 실행 되지 않는 경우에 올바르지 않습니다. 검색 하기 전에 프로세스가 실행 되 고 있는지 확인 해야 따라서는 <xref:System.Diagnostics.Process.Id%2A> 속성입니다. 프로세스가 종료 될 때까지 프로세스 식별자가 시스템에서 프로세스를 고유 하 게 식별 합니다.  
  
 새 로컬 또는 원격 컴퓨터에서 실행 중인 프로세스에 연결할 수 있습니다 <xref:System.Diagnostics.Process> 프로세스 식별자를 전달 하 여 인스턴스는 <xref:System.Diagnostics.Process.GetProcessById%2A> 메서드. <xref:System.Diagnostics.Process.GetProcessById%2A> `static` 새 구성 요소를 만드는 메서드를 설정 하 고는 <xref:System.Diagnostics.Process.Id%2A> 새 속성 <xref:System.Diagnostics.Process> 자동으로 인스턴스.  
  
 시스템 프로세스 식별자를 다시 사용할 수 있습니다. <xref:System.Diagnostics.Process.Id%2A> 연결된 프로세스가 실행 중인 동안에 속성 값이 고유 합니다. 시스템 프로세스 작업이 종료 된 후 다시 사용할 수는 <xref:System.Diagnostics.Process.Id%2A> 관련 되지 않은 프로세스에 대 한 속성 값입니다.  
  
 시스템에서 고유 식별자 이므로 전달할 수 있습니다 다른 스레드에 전달 하는 대신 한 <xref:System.Diagnostics.Process> 인스턴스. 이 작업 시스템 리소스를 절약 하면서 프로세스가 올바르게 확인 되더라도 보장할 수 있습니다.  
  
   
  
## Examples  
 다음 예제를 가져오는 방법을 <xref:System.Diagnostics.Process.Id%2A> 모든 응용 프로그램의 인스턴스를 실행 합니다. 코드 메모장의 새 인스턴스를 만들고 메모장의 모든 인스턴스를 나열 하 고 사용자를 입력할 수 있도록 합니다는 <xref:System.Diagnostics.Process.Id%2A> 특정 인스턴스를 제거할 수 있습니다.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Immediately stops the associated process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> 프로세스의 종료를 강제로 수행 하는 동안 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 만 종료를 요청 합니다. 그래픽 인터페이스를 사용 하 여 프로세스를 실행할 때 해당 메시지 루프는 대기 상태에 있습니다. 운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다 메시지 루프를 실행 합니다. 호출 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 는 잘 구성 된 응용 프로그램에서 자식 창을 닫고 응용 프로그램에 대 한 실행 중인 모든 메시지 루프를 취소 주 창에 근접 하는 요청을 보냅니다. 요청을 호출 하 여 프로세스를 종료 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 응용 프로그램 종료을 강제로 적용 하지 않습니다. 응용 프로그램을 종료 하기 전에 사용자 확인을 위해 묻거나 종료를 거부할 수 있습니다. 응용 프로그램을 종료 하려면을 사용 하 여는 <xref:System.Diagnostics.Process.Kill%2A> 메서드. 동작은 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 시스템 메뉴를 사용 하 여 응용 프로그램의 주 창을 닫을 수 있는 사용자와 동일 합니다. 따라서 주 창을 닫아 프로세스를 종료를 요청 응용 프로그램이 즉시 종료 강제로 적용 하지 않습니다.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A> 메서드가 비동기적으로 실행 합니다. 호출한 후의 <xref:System.Diagnostics.Process.Kill%2A> 메서드를 호출은 <xref:System.Diagnostics.Process.WaitForExit%2A> 검사를 종료 하려면 프로세스를 대기 하는 메서드는 <xref:System.Diagnostics.Process.HasExited%2A> 속성을 확인 하는 경우 프로세스가 종료 되었습니다.  
  
 프로세스에 의해 편집 하는 데이터 또는 프로세스에 할당 된 리소스 손실 될 수 있습니다를 호출 하면 <xref:System.Diagnostics.Process.Kill%2A>합니다. <xref:System.Diagnostics.Process.Kill%2A> 비정상적인 프로세스 종료를 사용 하면 필요한 경우에 사용 해야 합니다. <xref:System.Diagnostics.Process.CloseMainWindow%2A> 프로세스의 순차적 종료가 가능 하 고 인터페이스와 함께 응용 프로그램에 대 한 것 이므로 모든 창을 닫습니다. 경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 실패 하면 צ ְ ײ <xref:System.Diagnostics.Process.Kill%2A> 으 프로세스를 종료 합니다. <xref:System.Diagnostics.Process.Kill%2A> 그래픽 인터페이스를 갖지 않는 프로세스를 종료 하는 유일한 방법이입니다.  
  
 호출할 수 있습니다 <xref:System.Diagnostics.Process.Kill%2A> 및 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 로컬 컴퓨터에서 실행 중인 프로세스에 대해서만 합니다. 종료 하려면 원격 컴퓨터에서 프로세스 할 수 없습니다. 만 원격 컴퓨터에서 실행 중인 프로세스에 대 한 정보를 볼 수 있습니다.  
  
> [!NOTE]
>  경우에 대 한 호출은 <xref:System.Diagnostics.Process.Kill%2A> 메서드는 프로세스를 종료 하는 동안 구성 됩니다는 <xref:System.ComponentModel.Win32Exception> 액세스가 거부에 대해 발생 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The associated process could not be terminated.  -or-  The process is terminating.  -or-  The associated process is a Win16 executable.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer. The method is available only for processes running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 운영 체제 프로세스를 특수 모드에서 실행 됩니다. 속성을 읽거나 이러한 프로세스에 연결할 수 없으면 호출 하지 않는 한 <xref:System.Diagnostics.Process.EnterDebugMode%2A> 구성 요소에 있습니다. 호출 <xref:System.Diagnostics.Process.LeaveDebugMode%2A> 특수 모드에서 실행 되는 이러한 프로세스에 대 한 액세스를 더 이상 필요 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the computer the associated process is running on.</summary>
        <value>연결된 프로세스가 실행 중인 컴퓨터 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출할 수 없습니다. 하지만 원격 컴퓨터에서 실행 중인 프로세스에 대 한 프로세스 정보 및 통계 데이터를 볼 수 있습니다 <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, 또는 <xref:System.Diagnostics.Process.Kill%2A> 원격 컴퓨터에 있습니다.  
  
> [!NOTE]
>  연결된 된 프로세스를 로컬 컴퓨터에서 실행할 때이 속성은 마침표 반환 (".") 컴퓨터 이름입니다. 사용 해야는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 올바른 컴퓨터 이름을 가져올 속성입니다.  
  
   
  
## Examples  
 사용 먼저 다음 예제에서는 원격 컴퓨터에서 메모장의 인스턴스를 하나 이상 시작 합니다. 이 예제에서는 요청 메모장 실행 되 고 해당을 표시 하는 원격 컴퓨터의 이름을 <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, 및 <xref:System.Diagnostics.Process.MachineName%2A> 각 인스턴스에 대 한 속성입니다.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the main module for the associated process.</summary>
        <value>프로세스를 시작하는 데 사용된 <see cref="T:System.Diagnostics.ProcessModule" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 모듈 특정 프로세스에 로드 되는.dll 또는.exe 파일을 나타냅니다. <xref:System.Diagnostics.Process.MainModule%2A> 속성을 사용 하면 모듈 이름, 파일 이름 및 모듈 메모리 정보를 포함 하 여 프로세스를 시작 하는 데 사용 되는 실행 파일에 대 한 정보를 볼 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A 32-bit process is trying to access the modules of a 64-bit process.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the window handle of the main window of the associated process.</summary>
        <value>연결된 프로세스의 주 창에 대한 창 핸들입니다. 이 창 핸들은 시스템에서 생성됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 주 현재 포커스가 있는 프로세스에서 연 창입니다 (의 <xref:System.Windows.Forms.Form.TopLevel%2A> 양식). 사용 해야 합니다는 <xref:System.Diagnostics.Process.Refresh%2A> 를 새로 고치려면 메서드는 <xref:System.Diagnostics.Process> 변경 된 경우 현재 주 창 핸들을 가져올 개체입니다. 창 핸들은 캐시 되므로 일반적으로 사용 <xref:System.Diagnostics.Process.Refresh%2A> 현재 핸들 검색을 보장 하기 위해 사전에 미리 합니다.  
  
 가져올 수는 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 로컬 컴퓨터에서 실행 되는 프로세스에 대해서만 속성입니다. <xref:System.Diagnostics.Process.MainWindowHandle%2A> 속성은 고유 하 게 식별 하는 프로세스와 연결 된 창은 값입니다.  
  
 프로세스에 연결 된 프로세스에 그래픽 인터페이스 하는 경우에 주 창. 연결된 된 프로세스에는 주 창, 없는 경우는 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 값은 0입니다. 값 0이 숨겨져 있는 프로세스에 대 한 즉, 작업 표시줄에 표시 되지 않는 처리 이기도 합니다. 이 작업 표시줄의 맨 오른쪽 알림 영역에서 아이콘으로 표시 되는 프로세스에 대 한 사례 수 있습니다.  
  
 사용 하 여 방금 시작한 프로세스의 주 창 핸들을 사용할 경우 고려해는 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 메서드 시작이 완료 하는 프로세스의 주 창 핸들이 만들어졌는지 확인 합니다. 그렇지 않으면 예외가 throw됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the caption of the main window of the process.</summary>
        <value>프로세스의 주 창 제목입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스에 연결 된 프로세스에 그래픽 인터페이스 하는 경우에 주 창. 연결된 된 프로세스에 주 창이 없는 경우 (있도록 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 0), <xref:System.Diagnostics.Process.MainWindowTitle%2A> 은 빈 문자열 (""). 사용 하 여 방금 시작한 프로세스의 주 창 제목에 사용 하려는 하는 경우 고려는 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 메서드 시작이 완료 하는 프로세스의 주 창 핸들이 만들어졌는지 확인 합니다. 그렇지 않으면 시스템에서 예외가 throw됩니다.  
  
> [!NOTE]
>  현재 포커스가 있는; 창인지 주 창 프로세스에 대 한 기본 창 되지 않을 수 있습니다이 note 합니다. 사용 해야 합니다는 <xref:System.Diagnostics.Process.Refresh%2A> 를 새로 고치려면 메서드는 <xref:System.Diagnostics.Process> 변경 된 경우 현재 주 창 핸들을 가져올 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 하 고 프로세스의 주 창의 캡션을 검색 합니다.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowable working set size, in bytes, for the associated process.</summary>
        <value>프로세스에 대해 메모리에서 허용된 작업 집합의 최대 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는.dll 파일, system.dll 파일에서 페이지를 포함 하 여 응용 프로그램을 실행 하는 모든 명령이 들어 있는 페이지가 포함 됩니다. 작업 집합의 증가 하는 크기, 메모리 수요가 증가 합니다.  
  
 프로세스에 최대 및 최소 작업 집합 크기입니다. 프로세스 리소스를 만들 때마다 시스템의 최소 작업 집합 크기는 프로세스를 같은 메모리 용량을 예약 합니다. 가상 메모리 관리자 유지 하려고 이상 최소 메모리 양을 상주 하는 프로세스 활성화 되어 있지만 최대 크기 보다 유지 하지는 않습니다.  
  
 작업 집합 크기 기본을 설정 됩니다. 사용 하 여 이러한 크기를 수정할 수는 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 및 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 멤버입니다. 그러나 이러한 값을 설정할 보장 하지 않습니다 예약 되거나 상주 하는 메모리 한 이루어집니다.  
  
> [!NOTE]
>  프로세스의 작업 집합 크기를 늘리면 수행한 실제 메모리를 시스템의 나머지 가져오게 됩니다. 최소 또는 최대 작업 집합 크기 시스템 성능이 저하 수 때문에 너무 커서를 요청 하지 않으면 확인 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum working set size is invalid. It must be greater than or equal to the minimum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum allowable working set size, in bytes, for the associated process.</summary>
        <value>프로세스에 대해 메모리에서 필요로 하는 작업 집합의 최소 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는.dll 파일, system.dll 파일에서 페이지를 포함 하 여 응용 프로그램을 실행 하는 모든 명령이 들어 있는 페이지가 포함 됩니다. 작업 집합의 증가 하는 크기, 메모리 수요가 증가 합니다.  
  
 프로세스에 최대 및 최소 작업 집합 크기입니다. 프로세스 리소스를 만들 때마다 시스템의 최소 작업 집합 크기는 프로세스를 같은 메모리 용량을 예약 합니다. 가상 메모리 관리자 유지 하려고 이상 최소 메모리 양을 상주 하는 프로세스 활성화 되어 있지만 최대 크기 보다 유지 하지는 않습니다.  
  
 작업 집합 크기 기본을 설정 됩니다. 사용 하 여 이러한 크기를 수정할 수는 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 및 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 멤버입니다. 그러나 이러한 값을 설정할 보장 하지 않습니다 예약 되거나 상주 하는 메모리 한 이루어집니다.  
  
> [!NOTE]
>  프로세스의 작업 집합 크기를 늘리면 수행한 실제 메모리를 시스템의 나머지 가져오게 됩니다. 최소 또는 최대 작업 집합 크기 시스템 성능이 저하 수 때문에 너무 커서를 요청 하지 않으면 확인 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The minimum working set size is invalid. It must be less than or equal to the maximum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the modules that have been loaded by the associated process.</summary>
        <value>연결된 프로세스에 의해 로드된 모듈을 나타내는 <see cref="T:System.Diagnostics.ProcessModule" /> 형식의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 모듈 특정 프로세스에 로드 되는.dll 또는.exe 파일을 나타냅니다. A <xref:System.Diagnostics.ProcessModule> 인스턴스 모듈 이름, 파일 이름 및 모듈 메모리 정보를 포함 하 여 모듈에 대 한 정보를 볼 수 있습니다.  
  
 프로세스는 메모리에 여러 모듈을 로드할 수 있습니다. 예를 들어 추가.dll 파일을 로드 하는.exe 파일에 여러 개의 모듈이 있습니다.  
  
 프로세스를 시작한 후 시스템에서 프로세스를 로드할 때까지이 컬렉션은 비어 있습니다. 프로세스에 주 창이 경우 호출할 수 있습니다 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 목록을 컬렉션에 비어 있지 않은 경우를 위해이 속성을 검색 하기 전에 가져옵니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process. These processes do not have modules.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 없는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 없는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)에서 프로세스에서 사용 된 비페이징된 시스템 메모리의 현재 크기를 나타냅니다. 시스템 메모리는 운영 체제에서 사용 하는 실제 메모리와 페이지 단위 및 비페이징 풀 나뉘어 있습니다. 비페이징된 메모리 할당 시스템 메모리에 유지 되 고 가상 메모리 페이징 파일에 페이지 아웃 되지 않습니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **Pool Nonpaged Bytes** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 발생 시키는 API 메서드는는 <xref:System.Diagnostics.Process.Exited> 이벤트입니다. 호출 <xref:System.Diagnostics.Process.OnExited%2A> 하면는 <xref:System.Diagnostics.Process.Exited> 이벤트를 발생 및 사용 하 여 이벤트를 발생 하는 유일한 방법은 <xref:System.Diagnostics.Process> 구성 요소입니다. <xref:System.Diagnostics.Process.OnExited%2A> 이 구성 요소에서 클래스를 파생할 때 주로 사용 됩니다.  
  
 대신 <xref:System.Diagnostics.Process.OnExited%2A>, 이벤트 처리기를 작성할 수 있습니다. 사용자 고유의 이벤트 처리기 대리자 및 사용자 고유의 이벤트 처리 메서드를 만듭니다.  
  
> [!NOTE]
>  Visual Studio 환경을 사용 하는 경우 이벤트 처리기 대리자 (AddOnExited) 및 이벤트 처리 메서드 (Process1_Exited) 만들어집니다 끌면는 <xref:System.Diagnostics.Process> 구성 요소를 폼의 아이콘을 두 번 클릭 합니다. 만들 때 실행할 코드는 <xref:System.Diagnostics.Process.Exited> Process1_Exited 프로시저에 입력 된 이벤트가 발생 합니다. 만들 필요가 없습니다는 <xref:System.Diagnostics.Process.OnExited%2A> 멤버, 사용자에 대 한 구현 되기 때문에 있습니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Diagnostics.Process.OnExited%2A> 파생된 클래스에서 메서드.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트는 연결 된 <xref:System.Diagnostics.Process> 리디렉션된 줄 바꿈 문자로 종료 줄 입력 된 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
 이벤트를 사용할지 비동기 읽기 작업 동안 <xref:System.Diagnostics.Process.StandardOutput%2A>합니다. 비동기 읽기 작업을 시작 하려면 리디렉션해야는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 <xref:System.Diagnostics.Process>, 이벤트 처리기에 추가 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트 및 호출 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>합니다. 그런 다음는 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트 신호 프로세스 리디렉션된 쓸 때마다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림, 프로세스 종료 또는 호출 될 때까지 <xref:System.Diagnostics.Process.CancelOutputRead%2A>합니다.  
  
> [!NOTE]
>  비동기 출력을 처리 하는 응용 프로그램은 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드를 출력 버퍼 플러시 되었습니다.  
  
   
  
## Examples  
 다음 예제에서는 리디렉션된에 대해 비동기 읽기 작업을 수행 하는 방법을 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 `ipconfig` 명령입니다.  
  
 이 예에서는 대 한 이벤트 대리자를 만듭니다는 `OutputHandler` 이벤트 처리기에 연결 된 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트입니다. 이벤트 처리기는 리디렉션된 텍스트 줄을 받아서 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림에 텍스트의 서식을 지정 하 고 나중 예에 나오는 콘솔 창에 표시 되는 출력 문자열에 저장 합니다.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 의해 할당된 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>연결된 프로세스의 가상 메모리 페이징 파일에 할당된 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)는 프로세스에서 사용 하는 가상 메모리 페이징 파일에 있는 메모리의 현재 크기를 나타냅니다. 운영 체제를 사용 하 여 함께에서 가상 메모리 페이징 파일 실제 메모리와 각 프로세스에 대 한 가상 주소 공간을 관리 합니다. 사용 중인 페이징 가능한 메모리 없는 경우 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다. 프로세스에 대 한 운영 체제에서 사용 되는 메모리의 크기를 가져오려면는 <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> 속성입니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **페이지 파일 바이트** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 하 고 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 대해 할당된 시스템 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)에서 프로세스에 의해 사용 되는 페이징할 수 있는 시스템 메모리의 현재 크기를 나타냅니다. 시스템 메모리는 운영 체제에서 사용 하는 실제 메모리와 페이지 단위 및 비페이징 풀 나뉘어 있습니다. 사용 중인 페이징 가능한 메모리 없는 경우 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다. 프로세스에서 사용 되는 응용 프로그램 메모리의 크기를 가져오려면는 <xref:System.Diagnostics.Process.PagedMemorySize64%2A> 속성입니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **Pool Paged Bytes** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 의해 할당된 메모리의 최대 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>연결된 프로세스가 시작된 이후 연결된 프로세스의 가상 메모리 페이징 파일에 할당된 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)에서 시작 된 이후 프로세스에서 사용 되는 가상 메모리 페이징 파일에는 메모리의 최대 크기를 나타냅니다. 운영 체제를 사용 하 여 함께에서 가상 메모리 페이징 파일 실제 메모리와 각 프로세스에 대 한 가상 주소 공간을 관리 합니다. 사용 중인 페이징 가능한 메모리 없는 경우 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **페이지 파일 바이트 피크** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>연결된 프로세스에서 요청한 가상 메모리의 최대 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>연결된 프로세스가 시작된 이후 해당 프로세스에 할당된 가상 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)에서 시작 된 이후 프로세스에서 사용 하는 가상 메모리의 최대 크기를 나타냅니다. 운영 체제 디스크에 있는 가상 메모리 페이징 파일에 저장 된 페이지 또는 실제 메모리에 로드 하는 페이지에 각 프로세스에 대 한 가상 주소 공간을 매핑합니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **가상 바이트 피크** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the peak working set size for the associated process, in bytes.</summary>
        <value>연결된 프로세스에서 한 번에 요청한 실제 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는 프로세스는 실행 프로세스 모듈와 시스템 라이브러리를 포함 하는 모든 명령이 포함 된 페이지가 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of physical memory, in bytes, used by the associated process.</summary>
        <value>연결된 프로세스가 시작된 이후 해당 프로세스에 할당된 실제 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값의 작업 집합 메모리 바이트에서 시작 된 이후 프로세스에서 사용 되는 최대 크기를 나타냅니다. 프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는 프로세스는 실행 프로세스 모듈와 시스템 라이브러리의 지침을 포함 하는 모든 명령이 포함 된 페이지가 포함 됩니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **Working Set Peak** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</summary>
        <value>프로세스가 대기 상태에서 빠져나올 때 프로세스의 우선 순위를 동적으로 높여야 하는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 우선 순위 클래스에 있는 동적 우선 순위 열거형 값 중 하나에서 스레드가 실행 하는 경우 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), 시스템 스레드의 우선 순위를 대기 상태에서 나올 때 일시적으로 상승 시킵니다. 이렇게 하면 다른 프로세스에서 현재 스레드의 처리를 중단 합니다. <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 설정은 모든 기존 스레드 및 프로세스에서 만든 모든 스레드에 적용 합니다. 일반 동작을 복원 하려면 설정는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 속성을 `false`합니다.  
  
> [!NOTE]
>  우선 순위를 너무 승격 중요 한 운영 체제 및 네트워크 기능을 다른 운영 체제 작업에 문제가 발생 리소스를 드레이닝 할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Priority boost information could not be retrieved from the associated process resource.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the overall priority category for the associated process.</summary>
        <value>연결된 프로세스에 대한 우선 순위 범주입니다. 이를 통해 해당 프로세스의 <see cref="P:System.Diagnostics.Process.BasePriority" />를 계산할 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 우선 순위 클래스 스레드 우선 순위 수준의 범위를 포함합니다. 프로세스에서 실행 되는 우선 순위가 서로 다른 스레드는 프로세스의 우선 순위 클래스를 기준으로 실행 됩니다. Win32 클래스당 7 개 기본 우선 순위 수준을 4 개의 우선 순위 클래스를 사용합니다. 이러한 프로세스 우선 순위 클래스에 기록 되는 <xref:System.Diagnostics.ProcessPriorityClass> 프로세스 우선 순위를 설정 하는 수 있는 열거형 <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>합니다. 시간 경과 또는 기타 상승이, 기본 우선 순위 수준을 프로세스 프로세서에 대 한 액세스에 대 한 다른 미리 설정 해야 하는 경우 운영 체제에서 변경할 수 있습니다 기반으로 합니다. 또한 설정할 수 있습니다는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 일시적으로 높일 대기 상태에서 가져온 스레드의 우선 순위 수준에 있습니다. 우선 순위에는 프로세스가 대기 상태를 반환할 때 다시 설정 됩니다.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> 속성을 사용 하면 프로세스에 할당 된 우선 순위를 볼 수 있습니다. 그러나 읽기 전용 이므로 사용할 수 없습니다는 <xref:System.Diagnostics.Process.BasePriority%2A> 속성을 프로세스의 우선 순위를 설정 합니다. 우선 순위를 변경 하려면 사용 하 여는 <xref:System.Diagnostics.Process.PriorityClass%2A> 프로세스에 대 한 전체 우선 순위 범주를 가져오거나 설정 합니다.이 속성입니다.  
  
 시스템 모니터를 사용 하 여 우선 순위 클래스를 볼 수 없습니다. 다음 표에서 간의 관계를 보여 줍니다.는 <xref:System.Diagnostics.Process.BasePriority%2A> 및 <xref:System.Diagnostics.Process.PriorityClass%2A> 값입니다.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Process priority information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me). These platforms do not support those values for the priority class.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>연결된 프로세스에서 할당하여 다른 프로세스에서는 공유할 수 없는 바이트 수입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>연결된 프로세스에 할당되어 다른 프로세스와는 공유할 수 없는 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)를 다른 프로세스와 공유할 수 없는 프로세스에서 사용 되는 메모리의 현재 크기를 나타냅니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **전용 바이트** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the privileged processor time for this process.</summary>
        <value>프로세스가 운영 체제 코어 내부에서 코드를 실행하는 데 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the process.</summary>
        <value>사용자가 프로세스를 식별할 수 있도록 시스템에서 사용하는 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> .exe 확장명 또는 경로 포함 하지 않는 Outlook과 같은 실행 파일 이름, 속성에 저장 합니다. 가져오기 및 동일한 실행 파일에 연관 된 모든 프로세스를 조작 하기 위한 것이 유용 합니다.  
  
> [!NOTE]
>  [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 운영 체제는 <xref:System.Diagnostics.Process.ProcessName%2A> 프로세스 모듈 정보를 가져올 수 없으면 15 자로 속성 잘릴 수 있습니다.  
  
 호출할 수 있습니다 <xref:System.Diagnostics.Process.GetProcessesByName%2A>, 지정된 된 컴퓨터에서 실행 중인 모든 인스턴스를 포함 하는 배열을 검색 하는 실행 파일 이름을 전달 합니다. 실행 파일의 모든 실행 중인 인스턴스를 종료 하려면 예를 들어이 배열에 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">The process is not on this computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the processors on which the threads in this process can be scheduled to run.</summary>
        <value>연결된 프로세스의 스레드가 실행될 수 있는 프로세서를 나타내는 비트 마스크입니다. 기본값은 컴퓨터의 프로세서 수에 따라 다릅니다. 기본값은 2 <sup>n</sup> -1로, 여기서 n은 프로세서의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 이상 버전에서는 프로세스에서 스레드 프로세서 캐시 다시 로드 하는 각 마이그레이션을 사용 하 여 프로세서에서 마이그레이션할 수 있습니다. 시스템 로드가 특정 스레드를 실행 해야 하는 프로세서를 지정 하 수 줄여서 성능을 향상 시킬 수 있는 프로세서 캐시 다시 로드 되는 횟수입니다. 프로세서 및 스레드 간의 연결을 프로세서 선호도 라고 합니다.  
  
 각 프로세서 약간으로 표시 됩니다. 비트 0은 프로세서 1, 1 비트가 프로세서 2, 등입니다. 값 1 약간 설정 하면 해당 하는 프로세서가 스레드 할당에 대해 선택 되어 있습니다. 설정 하는 경우는 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 값을 0으로 운영 체제의 예약 알고리즘 집합 스레드의 선호도입니다. 경우는 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 값이 0이 아닌 값으로 설정, 값은 선택 가능한 프로세서를 지정 하는 비트 마스크로 해석 됩니다.  
  
 다음 표에서 다양 한 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 프로세서가 8 개인 시스템에 대 한 값입니다.  
  
|비트 마스크|이진 값|사용할 수 있는 프로세서|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1과 2|  
|0x0007|00000000 00000111|1, 2 및 3|  
|0x0009|00000000 00001001|1에서 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 및 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Discards any information about the associated process that has been cached inside the process component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 후 <xref:System.Diagnostics.Process.Refresh%2A> 호출 되는 첫 번째 요청 각 속성에 대 한 내용은 하면 연결된 된 프로세스에서 새 값을 가져올 프로세스 구성 요소에 대 한 합니다.  
  
 경우는 <xref:System.Diagnostics.Process> 구성 요소는 연결 된 프로세스 리소스의 속성 값은 <xref:System.Diagnostics.Process> 즉시 연결된 된 프로세스의 상태에 따라 채워집니다. 에 연결된 된 프로세스에 대 한 정보는 이후에 변경 되 면 해당 변경 내용이 반영 되지 않습니다는 <xref:System.Diagnostics.Process> 구성 요소의 값을 캐시 합니다. <xref:System.Diagnostics.Process> 구성 요소는 연결 된 시간에 프로세스 리소스의 스냅숏입니다. 연결된 된 프로세스에 대 한 현재 값을 보려면 호출에서 <xref:System.Diagnostics.Process.Refresh%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 최대 10 초 동안 2 초 간격 연결된 된 프로세스의 실제 메모리 사용률을 검색합니다. 이 예제에서는 10 초가 경과 하기 전에 프로세스를 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the user interface of the process is responding.</summary>
        <value>연결된 프로세스의 사용자 인터페이스가 시스템에 응답하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 사용자 인터페이스가 있는 프로세스는 <xref:System.Diagnostics.Process.Responding%2A> 프로세스 사용자 입력에 응답 하는지 여부를 확인 하는 사용자 인터페이스를 연결 하는 속성입니다. 인터페이스에 즉시 응답 하지 않는 경우는 <xref:System.Diagnostics.Process.Responding%2A> 속성에서 반환 `false`합니다. 연결된 된 프로세스의 인터페이스의 응답이 중지 하는지 여부를 확인 하려면이 속성을 사용 합니다.  
  
 프로세스에 없는 경우는 <xref:System.Diagnostics.Process.MainWindowHandle%2A>,이 속성은 반환 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle to this process.</summary>
        <value>이 프로세스에 대한 기본 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은만 호출 하는 구성 요소는 프로세스를 시작 하는 경우에 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Terminal Services session identifier for the associated process.</summary>
        <value>연결된 프로세스의 터미널 서비스 세션 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> 속성 응용 프로그램이 현재 실행 중인 세션을 식별 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">There is no session associated with this process.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this session identifier.  -or-  The associated process is not on this machine.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the error output of the application.</summary>
        <value>응용 프로그램의 표준 오류 스트림을 읽는 데 사용할 수 있는 <see cref="T:System.IO.StreamReader" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Diagnostics.Process> 표준 오류 스트림에 텍스트를 쓰는 해당 텍스트는 일반적으로 콘솔에 표시 됩니다. 리디렉션하여는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림을 조작 하거나 프로세스의 오류 출력을 표시 하지 않을 수 있습니다. 예를 들어 텍스트를 필터링 다르게 형식을 지정 하거나 콘솔 및 지정 된 로그 파일 모두에 출력을 쓸 수 있습니다.  
  
> [!NOTE]
>  사용 하려면 <xref:System.Diagnostics.Process.StandardError%2A>, 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 를 `false`, 설정 해야 하 고 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> 를 `true`합니다. 그렇지 않은 경우에서 읽기는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 예외를 throw 합니다.  
  
 리디렉션된 <xref:System.Diagnostics.Process.StandardError%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다. 와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 오류 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반면, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. 이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 동기 작업에서 읽는 호출자 간의 종속성을 유발 읽기는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림과 자식 해당 스트림에 쓰기를 처리 합니다. 이러한 종속성은 교착 상태 조건이 발생할 수 있습니다. 호출자에 게 자식 프로세스의 리디렉션된 스트림에서 읽으면 자식에 종속 됩니다. 호출자에 게 자식 스트림에 쓰거나 스트림을 닫고 때까지 읽기 작업을 대기 합니다. 리디렉션된 스트림을 맞게 충분 한 데이터를 기록 하는 자식 프로세스를 부모에 종속 됩니다. 자식 프로세스 부모 전체 스트림을 읽기 / 스트림의 닫을 때까지 다음 쓰기 작업에서 대기 합니다. 호출자와 자식 프로세스는 작업을 완료 하려면 서로 대기 하 고 아무 작업도 처리할 수 하는 경우 교착 상태가 발생 합니다. 호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.  
  
 예를 들어 다음 C# 코드에는 리디렉션된 스트림에서 읽은 하 고 자식 프로세스가 종료 될 때까지 대기 하는 방법을 보여 줍니다.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 호출 하 여 교착 상태를 방지 하는 코드 예제에서는 `p.StandardError.ReadToEnd` 전에 `p.WaitForExit`합니다. 부모 호출을 처리 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 전에 `p.StandardError.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다. 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 표준 출력과 표준 오류 스트림 모두에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다. 예를 들어 다음 C# 코드에서는 두 스트림이 읽기 작업을 수행합니다.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 부모 호출을 처리 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 이어서 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다. 부모 프로세스는 자식 프로세스를 닫으려면 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 이러한 종속성과 교착 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다. 또는 두 개의 스레드를 만들고 각 스트림에서 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다. 예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `net use` 명령을 사용자와 함께 네트워크 리소스를 매핑할 수는 인수를 제공 합니다. 그런 다음 net 명령의 표준 오류 스트림을 읽고 콘솔에 씁니다.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to write the input of the application.</summary>
        <value>응용 프로그램의 표준 입력 스트림을 쓰는 데 사용할 수 있는 <see cref="T:System.IO.StreamWriter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.Process> 는 표준 입력된 스트림 일반적으로 키보드에서에서 입력된 텍스트를 읽을 수 있습니다. 리디렉션하여는 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 입력을 프로그래밍 방식으로 지정할 수 있습니다. 예를 들어, 키보드 입력을 사용 하는 대신 지정 된 파일의 내용에서 텍스트 또는 다른 응용 프로그램에서 출력을 제공할 수 있습니다.  
  
> [!NOTE]
>  사용 하려면 <xref:System.Diagnostics.Process.StandardInput%2A>, 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 를 `false`, 설정 해야 하 고 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> 를 `true`합니다. 그렇지 않은 경우에 쓰기는 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 예외를 throw 합니다.  
  
   
  
## Examples  
 리디렉션하는 방법을 보여 주는 다음 예제는 <xref:System.Diagnostics.Process.StandardInput%2A> 프로세스의 스트림입니다. 이 예제에서는 시작는 `sort` 명령이 리디렉션된 입력을 사용 합니다. 그런 다음 텍스트에 대 한 사용자 요청에 해당 전달 하 고는 `sort` 리디렉션된를 사용 하 여 프로세스 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 합니다. `sort` 결과가 콘솔에 사용자에 게 표시 됩니다.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the textual output of the application.</summary>
        <value>응용 프로그램의 표준 출력 스트림을 읽는 데 사용할 수 있는 <see cref="T:System.IO.StreamReader" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Diagnostics.Process> 해당 텍스트는 일반적으로 콘솔에 표시 됩니다 텍스트를 표준 스트림에 씁니다. 리디렉션하여는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 조작 하거나 프로세스의 출력을 표시 하지 않을 수 있습니다. 예를 들어 텍스트를 필터링 다르게 형식을 지정 하거나 콘솔 및 지정 된 로그 파일 모두에 출력을 쓸 수 있습니다.  
  
> [!NOTE]
>  사용 하려면 <xref:System.Diagnostics.Process.StandardOutput%2A>, 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 를 `false`, 설정 해야 하 고 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> 를 `true`합니다. 그렇지 않은 경우에서 읽기는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 예외를 throw 합니다.  
  
 리디렉션된 <xref:System.Diagnostics.Process.StandardOutput%2A> 동기적 또는 비동기적으로 스트림은 읽을 수 있습니다. 와 같은 메서드 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓰려는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반면, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 이 메서드는 스트림 출력에 대 한 지정 된 이벤트 처리기 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 동기 작업에서 읽는 호출자 간의 종속성을 유발 읽기는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림과 자식 해당 스트림에 쓰기를 처리 합니다. 이러한 종속성은 교착 상태 조건이 발생할 수 있습니다. 호출자에 게 자식 프로세스의 리디렉션된 스트림에서 읽으면 자식에 종속 됩니다. 호출자에 게 자식 스트림에 쓰거나 스트림을 닫고 때까지 읽기 작업을 대기 합니다. 리디렉션된 스트림을 맞게 충분 한 데이터를 기록 하는 자식 프로세스를 부모에 종속 됩니다. 자식 프로세스 부모 전체 스트림을 읽기 / 스트림의 닫을 때까지 다음 쓰기 작업에서 대기 합니다. 호출자와 자식 프로세스는 작업을 완료 하려면 서로 대기 하 고 아무 작업도 처리할 수 하는 경우 교착 상태가 발생 합니다. 호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.  
  
 예를 들어 다음 C# 코드에는 리디렉션된 스트림에서 읽은 하 고 자식 프로세스가 종료 될 때까지 대기 하는 방법을 보여 줍니다.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 호출 하 여 교착 상태를 방지 하는 코드 예제에서는 `p.StandardOutput.ReadToEnd` 전에 `p.WaitForExit`합니다. 부모 호출을 처리 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 전에 `p.StandardOutput.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다. 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
 표준 출력과 표준 오류 스트림 모두에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다. 예를 들어 다음 C# 코드에서는 두 스트림이 읽기 작업을 수행합니다.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 부모 호출을 처리 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 이어서 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다. 부모 프로세스는 자식 프로세스를 닫으려면 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 자식 프로세스 전체에서 읽을 수 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 이러한 종속성과 교착 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다. 또는 두 개의 스레드를 만들고 각 스트림에서 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 리디렉션된 스트림이의 <xref:System.Diagnostics.Process> 열릴 비동기 또는 동기 모드에서 모든 이후 읽기 해당 스트림에서 작업을 동일한 모드에 있어야 합니다. 예를 들어을 따르지 않는 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 을 호출 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 ipconfig.exe 명령을 실행 하 고 예에 나오는 콘솔 창에는 표준 출력을 리디렉션합니다.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</summary>
        <returns>
          <see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 프로세스 리소스를 시작 하 여 현재 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. 반환 값은 `true` 는 새 프로세스 리소스가 시작 되었다는 것을 나타냅니다. 변수로 지정 된 프로세스 리소스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성은 컴퓨터에서 이미 실행 중, 추가 프로세스 리소스가 시작 되지 않은 합니다. 대신, 실행 중인 프로세스 리소스를 다시 사용 및 `false` 반환 됩니다.  
  
 처음 설치한 응용 프로그램 (예를 들어 웹 주소) 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작할 수 있습니다. 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
> [!NOTE]
>  Visual Studio의이 오버 로드를 사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 메서드는 끌어 놓고 코드에 삽입 하는 <xref:System.Diagnostics.Process> 디자이너 구성 요소를 합니다. 사용 하 여는 `Properties` 창이 확장 된 `StartInfo` 범주에 적절 한 값을 작성 하 고는 `FileName` 속성. 폼의 변경 내용은 나타납니다 `InitializeComponent` 프로시저입니다.  
  
 이 오버 로드의 <xref:System.Diagnostics.Process.Start%2A> 않습니다는 `static` 메서드. 인스턴스에서 호출 해야는 <xref:System.Diagnostics.Process> 클래스입니다. 호출 하기 전에 <xref:System.Diagnostics.Process.Start%2A>를 먼저 지정 해야 <xref:System.Diagnostics.Process.StartInfo%2A> 이 대 한 속성 정보 <xref:System.Diagnostics.Process> 정보가 사용 되는 시작 된 프로세스 리소스를 확인 하려면 않았기 때문에 인스턴스에 있습니다.  
  
 다른 오버 로드는 <xref:System.Diagnostics.Process.Start%2A> 메서드가 `static` 멤버입니다. 인스턴스를 만들 필요가 없습니다는 <xref:System.Diagnostics.Process> 메서드의 이러한 오버 로드를 호출 하기 전에 구성 요소입니다. 대신, 호출 수 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 클래스 자체 및 새 <xref:System.Diagnostics.Process> 프로세스가 시작 된 경우 구성 요소가 만들어집니다. 또는, `null` 프로세스를 다시 사용 하는 경우 반환 됩니다. 프로세스 리소스를 자동으로 연결 된 새 <xref:System.Diagnostics.Process> 에서 반환 되는 구성 요소는 <xref:System.Diagnostics.Process.Start%2A> 메서드.  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> 의 기능을 복제 하는 멤버를 사용할 수는 `Run` 대화 상자는 창의 `Start` 메뉴. 명령줄에 입력할 수 있는 모든 항목에서 적절 한 값을 설정 하 여 시작할 수 있습니다는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성입니다. 유일한 <xref:System.Diagnostics.Process.StartInfo%2A> 설정 해야 하는 속성은는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 실행 파일 일 필요가 없습니다. 확장 시스템에 설치 된 응용 프로그램에 연결 된 파일 형식일 수 있습니다. 예를 들어는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 편집기, 메모장과 같은 텍스트 파일에 연결 했는지 또는.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우.doc 확장명을 가질 수 있습니다 하는 경우.txt 확장명을 가질 수 있습니다.  
  
 명령줄에서 특정 형식의 파일에 대해 수행할 동작을 지정할 수 있습니다. 예를 들어 문서를 인쇄 하거나 텍스트 파일을 편집할 수 있습니다. 사용 하 여 이러한 동작을 지정 된 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성입니다. 다른 형식의 파일에 대해 지정할 수에서 파일을 시작할 때 명령줄 인수는 `Run` 대화 상자. 예를 들어 전달할 수 있습니다는 URL을 인수로으로 브라우저를 지정 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>합니다. 이 인수에 지정할 수는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성의 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 멤버입니다.  
  
 따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.  
  
> [!NOTE]
>  ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.  
  
 관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 프로세스 구성 요소에 대해 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드. 그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다. 일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다. 기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서 사용 하는 <xref:System.Diagnostics.Process> 클래스는 프로세스를 시작 합니다.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.
-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</param>
        <summary>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 지정 하 여 프로세스 리소스를 시작 하는 <xref:System.Diagnostics.ProcessStartInfo> 인스턴스. 오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.  
  
> [!NOTE]
>  시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스. 있는이 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.ProcessStartInfo> 매개 변수는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스를 해당 <xref:System.Diagnostics.Process.StartInfo%2A> 속성 및 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 사용 하는 <xref:System.Diagnostics.ProcessStartInfo> 매개 변수를 사용 하면 호출 인스턴스 <xref:System.Diagnostics.Process.Start%2A> 가장 전달 프로세스를 시작 하는 호출에 대해 제어 권한이 있는 합니다. 새로 만들 필요가 없다는 묶은 파일 이름 또는 파일 이름 및 인수를 전달 해야 하는 경우 <xref:System.Diagnostics.ProcessStartInfo> 옵션은 인스턴스. 유일한 <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> 설정 해야 하는 속성은는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성이 실행 파일을 나타내는 데 필요는 없습니다. 확장 시스템에 설치 된 응용 프로그램에 연결 된 파일 형식일 수 있습니다. 예를 들어는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 편집기, 메모장과 같은 텍스트 파일에 연결 했는지 또는.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우.doc 확장명을 가질 수 있습니다 하는 경우.txt 확장명을 가질 수 있습니다.  
  
 처음 설치한 응용 프로그램 (예를 들어 웹 주소) 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작할 수 있습니다. 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
 경우는 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 및 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 의 속성은 <xref:System.Diagnostics.Process.StartInfo%2A> 인스턴스 설정 된 관리 되지 않는 `CreateProcessWithLogonW` 함수가 호출 됩니다는 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> 속성 값이 `true` 또는 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> 속성 값은 <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>합니다. 경우는 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> 속성은 `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 속성 UPN 형식 이어야 합니다 *사용자*@*DNS_domain_name*합니다.   
  
 다른 오버 로드를 오버 로드와는 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 않습니다는 `static` 멤버입니다. 이미 만든 경우 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.Process> 인스턴스, 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스. 중 하나를 사용 하 여는 `static` 새 하려는 경우 overloads <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다. 이 오버 로드와 매개 변수가 없는 오버 로드를 사용 하면 사용 하 여 프로세스 리소스에 대 한 시작 정보를 지정할 수는 <xref:System.Diagnostics.ProcessStartInfo> 인스턴스.  
  
 따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.  
  
> [!NOTE]
>  ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.  
  
 관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 에 `startInfo` 매개 변수를 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드. 그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다. 일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다. 기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.  
  
   
  
## Examples  
 먼저 다음 예제에서는 Internet Explorer의 인스턴스를 생성 하 고 브라우저의 즐겨찾기 폴더의 내용을 표시 합니다. 그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지 또는 사이트를 표시 합니다. 마지막으로 특정 사이트를 탐색 하는 동안 최소화 된 상태로 창으로 Internet Explorer를 시작 합니다.  
  
 이 방법의 다른 사용의 또 다른 예에 대 한 참조의 각 속성에는 <xref:System.Diagnostics.ProcessStartInfo> 클래스입니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="startInfo" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of a document or application file to run in the process.</param>
        <summary>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 해당 파일 이름을 지정 하 여 프로세스 리소스를 시작 합니다. 오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.  
  
> [!NOTE]
>  시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스. 오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 설정 하 여 ClickOnce 응용 프로그램을 시작할 수는 `fileName` 위치 (예를 들어 웹 주소)를 처음 설치한 응용 프로그램에 매개 변수입니다. 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
 해당 파일 이름을 지정 하는 프로세스를 시작 하는 것은에 정보를 입력 비슷합니다는 `Run` 대화 상자는 창의 `Start` 메뉴. 따라서 파일 이름이 실행 파일을 나타내는 필요가 없습니다. 모든 형식의 파일을 확장에 연결 된 시스템에 설치 된 응용 프로그램 수 있습니다. 예를 들어.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우에 확장명이.doc를 가질 수 있습니다 또는 텍스트 파일을 메모장과 같은 편집기에 연결한 경우 파일 이름은.txt 확장명을 사용할 수 있습니다. 동일한 방식으로 `Run` .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다.  
  
 이 오버 로드 하는 프로세스에 대 한 명령줄 인수를 허용 하지 않습니다. 프로세스에 대 한 하나 이상의 명령줄 인수를 지정 해야 할 경우 사용 된 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> 또는 <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> 오버 로드 합니다.  
  
 다른 오버 로드를 오버 로드와는 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 않습니다는 `static` 멤버입니다. 이미 만든 경우 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.Process> 인스턴스, 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스. 중 하나를 사용 하 여는 `static` 새 하려는 경우 overloads <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다. 이 오버 로드와 매개 변수가 없는 오버 로드 시작할 프로세스 리소스의 파일 이름을 지정할 수 있도록 합니다.  
  
 따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.  
  
> [!NOTE]
>  ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.  
  
 관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 프로세스 구성 요소에 대해 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드. 그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다. 일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다. 기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.  
  
   
  
## Examples  
 먼저 다음 예제에서는 Internet Explorer의 인스턴스를 생성 하 고 브라우저의 즐겨찾기 폴더의 내용을 표시 합니다. 그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지 또는 사이트를 표시 합니다. 마지막으로 특정 사이트를 탐색 하는 동안 최소화 된 상태로 창으로 Internet Explorer를 시작 합니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 파일 이름 및 명령줄 인수를 지정 하 여 프로세스 리소스를 시작 합니다. 오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.  
  
> [!NOTE]
>  시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스. 오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 및 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 파일 이름 및 인수를 지정 하 여 프로세스를 시작 하는 것은 파일 이름 및 명령줄 인수에서 입력 비슷합니다는 `Run` 대화 상자는 창의 `Start` 메뉴. 따라서 파일 이름이 실행 파일을 나타내는 필요가 없습니다. 모든 형식의 파일을 확장에 연결 된 시스템에 설치 된 응용 프로그램 수 있습니다. 예를 들어.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우에 확장명이.doc를 가질 수 있습니다 또는 텍스트 파일을 메모장과 같은 편집기에 연결한 경우 파일 이름은.txt 확장명을 사용할 수 있습니다. 동일한 방식으로 `Run` .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다. 경우는 `fileName` 매개 변수는 실행 파일로 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다. 경우는 `fileName` 매개 변수는 명령 파일 (.cmd)을 나타냅니다는 `arguments` 매개 변수 하나를 포함 해야는 "`/c`"또는"`/k`" 인수를 명령 창 종료 또는 완료 된 후 남아 있는지 여부를 지정 합니다.  
  
 다른 오버 로드를 오버 로드와는 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 않습니다는 `static` 멤버입니다. 이미 만든 경우 오버 로드를 사용 하 여 한 <xref:System.Diagnostics.Process> 인스턴스, 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스. 중 하나를 사용 하 여는 `static` 새 하려는 경우 overloads <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다. 이 오버 로드와 매개 변수가 없는 오버 로드 프로세스 리소스를 시작 및 전달할 명령줄 인수 파일 이름을 지정할 수 있도록 합니다.  
  
 따옴표를 사용 하 여 시스템에 선언 된 경로 변수를 사용 하는 경우 해당 위치에 있는 프로세스를 시작할 때 해당 경로 완전히 정규화 해야 합니다. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` 사용자의 경로에 없는 따옴표를 사용 하 여 추가 하 고: `path = %path%;"c:\mypath"`의 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때입니다.  
  
> [!NOTE]
>  ASP.NET 웹 페이지 및 서버 제어 코드는 웹 서버에서 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 새 프로세스에서 ASP.NET 웹 페이지 또는 서버 컨트롤의 메서드를 제한 된 권한으로 웹 서버에서 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으면 되며 사용자 데스크톱에 대 한 액세스를 제공 하지 않습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성...  
  
 관리 되는 스레드의 아파트 상태에 대 한 메모는 여기에 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 은 `true` 프로세스 구성 요소에 대해 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램에 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드. 그렇지 않은 경우 관리 되는 스레드 수는 `unknown` 상태 또는 `MTA` 상태 이면와 충돌 하는 후자 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 고 `true`합니다. 일부 방법의 경우 아파트 상태 수 없음을 `unknown`합니다. 기본적으로 상태는 명시적으로 설정 하지, 응용 프로그램에서 이러한 메서드를 발견 한 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 를 운영 체제 셸을 스레드를 관리할 경우 예외가 발생 합니다.  
  
   
  
## Examples  
 먼저 다음 예제에서는 Internet Explorer의 인스턴스를 생성 하 고 브라우저의 즐겨찾기 폴더의 내용을 표시 합니다. 그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지 또는 사이트를 표시 합니다. 마지막으로 특정 사이트를 탐색 하는 동안 최소화 된 상태로 창으로 Internet Explorer를 시작 합니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 해당 파일 이름, 사용자 이름, 암호 및 도메인을 지정 하 여 새 프로세스와 해당 주 스레드를 만들 수 있습니다. 새 프로세스는 다음 지정 된 자격 증명 (사용자, 도메인 및 암호)의 보안 컨텍스트에서 지정된 된 실행 파일을 실행합니다.  
  
> [!NOTE]
>  실행 파일을 원격 드라이브에 있는 경우 연결 된 드라이브 문자가 아닌 uniform resource identifier (URI)를 사용 하 여 네트워크 공유를 식별 해야 합니다.  
  
> [!NOTE]
>  시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스. 오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, 및 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 의 속성은 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한 <xref:System.Diagnostics.Process> 인스턴스.  
  
 동일한 방식으로 **실행** .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다. 경우는 `fileName` 매개 변수는 실행 파일로 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다.  
  
> [!NOTE]
>  파일 이름에는 실행 파일을 나타내야 합니다는 <xref:System.Diagnostics.Process.Start%2A> 오버 로드의 `userName`, `password`, 및 `domain` 매개 변수입니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성...  
  
   
  
## Examples  
 다음 코드 예제에서는이 오버 로드를 실행 파일로 시작의 사용법을 보여줍니다 및에서는의 <xref:System.ComponentModel.Win32Exception> 파일과와 연결 된 응용 프로그램을 시작 하려고 할 때입니다.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 파일 이름, 명령줄 인수, 사용자 이름, 암호 및 도메인을 지정 하 여 새 프로세스와 해당 주 스레드를 만들 수 있습니다. 새 프로세스는 다음 지정 된 자격 증명 (사용자, 도메인 및 암호)의 보안 컨텍스트에서 지정된 된 실행 파일을 실행합니다.  
  
> [!NOTE]
>  실행 파일을 원격 드라이브에 있는 경우 연결 된 드라이브 문자가 아닌 uniform resource identifier (URI)를 사용 하 여 네트워크 공유를 식별 해야 합니다.  
  
> [!NOTE]
>  시작할 실행 파일의 주소가 URL 인 경우에 프로세스가 시작 되지 않은 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하는 프로세스를 만들지 않고 새 시작할 수 있습니다. <xref:System.Diagnostics.Process> 인스턴스. 오버 로드는 새로 만드는 데 따른 명시적 단계에 대 한 대안 <xref:System.Diagnostics.Process> 설정 인스턴스는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, 및 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 의 속성은 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 동일한 방식으로 **실행** .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다. 경우는 `fileName` 매개 변수는 실행 파일로 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다.  
  
> [!NOTE]
>  파일 이름에는 실행 파일을 나타내야 합니다는 <xref:System.Diagnostics.Process.Start%2A> 오버 로드의 `userName`, `password`, 및 `domain` 매개 변수입니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하려면를 닫습니다 하거나 시스템 리소스를 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다는 <xref:System.Diagnostics.Process.HasExited%2A> 속성...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>프로세스를 시작하는 데 사용된 데이터를 나타내는 <see cref="T:System.Diagnostics.ProcessStartInfo" />입니다. 이러한 인수에는 프로세스를 시작하는 데 사용된 실행 파일이나 문서 이름이 포함됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 프로세스를 시작 하는 데 매개 변수 집합을 나타냅니다. 때 <xref:System.Diagnostics.Process.Start%2A> 호출 되는 <xref:System.Diagnostics.Process.StartInfo%2A> 프로세스가 시작 되도록 지정 하는 데 사용 됩니다. 유일한 필수 <xref:System.Diagnostics.Process.StartInfo%2A> 설정 하는 멤버는는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다. 지정 하 여 프로세스를 시작는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성에 정보를 입력 하는 것과 비슷합니다는 **실행** 대화 상자는 창의 **시작** 메뉴. 따라서는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성이 실행 파일을 나타내는 데 필요는 없습니다. 모든 형식의 파일을 확장에 연결 된 시스템에 설치 된 응용 프로그램 수 있습니다. 예를 들어는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 편집기, 메모장과 같은 텍스트 파일에 연결 했는지 또는.doc 파일을 Microsoft Word와 같은 워드 프로세서 도구에 있는 경우에 확장명이.doc를 가질 수 있습니다 하는 경우.txt 확장명을 가질 수 있습니다. 동일한 방식으로 **실행** .exe 확장명은의 경우 선택 사항, 대화 상자에는.exe 확장명이 있거나 없는 실행 파일 이름을 사용할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 멤버입니다. 예를 들어, 설정할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성을 "Notepad.exe" 또는 "Notepad" 중 하나입니다.  
  
 설정 하 여 ClickOnce 응용 프로그램을 시작할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성을 원래 응용 프로그램 설치 위치 (예를 들어 웹 주소). 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
 파일 이름 예:.doc 파일 파일과 포함 되는 경우에 파일에 수행할 동작을 지정 하는 동사를 포함할 수 있습니다. 예를 들어 설정할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> .doc 확장명으로 끝나는 파일에 대 한 "print"입니다. 지정 된 파일 이름이 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성에 대 한 값을 수동으로 입력 하는 경우 확장명을 가질 필요가 없습니다는 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 속성입니다. 그러나 사용 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> 동사를 확인 하려면 속성을 사용할 수 있는 확장을 포함 해야 합니다.  
  
 에 지정 된 매개 변수를 변경할 수는 <xref:System.Diagnostics.Process.StartInfo%2A> 호출 전까지 속성은 <xref:System.Diagnostics.Process.Start%2A> 프로세스에서 메서드. 프로세스를 시작 하면 변경 된 <xref:System.Diagnostics.Process.StartInfo%2A> 값에 영향을 하거나 연결된 된 프로세스를 다시 시작 하지 않습니다. 호출 하는 경우는 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> 메서드는 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 및 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 속성 집합, 관리 되지 않는 `CreateProcessWithLogonW` 함수가 호출 되는 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> 속성 값이 `true` 또는 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> 속성 값은 <xref:System.Diagnostics.ProcessWindowStyle.Hidden>합니다.  
  
 사용 하지 않은 경우는 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하는 메서드는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성 매개 변수는 프로세스를 시작 하는 데 사용 되지는지 않습니다. 예를 들어, 사용 하는 경우 <xref:System.Diagnostics.Process.GetProcesses%2A> 컴퓨터에서 실행 중인 프로세스의 배열을 가져올 수는 <xref:System.Diagnostics.Process.StartInfo%2A> 각 속성 <xref:System.Diagnostics.Process> 원래 파일 이름 또는 프로세스를 시작 하는 데 사용 되는 인수를 포함 하지 않습니다.  
  
 파일 이름 (읽기 전용) 정보를 표시 하는 파일은 프로세스가 시작 되 면 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다. 프로세스가 시작 된 후 프로세스와 연결 된 실행 파일을 검색, 사용 하려는 경우는 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다. 실행 파일을 설정 하려는 경우는 <xref:System.Diagnostics.Process> 있는 연결된 된 프로세스가 시작 되지 않은 대 한 인스턴스를 사용 하 여는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성의 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 멤버입니다. 때문에의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성에 전달 되는 인수는는 <xref:System.Diagnostics.Process.Start%2A> 변경 하는 프로세스의 메서드는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 연결된 된 프로세스가 시작 된 후 다시 설정 되지 것입니다는 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다. 이러한 속성은 연결된 된 프로세스 초기화에 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Diagnostics.Process.StartInfo%2A> 실행 파일에 대해 수행 된 작업 및 사용자 인터페이스를 표시 해야 하는지 여부입니다. 다른 예제를 보려면 참조 페이지의 속성에 대 한 참조는 <xref:System.Diagnostics.ProcessStartInfo> 클래스입니다.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process was started.</summary>
        <value>해당 프로세스가 시작된 시간을 나타내는 개체입니다. 프로세스가 실행되고 있지 않으면 예외가 throw됩니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not been started.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred in the call to the Windows function.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</summary>
        <value>프로세스에서 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트의 결과로 발생하는 이벤트 처리기 호출을 마샬링하는 데 사용되는 <see cref="T:System.ComponentModel.ISynchronizeInvoke" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 은 `null`를 처리 하는 메서드는 <xref:System.Diagnostics.Process.Exited> 시스템 스레드 풀의 스레드라도에서 이벤트를 호출 합니다. 시스템 스레드 풀에 대 한 자세한 내용은 참조 하십시오. <xref:System.Threading.ThreadPool>합니다.  
  
 때는 <xref:System.Diagnostics.Process.Exited> 이벤트가 같은 visual Windows Forms 구성 요소에 의해 처리 되는 <xref:System.Windows.Forms.Button>, 작동 하지 않을 수 시스템 스레드 풀을 통해 구성 요소를 액세스 하거나 예외가 발생할 수 있습니다. 설정 하 여이 문제를 방지 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 처리 하는 메서드가 때문에 Windows Forms 구성 요소에는 <xref:System.Diagnostics.Process.Exited> 구성 요소를 만든 동일한 스레드에서 호출 이벤트입니다.  
  
 경우는 <xref:System.Diagnostics.Process> 안에서 사용 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Windows Forms 디자이너에서 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 포함 하는 컨트롤에 자동으로 설정 됩니다는 <xref:System.Diagnostics.Process>합니다. 예를 들어, 배치 하는 경우는 <xref:System.Diagnostics.Process> 에 대 한 디자이너에서 `Form1` (에서 상속 되 <xref:System.Windows.Forms.Form>)는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성 <xref:System.Diagnostics.Process> 인스턴스의로 설정 된 `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 일반적으로 이러한 구성 요소는 특정 스레드에 바인딩되어 있기 때문에 구성 요소 컨트롤 또는 폼에 배치 된 경우이 속성이 설정 되어 있습니다.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the set of threads that are running in the associated process.</summary>
        <value>연결된 프로세스에서 현재 실행 중인 운영 체제 스레드를 나타내는 <see cref="T:System.Diagnostics.ProcessThread" /> 형식의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드는 프로세스의 코드를 실행 합니다. 각 프로세스는 단일 스레드로 기본 스레드도 시작 됩니다. 모든 스레드가 추가 스레드를 만들 수 있습니다. 프로세스 내에서 스레드 프로세스의 주소 공간을 공유 합니다.  
  
 사용 하 여 <xref:System.Diagnostics.ProcessThread> 현재 프로세스와 관련 된 모든 스레드를 가져오려면 합니다. 주 스레드를 반드시 배열의 인덱스 0에 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formats the process's name as a string, combined with the parent component type, if applicable.</summary>
        <returns>The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total processor time for this process.</summary>
        <value>연결된 프로세스에서 CPU를 사용해 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다. 이 값은 <see cref="P:System.Diagnostics.Process.UserProcessorTime" />과 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />의 합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user processor time for this process.</summary>
        <value>연결된 프로세스가 운영 체제 코어 내부가 아닌 프로세스의 응용 프로그램 부분 내부에서 코드를 실행하는 데 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of the process's virtual memory, in bytes.</summary>
        <value>연결된 프로세스에서 요청한 가상 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of the virtual memory, in bytes, allocated for the associated process.</summary>
        <value>연결된 프로세스에 할당된 가상 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)에서 프로세스에 의해 사용 되는 가상 메모리의 현재 크기를 나타냅니다. 운영 체제 디스크에 있는 가상 메모리 페이징 파일에 저장 된 페이지 또는 실제 메모리에 로드 하는 페이지에 각 프로세스에 대 한 가상 주소 공간을 매핑합니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **가상 바이트** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited. To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.  For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 연결된 된 프로세스가 종료 될 때까지 대기 하는 현재 스레드를 만듭니다.  프로세스에서 다른 모든 메서드를 호출 후에 호출 되어야 합니다. 현재 스레드가 차단되는 것을 방지하려면 <xref:System.Diagnostics.Process.Exited> 이벤트를 사용합니다.  
  
 이 메서드는 <xref:System.Diagnostics.Process> 구성 요소를 종료 하려면 프로세스 및 이벤트 처리기에 대 한 시간을 무기한 대기 합니다. 이 인해 응답 하지 응용 프로그램이 수 있습니다. 예를 들어, 호출 하는 경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 사용자 인터페이스가 있는 프로세스에 대해 연결된 된 프로세스를 종료 하는 운영 체제에 요청 수 처리할 수 없는 입력 하지 않는 것의 메시지 루프를 작성 하는 경우.  
  
> [!NOTE]
>  에 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 및 이전 버전의 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드에 대 한 대기 <xref:System.Int32.MaxValue> 밀리초 (약 24 일), not 무기한 합니다. 또한 이전 버전 기다리지 않고 이벤트 처리기를 끝낼 전체 <xref:System.Int32.MaxValue> 시간에 도달 했습니다.  
  
 이 오버 로드는 모든 처리가 완료 되었음을 나타내는, 리디렉션된 표준 출력에 대 한 비동기 이벤트 처리를 포함 하 여 확인 합니다. 호출한 후이 오버 로드를 사용 해야는 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 비동기 이벤트 처리기로 표준 출력이 리디렉션된 경우 오버 로드 합니다.  
  
 시스템 프로세스에 대 한 관리 정보를 저장 하 고이 호출한 하는 구성 요소를 반환 (즉, 것 종료 될 때 운영 체제의 정상 또는 비정상 종료에서) 연결된 된 프로세스가 종료 될 때 <xref:System.Diagnostics.Process.WaitForExit>합니다. <xref:System.Diagnostics.Process> 구성 요소에 포함 된 정보를 액세스할 수는 <xref:System.Diagnostics.Process.ExitTime%2A>, 사용 하 여는 <xref:System.Diagnostics.Process.Handle%2A> 종료 프로세스에 있습니다.  
  
 연결된 된 프로세스가 종료 되었으므로 <xref:System.Diagnostics.Process.Handle%2A> 의 구성 요소 속성은 더 이상 기존 프로세스 리소스를 가리킵니다. 대신, 핸들 프로세스 리소스에 대 한 운영 체제의 정보를 액세스할 때만 사용할 수 있습니다. 시스템에서 인식 하 여 해제 되지 않은 종료 된 프로세스에 대 한 핸들의 <xref:System.Diagnostics.Process> 유지할 수 있도록 구성 요소는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 될 때까지 메모리에 대 한 정보는 <xref:System.Diagnostics.Process> 구성 요소 리소스를 해제할 합니다. 이러한 이유로 든 지 호출할 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스를 호출 <xref:System.Diagnostics.Process.Close%2A> 때 연결된 된 프로세스가 종료 하 고 항목에 대 한 관리 정보는 더 이상 필요 합니다. <xref:System.Diagnostics.Process.Close%2A> 종료 프로세스에 할당 된 메모리를 해제 합니다.  
  
   
  
## Examples  
 설명 섹션을 참조는 <xref:System.Diagnostics.Process.StandardError%2A> 속성 참조 페이지입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">The amount of time, in milliseconds, to wait for the associated process to exit. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</param>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</summary>
        <returns>
          <see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 연결된 된 프로세스가 종료 될 때까지 대기 하는 현재 스레드를 만듭니다. 프로세스에서 다른 모든 메서드를 호출 후에 호출 되어야 합니다. 현재 스레드가 차단되는 것을 방지하려면 <xref:System.Diagnostics.Process.Exited> 이벤트를 사용합니다.  
  
 이 메서드는 <xref:System.Diagnostics.Process> 구성 요소를 종료 하려면 프로세스에 대 한 유한 기간 대기 합니다. 연결된 된 프로세스가 종료 요청이 거부 되었기 때문에 간격의 끝에서 종료 되지 않은 경우 `false` 호출 하는 프로시저로 반환 됩니다. 지정할 수 있습니다 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대 한 `milliseconds`, 및 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> 동작이 동일는 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드 합니다. 반환 하는 경우에 0 (영) 메서드에 전달, `true` 프로세스가 이미 종료 되었습니다; 경우에 이렇게 하지 않으면 즉시 반환 `false`합니다.  
  
> [!NOTE]
>  에 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 및 이전 버전 경우 `milliseconds` 가-1는 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 오버 로드에 대 한 대기 <xref:System.Int32.MaxValue> 밀리초 (약 24 일), not 무기한 합니다.  
  
 비동기 이벤트 처리기로 표준 출력이 리디렉션된, 경우에 출력 프로세스가 완료 되지 않을이 메서드가 반환 될 수 있습니다. 비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출는 <xref:System.Diagnostics.Process.WaitForExit> 수신 후 없는 매개 변수를 사용 하는 오버 로드는 `true` 이 오버 로드 합니다. 않도록 하기 위한는 <xref:System.Diagnostics.Process.Exited> 설정, Windows Forms 응용 프로그램에서 이벤트를 올바르게 처리는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성입니다.  
  
 연결된 된 프로세스가 종료 되는 경우 (종료 된 운영 체제의 정상 또는 비정상 종료에서) 시스템의 프로세스에 대 한 관리 정보를 저장 하 고 마치 호출 하는 구성 요소에 반환 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>합니다. <xref:System.Diagnostics.Process> 구성 요소에 포함 된 정보를 액세스할 수는 <xref:System.Diagnostics.Process.ExitTime%2A>, 사용 하 여는 <xref:System.Diagnostics.Process.Handle%2A> 종료 프로세스에 있습니다.  
  
 연결된 된 프로세스가 종료 되었으므로 <xref:System.Diagnostics.Process.Handle%2A> 의 구성 요소 속성은 더 이상 기존 프로세스 리소스를 가리킵니다. 대신, 핸들 프로세스 리소스에 대 한 운영 체제의 정보를 액세스할 때만 사용할 수 있습니다. 시스템에서 인식 하 여 해제 되지 않은 종료 된 프로세스에 대 한 핸들의 <xref:System.Diagnostics.Process> 유지할 수 있도록 구성 요소는 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 될 때까지 메모리에 대 한 정보는 <xref:System.Diagnostics.Process> 구성 요소 리소스를 해제할 합니다. 이러한 이유로 든 지 호출할 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스를 호출 <xref:System.Diagnostics.Process.Close%2A> 때 연결된 된 프로세스가 종료 하 고 항목에 대 한 관리 정보는 더 이상 필요 합니다. <xref:System.Diagnostics.Process.Close%2A> 종료 프로세스에 할당 된 메모리를 해제 합니다.  
  
   
  
## Examples  
 에 대 한 코드 예제를 보려면는 <xref:System.Diagnostics.Process.ExitCode%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.Process.WaitForInputIdle> 메시지 루프에 유휴 상태로 반환 될 때까지 대기 하는 응용 프로그램의 처리 되도록 합니다. 사용자 인터페이스를 사용 하 여 프로세스를 실행할 때 운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다의 메시지 루프를 실행 합니다. 프로세스는 다음 메시지 루프를 반환합니다. 메시지 루프 내에서 메시지를 대기 하 고 유휴 상태에 있는 것으로 프로세스 라고 합니다. 이 상태는 응용 프로그램에 응용 프로그램이 해당 창와 통신 하기 전에 주 창을 만들기를 완료 프로세스를 시작 하는 대기 해야 하는 경우 예를 들어 유용 합니다.  
  
 프로세스에 메시지 루프에 없는 경우 <xref:System.Diagnostics.Process.WaitForInputIdle> throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> 오버 로드는 <xref:System.Diagnostics.Process> 구성 요소를 메시지 루프에서 유휴 상태가 프로세스에 대 한 무기한 대기 합니다. 이 명령에 응답을 중지 하도록 응용 프로그램 발생할 수 있습니다. 예를 들어 프로세스에 항상 기록 하는 경우의 메시지 루프 즉시 종료 코드 조각에서와 같이 `while(true)`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle. A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</param>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 메시지 루프에 유휴 상태로 반환 될 때까지 대기 하는 응용 프로그램의 처리 되도록 합니다. 사용자 인터페이스를 사용 하 여 프로세스를 실행할 때 운영 체제에 의해 프로세스에 Windows 메시지를 보낼 때마다의 메시지 루프를 실행 합니다. 프로세스는 다음 메시지 루프를 반환합니다. 메시지 루프 내에서 메시지를 대기 하 고 유휴 상태에 있는 것으로 프로세스 라고 합니다. 이 상태는 응용 프로그램에 응용 프로그램이 해당 창와 통신 하기 전에 주 창을 만들기를 완료 프로세스를 시작 하는 대기 해야 하는 경우 예를 들어 유용 합니다.  
  
 프로세스에 메시지 루프에 없는 경우 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 오버 로드는 <xref:System.Diagnostics.Process> 구성 요소를 제한 된 양의 메시지 루프에서 유휴 상태가 프로세스 시간을 대기 합니다. 루프에서 계속 메시지를 처리 하므로 연결된 된 프로세스에 간격의 끝에서 유휴 상태가 되지 경우 `false` 호출 하는 프로시저로 반환 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the associated process's physical memory usage, in bytes.</summary>
        <value>연결된 프로세스에서 사용 중인 실제 메모리의 총 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)에서, 프로세스에서 사용한 작업 집합 메모리의 현재 크기를 나타냅니다. 프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는 프로세스는 실행 프로세스 모듈와 시스템 라이브러리를 포함 하는 모든 명령이 포함 된 페이지가 포함 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 하 고 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory, in bytes, allocated for the associated process.</summary>
        <value>연결된 프로세스에 할당된 실제 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 값 (바이트)에서, 프로세스에서 사용한 작업 집합 메모리의 현재 크기를 나타냅니다. 프로세스의 작업 집합은 실제 RAM 메모리에서 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는 시스템 라이브러리 및 프로세스 모듈의 명령을 포함 하 여 프로세스에서 실행 하는 모든 명령이 포함 된 페이지가 포함 됩니다.  
  
 프로세서 32 비트 또는 64 비트 프로세서가 있는 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값은 해당 하는 **작업 집합** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 예제에서는 프로세스가 종료 될 때 감지 된 종료 코드와 최고 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>