<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2145a11bbb9faa94763035b22147eede6d4adee" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30400607" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows 이벤트 로그 조작을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> 에 액세스 하거나 중요 한 소프트웨어 또는 하드웨어 이벤트에 대 한 정보를 기록 하는 Windows 이벤트 로그를 사용자 지정할 수 있습니다. 사용 하 여 <xref:System.Diagnostics.EventLog>, 있습니다 기존 로그에서 읽을, 엔트리를 쓰고, 만들기 또는 이벤트 소스를 삭제, 로그를 삭제 하 고 응답할 수 로그 항목입니다. 이벤트 소스를 만들 때 새 로그를 만들 수도 있습니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 개별 이벤트 로그 및 해당 항목에 대 한 액세스를 제공 하는 <xref:System.Diagnostics.EventLog> 클래스 사용의 모든 이벤트 로그 컬렉션에 액세스할 수 있습니다. 사용할 수는 `static` 멤버인 <xref:System.Diagnostics.EventLog> 로그를 삭제 하려면 로그 목록을 가져오고, 만들거나 소스, 삭제 또는 컴퓨터는 특정 원본이 이미 들어 있는지 확인 합니다.  
  
 세 가지 기본 이벤트 로그가: 응용 프로그램, 시스템 및 보안 합니다. 보안 로그에는 읽기 전용입니다. 다른 응용 프로그램과 서비스를 설치 하면 Active Directory와 같은 추가 이벤트 로그에 있을 수 있습니다.  
  
 사용 하는 경우 보안 고려 사항이 <xref:System.Diagnostics.EventLog> 클래스입니다. <xref:System.Diagnostics.EventLog> 필요한 <xref:System.Diagnostics.EventLogPermission> .NET Framework 2.0 및 이상 버전에서 특정 작업 또는.NET Framework 1.0 및 1.1에서 완전 신뢰에 대 한 사용 권한입니다. 좋습니다 <xref:System.Diagnostics.EventLogPermission> 부분적으로 신뢰할 수 있는 코드에 부여 되지 않습니다.  직접 전달 하면 안 이벤트 로그 개체를 포함 하 여 <xref:System.Diagnostics.EventLogEntryCollection> 및 <xref:System.Diagnostics.EventLogEntry> 덜 신뢰할 수 있는 코드를 개체입니다. 예를 들어 만들기는 <xref:System.Diagnostics.EventLog> 개체, 항목을 작성 하 고 전달는 <xref:System.Diagnostics.EventLog> 이벤트 로그를 읽고 쓸 수 보내는 등의 작업을 수행 하도록 허용 하기 때문에 개체를 부분적으로 신뢰할 수 있는 코드 보안 문제를 만들 수 이벤트 로그 메시지를 다른 응용 프로그램의 이름입니다.  
  
 Windows Vista 이상에서는 사용자 계정 컨트롤 (UAC)는 사용자의 자격 증명을 결정 합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 보안 로그에 액세스 하는 코드를 실행 하려면 먼저 자격 증명에서 높여야 표준 사용자 관리자에 게 있습니다. 응용 프로그램에 대 한 바로 가기 메뉴를 열고 응용 프로그램을 시작 하는 경우 이렇게 할 수 있습니다 (마우스를 사용 하는 단추로 클릭 하 고 응용 프로그램 아이콘)를 관리자 권한으로 실행 하 고 있습니다.  
  
 사용할 수 있습니다 <xref:System.Diagnostics.EventLog> 이벤트 뷰어의 서버를 통해 볼 수 있는 사용자 지정 이벤트 로그를 만들도록 합니다. 사용 된 <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> 메서드를 이벤트 뷰어의 이벤트 로그에 대 한 지역화 된 이름을 표시 합니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> 메서드를 최대 로그 크기에 도달할 때 이벤트 로그의 동작을 구성 합니다.  
  
 이벤트 로그를 읽으려면 로그 이름을 지정 합니다 (<xref:System.Diagnostics.EventLog.Log%2A> 속성) 및 서버 컴퓨터 이름 (<xref:System.Diagnostics.EventLog.MachineName%2A> 이벤트 로그에 대 한 속성. 로컬 컴퓨터의 서버 컴퓨터 이름을 지정 하지 않으면 "."를 가정 합니다. 이벤트 소스를 지정할 필요는 없습니다 (<xref:System.Diagnostics.EventLog.Source%2A> 속성)는 원본 로그에 쓰기에 대해서만 필요 하기 때문에, 합니다. <xref:System.Diagnostics.EventLog.Entries%2A> 속성은 항목의 이벤트 로그의 목록을 자동으로 채워집니다.  
  
 이벤트 로그를 작성 하려면를 지정 하거나 이벤트 소스를 만듭니다 (<xref:System.Diagnostics.EventLog.Source%2A> 속성). 새 이벤트 원본을 만들 수 있도록 컴퓨터에 관리 자격 증명이 있어야 합니다. 이벤트 소스 항목의 유효한 소스로 이벤트 로그와 응용 프로그램을 등록합니다. 한 번에 하나의 로그에 기록할 이벤트 소스를 사용할 수 있습니다. <xref:System.Diagnostics.EventLog.Source%2A> 속성 모든 임의의 문자열일 수 있지만 이름을 컴퓨터의 다른 원본을 구별 되어야 합니다. 이벤트 소스는 일반적으로 응용 프로그램 또는 다른 식별 문자열 이름입니다. 중복을 만들려고 <xref:System.Diagnostics.EventLog.Source%2A> 값 예외를 throw 합니다. 그러나 하나의 이벤트 로그는 여러 원본과 연결할 수 있습니다.  
  
 이벤트 로그에 대 한 이벤트 소스와 연결 된 경우는 <xref:System.Diagnostics.EventLog> 인스턴스가 없습니다., 새 이벤트 소스를 만듭니다. 이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 만들려면 관리 자격 증명이 있어야 합니다.  
  
 이 요구 사항은 되므로 이벤트 소스 고유한 지 확인 하려면 보안 로그를 포함 하 여 모든 이벤트 로그를 검색 해야 합니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException> throw 됩니다.  
  
> [!IMPORTANT]
>  만들기 또는 삭제 이벤트 소스 명명된 된 뮤텍스를 사용 하 여 기본 코드의 동기화가 필요 합니다. 높은 권한이 필요한 응용 프로그램에서 명명 된 뮤텍스를 잠그는 하는 경우에 잠금이 해제 될 때까지 응답을 중지 하도록 응용을 프로그램이 만들거나 이벤트 소스를 삭제 하려고 합니다. 이 문제를 방지 하려면 부여 안 <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> 신뢰할 수 없는 코드는 권한입니다. 또한 <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> 권한 잠재적으로 기타 사용 권한을 무시할 수 및 신뢰할 수 있는 코드에만 부여 해야 합니다.  
  
 응용 프로그램 및 서비스 응용 프로그램 로그 나 사용자 지정 로그를 작성 해야 합니다. 장치 드라이버 시스템 로그에 써야 합니다. 명시적으로 설정 하지 않은 경우는 <xref:System.Diagnostics.EventLog.Log%2A> 속성, 이벤트 로그의 응용 프로그램 로그에 기본값입니다.  
  
> [!NOTE]
>  등록 된 소스로 쓰기에서 응용 프로그램을 보호 하는 일은 없습니다.  응용 프로그램에 부여 하는 경우 <xref:System.Diagnostics.EventLogPermissionAccess.Write> 권한, 컴퓨터에 등록 된 유효한 소스에 대 한 이벤트 작성할 수 있습니다.  
  
 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 및 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 이벤트 로그에 이벤트를 쓰는 메서드가 있습니다. 이벤트를 작성 하는 이벤트 소스를 지정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에는 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller> 개체 또는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 원본을 만들 수 있도록 컴퓨터에 관리 자격 증명이 있어야 합니다.  
  
 각 소스; 한 번에 하나의 이벤트 로그에 쓸 수 있습니다. 그러나 응용 프로그램 여러 이벤트 로그에 쓸 여러 소스를 사용할 수 있습니다. 예를 들어 응용 프로그램에 다른 이벤트 로그 또는 서로 다른 리소스 파일에 대해 구성 된 여러 소스가 필요할 수 있습니다. 기존 소스 구성 세부 정보를 변경 하려면 소스를 삭제 하 고 새 구성으로 만듭니다. 다른 응용 프로그램이 나 구성 요소는 기존 소스를 사용 하는 경우 기존 소스를 삭제 하는 대신 업데이트 된 구성을 사용 하 여 새 원본을 만듭니다.  
  
 이벤트 범주, 메시지 문자열에 대 한 지역화 된 리소스가 포함 된 이벤트 소스를 등록할 수 있습니다. 응용 프로그램 실제 문자열 값을 지정 하는 대신 리소스 식별자를 사용 하 여 이벤트 로그 항목을 쓸 수 있습니다. 참조는 <xref:System.Diagnostics.EventLogInstaller> 및 <xref:System.Diagnostics.EventSourceCreationData> 클래스 리소스 파일을 사용 하 여 소스를 구성 하는 방법에 대 한 자세한 내용은 합니다.  
  
 응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는, 리소스 원본에 대 한 파일 속성을 설정할 필요가 없습니다. 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
 이벤트를 쓸 때 메시지 문자열에 대 한 리소스 식별자 또는 메시지 문자열 중 하나 이상 지정 해야 합니다. 다른 이벤트 속성은 선택 사항입니다. 선택적 이벤트 설정의 예는 다음과 같습니다.  
  
-   설정할 수 있습니다는 <xref:System.Diagnostics.EventLogEntryType> 이벤트 뷰어에서 항목에 대해 표시 되는 아이콘을 지정할 수 있습니다.  
  
-   응용 프로그램 범주를 사용 하 여 이벤트를 필터링 하는 경우 이벤트에 대 한 범주 식별자를 지정할 수 있습니다.  
  
-   지정된 된 이벤트와 추가 정보를 연결 하려는 경우 이진 데이터 이벤트 항목에 연결할 수 있습니다.  
  
> [!IMPORTANT]
>  이벤트 로깅 디스크 공간, 프로세서 시간 및 기타 시스템 리소스를 사용합니다. 중요 한 정보만 기록 하는 것이 유용 합니다. 이벤트 로그 호출 오류 경로에 배치 되지 않고을 주 코드 경로에 있으므로 하지 성능이 저하 될 것이 좋습니다.  
  
 인스턴스에 대 한 초기 속성 값 목록은 <xref:System.Diagnostics.EventLog>, 참조는 <xref:System.Diagnostics.EventLog.%23ctor%2A> 생성자입니다.  
  
   
  
## Examples  
 다음 예제에서는 이벤트 소스 `MySource` 존재 하지 않는 경우 및 이벤트 로그에 엔트리를 씁니다 `MyNewLog`합니다.  
  
> [!NOTE]
>  Windows Vista 이상에서는 관리자 권한으로이 응용 프로그램을 실행 해야 합니다.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> 클래스의 새 인스턴스를 초기화합니다. 인스턴스를 로그와 연결하지 않습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하기 전에 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 지정는 <xref:System.Diagnostics.EventLog.Source%2A> 의 속성은 <xref:System.Diagnostics.EventLog> 인스턴스. 만 읽는 경우 <xref:System.Diagnostics.EventLog.Entries%2A> 로그에서 지정할 수 있습니다만 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성입니다.  
  
> [!NOTE]
>  지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Diagnostics.EventLog>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|빈 문자열("")입니다.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|빈 문자열("")입니다.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|로컬 컴퓨터 (".").|  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 이미 존재 하지 않는 하 고 이벤트 로그에 항목을 기록 하는 경우 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">로컬 컴퓨터의 로그 이름입니다.</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> 클래스의 새 인스턴스를 초기화합니다. 로컬 컴퓨터에 있는 로그에 인스턴스를 연결합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하는이 오버 로드는 <xref:System.Diagnostics.EventLog.Log%2A> 속성을는 `logName` 매개 변수입니다. 호출 하기 전에 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 지정는 <xref:System.Diagnostics.EventLog.Source%2A> 의 속성은 <xref:System.Diagnostics.EventLog> 인스턴스. 만 읽는 경우 <xref:System.Diagnostics.EventLog.Entries%2A> 로그에서 지정할 수 있습니다만 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성입니다.  
  
> [!NOTE]
>  지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다. 이 오버 로드 생성자의 지정 된 <xref:System.Diagnostics.EventLog.Log%2A> 속성 되지만 변경할 수 있습니다이 읽기 전에 <xref:System.Diagnostics.EventLog.Entries%2A> 속성입니다.  
  
 에 지정 된 소스는 <xref:System.Diagnostics.EventLog.Source%2A> 한 후속 호출에는 컴퓨터에 있는 다른 원본의 속성은 고유 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 아직 없는 경우 지정 된 이름의 한 로그를 만듭니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Diagnostics.EventLog>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|빈 문자열("")입니다.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 매개 변수입니다.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|로컬 컴퓨터 (".").|  
  
   
  
## Examples  
 다음 예제에서는 "myNewLog" 로컬 컴퓨터에서 이벤트 로그에 엔트리를 읽습니다.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">로그 이름이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">로그 이름이 잘못된 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">지정된 컴퓨터의 로그 이름입니다.</param>
        <param name="machineName">로그가 있는 컴퓨터입니다.</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> 클래스의 새 인스턴스를 초기화합니다. 지정한 컴퓨터에 있는 로그에 인스턴스를 연결합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하는이 오버 로드는 <xref:System.Diagnostics.EventLog.Log%2A> 속성을는 `logName` 매개 변수 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성을는 `machineName` 매개 변수입니다. 호출 하기 전에 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 지정는 <xref:System.Diagnostics.EventLog.Source%2A> 의 속성은 <xref:System.Diagnostics.EventLog>합니다. 만 읽는 경우 <xref:System.Diagnostics.EventLog.Entries%2A> 로그에서 지정할 수 있습니다만 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성입니다.  
  
> [!NOTE]
>  이 오버 로드 생성자의 지정 된 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 있지만 속성을 읽기 전에 해당 변경할 수는 <xref:System.Diagnostics.EventLog.Entries%2A> 속성입니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Diagnostics.EventLog>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|빈 문자열("")입니다.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 매개 변수입니다.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 매개 변수입니다.|  
  
   
  
## Examples  
 다음 예제에서는 "myNewLog" "myServer" 컴퓨터에서 이벤트 로그에 엔트리를 읽습니다.  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">로그 이름이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">로그 이름이 잘못된 경우  
  
 또는  
  
 컴퓨터 이름이 잘못된 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">지정된 컴퓨터의 로그 이름입니다.</param>
        <param name="machineName">로그가 있는 컴퓨터입니다.</param>
        <param name="source">이벤트 로그 항목의 원본입니다.</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> 클래스의 새 인스턴스를 초기화합니다. 지정한 컴퓨터에 있는 로그에 인스턴스를 연결하고 <see cref="T:System.Diagnostics.EventLog" />에 지정한 원본을 만들거나 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 설정의 <xref:System.Diagnostics.EventLog.Log%2A> 속성을는 `logName` 매개 변수는 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성을는 `machineName` 매개 변수를 및 <xref:System.Diagnostics.EventLog.Source%2A> 속성을는 `source` 매개 변수. <xref:System.Diagnostics.EventLog.Source%2A> 속성은 이벤트 로그에 쓸 때 필요 합니다. 그러나만 이벤트 로그에서 읽기만 하는 경우는 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A> (으로 서버에서 이벤트 로그에 이미 연결 된 원본이) 속성은 필수입니다. 이벤트 로그에서 읽기만 하는, 다른 오버 로드 생성자의 충분히 사용할 수 있습니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Diagnostics.EventLog>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` 매개 변수입니다.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 매개 변수입니다.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 매개 변수입니다.|  
  
   
  
## Examples  
 다음 예제에서는 "소스가"를 사용 하 여 로컬 컴퓨터에서 "MyNewLog" 이벤트 로그에 엔트리를 씁니다.  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">로그 이름이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">로그 이름이 잘못된 경우  
  
 또는  
  
 컴퓨터 이름이 잘못된 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>양식에서 사용하거나 다른 구성 요소에서 사용하는 <see cref="T:System.Diagnostics.EventLog" />를 초기화합니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼에 또는 다른 구성 요소를 사용 하는 구성 초기화를 시작 합니다. <xref:System.Diagnostics.EventLog.EndInit%2A> 메서드 초기화를 끝냅니다. 사용 하 여 <xref:System.Diagnostics.EventLog.BeginInit%2A> 및 <xref:System.Diagnostics.EventLog.EndInit%2A> 메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" />가 이미 초기화된 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이벤트 로그에서 모든 엔트리를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 로그 항목의 개수를 포함할 수를 결정 하는 최대 크기가 설정 됩니다. 이벤트 로그가 꽉 차면 새 이벤트 정보 기록을 중지 하거나 시작 이전 엔트리를 덮어쓰게 합니다. 이벤트 기록을 중지 한 경우 기존 항목에 대 한 로그를 지우고 이벤트 기록을 다시 시작할 수 있도록 허용 하려면이 메서드를 사용할 수 있습니다. 이벤트 로그 항목의 선택을 취소 하는 로그 상주 하는 컴퓨터에 대 한 관리자 권한이 있어야 합니다.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> 이벤트 로그를 닫고 새 검색 읽기 및 쓰기 핸들을 이벤트 핸들을 해제 이벤트 로그를 다시 열립니다. 기존 이벤트와 함께 메서드를 호출한 후 받은 이벤트 지워지지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 이벤트 로그를 지웁니다.  
  
> [!CAUTION]
>  응용 프로그램, 시스템, 보안 및 기타 사용자 지정이 아닌 로그에, 중요 한 정보가 포함 될 수 있으므로 이 예제 코드를 실행 하기 전에 사용자 지정 로그를 지정 해야 합니다. 사용자 지정 로그를 삭제 하는이 예제 `myNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그가 지워지지 않은 경우  
  
 또는  
  
 로그를 열 수 없는 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 속성에 값이 지정되지 않은 경우. 로그 이름이 빈 문자열이 아닌지 확인하십시오.</exception>
        <exception cref="T:System.InvalidOperationException">로그가 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이벤트 로그를 닫고 읽기 및 쓰기 핸들을 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A> 메서드를 호출 하 여 보호 된 <xref:System.ComponentModel.Component.Dispose%2A> 메서드. 호출할 필요가 없습니다 <xref:System.Diagnostics.EventLog.Close%2A> 호출 하기 전에 <xref:System.ComponentModel.Component.Dispose%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그의 읽기 또는 쓰기 핸들을 해제하지 못한 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>시스템의 특정 로그에 이벤트 정보를 쓸 수 있도록 응용 프로그램을 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">이벤트 원본과 대상 이벤트 로그에 대한 구성 속성입니다.</param>
        <summary>이벤트 소스와 해당 이벤트 로그에 대한 지정된 구성 속성을 사용하여 지역화된 이벤트 메시지를 작성할 올바른 이벤트 소스를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 로컬 컴퓨터나 원격 컴퓨터에서 이벤트 로그에 엔트리를 쓰기 위한 새 소스를 구성할 수 있습니다. 이 메서드를 사용 하 여 이벤트 로그에서 읽을 필요는 없습니다.  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드는 입력을 사용 하 여 `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> 및 <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> 속성을 새 소스 및 관련된 이벤트 로그에 대 한 대상 컴퓨터에서 레지스트리 값을 만듭니다. 새 소스 이름이 기존 원본 이름 또는 대상 컴퓨터에서 기존 이벤트 로그 이름과 일치할 수 없습니다. 경우는 <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> 속성이 설정 되지 않은, 응용 프로그램 이벤트 로그에 대 한 원본이 등록 되어 있습니다. 경우는 <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> 로컬 컴퓨터에 등록 되는 소스를 설정 하지 않으면 합니다.  
  
> [!NOTE]
>  이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 만들려면 관리자 권한이 있어야 합니다.  
>   
>  이 요구 사항에 대 한 이유 보안을 비롯 한 모든 이벤트 로그 이벤트 소스가 고유한 지 확인 하려면 검색 해야입니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException> throw 됩니다.  
>   
>  Windows Vista 이상에서는 사용자 계정 컨트롤 (UAC)는 사용자의 권한을 결정 합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 보안 로그에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 사용 하 여 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 및 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 이벤트 이벤트 로그에 쓰려고 합니다. 이벤트를 작성 하는 이벤트 소스를 지정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 기존 이벤트 로그 또는 새 이벤트 로그에 대 한 이벤트 소스를 만들 수 있습니다. 새 이벤트 로그에 대 한 새 원본을 만들 때 해당 로그에 대 한 소스를 등록 하는 시스템 하지만 첫 번째 항목에 기록할 때 까지는 로그가 만들어지지 않습니다.  
  
 운영 체제 이벤트 로그를 파일로 저장합니다. 사용 하는 경우 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 새 이벤트 로그를 만들려면 연결된 된 파일은 지정된 된 컴퓨터의 %SystemRoot%\System32\Config 디렉터리에 저장 됩니다. 처음 8 자를 추가 하 여 파일 이름이 설정 되는 <xref:System.Diagnostics.EventLog.Log%2A> ".evt" 파일 이름 확장명을 가진 속성입니다.  
  
 각 소스가 한 번에 하나의 이벤트 로그에 쓸 수만 그러나 응용 프로그램 여러 이벤트 로그에 쓸 여러 소스를 사용할 수 있습니다. 예를 들어 응용 프로그램에 다른 이벤트 로그 또는 서로 다른 리소스 파일에 대해 구성 된 여러 소스가 필요할 수 있습니다.  
  
 이벤트 범주, 메시지 문자열에 대 한 지역화 된 리소스 파일에 있는 이벤트 소스를 등록할 수 있습니다. 응용 프로그램 이벤트 로그 항목에서는 실제 문자열을 지정 하지 않고 리소스 식별자를 사용 하 여 쓸 수 있습니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여을 찾아 현재 언어 설정에 따라 지역화 된 리소스 파일에서 해당 문자열을 표시 합니다. 이벤트 범주, 메시지 및 매개 변수 삽입 문자열에 대 한 별도 파일을 등록할 수 있습니다 또는 모든 세 가지 유형의 문자열에 같은 리소스 파일을 등록할 수 있습니다. 사용 하 여는 <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, 및 <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> 원본을 구성 하 여 이벤트 로그에 지역화 된 엔트리를 쓸 속성입니다. 응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰면, 이러한 속성을 설정할 필요가 없습니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
 기존 소스 구성 세부 정보를 변경 하려면 소스를 삭제 하 고 새 구성으로 만듭니다. 다른 응용 프로그램이 나 구성 요소는 기존 소스를 사용 하는 경우 기존 소스를 삭제 하는 대신 업데이트 된 구성으로 새 소스를 만듭니다.  
  
> [!NOTE]
>  소스를 구성 하는 이벤트 로그에 대 한 다른 이벤트 로그에 대 한 다시 구성 하는 경우에 변경 내용을 적용 하려면 컴퓨터를 다시 시작 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 이벤트 소스 이름을 지정 여부를 확인 `SampleApplicationSource` 로컬 컴퓨터에 등록 합니다. 이벤트 소스가 없는 경우이 예제에서는 소스에 대 한 메시지 리소스 파일을 설정 하 고 새 이벤트 소스를 만듭니다. 이 예제에서는 리소스 식별자 값을 사용 하 여 이벤트 로그에 대 한 지역화 된 표시 이름을 설정 하는 마지막으로, `DisplayNameMsgId` 및 리소스 파일 경로에 `messageFile`합니다.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 이 예제에서는 리소스 라이브러리 EventLogMsgs.dll에 기본 제공 되는 다음과 같은 메시지 텍스트 파일을 사용 합니다. 메시지 텍스트 파일은 소스 메시지 리소스 파일이 만들어집니다. 메시지 텍스트 파일의 리소스 식별자와 범주, 이벤트 메시지 및 매개 변수 삽입 문자열에 대 한 텍스트를 정의합니다. 특히, 리소스 식별자 5001이 고 이벤트 로그의 지역화 된 이름에 대해 정의 됩니다.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceData" />에 지정한 컴퓨터 이름이 잘못된 경우  
  
 \- 또는 -  
  
 <paramref name="sourceData" />에 지정된 소스 이름이 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <paramref name="sourceData" />에 지정한 로그 이름이 잘못된 경우. 이벤트 로그 이름은 인쇄할 수 있는 문자로 구성되어야 하며 '*', '?' 또는 '\\'를 사용할 수 없습니다.  
  
 \- 또는 -  
  
 <paramref name="sourceData" />에 지정한 로그 이름을 사용자 로그를 만드는 데 사용할 수 없는 경우. 이벤트 로그 이름 AppEvent, SysEvent 및 SecEvent는 시스템용으로 예약되어 있습니다.  
  
 \- 또는 -  
  
 로그 이름이 기존 이벤트 소스 이름과 일치하는 경우  
  
 \- 또는 -  
  
 <paramref name="sourceData" />에 지정한 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우  
  
 \- 또는 -  
  
 <paramref name="sourceData" />에 지정한 로그 이름의 처음 8개 문자가 고유하지 않은 경우  
  
 \- 또는 -  
  
 <paramref name="sourceData" />에 지정한 소스 이름이 이미 등록된 경우  
  
 \- 또는 -  
  
 <paramref name="sourceData" />에 지정한 소스 이름이 기존 이벤트 로그 이름과 일치하는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">로컬 컴퓨터에 등록되는 응용 프로그램의 원본 이름입니다.</param>
        <param name="logName">소스 엔트리를 쓸 로그의 이름입니다. 가능한 값은 응용 프로그램, 시스템 또는 사용자 지정 이벤트 로그를 포함합니다.</param>
        <summary>로컬 컴퓨터의 로그에 엔트리를 쓰는 유효한 이벤트 소스로 지정된 소스 이름을 설정합니다. 또한 이 방법을 사용하면 로컬 컴퓨터에 새로운 사용자 지정 로그를 만들 수도 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 사용자 지정 로그를 만들도록 하거나 만들고 등록 하는 <xref:System.Diagnostics.EventLog.Source%2A> 로컬 컴퓨터에 있는 기존 로그 합니다.  
  
 경우 `logName` 은 `null` 또는 빈 문자열 ("")를 호출 하면 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, 응용 프로그램 로그에 로그는 기본적 합니다. 로그는 로컬 컴퓨터에 없는 경우 시스템 사용자 지정 로그를 만들고 응용 프로그램으로 등록 한 <xref:System.Diagnostics.EventLog.Source%2A> 해당 로그에 대 한 합니다.  
  
> [!NOTE]
>  이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 만들려면 관리자 권한이 있어야 합니다.  
>   
>  이 요구 사항에 대 한 이유 보안을 비롯 한 모든 이벤트 로그 이벤트 소스가 고유한 지 확인 하려면 검색 해야입니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException> throw 됩니다.  
>   
>  Windows Vista 이상에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 보안 로그에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 이벤트 로그에 작성 하는 경우 이벤트 소스를 생성 하기만 하면 됩니다. 이벤트 로그에 엔트리를 쓰기 전에 유효한 이벤트 소스로 이벤트 로그와 이벤트 소스를 등록 해야 있습니다. 시스템에 사용 하 여 로그 항목을 작성 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 입력 한 내용을 배치할 수 있는 적절 한 로그를 찾을 수 있습니다. 읽는 경우 이벤트 로그를 지정 하거나는 <xref:System.Diagnostics.EventLog.Source%2A>, 또는 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A>합니다.  
  
> [!NOTE]
>  지정할 필요가 없습니다는 <xref:System.Diagnostics.EventLog.MachineName%2A> 로그는 로컬 컴퓨터에 연결 하는 경우. 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 를 읽을 때 로그를 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 사용 하 여 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 및 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 이벤트 이벤트 로그에 쓰려고 합니다. 이벤트를 작성 하는 이벤트 소스를 지정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 기존 이벤트 로그 또는 새 이벤트 로그에 대 한 이벤트 소스를 만들 수 있습니다. 새 이벤트 로그에 대 한 새 원본을 만들 때 해당 로그에 대 한 소스를 등록 하는 시스템 하지만 첫 번째 항목에 기록할 때 까지는 로그가 만들어지지 않습니다.  
  
 운영 체제 이벤트 로그를 파일로 저장합니다. 사용 하는 경우 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 새 이벤트 로그를 만들려면 연결된 된 파일은 지정된 된 컴퓨터의 %SystemRoot%\System32\Config 디렉터리에 저장 됩니다. 처음 8 자를 추가 하 여 파일 이름이 설정 되는 <xref:System.Diagnostics.EventLog.Log%2A> ".evt" 파일 이름 확장명을 가진 속성입니다.  
  
 소스는 로컬 컴퓨터에서 고유 해야 합니다. 새 소스 이름이 기존 원본 이름 또는 기존 이벤트 로그 이름과 일치할 수 없습니다. 각 소스; 한 번에 하나의 이벤트 로그에 쓸 수 있습니다. 그러나 응용 프로그램 여러 이벤트 로그에 쓸 여러 소스를 사용할 수 있습니다. 예를 들어 응용 프로그램에 다른 이벤트 로그 또는 서로 다른 리소스 파일에 대해 구성 된 여러 소스가 필요할 수 있습니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
 기존 소스 구성 세부 정보를 변경 하려면 소스를 삭제 하 고 새 구성으로 만듭니다. 다른 응용 프로그램이 나 구성 요소는 기존 소스를 사용 하는 경우 기존 소스를 삭제 하는 대신 업데이트 된 구성으로 새 소스를 만듭니다.  
  
> [!NOTE]
>  원본 로그에 이미 매핑 되었습니다에서 새 로그에 다시 배치 하는 경우에 변경 내용을 적용 하려면 컴퓨터를 다시 시작 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 이미 존재 하지 않는 하 고 이벤트 로그에 항목을 기록 하는 경우 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" />가 빈 문자열("")이나 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <paramref name="logName" />이 올바른 이벤트 로그 이름이 아닌 경우. 이벤트 로그 이름은 인쇄할 수 있는 문자로 구성되어야 하며 '*', '?' 또는 '\\'를 사용할 수 없습니다.  
  
 \- 또는 -  
  
 <paramref name="logName" />은 사용자 로그 작성에 유효하지 않습니다. 이벤트 로그 이름 AppEvent, SysEvent 및 SecEvent는 시스템용으로 예약되어 있습니다.  
  
 \- 또는 -  
  
 로그 이름이 기존 이벤트 소스 이름과 일치하는 경우  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우  
  
 \- 또는 -  
  
 <paramref name="logName" />의 처음 8개 문자가 기존 이벤트 로그 이름의 처음 8개 문자와 일치하는 경우  
  
 \- 또는 -  
  
 소스가 이미 로컬 컴퓨터에 있기 때문에 해당 소스를 등록할 수 없는 경우  
  
 \- 또는 -  
  
 소스 이름이 기존 이벤트 로그 이름과 일치하는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 로컬 컴퓨터에서 열 수 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">지정한 컴퓨터에 등록되는 응용 프로그램의 원본입니다.</param>
        <param name="logName">소스 엔트리를 쓸 로그의 이름입니다. 가능한 값은 응용 프로그램, 시스템 또는 사용자 지정 이벤트 로그를 포함합니다. 값을 지정하지 않은 경우 <c>logName</c>이 응용 프로그램에 대한 기본값으로 설정됩니다.</param>
        <param name="machineName">이 이벤트 원본을 등록할 컴퓨터의 이름입니다. 로컬 컴퓨터의 경우에는 "."입니다.</param>
        <summary>지정된 컴퓨터의 로그에 엔트리를 쓰는 유효한 이벤트 소스로 지정된 소스 이름을 설정합니다. 또한 이 방법을 사용하면 지정한 컴퓨터에 새로운 사용자 지정 로그를 만들 수도 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 사용자 지정 로그를 만들도록 하거나 만들고 등록 하는 <xref:System.Diagnostics.EventLog.Source%2A> 지정된 된 컴퓨터에 있는 기존 로그 합니다.  
  
 경우 `logName` 은 `null` 또는 빈 문자열 ("")를 호출 하면 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, 응용 프로그램 로그에 로그는 기본적 합니다. 지정된 된 컴퓨터에서 로그가 없는 경우 시스템 사용자 지정 로그를 만들고 응용 프로그램으로 등록 한 <xref:System.Diagnostics.EventLog.Source%2A> 해당 로그에 대 한 합니다.  
  
 이벤트 로그에 작성 하는 경우 이벤트 소스를 생성 하기만 하면 됩니다. 이벤트 로그에 엔트리를 쓰기 전에 유효한 이벤트 소스로 이벤트 로그와 이벤트 소스를 등록 해야 있습니다. 시스템에 사용 하 여 로그 항목을 작성 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 입력 한 내용을 배치할 수 있는 적절 한 로그를 찾을 수 있습니다. 읽는 경우 이벤트 로그를 지정 하거나는 <xref:System.Diagnostics.EventLog.Source%2A>, 또는 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A>합니다.  
  
> [!NOTE]
>  이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 만들려면 관리자 권한이 있어야 합니다.  
>   
>  이 요구 사항에 대 한 이유 보안을 비롯 한 모든 이벤트 로그 이벤트 소스가 고유한 지 확인 하려면 검색 해야입니다. 보안 로그;에 액세스할 수 있는 권한을 Windows Vista 이상 버전에서는 사용자 권한이 없습니다. 따라서 한 <xref:System.Security.SecurityException> throw 됩니다.  
>   
>  Windows Vista 이상에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 보안 로그에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 사용 하 여 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 및 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 이벤트 이벤트 로그에 쓰려고 합니다. 이벤트를 작성 하는 이벤트 소스를 지정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 기존 이벤트 로그 또는 새 이벤트 로그에 대 한 이벤트 소스를 만들 수 있습니다. 새 이벤트 로그에 대 한 새 원본을 만들 때 해당 로그에 대 한 소스를 등록 하는 시스템 하지만 첫 번째 항목에 기록할 때 까지는 로그가 만들어지지 않습니다.  
  
 운영 체제 이벤트 로그를 파일로 저장합니다. 사용 하는 경우 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 새 이벤트 로그를 만들려면 연결된 된 파일은 지정된 된 컴퓨터의 %SystemRoot%\System32\Config 디렉터리에 저장 됩니다. 처음 8 자를 추가 하 여 파일 이름이 설정 되는 <xref:System.Diagnostics.EventLog.Log%2A> ".evt" 파일 이름 확장명을 가진 속성입니다.  
  
 소스는 로컬 컴퓨터에서 고유 해야 합니다. 새 소스 이름이 기존 원본 이름 또는 기존 이벤트 로그 이름과 일치할 수 없습니다. 각 소스; 한 번에 하나의 이벤트 로그에 쓸 수 있습니다. 그러나 응용 프로그램 여러 이벤트 로그에 쓸 여러 소스를 사용할 수 있습니다. 예를 들어 응용 프로그램에 다른 이벤트 로그 또는 서로 다른 리소스 파일에 대해 구성 된 여러 소스가 필요할 수 있습니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
 기존 소스 구성 세부 정보를 변경 하려면 소스를 삭제 하 고 새 구성으로 만듭니다. 다른 응용 프로그램이 나 구성 요소는 기존 소스를 사용 하는 경우 기존 소스를 삭제 하는 대신 업데이트 된 구성으로 새 소스를 만듭니다.  
  
> [!NOTE]
>  원본 로그에 이미 매핑 되었습니다에서 새 로그에 다시 배치 하는 경우에 변경 내용을 적용 하려면 컴퓨터를 다시 시작 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 컴퓨터에서 `MyServer`, 이벤트 로그에 항목을 씁니다 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" />이 올바른 컴퓨터 이름이 아닌 경우  
  
 \- 또는 -  
  
 <paramref name="source" />가 빈 문자열("")이나 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <paramref name="logName" />이 올바른 이벤트 로그 이름이 아닌 경우. 이벤트 로그 이름은 인쇄할 수 있는 문자로 구성되어야 하며 '*', '?' 또는 '\\'를 사용할 수 없습니다.  
  
 \- 또는 -  
  
 <paramref name="logName" />은 사용자 로그 작성에 유효하지 않습니다. 이벤트 로그 이름 AppEvent, SysEvent 및 SecEvent는 시스템용으로 예약되어 있습니다.  
  
 \- 또는 -  
  
 로그 이름이 기존 이벤트 소스 이름과 일치하는 경우  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우  
  
 \- 또는 -  
  
 <paramref name="logName" />의 처음 8개 문자가 지정된 컴퓨터에 있는 기존 이벤트 로그 이름의 처음 8개 문자와 일치하는 경우  
  
 \- 또는 -  
  
 소스가 이미 지정한 컴퓨터에 있기 때문에 해당 소스를 등록할 수 없는 경우  
  
 \- 또는 -  
  
 소스 이름이 기존 이벤트 소스 이름과 일치하는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 지정한 컴퓨터에서 열 수 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>로그 리소스를 제거합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">삭제할 로그의 이름입니다. 이 이름에는 응용 프로그램, 보안, 시스템 또는 컴퓨터의 모든 사용자 지정 이벤트 로그를 사용할 수 있습니다.</param>
        <summary>로컬 컴퓨터에서 이벤트 로그를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 삭제 하려는 로그는 로컬 컴퓨터에 있으면이 메서드를 사용 합니다. 적절 한 레지스트리 사용 권한이 있는 경우에 컴퓨터에 있는 모든 로그를 삭제할 수 있습니다.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 지정 된 로그 제거 `logName` 로컬 컴퓨터에서 합니다. 삭제 하려는 경우 로그에는 소스에만 등록, 호출 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>합니다. 로그 항목을 삭제 하려는 경우에 호출 <xref:System.Diagnostics.EventLog.Clear%2A>합니다. <xref:System.Diagnostics.EventLog.Delete%2A> 및 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 는 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다. 새 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog> 메서드 중 하나를 호출 합니다.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 메서드는 로그의 내용을 포함 하는 파일을 먼저 삭제 합니다. 그런 다음 레지스트리에 액세스 하 고 해당 로그에 대해 등록 된 모든 이벤트 소스를 제거 합니다. 나중에 로그를 다시 만드는 경우 등록 이벤트 소스 마찬가지로 다시 사용 하려는 경우. 이벤트 소스를 등록 하지 않으면 로그 이름을 지정 하지 않고 이벤트 소스에 다른 사용자가 작성 하는 경우 응용 프로그램 이벤트 로그에서 이벤트 소스가 만들어질 수 있습니다. 따라서 응용 프로그램 삭제 하 고 다시 로그에 엔트리를 쓸 수 있었던는 쓰지 응용 프로그램 로그에 대신 이제 이벤트 소스를 포함 하기 때문에 합니다.  
  
> [!NOTE]
>  이벤트 로그를 다시 만드는 과정은 어려울 수 있습니다. 응용 프로그램 로그와 같은 시스템에서 만든 이벤트 로그를 삭제 하지 마십시오.  
  
 호출을 통해 로그를 삭제 <xref:System.Diagnostics.EventLog.Delete%2A> 해당 로그에 등록 된 소스를 자동으로 삭제 합니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에서 로그를 삭제 합니다. 이 예제에서는 소스에서 로그를 확인 합니다.  
  
> [!NOTE]
>  둘 이상의 소스 프로그램 이벤트 로그에 쓸 수 있습니다. 사용자 지정 로그를 삭제 하기 전에 해당 로그에 쓰는 다른 소스가 없는지 확인 합니다.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" />가 빈 문자열("")이나 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 로컬 컴퓨터에서 열 수 없는 경우  
  
 \- 또는 -  
  
 로컬 컴퓨터에 로그가 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그가 지워지지 않은 경우  
  
 또는  
  
 로그를 열 수 없는 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">삭제할 로그의 이름입니다. 이 이름에는 응용 프로그램, 보안, 시스템 또는 지정한 컴퓨터의 모든 사용자 지정 이벤트 로그를 사용할 수 있습니다.</param>
        <param name="machineName">로그를 삭제할 컴퓨터의 이름입니다. 로컬 컴퓨터의 경우에는 "."입니다.</param>
        <summary>지정한 컴퓨터에서 이벤트 로그를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 삭제 하려는 로그는 원격 컴퓨터에 있으면이 메서드를 사용 합니다. 적절 한 레지스트리 사용 권한이 있는 경우에 컴퓨터에 있는 모든 로그를 삭제할 수 있습니다.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 지정 된 로그 제거 `logName` 에 지정 된 컴퓨터에서 `machineName`합니다. 삭제 하려는 경우 로그에는 소스에만 등록, 호출 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>합니다. 로그 항목을 삭제 하려는 경우에 호출 <xref:System.Diagnostics.EventLog.Clear%2A>합니다. <xref:System.Diagnostics.EventLog.Delete%2A> 및 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 는 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다. 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog> 메서드 중 하나를 호출 합니다.  
  
 이 메서드는 먼저 로그의 내용을 포함 하는 파일을 삭제 합니다. 그런 다음 레지스트리에 액세스 하 고 해당 로그에 대해 등록 된 모든 이벤트 소스를 제거 합니다. 나중에 로그를 다시 만드는 경우 등록 이벤트 소스 마찬가지로 다시 사용 하려는 경우. 이벤트 소스를 등록 하지 않으면 로그 이름을 지정 하지 않고 이벤트 소스에 다른 사용자가 작성 하는 경우 응용 프로그램 이벤트 로그에서 이벤트 소스가 만들어질 수 있습니다. 따라서 응용 프로그램 삭제 하 고 다시 로그에 엔트리를 쓸 수 있었던는 쓰지 응용 프로그램 로그에 대신 이제 이벤트 소스를 포함 하기 때문에 합니다.  
  
> [!NOTE]
>  이벤트 로그를 다시 만드는 과정은 어려울 수 있습니다. 응용 프로그램 로그와 같은 시스템에서 만든 이벤트 로그를 삭제 하지 마십시오.  
  
 호출을 통해 로그를 삭제 <xref:System.Diagnostics.EventLog.Delete%2A> 해당 로그에 등록 된 소스를 자동으로 삭제 합니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 컴퓨터에서 로그를 삭제 합니다. 이 예제에서는 소스에서 로그를 확인 합니다.  
  
> [!NOTE]
>  둘 이상의 소스 프로그램 이벤트 로그에 쓸 수 있습니다. 사용자 지정 로그를 삭제 하기 전에 해당 로그에 쓰는 다른 소스가 없는지 확인 합니다.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" />가 빈 문자열("")이나 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <paramref name="machineName" />이 올바른 컴퓨터 이름이 아닌 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 지정한 컴퓨터에서 열 수 없는 경우  
  
 \- 또는 -  
  
 지정된 컴퓨터에 로그가 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그가 지워지지 않은 경우  
  
 또는  
  
 로그를 열 수 없는 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이벤트 로그에서 응용 프로그램의 이벤트 소스 등록을 제거합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">이벤트 로그 시스템에 등록된 응용 프로그램 이름입니다.</param>
        <summary>로컬 컴퓨터의 이벤트 로그에서 이벤트 소스 등록을 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여의 등록을 제거 하는 <xref:System.Diagnostics.EventLog.Source%2A> 로컬 컴퓨터에서 합니다. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 로컬 컴퓨터에서 레지스트리에 액세스 하 고 유효한 이벤트 소스로 응용 프로그램의 등록을 제거 합니다.  
  
 해당 로그에 엔트리를 쓸 더 이상 필요할 경우 유효한 이벤트 소스로 구성 요소를 제거할 수 없습니다. 예를 들어 하나의 로그에서 다른 구성 요소를 변경 해야 할 경우이 작업을 수행 될 수 있습니다. 소스 한 번에 하나의 로그만 등록할 수 있습니다, 때문에 로그를 변경 하려면 현재 등록을 제거 합니다.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 로그에 등록 하는 소스만 제거 합니다. 로그 자체를 제거 하려는 경우에 호출 <xref:System.Diagnostics.EventLog.Delete%2A>합니다. 로그 항목을 삭제 하려는 경우에 호출 <xref:System.Diagnostics.EventLog.Clear%2A>합니다. <xref:System.Diagnostics.EventLog.Delete%2A> 및 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 는 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다. 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog> 메서드 중 하나를 호출 합니다.  
  
 호출을 통해 로그를 삭제 <xref:System.Diagnostics.EventLog.Delete%2A> 해당 로그에 등록 된 소스를 자동으로 삭제 합니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다.  
  
> [!NOTE]
>  원본 로그에 이미 매핑 되었습니다에서 새 로그에 다시 배치 하는 경우에 변경 내용을 적용 하려면 컴퓨터를 다시 시작 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에서 소스를 삭제 합니다. 이 예제에서는 해당 원본에서 로그를 확인 한 다음 로그를 삭제 합니다.  
  
> [!NOTE]
>  둘 이상의 소스 프로그램 이벤트 로그에 쓸 수 있습니다. 사용자 지정 로그를 삭제 하기 전에 해당 로그에 쓰는 다른 소스가 없는지 확인 합니다.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 매개 변수가 로컬 컴퓨터의 레지스트리에 없는 경우  
  
 \- 또는 -  
  
 이벤트 로그의 레지스트리 키에 대한 쓰기 권한이 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">이벤트 로그 시스템에 등록된 응용 프로그램 이름입니다.</param>
        <param name="machineName">등록을 제거할 컴퓨터의 이름입니다. 로컬 컴퓨터의 경우에는 "."입니다.</param>
        <summary>지정한 컴퓨터에서 응용 프로그램의 이벤트 소스 등록을 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여의 등록을 제거 하는 <xref:System.Diagnostics.EventLog.Source%2A> 원격 컴퓨터에서 합니다. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 에 지정 된 컴퓨터의 레지스트리에 액세스 `machineName` 유효한 이벤트 소스로 응용 프로그램의 등록을 제거 합니다.  
  
 해당 로그에 엔트리를 쓸 더 이상 필요할 경우 유효한 이벤트 소스로 구성 요소를 제거할 수 없습니다. 예를 들어 하나의 로그에서 다른 구성 요소를 변경 해야 할 경우이 작업을 수행 될 수 있습니다. 소스 한 번에 하나의 로그만 등록할 수 있습니다, 때문에 로그를 변경 하려면 현재 등록을 제거 합니다.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 로그에 등록 하는 소스만 제거 합니다. 로그 자체를 제거 하려는 경우에 호출 <xref:System.Diagnostics.EventLog.Delete%2A>합니다. 로그 항목을 삭제 하려는 경우에 호출 <xref:System.Diagnostics.EventLog.Clear%2A>합니다. <xref:System.Diagnostics.EventLog.Delete%2A> 및 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 는 `static` 메서드 이므로 클래스 자체에 호출할 수 있습니다. 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog> 메서드 중 하나를 호출 합니다.  
  
 호출을 통해 로그를 삭제 <xref:System.Diagnostics.EventLog.Delete%2A> 해당 로그에 등록 된 소스를 자동으로 삭제 합니다. 이 작동 하 여 로그를 사용 하 여 다른 응용 프로그램 해질 수 있습니다.  
  
> [!NOTE]
>  원본 로그에 이미 매핑 되었습니다에서 새 로그에 다시 배치 하는 경우에 변경 내용을 적용 하려면 컴퓨터를 다시 시작 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 컴퓨터에서 소스를 삭제 합니다. 이 예제에서는 해당 원본에서 로그를 확인 한 다음 로그를 삭제 합니다.  
  
> [!NOTE]
>  둘 이상의 소스 프로그램 이벤트 로그에 쓸 수 있습니다. 사용자 지정 로그를 삭제 하기 전에 해당 로그에 쓰는 다른 소스가 없는지 확인 합니다.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 매개 변수가 잘못된 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 매개 변수가 지정한 컴퓨터의 레지스트리에 없는 경우  
  
 \- 또는 -  
  
 이벤트 로그의 레지스트리 키에 대한 쓰기 권한이 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          레지스트리에서 <paramref name="source" />에 대한 부모 레지스트리 키에 같은 이름의 하위 키가 없기 때문에 <paramref name="source" />를 삭제할 수 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 public `Dispose()` 메서드 및 <xref:System.Object.Finalize%2A> 메서드. `Dispose()` 보호 된 호출 `Dispose(Boolean)` 메서드는 `disposing` 매개 변수 설정 `true`합니다. <xref:System.Object.Finalize%2A> 호출 `Dispose` 와 `disposing` 로 설정 `false`합니다.  
  
 경우는 `disposing` 매개 변수가 true 이면이 메서드는 관리 개체가 보유 하는 모든 리소스를 해제 합니다.이 <xref:System.Diagnostics.EventLog> 참조 합니다. 이 메서드는 참조되는 각 개체의 `Dispose()` 메서드를 호출합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" />는 다른 개체에서 여러 번 호출할 수 있습니다. 재정의 하는 경우 <see langword="Dispose(Boolean)" /> 이전 호출에서 삭제 된 개체를 참조 하지 않도록 주의 <see langword="Dispose" />합니다. 구현 하는 방법에 대 한 자세한 내용은 <see langword="Dispose(Boolean)" />, 참조 [Dispose 메서드를 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
 에 대 한 자세한 내용은 <see langword="Dispose" /> 및 <see cref="M:System.Object.Finalize" />, 참조 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md)합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" />가 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 이벤트 알림을 받는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          로그에 항목을 쓸 때 <see cref="T:System.Diagnostics.EventLog" />에서 알림을 받으면 <see langword="true" />이고, 받지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 속성 결정 여부는 <xref:System.Diagnostics.EventLog> 항목이 로그에 기록 되 면 이벤트를 발생 합니다. 속성이 `true`를 수신 하는 구성 요소는 <xref:System.Diagnostics.EventLog.EntryWritten> 이벤트 알림이 언제 든 지 항목에 지정 된 로그에 기록 됩니다는 <xref:System.Diagnostics.EventLog.Log%2A> 속성입니다. 경우 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 은 `false`, 이벤트가 발생 합니다.  
  
> [!NOTE]
>  로컬 컴퓨터에 엔트리를 쓸 경우에 이벤트 알림을 받을 수 있습니다. 원격 컴퓨터에서 기록 된 항목에 대 한 알림을 받을 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 핸들은 <xref:System.Diagnostics.EventLog.EntryWritten> 이벤트입니다.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이벤트 로그가 원격 컴퓨터에 있는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>양식에서 사용하거나 다른 구성 요소에서 사용하는 <see cref="T:System.Diagnostics.EventLog" />의 초기화를 끝냅니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼에 또는 다른 구성 요소를 사용 하는 구성 초기화를 끝냅니다. <xref:System.Diagnostics.EventLog.BeginInit%2A> 메서드 초기화를 시작 합니다. 사용 하는 <xref:System.Diagnostics.EventLog.BeginInit%2A> 및 <xref:System.Diagnostics.EventLog.EndInit%2A> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이벤트 로그의 내용을 가져옵니다.</summary>
        <value>이벤트 로그에서 항목을 유지하는 <see cref="T:System.Diagnostics.EventLogEntryCollection" />입니다. 각 항목은 <see cref="T:System.Diagnostics.EventLogEntry" /> 클래스의 인스턴스에 연결됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Diagnostics.EventLog.Entries%2A> 이벤트 로그에서 읽을 때 멤버입니다.  
  
 항목을 수정 하거나 사용 하 여 로그에 쓸 수 없습니다 속성이 읽기 전용 이므로 <xref:System.Diagnostics.EventLog.Entries%2A>합니다. 대신, 지정는 <xref:System.Diagnostics.EventLog.Source%2A> 호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 새 로그 엔트리를 씁니다. 사용할 수 있습니다 <xref:System.Diagnostics.EventLog.Entries%2A> 하 고 이벤트 로그의 항목 수를 계산 하 고 각 볼 <xref:System.Diagnostics.EventLogEntry> 컬렉션에 있습니다. 사용 하 여 인덱싱된 <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> 같은 특정 항목에 대 한 정보를 검색 하려면 멤버 <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, 또는 <xref:System.Diagnostics.EventLogEntry.EntryType%2A>합니다.  
  
 지정할 필요는 없습니다는 <xref:System.Diagnostics.EventLog.Source%2A> 로그에서 읽기만 할 경우. 만 지정할 수는 <xref:System.Diagnostics.EventLog.Log%2A> 이름 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 에 대 한 속성 (서버 컴퓨터 이름)는 <xref:System.Diagnostics.EventLog> 인스턴스. 두 경우 모두는 <xref:System.Diagnostics.EventLog.Entries%2A> 멤버 항목의 이벤트 로그의 목록에 자동으로 채워집니다. 개별 항목을 읽을 수는이 목록의 항목에 대 한 적절 한 인덱스를 선택할 수 있습니다.  
  
 중요 한 차이 읽기 및 쓰기 로그 항목 읽기 메서드를 명시적으로 호출 하는 데 필요한 된다는 점입니다. 이후에 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 지정 된는 <xref:System.Diagnostics.EventLog.Entries%2A> 속성이 자동으로 채워집니다. 값을 변경 하는 경우는 <xref:System.Diagnostics.EventLog.Log%2A> 또는 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성에는 <xref:System.Diagnostics.EventLog.Entries%2A> 속성 읽은 다음에 다시 채워야 합니다.  
  
> [!NOTE]
>  지정할 필요가 없습니다는 <xref:System.Diagnostics.EventLog.MachineName%2A> 로그에 연결 하는 경우. 지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 "."를 가정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 이벤트 로그에 "MyNewLog" 로컬 컴퓨터에서 엔트리를 읽습니다.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로컬 컴퓨터에 있는 이벤트 로그에 엔트리를 쓸 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 알림을 하려면 설정 해야 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 를 `true`합니다. 로컬 컴퓨터에 엔트리를 쓸 경우에 이벤트 알림을 받을 수 있습니다. 원격 컴퓨터에서 기록 된 항목에 대 한 알림을 받을 수 없습니다.  
  
 <xref:System.Diagnostics.EventLog.EntryWritten> 대리자를 만드는 경우 이벤트를 처리할 메서드를 결정합니다. 이벤트를 이벤트 처리기와 연결하려면 대리자의 인스턴스를 해당 이벤트에 추가합니다. 대리자를 제거 하기 전 까지는 이벤트가 발생할 때마다 이벤트 처리기가 호출 됩니다. 대리자와 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 시스템에 응답 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 마지막 쓰기 이벤트 6 초 이상 이전에 발생 한 경우에 합니다. 이 인해 수신만 <xref:System.Diagnostics.EventLog.EntryWritten> 6 초 간격 내에서 이벤트 알림이 하나 이상의 이벤트 로그 변경 하는 경우에 발생 합니다. 호출 사이 충분히 긴 대기 간격 (약 10 초)을 삽입 하는 경우 <xref:System.Diagnostics.EventLog.WriteEntry%2A>는 이벤트를 놓칠 가능성이 더 낮아집니다. 그러나 쓰기 이벤트가 더 자주 발생 이벤트 알림이 다음 간격까지 표시 되지 않을 수도 있습니다. 일반적으로 누락 된 이벤트 알림은 되지 손실, 하지만 지연 합니다.  
  
   
  
## Examples  
 다음 예제에서는 항목 쓰기 이벤트를 처리 합니다.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 로그가 있는지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">검색할 로그의 이름입니다. 이 이름에는 응용 프로그램, 보안, 시스템, 기타 응용 프로그램 관련 로그(예: Active Directory와 연결된 로그) 또는 컴퓨터에 있는 모든 사용자 지정 로그를 사용할 수 있습니다.</param>
        <summary>로컬 컴퓨터에 로그가 있는지를 확인합니다.</summary>
        <returns>
          로컬 컴퓨터에 로그가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로컬 컴퓨터에 로그가 있는지를 확인 하려면이 메서드를 사용 합니다. 소스 사용 하 여 로컬 컴퓨터에 있는지 확인 하려면 <xref:System.Diagnostics.EventLog.SourceExists%2A>합니다.  
  
 이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 로컬 컴퓨터에 있어야 그렇지 않은 경우 쿼리에서 반환 `false`합니다.  
  
 동일한 컴퓨터에 새 로그에 기존 로그의 이름을 지정할 수 없습니다, 때문에이 메서드를 만들기 전에 사용 새 로그를 확인 하는 경우 지정 된 `logName` 로컬 컴퓨터에 이미 있습니다. `logName` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 이 `static` 메서드, 클래스 자체에 호출할 수 있습니다. 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog> 호출할 <xref:System.Diagnostics.EventLog.Exists%2A>합니다.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName이 <see langword="null" />이거나 값이 비어 있는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">검색할 로그입니다. 이 이름에는 응용 프로그램, 보안, 시스템, 기타 응용 프로그램 관련 로그(예: Active Directory와 연결된 로그) 또는 컴퓨터에 있는 모든 사용자 지정 로그를 사용할 수 있습니다.</param>
        <param name="machineName">로그를 검색할 컴퓨터의 이름입니다. 로컬 컴퓨터의 경우 "."입니다.</param>
        <summary>지정한 컴퓨터에 로그가 있는지를 확인합니다.</summary>
        <returns>
          지정한 컴퓨터에 로그가 있으면 <see langword="true" />이고, 없으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 원격 컴퓨터에 로그가 있는지를 확인 합니다. 소스를 사용 하 여 원격 컴퓨터에 있는지 여부를 확인 하려는 경우 <xref:System.Diagnostics.EventLog.SourceExists%2A>합니다.  
  
 이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 지정한 컴퓨터에 있어야 그렇지 않은 경우 쿼리에서 반환 `false`합니다.  
  
 동일한 컴퓨터에 새 로그에 기존 로그의 이름을 지정할 수 없습니다, 때문에이 메서드를 만들기 전에 사용 새 로그를 확인 한 경우 지정 된 `logName` 에서 지정한 서버에 이미는 `machineName` 매개 변수입니다. `logName` 및 `machineName` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 이 `static` 메서드, 클래스 자체에 호출할 수 있습니다. 새 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog> 호출할 <xref:System.Diagnostics.EventLog.Exists%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">잘못된 형식의 <paramref name="machineName" /> 매개 변수인 경우. 검색할 컴퓨터에 적절한 구문을 사용했는지 확인하십시오.  
  
 또는  
  
 <paramref name="logName" />이 <see langword="null" />이거나 값이 비어 있는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이벤트 로그의 배열을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>로컬 컴퓨터에서 모든 이벤트 로그를 검색하여 목록을 포함하는 <see cref="T:System.Diagnostics.EventLog" /> 개체의 배열을 만듭니다.</summary>
        <returns>로컬 컴퓨터의 로그를 나타내는 <see cref="T:System.Diagnostics.EventLog" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열 <xref:System.Diagnostics.EventLog> 개체는 로컬 컴퓨터에서 모든 이벤트 로그의 스냅숏을 때 호출 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> 이루어집니다. 이 아니므로 동적 컬렉션을 삭제 나 로그를 실시간으로 생성은 반영 하지 않습니다. 배열에 있는 로그를 읽거나 쓰려고 전에 존재 하는지 확인 해야 합니다. 배열에는 일반적으로 로그를 3 개 이상 포함: 응용 프로그램, 시스템 및 보안 합니다. 로컬 컴퓨터에 사용자 지정 로그를 만든 경우의 배열에도 표시 됩니다.  
  
 이벤트 로그의 목록을 검색 하려면 적절 한 레지스트리 사용 권한이 있어야 합니다. 이러한 권한은 동일 하 게 호출 하는 데 필요한 <xref:System.Diagnostics.EventLog.Exists%2A> 및 <xref:System.Diagnostics.EventLog.SourceExists%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에 정의 된 이벤트 로그를 열거 하 고 각 이벤트 로그에 대 한 구성 세부 정보를 표시 합니다.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">레지스트리에 대한 읽기 권한이 없는 경우  
  
 또는  
  
 컴퓨터에 이벤트 로그 서비스가 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">이벤트 로그를 검색할 컴퓨터입니다.</param>
        <summary>지정한 컴퓨터에서 모든 이벤트 로그를 검색하여 목록을 포함하는 <see cref="T:System.Diagnostics.EventLog" /> 개체의 배열을 만듭니다.</summary>
        <returns>지정한 컴퓨터의 로그를 나타내는 <see cref="T:System.Diagnostics.EventLog" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열 <xref:System.Diagnostics.EventLog> 개체는에 지정 된 컴퓨터에서 모든 이벤트 로그의 스냅숏을 `machineName` 매개 변수 때 호출 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> 이루어집니다. 이 아니므로 동적 컬렉션을 삭제 나 로그를 실시간으로 생성은 반영 하지 않습니다. 배열에 있는 로그를 읽거나 쓰려고 전에 존재 하는지 확인 해야 합니다. 배열에는 일반적으로 로그를 3 개 이상 포함: 응용 프로그램, 시스템 및 보안 합니다. 지정된 된 컴퓨터에서 사용자 지정 로그를 만든 경우의 배열에도 표시 됩니다.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> 이 `static` 메서드를 호출 될 수는 <xref:System.Diagnostics.EventLog> 클래스 자체입니다. 인스턴스를 만들 필요는 없습니다는 <xref:System.Diagnostics.EventLog> 메서드를 호출 하는 개체입니다.  
  
 이벤트 로그의 목록을 검색 하려면 적절 한 레지스트리 사용 권한이 있어야 합니다. 이러한 권한은 동일 하 게 호출 하는 데 필요한 <xref:System.Diagnostics.EventLog.Exists%2A> 및 <xref:System.Diagnostics.EventLog.SourceExists%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 "myServer" 컴퓨터에서 로그 목록을 가져옵니다. 그런 다음 각 로그의 이름을 출력 합니다.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 매개 변수가 잘못된 컴퓨터 이름인 경우</exception>
        <exception cref="T:System.InvalidOperationException">레지스트리에 대한 읽기 권한이 없는 경우  
  
 또는  
  
 컴퓨터에 이벤트 로그 서비스가 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>읽거나 쓸 로그의 이름을 가져오거나 설정합니다.</summary>
        <value>로그의 이름입니다. 이 이름에는 응용 프로그램, 시스템, 보안 또는 사용자 지정 로그 이름을 사용할 수 있습니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 3 개의 로그 파일 서버에서 기본적으로 존재: 응용 프로그램, 시스템 및 보안 합니다. 응용 프로그램 및 서비스 응용 프로그램 로그 파일을 사용 합니다. 장치 드라이버는 시스템 로그 파일을 사용합니다. 성공 및 실패 감사 이벤트는 감사 상태에서 보안 로그에 생성 됩니다. 설치 된 Windows 서버에서 Active Directory와 같은 다른 응용 프로그램의 경우 다른 기본 로그 파일이 있을 수 있습니다. 또한 로컬 또는 원격 컴퓨터에서 사용자 지정 로그 파일을 만들 수 있습니다. 사용자 지정 로그를 사용 중인 구성 요소는 기본 응용 프로그램 로그에 이벤트를 기록 하는 경우 허용 된 것 보다 더 자세한 방식에서 엔트리를 구성할 수 있습니다.  
  
> [!NOTE]
>  로그 이름은를 8 자로 제한 됩니다. 체계에 따라 MyLogSample1 및 MyLogSample2 동일한 로그는입니다.  
  
 이벤트 로그에 작성 하는 경우 것 만으로는 부족 지정 하는 <xref:System.Diagnostics.EventLog.Log%2A> 속성입니다. 연결 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 특정 로그에 연결할 이벤트 로그 리소스를 사용 하 여 속성입니다. 지정할 필요는 없습니다는 <xref:System.Diagnostics.EventLog.Source%2A> 로그에 있지만 이벤트 소스에서 읽기만 서버의 레지스트리에 이벤트 로그 리소스와 연결 해야 경우. 만 지정할 수는 <xref:System.Diagnostics.EventLog.Log%2A> 이름 및 <xref:System.Diagnostics.EventLog.MachineName%2A> 에서 읽는 데 (서버 컴퓨터 이름).  
  
> [!NOTE]
>  지정할 필요가 없습니다는 <xref:System.Diagnostics.EventLog.MachineName%2A> 로그에 연결 하는 경우. 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 속성을 지정 하지에 대 한 호출 <xref:System.Diagnostics.EventLog.Log%2A> 경우 빈 문자열을 반환 <xref:System.Diagnostics.EventLog.Log%2A> 명시적으로 설정 되지 않았습니다 (설정 하 여는 <xref:System.Diagnostics.EventLog.Log%2A> 속성 또는 생성자를 통해). 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 지정 <xref:System.Diagnostics.EventLog.Log%2A> 해당 소스를 등록 하는 로그의 이름을 반환 합니다.  
  
 만 소스는 한 번에 하나의 로그 등록할 수 있습니다. 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 의 인스턴스에 대 한 속성이 설정 된 <xref:System.Diagnostics.EventLog>를 변경할 수 없습니다는 <xref:System.Diagnostics.EventLog.Log%2A> 속성에 대 한 <xref:System.Diagnostics.EventLog> 의 값을 변경 하지 않고 <xref:System.Diagnostics.EventLog.Source%2A> 호출 또는 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 첫 번째입니다. 변경 하는 경우는 <xref:System.Diagnostics.EventLog.Log%2A> 후의 <xref:System.Diagnostics.EventLog.Source%2A> 속성이 설정 되어, 예외를 throw 하는 로그 항목을 작성 합니다.  
  
 운영 체제 이벤트 로그를 파일로 저장합니다. 사용 하는 경우 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 새 이벤트 로그를 만들려면 연결된 된 파일은 지정된 된 컴퓨터의 %SystemRoot%\System32\Config 디렉터리에 저장 됩니다. 처음 8 자를 추가 하 여 파일 이름이 설정 되는 <xref:System.Diagnostics.EventLog.Log%2A> ".evt" 파일 이름 확장명을 가진 속성입니다.  
  
 사용 하 여 새 로그를 만들 수 없습니다는 <xref:System.Diagnostics.EventLog.Log%2A> 속성만 (하지 않고 로그에 대 한 원본을 지정). 호출할 수 있습니다 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>새 로그 이름을 매개 변수로 전달 하 고, 다음 호출 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>합니다. 그러나 의도 일반적으로 만들 (및 항목을 쓸)에 새 응용 프로그램 관련 로그 또는 기존 로그에서 읽을 수 있습니다.  
  
 경우는 <xref:System.Diagnostics.EventLog.Log%2A> 값이 변경 되는 이벤트 로그가 닫히고 모든 이벤트 핸들이 해제 됩니다.  
  
> [!CAUTION]
>  설정 하는 경우는 <xref:System.Diagnostics.EventLog.Log%2A> 속성을 존재 하지 않는 로그의 이름, 시스템 연결는 <xref:System.Diagnostics.EventLog> 응용 프로그램 로그에 경고가 나타나지는 않습니다 지정한 것 이외의 로그를 사용 중인 하지만 합니다.  
  
   
  
## Examples  
 다음 예제에서는 이벤트 로그에 "NewEventLog" 로컬 컴퓨터에서 엔트리를 읽습니다.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이벤트 로그 이름을 가져옵니다.</summary>
        <value>시스템의 이벤트 뷰어에서 이벤트 로그를 나타내는 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Windows Vista 이상 버전에서는 사용자가 보안 로그에 액세스할 수 있는 권한이 없는 합니다. Windows Vista를 실행 하거나 나중에 사용자로 받아볼 수는 <xref:System.Security.SecurityException> 보안 로그에 있는 이벤트에 대 한 표시 이름에 액세스 하려고 합니다.  
>   
>  Windows Vista 이상에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 보안 로그에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에 정의 된 이벤트 로그를 열거 하 고 표시 된 <xref:System.Diagnostics.EventLog.LogDisplayName%2A> 각 이벤트 로그에 대 한 합니다.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">지정한 <see cref="P:System.Diagnostics.EventLog.Log" />가 이 컴퓨터의 레지스트리에 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">지정 된 레지스트리 키를 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">지정 된 레지스트리 키 if에 액세스할 수 있도록 하는 원격 키입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">이벤트 원본의 이름입니다.</param>
        <param name="machineName">검색할 컴퓨터의 이름입니다. 로컬 컴퓨터의 경우 "."입니다.</param>
        <summary>지정한 소스가 등록된 로그의 이름을 가져옵니다.</summary>
        <returns>레지스트리에서 지정한 소스와 연결된 로그의 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 소스는 이벤트 로그를 나타냅니다. 것이 응용 프로그램의 이름 또는 하위 구성 요소는 응용 프로그램의 이름을 응용 프로그램이 큰 경우. 응용 프로그램 및 서비스 응용 프로그램 로그 나 사용자 지정 로그에 써야 합니다. 장치 드라이버 시스템 로그에 써야 합니다.  
  
 수만 로그에 작성 한 한 번에 새 소스를 만들면 시스템 이벤트 로그와 응용 프로그램 유효한 항목 소스로 등록 합니다. <xref:System.Diagnostics.EventLog.Source%2A> 속성에는 모든 문자열을 지정할 수 있지만 다른 소스에서 컴퓨터 이름을 사용할 수 없습니다. 중복 된 경우 만들려는 시도가 <xref:System.Diagnostics.EventLog.Source%2A> 값 예외를 throw 합니다. 그러나 하나의 이벤트 로그에 쓰기를 여러 소스 있을 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에서 소스를 삭제 합니다. 이 예제에서는 해당 원본에서 로그를 확인 한 다음 로그를 삭제 합니다.  
  
> [!NOTE]
>  둘 이상의 소스 프로그램 이벤트 로그에 쓸 수 있습니다. 사용자 지정 로그를 삭제 하기 전에 해당 로그에 쓰는 다른 소스가 없는지 확인 합니다.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이벤트를 읽거나 쓸 컴퓨터 이름을 가져오거나 설정합니다.</summary>
        <value>이벤트 로그가 있는 서버의 이름입니다. 기본값은 로컬 컴퓨터(".")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 로그에 작성 하는 경우 연결 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 이벤트 로그 개체를 특정 로그에 연결 합니다. 지정할 필요는 없습니다는 <xref:System.Diagnostics.EventLog.Source%2A> 만 로그에서 읽을 때 속성입니다. 만 지정할 수는 <xref:System.Diagnostics.EventLog.Log%2A> 이름 및 <xref:System.Diagnostics.EventLog.MachineName%2A> (서버 컴퓨터 이름).  
  
> [!NOTE]
>  지정 하지 않아도 <xref:System.Diagnostics.EventLog.MachineName%2A> 로그에 연결 하는 경우. 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 만 소스는 한 번에 하나의 로그 등록할 수 있습니다. 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 의 인스턴스에 대 한 속성이 설정 된 <xref:System.Diagnostics.EventLog>를 변경할 수 없습니다는 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성에 대 한 <xref:System.Diagnostics.EventLog> 의 값을 변경 하지 않고 <xref:System.Diagnostics.EventLog.Source%2A> 호출 또는 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 첫 번째입니다. 변경 하는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 속성에는 <xref:System.Diagnostics.EventLog> 모든 핸들을 닫고 로그 및 새 컴퓨터에는 소스에 다시 연결 합니다.  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> 값에는 빈 문자열일 수 없습니다. 명시적으로 설정 하지 않으면 기본값은 로컬 컴퓨터 (".").  
  
   
  
## Examples  
 다음 예제에서는 이벤트 로그에 "NewEventLog" 지정된 된 컴퓨터에서 엔트리를 읽습니다.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">컴퓨터 이름이 잘못된 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최대 이벤트 로그 크기(KB)를 가져오거나 설정합니다.</summary>
        <value>최대 이벤트 로그 크기(KB)입니다. 기본값은 512로, 최대 파일 크기가 512KB임을 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> 속성은 이벤트 로그 파일의 크기 제한을 나타냅니다. 이벤트 로그에서 구성된 된 크기 제한에 도달 하면 때 <xref:System.Diagnostics.EventLog.OverflowAction%2A> 값과 새 항목을 삭제 하는지 여부 또는 이전 항목 덮어쓰는지 여부를 결정 합니다.  
  
> [!NOTE]
>  이 속성은이 인스턴스가 나타내는 이벤트 로그에 대 한 구성 설정을 나타냅니다. 이벤트 로그의 최대 크기에 도달 하면이 속성이 운영 체제 이벤트 로그에 대해 등록 된 모든 이벤트 소스가 작성 하는 새 항목을 처리 하는 방법을 지정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에 정의 된 이벤트 로그를 열거 하 고 각 이벤트 로그에 대 한 구성 세부 정보를 표시 합니다.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">지정된 값이 64보다 작거나 4194240보다 크거나 64의 짝수 배수가 아닌 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 값이 올바른 로그 이름이 아닌 경우  
  
 \- 또는 -  
  
 이벤트 로그의 레지스트리 키를 대상 컴퓨터에서 열 수 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이벤트 로그에 엔트리를 유지할 날짜 수를 가져옵니다.</summary>
        <value>이벤트 로그의 엔트리가 유지되는 날짜 수입니다. 기본값은 7입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 이벤트 로그에 대 한 현재 설정을 검사 하는 속성입니다. 사용 하 여 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> 이벤트 로그의 각 항목을 유지 해야 하는 일의 최소 수를 변경 합니다.  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 값은 이벤트 로그의 구성된 된 오버플로 동작에 따라 달라 집니다. 경우는 <xref:System.Diagnostics.OverflowAction> 이벤트 로그에 대 한 속성이로 설정 되어 <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, 그런 다음 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 값은 0입니다. 경우는 <xref:System.Diagnostics.OverflowAction> 이벤트 로그에 대 한 속성이로 설정 되어 <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, 그런 다음 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 값은-1입니다. 경우는 <xref:System.Diagnostics.OverflowAction> 이벤트 로그에 대 한 속성이로 설정 되어 <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, 그런 다음 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 값이 0 보다 크면 및 이벤트 로그가 가득 찼을 때 이벤트 로그 항목을 보존할 일 수를 나타냅니다.  
  
 이벤트 로그 크기 제한에 도달 하는 경우에 오버플로 동작 발생 합니다. 경우는 <xref:System.Diagnostics.EventLog> 가 해당 <xref:System.Diagnostics.EventLog.OverflowAction%2A> 로 설정 <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, 이벤트 로그의 최대 크기에 도달 하 고 다음 엔트리를 대체할 수 있는 경우 새 항목이 기록는 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 기간입니다. 이벤트 로그를 정기적으로 보관 하는 경우 최소 기간에 대 한 이벤트 항목을 유지 하는 것은 적합 합니다. 그렇지 않으면 이벤트 로그의 제한에 도달할 때 새 항목을 손실 위험이 있습니다. 새 이벤트 정보가 손실 되지 않도록, 특정 이벤트 로그에 대 한 보관 일정에 따라 이벤트에 대 한 최소 보존 (일)을 설정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에 정의 된 이벤트 로그를 열거 하 고 각 이벤트 로그에 대 한 구성 세부 정보를 표시 합니다.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">이벤트 로그에 새 항목을 쓰기 위한 오버플로 동작입니다.</param>
        <param name="retentionDays">각 이벤트 로그 엔트리가 유지되는 최소 날짜 수입니다. 이 매개 변수는 <c>작업</c>이 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />로 설정되어 있는 경우에만 사용됩니다.</param>
        <summary>이벤트 로그가 최대 파일 크기에 도달할 때 새 엔트리를 쓰기 위한 구성된 동작을 변경합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 항목은 최대 파일 크기에 도달 하는 로그에 기록 되도록 하는 경우 지정 하는 이벤트 로그에 대 한 오버플로 동작 합니다.  
  
> [!NOTE]
>  오버플로 동작은 이벤트 로그가 최대 파일 크기에 도달 하는 경우에 적용이 됩니다. 오버플로 동작 추가 이벤트 로그 항목을 사용할 수 있는 로그에 새 항목을 쓰는 적용 되지 않습니다.  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> 메서드 이벤트 로그의 오버플로 동작을 구성 합니다. <xref:System.Diagnostics.EventLog> 인스턴스입니다. 지정 된 이벤트 로그에 대 한이 메서드를 호출한 후는 <xref:System.Diagnostics.EventLog.Log%2A> 속성에는 <xref:System.Diagnostics.EventLog.OverflowAction%2A> 및 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> 속성 값 새로 구성된 된 오버플로 동작을 반영 합니다.  
  
> [!NOTE]
>  이 속성은이 인스턴스가 나타내는 이벤트 로그에 대 한 구성 설정을 나타냅니다. 이벤트 로그의 최대 크기에 도달 하면이 속성이 운영 체제 이벤트 로그에 대해 등록 된 모든 이벤트 소스가 작성 하는 새 항목을 처리 하는 방법을 지정 합니다.  
  
 설정의 `action` 매개 변수를 <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> 새 항목이 가장 오래 된 항목을 덮어씁니다를 나타내기 위해 때는 <xref:System.Diagnostics.EventLog> 최대 크기에 도달 합니다. 경우는 `action` 로 설정 된 <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, `retentionDays` 매개 변수 값은 무시 됩니다.  
  
 설정의 `action` 매개 변수를 <xref:System.Diagnostics.OverflowAction.OverwriteOlder> 를 각각의 새 항목이 덮어씁니다 이전 항목을 나타내기 위해 때는 <xref:System.Diagnostics.EventLog> 최대 크기에 도달 합니다. 사용 하 여 로그에 이벤트를 유지 해야 하는 일 수를 지정 된 `retentionDays` 매개 변수입니다. 보존 범위 내에 기록 되는 이벤트는 새 항목으로 덮어쓰지 않습니다.  
  
 설정의 `action` 매개 변수를 <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> 최대 로그 크기에 도달 하면 새 이벤트를 삭제 하도록 합니다. 경우는 `action` 로 설정 된 <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, `retentionDays` 매개 변수 값은 무시 됩니다.  
  
> [!CAUTION]
>  오버플로 정책을 설정 <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> 새 항목이 이벤트 로그가 가득 찼을 때 삭제 하도록 지정 합니다. 이 설정을 사용 하는 경우 이벤트 로그는 정기적으로 보관 되 고 최대 크기 한도 도달 하지 않도록 하려면 삭제를 확인 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 이벤트 로그에 대 한 구성된 된 오버플로 정책을 표시 하 고 이벤트 로그에 대 한 새 오버플로 정책 설정을 선택할 수 있습니다.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" />은 유효한 <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 값이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" />가 0보다 작거나 365보다 큰 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 값이 올바른 로그 이름이 아닌 경우  
  
 \- 또는 -  
  
 이벤트 로그의 레지스트리 키를 대상 컴퓨터에서 열 수 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이벤트 로그가 최대 파일 크기에 도달할 때 새 엔트리를 저장하기 위한 구성된 동작을 가져옵니다.</summary>
        <value>이벤트 로그가 최대 로그 크기에 도달할 때 새 항목을 저장하기 위해 구성된 동작을 지정하는 <see cref="T:System.Diagnostics.OverflowAction" /> 값입니다. 기본값은 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 이벤트 기록 될 때 이벤트 로그의 크기가 증가 합니다. 각 이벤트 로그에 구성 된 최대 크기 제한이 있습니다. <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> 속성 (킬로바이트) 이벤트 로그 파일 크기에 허용 된 최대 수를 정의 합니다.  
  
 사용 하 여 <xref:System.Diagnostics.EventLog.OverflowAction%2A> 속성 값을 최대 크기는 이벤트 로그에 대해 구성된 된 오버플로 동작을 검사 합니다. 사용 된 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> 메서드를 이벤트 로그에 대 한 오버플로 동작을 변경 합니다.  
  
> [!NOTE]
>  오버플로 동작은 이벤트 로그가 최대 파일 크기에 도달 하는 경우에 적용이 됩니다. 오버플로 동작 추가 이벤트 로그 항목을 사용할 수 있는 로그에 새 항목을 쓰는 적용 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에 정의 된 이벤트 로그를 열거 하 고 각 이벤트 로그에 대 한 구성 세부 정보를 표시 합니다.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">지역화된 리소스 파일의 완전하게 지정된 경로입니다.</param>
        <param name="resourceId">리소스 파일에 있는 지역화된 문자열을 인덱싱하는 리소스 식별자입니다.</param>
        <summary>서버 이벤트 뷰어에 표시되는 이벤트 로그의 지역화된 이름을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> 등록 하 고 이벤트 뷰어의 사용자 지정 이벤트 로그에 대 한 지역화 된 이름을 표시 합니다.  
  
 지정 된 리소스 식별자는 리소스 파일에 정의 된 지역화 된 문자열 일치 해야 합니다. 이벤트 뷰어는 지역화 된 문자열 및 현재 문화권 설정을 사용 하 여 사용자 지정 이벤트 로그 이름이 표시 됩니다. 예를 들어 리소스 파일에 서로 다른 문화권에 맞게 지역화 하는 여러 이벤트 로그 이름을 정의할 수 있습니다. 이벤트 뷰어에서 현재 사용자의 문화권 설정에 해당 하는 지역화 된 문자열을 표시 합니다.  
  
 이벤트 뷰어는 리소스 파일에서 지역화 된 문자열을 로드할 수 없습니다 또는 이벤트 로그에 대해 등록 된 표시 이름이 없는 경우 다음 이벤트 뷰어에서 이벤트 로그 이름을 표시에 정의 된 경우 <xref:System.Diagnostics.EventLog.Log%2A>합니다.  
  
> [!NOTE]
>  미리 정의 된 이벤트 로그에 대 한 표시 이름을 등록할 필요가 없습니다. 운영 체제는 응용 프로그램, 시스템 및 보안 이벤트 로그에 대 한 지역화 된 표시 이름을 등록합니다.  
  
   
  
## Examples  
 다음 예제에서는 이벤트 소스 이름을 지정 여부를 확인 `SampleApplicationSource` 로컬 컴퓨터에 등록 합니다. 이벤트 소스가 없는 경우이 예제에서는 소스에 대 한 메시지 리소스 파일을 설정 하 고 새 이벤트 소스를 만듭니다. 이 예제에서는 리소스 식별자 값을 사용 하 여 이벤트 로그에 대 한 지역화 된 표시 이름을 설정 하는 마지막으로, `DisplayNameMsgId` 및 리소스 파일 경로에 `messageFile`합니다.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 이 예제에서는 리소스 라이브러리 EventLogMsgs.dll에 기본 제공 되는 다음과 같은 메시지 텍스트 파일을 사용 합니다. 메시지 텍스트 파일은 소스 메시지 리소스 파일이 만들어집니다. 메시지 텍스트 파일의 리소스 식별자와 범주, 이벤트 메시지 및 매개 변수 삽입 문자열에 대 한 텍스트를 정의합니다. 특히, 리소스 식별자 5001이 고 이벤트 로그의 지역화 된 이름에 대해 정의 됩니다.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 값이 올바른 로그 이름이 아닌 경우  
  
 \- 또는 -  
  
 이벤트 로그의 레지스트리 키를 대상 컴퓨터에서 열 수 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 관리 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이벤트 로그에 쓸 때 등록하고 사용할 소스 이름을 가져오거나 설정합니다.</summary>
        <value>엔트리 소스로 이벤트 로그에 등록되는 이름입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 소스는 이벤트 로그를 나타냅니다. 것이 응용 프로그램의 이름 또는 하위 구성 요소는 응용 프로그램의 이름을 응용 프로그램이 큰 경우. 응용 프로그램 및 서비스 응용 프로그램 로그 나 사용자 지정 로그에 써야 합니다. 장치 드라이버 시스템 로그에 써야 합니다.  
  
 이벤트 로그에 작성 하는 경우 이벤트 소스를 지정 하기만 하면 됩니다. 이벤트 로그에 엔트리를 쓰기 전에 유효한 이벤트 소스로 이벤트 로그와 이벤트 소스를 등록 해야 있습니다. 시스템에 사용 하 여 로그 항목을 작성 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 속성을 입력 한 내용을 배치할 수 있는 적절 한 로그를 찾습니다. 읽는 경우 이벤트 로그를 지정 하거나는 <xref:System.Diagnostics.EventLog.Source%2A>, 또는 <xref:System.Diagnostics.EventLog.Log%2A> 및 <xref:System.Diagnostics.EventLog.MachineName%2A>합니다.  
  
> [!NOTE]
>  지정할 필요가 없습니다는 <xref:System.Diagnostics.EventLog.MachineName%2A> 로그는 로컬 컴퓨터에 연결 하는 경우. 지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 사용 하 여 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 및 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 이벤트 이벤트 로그에 쓰려고 합니다. 이벤트를 작성 하는 이벤트 소스를 지정 해야 합니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 기존 이벤트 로그 또는 새 이벤트 로그에 대 한 이벤트 소스를 만들 수 있습니다. 새 이벤트 로그에 대 한 새 원본을 만들 때 해당 로그에 대 한 소스를 등록 하는 시스템 하지만 첫 번째 항목에 기록할 때 까지는 로그가 만들어지지 않습니다.  
  
 소스는 로컬 컴퓨터에서 고유 해야 합니다. 새 소스 이름이 기존 원본 이름 또는 기존 이벤트 로그 이름과 일치할 수 없습니다. 각 소스; 한 번에 하나의 이벤트 로그에 쓸 수 있습니다. 그러나 응용 프로그램 여러 이벤트 로그에 쓸 여러 소스를 사용할 수 있습니다. 예를 들어 응용 프로그램에 다른 이벤트 로그 또는 서로 다른 리소스 파일에 대해 구성 된 여러 소스가 필요할 수 있습니다.  
  
 변경 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 값은 <xref:System.Diagnostics.EventLog> 에 등록 되어 있는 닫혀 있으며 모든 이벤트 핸들이 해제 됩니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
 기존 소스 구성 세부 정보를 변경 하려면 소스를 삭제 하 고 새 구성으로 만듭니다. 다른 응용 프로그램이 나 구성 요소는 기존 소스를 사용 하는 경우 기존 소스를 삭제 하는 대신 업데이트 된 구성으로 새 소스를 만듭니다.  
  
> [!NOTE]
>  원본 로그에 이미 매핑 되었습니다에서 새 로그에 다시 배치 하는 경우에 변경 내용을 적용 하려면 컴퓨터를 다시 시작 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 이미 존재 하지 않는 하 고 이벤트 로그에 항목을 기록 하는 경우 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컴퓨터 레지스트리에서 지정한 이벤트 소스를 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">이벤트 원본의 이름입니다.</param>
        <summary>이벤트 소스가 로컬 컴퓨터에 등록되었는지를 확인합니다.</summary>
        <returns>
          로컬 컴퓨터에 이벤트 소스가 등록되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 이벤트 소스는 로컬 컴퓨터에 있는지 여부를 확인 합니다. 사용 하 여 로컬 컴퓨터에 로그가 있는지 여부를 확인 하려는 경우 <xref:System.Diagnostics.EventLog.Exists%2A>합니다.  
  
 이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 로컬 컴퓨터에 있어야 그렇지 않은 경우는 <xref:System.Security.SecurityException> throw 됩니다.  
  
> [!NOTE]
>  이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 검색 하려면 관리자 권한이 있어야 합니다.  
>   
>  이 요구 사항에 대 한 이유 보안을 비롯 한 모든 이벤트 로그 이벤트 소스가 고유한 지 확인 하려면 검색 해야입니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException> throw 됩니다.  
>   
>  Windows Vista 이상에서는 사용자 계정 컨트롤 (UAC)는 사용자의 권한을 결정 합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
> [!NOTE]
>  실행 되 고 있는 서비스는 <xref:System.ServiceProcess.ServiceAccount.LocalSystem> 계정에이 메서드를 실행 하는 데 필요한 권한이 없는 합니다. 해결 방법은 이벤트 소스에 있는지 여부를 확인 하는 <xref:System.ServiceProcess.ServiceInstaller>, 존재, 소스를 만들려면 설치 프로그램의 경우.  
  
 동일한 컴퓨터에서 기존 원본 이름 새 소스를 지정할 수 없습니다, 때문에이 메서드를 사용 하기 전에 호출할 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 되도록 원본으로 지정 된 이름의 `source` 로컬 컴퓨터에 이미 존재 하지 않습니다. `source` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 이미 존재 하지 않는 하 고 이벤트 로그에 항목을 기록 하는 경우 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" />를 찾을 수 없었지만 모든 또는 일부 이벤트 로그를 검색할 수 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">이벤트 원본의 이름입니다.</param>
        <param name="machineName">검색할 컴퓨터의 이름입니다. 로컬 컴퓨터의 경우에는 "."입니다.</param>
        <summary>이벤트 소스가 지정한 컴퓨터에 등록되었는지를 확인합니다.</summary>
        <returns>
          지정한 컴퓨터에 이벤트 원본이 등록되어 있으면 <see langword="true" />이고, 등록되지 않았으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 이벤트 소스에서 지정한 컴퓨터에 있는지 여부를 결정 하는 `machineName` 매개 변수입니다. 로그를 사용 하 여 지정된 된 컴퓨터에 있는지 여부를 확인 하려는 경우 <xref:System.Diagnostics.EventLog.Exists%2A>합니다.  
  
 이 메서드는 레지스트리를 액세스, 하므로 적절 한 레지스트리 사용 권한을 지정 된 서버에 있어야 그렇지 않은 경우는 <xref:System.Security.SecurityException> throw 됩니다.  
  
> [!NOTE]
>  이벤트 소스 Windows Vista 이상 또는 Windows Server 2003을 검색 하려면 관리자 권한이 있어야 합니다.  
>   
>  이 요구 사항에 대 한 이유 보안을 비롯 한 모든 이벤트 로그 이벤트 소스가 고유한 지 확인 하려면 검색 해야입니다. Windows Vista 이상에서는 사용자가 권한이 없습니다; 보안 로그에 액세스할 수 따라서 한 <xref:System.Security.SecurityException> throw 됩니다.  
>   
>  Windows Vista 이상에서는 사용자 계정 컨트롤 (UAC)는 사용자의 권한을 결정 합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 귀하의 권한을 표준 사용자에서 관리자에 게 있습니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
> [!NOTE]
>  실행 되 고 있는 서비스는 <xref:System.ServiceProcess.ServiceAccount.LocalSystem> 계정에이 메서드를 실행 하는 데 필요한 권한이 없는 합니다. 해결 방법은 이벤트 소스에 있는지 여부를 확인 하는 <xref:System.ServiceProcess.ServiceInstaller>, 존재, 소스를 만들려면 설치 프로그램의 경우.  
  
 동일한 컴퓨터에서 기존 원본 이름 새 소스를 지정할 수 없습니다, 때문에이 메서드를 사용 하기 전에 호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 되도록 원본으로 지정 된 이름의 `source` 는 컴퓨터에 이미 존재 하지 않습니다. `source` 및 `machineName` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> 이 `static` 메서드, 클래스 자체에 호출할 수 있습니다. 인스턴스를 만들 필요는 없습니다 <xref:System.Diagnostics.EventLog> 호출할 <xref:System.Diagnostics.EventLog.SourceExists%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 컴퓨터에서 `MyServer`, 이벤트 로그에 항목을 씁니다 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" />이 잘못된 컴퓨터 이름인 경우</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" />를 찾을 수 없었지만 모든 또는 일부 이벤트 로그를 검색할 수 없는 경우</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.EventLog" /> 항목 쓰기 이벤트의 결과로 발생하는 이벤트 처리기 호출을 마샬링하는 데 사용되는 개체를 가져오거나 설정합니다.</summary>
        <value>이벤트 로그에서 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 이벤트의 결과로 발생하는 이벤트 처리기 호출을 마샬링하는 데 사용되는 <see cref="T:System.ComponentModel.ISynchronizeInvoke" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 은 `null`를 처리 하는 메서드가 <xref:System.Diagnostics.EventLog.EntryWritten> 시스템 스레드 풀의 스레드라도에서 이벤트를 호출 합니다. 시스템 스레드 풀에 대 한 자세한 내용은 참조 하십시오. <xref:System.Threading.ThreadPool>합니다.  
  
 경우는 <xref:System.Diagnostics.EventLog.EntryWritten> 시스템 스레드 풀을 통해 구성 요소에 액세스 하는 단추와 같은 구성 요소가 작동 하지 않을 수 또는 예외가 발생할 수 있습니다는 Windows Forms 시각적 이벤트를 처리 합니다. 설정 하 여이 문제를 방지 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 처리 하는 메서드가 때문에 Windows Forms 구성 요소에는 <xref:System.Diagnostics.EventLog.EntryWritten> 구성 요소를 만든 동일한 스레드에서 호출 이벤트입니다.  
  
 경우는 <xref:System.Diagnostics.EventLog> 안에서 사용 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Windows Forms 디자이너에서 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 포함 하는 컨트롤에 자동으로 설정 됩니다는 <xref:System.Diagnostics.EventLog>합니다. 예를 들어, 배치 하는 경우는 <xref:System.Diagnostics.EventLog> form1 디자이너에서 (에서 상속 되 <xref:System.Windows.Forms.Form>)는 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 속성 <xref:System.Diagnostics.EventLog> Form1의 인스턴스로 설정 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이벤트 로그에 엔트리를 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <summary>지정한 메시지 텍스트로 정보 형식 엔트리를 이벤트 로그에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여이 연결 된 이벤트 로그에 정보 항목을 쓸 <xref:System.Diagnostics.EventLog> 인스턴스. 다른 지정 하려는 경우 <xref:System.Diagnostics.EventLogEntryType>, 다른 오버 로드를 사용 하 여 <xref:System.Diagnostics.EventLog.WriteEntry%2A>합니다.  
  
> [!NOTE]
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
 설정 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 속성에 사용자 <xref:System.Diagnostics.EventLog> 로그에 항목을 작성 하려면 먼저 구성 요소입니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 속성 <xref:System.Diagnostics.EventLog> 인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 소스를 등록 하 고 있습니다.  
  
> [!NOTE]
>  지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 에 대 한 프로그램 <xref:System.Diagnostics.EventLog> 호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 시스템을 등록 해야 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 호출을 통해 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 및 <xref:System.Diagnostics.EventLog.Log%2A> 에 속성이 설정 되지 프로그램 <xref:System.Diagnostics.EventLog> 인스턴스를 응용 프로그램 로그는 로그 기본적 합니다.  
  
> [!NOTE]
>  등록 하는 동안 발생 한 오류에 의해 생성 된 위에 나열 된 예외 목록의 대부분은 <xref:System.Diagnostics.EventLog.Source%2A>합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  원격 컴퓨터에 한 항목을 작성 하는 경우 메시지 (텍스트 문자열)의 값은 원격 컴퓨터에.NET Framework 실행 되지 않는 경우 예상 대로 아닐 수 있습니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 이미 존재 하지 않는 하 고 이벤트 로그에 항목을 기록 하는 경우 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" />의 <see cref="T:System.Diagnostics.EventLog" /> 속성이 설정되지 않은 경우  
  
 또는  
  
 메서드가 새 이벤트 원본을 등록하려고 시도했지만 <see cref="P:System.Diagnostics.EventLog.MachineName" />의 컴퓨터 이름이 유효하지 않습니다.  
  
 \- 또는 -  
  
 소스가 이미 다른 이벤트 로그에 등록된 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <summary>지정한 메시지 텍스트로 오류, 경고, 정보, 성공 감사 또는 실패 감사 엔트리를 이벤트 로그에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 지정 된 항목을 쓰려고 <xref:System.Diagnostics.EventLogEntryType> 이벤트 로그에 있습니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다.  
  
> [!NOTE]
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
 설정 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 속성에 사용자 <xref:System.Diagnostics.EventLog> 로그에 항목을 작성 하려면 먼저 구성 요소입니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 속성 <xref:System.Diagnostics.EventLog> 인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 소스를 등록 하 고 있습니다.  
  
> [!NOTE]
>  지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 에 대 한 프로그램 <xref:System.Diagnostics.EventLog> 호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 시스템을 등록 해야 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 호출을 통해 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 및 <xref:System.Diagnostics.EventLog.Log%2A> 에 속성이 설정 되지 프로그램 <xref:System.Diagnostics.EventLog> 인스턴스를 응용 프로그램 로그는 로그 기본적 합니다.  
  
> [!NOTE]
>  위에 나열 된 대부분의 예외 등록 과정 중에 발생 한 오류에 의해 생성 되는 <xref:System.Diagnostics.EventLog.Source%2A>합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  원격 컴퓨터에 한 항목을 작성 하는 경우 메시지 (텍스트 문자열)의 값은 원격 컴퓨터에.NET Framework 실행 되지 않는 경우 예상 대로 아닐 수 있습니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에서 "MyNewLog" 이벤트 로그에 경고 항목을 기록 합니다.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" />의 <see cref="T:System.Diagnostics.EventLog" /> 속성이 설정되지 않은 경우  
  
 또는  
  
 메서드가 새 이벤트 원본을 등록하려고 시도했지만 <see cref="P:System.Diagnostics.EventLog.MachineName" />의 컴퓨터 이름이 유효하지 않습니다.  
  
 \- 또는 -  
  
 소스가 이미 다른 이벤트 로그에 등록된 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">지정한 컴퓨터에 등록되는 응용 프로그램의 원본입니다.</param>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <summary>특정 등록 이벤트 소스를 사용하여 정보 형식 엔트리를 지정된 메시지 텍스트로 이벤트 로그에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 되어 있는 원본을 사용 하 여 이벤트 로그에 정보 항목을 기록 합니다. 다른 지정 하려는 경우 <xref:System.Diagnostics.EventLogEntryType>, 다른 오버 로드를 사용 하 여 <xref:System.Diagnostics.EventLog.WriteEntry%2A>합니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
>   
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 소스 `MySource` 이미 존재 하지 않는 하 고 이벤트 로그에 항목을 기록 하는 경우 `MyNewLog`합니다.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 값이 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 값이 <see langword="null" />입니다.  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <param name="eventID">이벤트의 응용 프로그램별 식별자입니다.</param>
        <summary>지정한 메시지 텍스트와 응용 프로그램 정의 이벤트 식별자로 엔트리를 이벤트 로그에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 응용 프로그램 정의 된 `eventID` 이벤트 로그에 있습니다. `eventID` 소스와 함께 이벤트 고유 하 게 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.  
  
> [!NOTE]
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
 이벤트 식별자와 함께 지정할 수 있습니다는 <xref:System.Diagnostics.EventLogEntryType> 이벤트 로그에 기록 되 고 이벤트에 대 한 합니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.  
  
 설정 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 속성에 사용자 <xref:System.Diagnostics.EventLog> 로그에 항목을 작성 하려면 먼저 구성 요소입니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 속성 <xref:System.Diagnostics.EventLog> 인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 소스를 등록 하 고 있습니다.  
  
> [!NOTE]
>  지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 에 대 한 프로그램 <xref:System.Diagnostics.EventLog> 호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 시스템을 등록 해야 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 호출을 통해 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 및 <xref:System.Diagnostics.EventLog.Log%2A> 에 속성이 설정 되지 프로그램 <xref:System.Diagnostics.EventLog> 인스턴스를 응용 프로그램 로그는 로그 기본적 합니다.  
  
> [!NOTE]
>  위에 나열 된 대부분의 예외 등록 과정 중에 발생 한 오류에 의해 생성 되는 <xref:System.Diagnostics.EventLog.Source%2A>합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  원격 컴퓨터에 한 항목을 작성 하는 경우 메시지 (텍스트 문자열)의 값은 원격 컴퓨터에.NET Framework 실행 되지 않는 경우 예상 대로 아닐 수 있습니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" />의 <see cref="T:System.Diagnostics.EventLog" /> 속성이 설정되지 않은 경우  
  
 또는  
  
 메서드가 새 이벤트 원본을 등록하려고 시도했지만 <see cref="P:System.Diagnostics.EventLog.MachineName" />의 컴퓨터 이름이 유효하지 않습니다.  
  
 \- 또는 -  
  
 소스가 이미 다른 이벤트 로그에 등록된 경우  
  
 \- 또는 -  
  
 <paramref name="eventID" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">지정한 컴퓨터에 등록되는 응용 프로그램의 원본입니다.</param>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <summary>특정 등록 이벤트 소스를 사용하여 지정된 메시지 텍스트로 오류, 경고, 정보, 성공 감사 또는 실패 감사 엔트리를 이벤트 로그에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 지정 된 항목을 쓰려고 <xref:System.Diagnostics.EventLogEntryType> 적절 한 로그에 대 한 이벤트 소스로 이벤트 로그에는 소스를 이미 사용 하 여 등록 합니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다.  
  
> [!NOTE]
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터에서 "MyNewLog" 이벤트 로그에 경고 항목을 기록 합니다.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 값이 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 값이 <see langword="null" />입니다.  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <param name="eventID">이벤트의 응용 프로그램별 식별자입니다.</param>
        <param name="category">메시지와 연결된 응용 프로그램별 하위 범주입니다.</param>
        <summary>지정한 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자 및 응용 프로그램 정의 범주로 엔트리를 이벤트 로그에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 응용 프로그램 정의 된 `category` 이벤트 로그에 있습니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.  
  
> [!NOTE]
>  `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 나타납니다.  
  
> [!NOTE]
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
 이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 구성 범주 리소스 파일 및 리소스 파일에서 범주 문자열의 수를 사용 하는 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventSourceCreationData> 클래스입니다.  
  
 범주와 함께 이벤트 로그에 기록 되 고 이벤트에 대 한 이벤트 식별자를 지정할 수 있습니다. 이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.  
  
 마지막으로 지정할 수는 <xref:System.Diagnostics.EventLogEntryType> 이벤트 로그에 기록 되 고 이벤트에 대 한 합니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.  
  
 설정 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 속성에 사용자 <xref:System.Diagnostics.EventLog> 로그에 항목을 작성 하려면 먼저 구성 요소입니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 속성 <xref:System.Diagnostics.EventLog> 인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 소스를 등록 하 고 있습니다.  
  
> [!NOTE]
>  지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 에 대 한 프로그램 <xref:System.Diagnostics.EventLog> 호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 시스템을 등록 해야 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 호출을 통해 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 및 <xref:System.Diagnostics.EventLog.Log%2A> 에 속성이 설정 되지 프로그램 <xref:System.Diagnostics.EventLog> 인스턴스를 응용 프로그램 로그는 로그 기본적 합니다.  
  
> [!NOTE]
>  위에 나열 된 대부분의 예외 등록 과정 중에 발생 한 오류에 의해 생성 되는 <xref:System.Diagnostics.EventLog.Source%2A>합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  원격 컴퓨터에 한 항목을 작성 하는 경우 메시지 (텍스트 문자열)의 값은 원격 컴퓨터에.NET Framework 실행 되지 않는 경우 예상 대로 아닐 수 있습니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" />의 <see cref="T:System.Diagnostics.EventLog" /> 속성이 설정되지 않은 경우  
  
 또는  
  
 메서드가 새 이벤트 원본을 등록하려고 시도했지만 <see cref="P:System.Diagnostics.EventLog.MachineName" />의 컴퓨터 이름이 유효하지 않습니다.  
  
 \- 또는 -  
  
 소스가 이미 다른 이벤트 로그에 등록된 경우  
  
 \- 또는 -  
  
 <paramref name="eventID" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">지정한 컴퓨터에 등록되는 응용 프로그램의 원본입니다.</param>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <param name="eventID">이벤트의 응용 프로그램별 식별자입니다.</param>
        <summary>특정 등록 이벤트 소스를 사용하여 엔트리를 지정된 메시지 텍스트와 응용 프로그램 정의 이벤트 식별자로 이벤트 로그에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 응용 프로그램 정의 된 `eventID` 적절 한 로그에 대 한 이벤트 소스로 이벤트 로그에는 소스를 이미 사용 하 여 등록 합니다. `eventID`는 소스와 함께 이벤트 고유 하 게 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 사용자에 게 이러한 문자열을 표시 합니다.  
  
> [!NOTE]
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
 이벤트 식별자 외에도이 오버 로드의 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 지정할 수 있습니다는 <xref:System.Diagnostics.EventLogEntryType> 이벤트 로그에 기록 되 고 이벤트에 대 한 합니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 값이 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 값이 <see langword="null" />입니다.  
  
 \- 또는 -  
  
 <paramref name="eventID" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <param name="eventID">이벤트의 응용 프로그램별 식별자입니다.</param>
        <param name="category">메시지와 연결된 응용 프로그램별 하위 범주입니다.</param>
        <param name="rawData">항목과 연관된 이진 데이터를 보유하는 바이트의 배열입니다.</param>
        <summary>지정한 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자, 응용 프로그램 정의 범주로 엔트리를 이벤트 로그에 쓰고 메시지에 이진 데이터를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 이벤트 로그에 이벤트 관련 응용 프로그램 정의 데이터를 쓰려고 합니다. 이벤트 뷰어는이 데이터를 해석 하지 않으므로 원시 데이터는 결합 된 16 진수 및 텍스트 형식에만 표시 됩니다. 사용 이벤트 관련 데이터는 것은 문제를 디버깅 하는 사람에 게 유용한 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 사용자 이벤트에 대해 특별히 뷰어를 작성 하거나 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만들고 로그 파일을 검색 하는 프로그램을 작성할 수 있습니다.  
  
 이진 데이터 뿐만 아니라 응용 프로그램 정의 된 범주 및 응용 프로그램 정의 이벤트 식별자를 지정할 수 있습니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.  
  
> [!NOTE]
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
> [!NOTE]
>  `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 나타납니다.  
  
 이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 구성 범주 리소스 파일 및 리소스 파일에서 범주 문자열의 수를 사용 하는 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventSourceCreationData> 클래스입니다.  
  
 이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.  
  
 마지막으로 지정할 수는 <xref:System.Diagnostics.EventLogEntryType> 이벤트 로그에 기록 되 고 이벤트에 대 한 합니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.  
  
 설정 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 속성에 사용자 <xref:System.Diagnostics.EventLog> 로그에 항목을 작성 하려면 먼저 구성 요소입니다. 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다.  
  
 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 소스에 지정 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 속성 <xref:System.Diagnostics.EventLog> 인스턴스 구성 요소를 작성 하는 컴퓨터에 등록 되지 않았습니다 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 호출 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 소스를 등록 하 고 있습니다.  
  
> [!NOTE]
>  지정 하지 않을 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 에 대 한 프로그램 <xref:System.Diagnostics.EventLog> 호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 또는 <xref:System.Diagnostics.EventLog.WriteEntry%2A>, 로컬 컴퓨터 (".")으로 간주 됩니다.  
  
 시스템을 등록 해야 하는 경우는 <xref:System.Diagnostics.EventLog.Source%2A> 호출을 통해 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 및 <xref:System.Diagnostics.EventLog.Log%2A> 에 속성이 설정 되지 프로그램 <xref:System.Diagnostics.EventLog> 인스턴스를 응용 프로그램 로그는 로그 기본적 합니다.  
  
> [!NOTE]
>  위에 나열 된 대부분의 예외 등록 과정 중에 발생 한 오류에 의해 생성 되는 <xref:System.Diagnostics.EventLog.Source%2A>합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  원격 컴퓨터에 한 항목을 작성 하는 경우 메시지 (텍스트 문자열)의 값은 원격 컴퓨터에.NET Framework 실행 되지 않는 경우 예상 대로 아닐 수 있습니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" />의 <see cref="T:System.Diagnostics.EventLog" /> 속성이 설정되지 않은 경우  
  
 또는  
  
 메서드가 새 이벤트 원본을 등록하려고 시도했지만 <see cref="P:System.Diagnostics.EventLog.MachineName" />의 컴퓨터 이름이 유효하지 않습니다.  
  
 \- 또는 -  
  
 소스가 이미 다른 이벤트 로그에 등록된 경우  
  
 \- 또는 -  
  
 <paramref name="eventID" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">지정한 컴퓨터에 등록되는 응용 프로그램의 원본입니다.</param>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <param name="eventID">이벤트의 응용 프로그램별 식별자입니다.</param>
        <param name="category">메시지와 연결된 응용 프로그램별 하위 범주입니다.</param>
        <summary>특정 등록 이벤트 소스를 사용하여 엔트리를 지정된 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자, 응용 프로그램 정의 범주로 이벤트 로그에 씁니다. 이벤트 뷰어에서 <paramref name="category" />를 사용하여 로그의 이벤트를 필터링할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 응용 프로그램 정의 된 `category` 이벤트 로그에 적절 한 로그에 대 한 이벤트 소스로 이미 등록 되어 있는 소스를 사용 합니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.  
  
> [!NOTE]
>  `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 나타납니다.  
  
 이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 구성 범주 리소스 파일 및 리소스 파일에서 범주 문자열의 수를 사용 하는 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventSourceCreationData> 클래스입니다.  
  
 범주와 함께 이벤트 로그에 기록 되 고 이벤트에 대 한 이벤트 식별자를 지정할 수 있습니다. 이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.  
  
 마지막으로 지정할 수는 <xref:System.Diagnostics.EventLogEntryType> 이벤트 로그에 기록 되 고 이벤트에 대 한 합니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
>   
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 값이 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 값이 <see langword="null" />입니다.  
  
 \- 또는 -  
  
 <paramref name="eventID" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">지정한 컴퓨터에 등록되는 응용 프로그램의 원본입니다.</param>
        <param name="message">이벤트 로그에 쓸 문자열입니다.</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 값 중 하나입니다.</param>
        <param name="eventID">이벤트의 응용 프로그램별 식별자입니다.</param>
        <param name="category">메시지와 연결된 응용 프로그램별 하위 범주입니다.</param>
        <param name="rawData">항목과 연관된 이진 데이터를 보유하는 바이트의 배열입니다.</param>
        <summary>특정 등록 이벤트 소스를 사용하여 엔트리를 지정된 메시지 텍스트, 응용 프로그램 정의 이벤트 식별자, 응용 프로그램 정의 범주로 이벤트 로그에 쓰고 메시지에 이진 데이터를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 된 소스를 사용 하 여 이벤트 로그에 이벤트 관련 응용 프로그램 정의 데이터를 쓰려고 합니다. 이벤트 뷰어는이 데이터를 해석 하지 않으므로 원시 데이터는 결합 된 16 진수 및 텍스트 형식에만 표시 됩니다. 이벤트 관련 데이터를 사용 하 여 엄밀한; 유용할 것 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 사용자 이벤트에 대해 특별히 뷰어를 작성 하거나 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만들고 로그 파일을 검색 하는 프로그램을 작성할 수 있습니다.  
  
 이진 데이터 뿐만 아니라 응용 프로그램 정의 된 범주 및 응용 프로그램 정의 이벤트 식별자를 지정할 수 있습니다. 이벤트 뷰어에서 이벤트 소스를 기록한 이벤트를 필터링 하려면 범주를 사용 합니다. 이벤트 뷰어를 숫자 값으로 범주를 표시할 수 있습니다 또는 지역화 된 범주 문자열을 표시 하는 범주를 리소스 식별자로 사용할 수 있습니다.  
  
> [!NOTE]
>  `category` 매개 변수는 양수 값 이어야 합니다. 음수 범주 값 뷰어를 이벤트에 상호 보완적인 양수 표시 됩니다. 예를 들어 – 10 65,526 표시 됩니다.  
  
 이벤트 뷰어에서 지역화 된 범주 문자열을 표시 하려면 범주 리소스 파일을 사용 하 여 구성 하 고 설정 이벤트 소스를 사용 해야 합니다는 `category` 범주 리소스 파일의 리소스 식별자로. 구성된 범주 리소스 파일 또는 지정 된 이벤트 소스에 없는 경우 `category` 이벤트 뷰어에서 해당 항목에 대 한 숫자 범주 값 표시 한 다음 category 리소스 파일에 문자열을 인덱싱하지 않습니다. 구성 범주 리소스 파일 및 리소스 파일에서 범주 문자열의 수를 사용 하는 <xref:System.Diagnostics.EventLogInstaller> 또는 <xref:System.Diagnostics.EventSourceCreationData> 클래스입니다.  
  
 이벤트 소스와 함께 이벤트 식별자는 고유 하 게 이벤트를 식별 합니다. 각 응용 프로그램 자체 번호가 매겨진된 이벤트 및 매핑되는 설명 문자열을 정의할 수 있습니다. 이벤트 뷰어 사용자가 오류를 확인 하 고 적절 한 조치를 수행할 수 있도록 이러한 문자열 값을 표시 합니다.  
  
 마지막으로 지정할 수는 <xref:System.Diagnostics.EventLogEntryType> 이벤트 로그에 기록 되 고 이벤트에 대 한 합니다. `type` 아이콘 및 텍스트 로그의 이벤트 뷰어에서 유형 열에 표시 됩니다. 이 매개 변수는 오류, 경고, 정보, 성공 감사 또는 실패 감사 이벤트 형식이 인지를 나타냅니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드 이벤트 로그에 직접 지정된 된 문자열을 씁니다; 지역화할 수 있는 메시지 리소스 파일을 사용 하지 않습니다. 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 지역화 된 메시지 리소스 파일을 사용 하 여 이벤트를 작성할 수 있습니다.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  경우는 `message` NUL 문자를 포함 하는 매개 변수, 이벤트 로그에 메시지가 NUL 문자에서 끝납니다.  
>   
>  `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 값이 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 값이 <see langword="null" />입니다.  
  
 \- 또는 -  
  
 <paramref name="eventID" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 메시지 문자열이 31,839 바이트보다 깁니다(Windows Vista 이전의 Windows 운영 체제에서 32,766 바이트).  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" />은 유효한 <see cref="T:System.Diagnostics.EventLogEntryType" />이 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이벤트 로그에 지역화된 이벤트 엔트리를 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">지역화된 이벤트 로그 항목을 나타내는 <see cref="T:System.Diagnostics.EventInstance" /> 인스턴스입니다.</param>
        <param name="values">이벤트 로그 항목의 메시지 텍스트로 병합될 문자열의 배열입니다.</param>
        <summary>이벤트 로그에 지역화된 엔트리를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 이벤트 로그에 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 해당 문자열에 대 한 지역화 된 리소스 파일을 표시 하는 <xref:System.Diagnostics.EventLog.Source%2A>합니다. 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.  
  
 입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A> 의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력 합니다. 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A> 및 <xref:System.Diagnostics.EventInstance.EntryType%2A> 의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력 합니다. 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.  
  
 설정 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 속성에 사용자 <xref:System.Diagnostics.EventLog> 사용 하기 전에 구성 요소 <xref:System.Diagnostics.EventLog.WriteEvent%2A>합니다. 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 사용 된 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 메서드.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  원격 컴퓨터의 값에 항목을 기록 하는 경우는 `message` 문자열 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 예상 되지 않을 수 있습니다. 또한는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 감사 이벤트 로그에 항목을 작성 `myNewLog`합니다. 이 예제에서는 로컬 컴퓨터에 존재 하지 않는 새 이벤트 소스와 새 이벤트 로그를 만듭니다. 이벤트 메시지 텍스트는 리소스 식별자를 사용 하 여 리소스 파일에 지정 합니다.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 이 예제에서는 리소스 라이브러리 EventLogMsgs.dll에 기본 제공 되는 다음과 같은 메시지 텍스트 파일을 사용 합니다. 메시지 텍스트 파일은 소스 메시지 리소스 파일이 만들어집니다. 메시지 텍스트 파일의 리소스 식별자와 범주, 이벤트 메시지 및 매개 변수 삽입 문자열에 대 한 텍스트를 정의합니다.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" />의 <see cref="T:System.Diagnostics.EventLog" /> 속성이 설정되지 않은 경우  
  
 또는  
  
 메서드가 새 이벤트 원본을 등록하려고 시도했지만 <see cref="P:System.Diagnostics.EventLog.MachineName" />의 컴퓨터 이름이 유효하지 않습니다.  
  
 \- 또는 -  
  
 소스가 이미 다른 이벤트 로그에 등록된 경우  
  
 \- 또는 -  
  
 <paramref name="instance.InstanceId" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 <paramref name="values" />의 요소가 256개가 넘는 경우  
  
 \- 또는 -  
  
 <paramref name="values" /> 요소 중 하나가 32766바이트보다 긴 경우  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">지역화된 이벤트 로그 항목을 나타내는 <see cref="T:System.Diagnostics.EventInstance" /> 인스턴스입니다.</param>
        <param name="data">항목과 연관된 이진 데이터를 보유하는 바이트의 배열입니다.</param>
        <param name="values">이벤트 로그 항목의 메시지 텍스트로 병합될 문자열의 배열입니다.</param>
        <summary>지정된 이벤트 데이터, 메시지 대체 문자열 및 관련 이진 데이터가 포함된 이벤트 로그 엔트리를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 이벤트 로그에 이벤트 관련 데이터가 추가 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 해당 문자열에 대 한 지역화 된 리소스 파일을 표시 하는 <xref:System.Diagnostics.EventLog.Source%2A>합니다. 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.  
  
 입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A> 의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력 합니다. 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A> 및 <xref:System.Diagnostics.EventInstance.EntryType%2A> 의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력 합니다. 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.  
  
 이진 데이터는 이벤트에 대 한 추가 정보를 제공 해야 하는 경우의 이벤트를 지정 합니다. 예를 들어, 사용 된 `data` 특정 오류에 대 한 정보를 포함 하도록 매개 변수입니다. 이벤트 뷰어에서 관련된 이벤트 데이터를 해석 하지는 않습니다. 결합 된 16 진수 및 텍스트 형식에서 데이터를 표시합니다. 이벤트 관련 데이터를 사용 하 여 엄밀한; 유용할 것 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 뷰어를 사용자 이벤트에 대해 특별히 작성 하거나 이벤트 로그를 검사 하 고 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만듭니다는 프로그램을 작성할 수 있습니다.  
  
 설정 해야 합니다는 <xref:System.Diagnostics.EventLog.Source%2A> 속성에 사용자 <xref:System.Diagnostics.EventLog> 구성 요소를 사용 하기 전에 하기 전에 구성 요소 <xref:System.Diagnostics.EventLog.WriteEvent%2A>합니다. 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
> [!NOTE]
>  지정 하지 않는 경우는 <xref:System.Diagnostics.EventLog.MachineName%2A> 에 대 한 프로그램 <xref:System.Diagnostics.EventLog> 호출 하기 전에 인스턴스 <xref:System.Diagnostics.EventLog.WriteEvent%2A>, 로컬 컴퓨터 (".") 것으로 간주 됩니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 사용 된 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 메서드.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
> [!NOTE]
>  원격 컴퓨터의 값에 항목을 기록 하는 경우는 `message` 문자열 원격 컴퓨터의.NET Framework를 실행 하지 않는 경우 예상 되지 않을 수 있습니다. 또한는 `message` 문자열 %를 포함할 수 없습니다*n*여기서 *n* 이벤트 뷰어 삽입 문자열으로 처리 하기 때문에 정수 값 (예: %1)입니다. 문자 시퀀스를 인터넷 프로토콜 버전 6 (IPv6) 주소가이 포함 될 수 있습니다, 때문에 IPv6 주소를 포함 하는 이벤트 메시지를 기록할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 감사 이벤트 로그에 항목을 작성 `myNewLog`합니다. 이 예제에서는 로컬 컴퓨터에 존재 하지 않는 새 이벤트 소스와 새 이벤트 로그를 만듭니다. 이벤트 메시지 텍스트는 리소스 식별자를 사용 하 여 리소스 파일에 지정 합니다.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 이 예제에서는 리소스 라이브러리 EventLogMsgs.dll에 기본 제공 되는 다음과 같은 메시지 텍스트 파일을 사용 합니다. 메시지 텍스트 파일은 소스 메시지 리소스 파일이 만들어집니다. 메시지 텍스트 파일의 리소스 식별자와 범주, 이벤트 메시지 및 매개 변수 삽입 문자열에 대 한 텍스트를 정의합니다.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" />의 <see cref="T:System.Diagnostics.EventLog" /> 속성이 설정되지 않은 경우  
  
 또는  
  
 메서드가 새 이벤트 원본을 등록하려고 시도했지만 <see cref="P:System.Diagnostics.EventLog.MachineName" />의 컴퓨터 이름이 유효하지 않습니다.  
  
 \- 또는 -  
  
 소스가 이미 다른 이벤트 로그에 등록된 경우  
  
 \- 또는 -  
  
 <paramref name="instance.InstanceId" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 <paramref name="values" />의 요소가 256개가 넘는 경우  
  
 \- 또는 -  
  
 <paramref name="values" /> 요소 중 하나가 32766바이트보다 긴 경우  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">지정된 컴퓨터의 응용 프로그램에 등록된 이벤트 원본의 이름입니다.</param>
        <param name="instance">지역화된 이벤트 로그 항목을 나타내는 <see cref="T:System.Diagnostics.EventInstance" /> 인스턴스입니다.</param>
        <param name="values">이벤트 로그 항목의 메시지 텍스트로 병합될 문자열의 배열입니다.</param>
        <summary>지정한 등록된 이벤트 소스를 사용하여 지정된 이벤트 데이터와 메시지 대체 문자열이 포함된 이벤트 로그 엔트리를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 된 소스를 사용 하 여 이벤트 로그에 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 원본에 대 한 지역화 된 리소스 파일에서 해당 문자열을 표시 합니다. 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.  
  
 입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A> 의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력 합니다. 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A> 및 <xref:System.Diagnostics.EventInstance.EntryType%2A> 의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력 합니다. 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.  
  
 지정된 된 소스 이벤트 로그에 대 한 사용 하기 전에 등록 해야 <xref:System.Diagnostics.EventLog.WriteEvent%2A>합니다. 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 사용 된 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 메서드.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
   
  
## Examples  
 다음 예제에서는 기존 이벤트 로그에 정보 이벤트 엔트리 및 경고 이벤트 엔트리를 씁니다. 이벤트 메시지 텍스트는 리소스 식별자를 사용 하 여 리소스 파일에 지정 합니다. 이 예제에서는 해당 리소스 파일의 원본에 대 한 등록 되었다고 가정 합니다.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 이 예제에서는 리소스 라이브러리 EventLogMsgs.dll에 기본 제공 되는 다음과 같은 메시지 텍스트 파일을 사용 합니다. 메시지 텍스트 파일은 소스 메시지 리소스 파일이 만들어집니다. 메시지 텍스트 파일의 리소스 식별자와 범주, 이벤트 메시지 및 매개 변수 삽입 문자열에 대 한 텍스트를 정의합니다.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 값이 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 값이 <see langword="null" />입니다.  
  
 \- 또는 -  
  
 <paramref name="instance.InstanceId" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 <paramref name="values" />의 요소가 256개가 넘는 경우  
  
 \- 또는 -  
  
 <paramref name="values" /> 요소 중 하나가 32766바이트보다 긴 경우  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">지정된 컴퓨터의 응용 프로그램에 등록된 이벤트 원본의 이름입니다.</param>
        <param name="instance">지역화된 이벤트 로그 항목을 나타내는 <see cref="T:System.Diagnostics.EventInstance" /> 인스턴스입니다.</param>
        <param name="data">항목과 연관된 이진 데이터를 보유하는 바이트의 배열입니다.</param>
        <param name="values">이벤트 로그 항목의 메시지 텍스트로 병합될 문자열의 배열입니다.</param>
        <summary>지정한 등록된 이벤트 소스를 사용하여 지정된 이벤트 데이터, 메시지 대체 문자열 및 관련 이진 데이터가 포함된 이벤트 로그 엔트리를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 적절 한 로그에 대 한 이벤트 소스로 이미 등록 된 소스를 사용 하 여 이벤트 로그에 이벤트 관련 데이터가 추가 지역화 된 엔트리를 씁니다. 문자열 값이 아닌 리소스 식별자와 함께 이벤트 속성을 지정 합니다. 이벤트 뷰어에서 리소스 식별자를 사용 하 여 원본에 대 한 지역화 된 리소스 파일에서 해당 문자열을 표시 합니다. 리소스 식별자를 사용 하 여 이벤트를 작성 하기 전에 해당 리소스 파일에는 소스를 등록 해야 합니다.  
  
 입력 `instance` 인스턴스 이벤트 메시지 및 속성을 지정 합니다. 설정의 <xref:System.Diagnostics.EventInstance.InstanceId%2A> 의 `instance` 소스 메시지 리소스 파일에서 정의 된 메시지에 대 한 입력 합니다. 선택적으로 설정할 수는 <xref:System.Diagnostics.EventInstance.CategoryId%2A> 및 <xref:System.Diagnostics.EventInstance.EntryType%2A> 의 `instance` 이벤트 항목의 범주 및 이벤트 유형을 정의 하는 입력 합니다. 지역화 된 메시지 텍스트에 삽입 하는 언어에 관계 없이 문자열의 배열을 지정할 수도 있습니다. 설정 `values` 를 `null` 이벤트 메시지 대체 문자열에 대 한 서식 지정 자리 표시자 포함 되어 있지 않습니다.  
  
 이진 데이터는 이벤트에 대 한 추가 정보를 제공 해야 하는 경우의 이벤트를 지정 합니다. 예를 들어, 사용 된 `data` 특정 오류에 대 한 정보를 포함 하도록 매개 변수입니다. 이벤트 뷰어에서 관련된 이벤트 데이터를 해석 하지는 않습니다. 결합 된 16 진수 및 텍스트 형식에서 데이터를 표시합니다. 이벤트 관련 데이터를 사용 하 여 엄밀한; 유용할 것 경우에 포함 합니다. 또한 응용 프로그램 이벤트 뷰어 독립적으로 처리할 수 정보를 저장할 이벤트 관련 데이터를 사용할 수 있습니다. 예를 들어 뷰어를 사용자 이벤트에 대해 특별히 작성 하거나 이벤트 로그를 검사 하 고 이벤트 관련 데이터에서 정보를 포함 하는 보고서를 만듭니다는 프로그램을 작성할 수 있습니다.  
  
 지정된 된 소스 이벤트 로그에 대 한 사용 하기 전에 등록 해야 <xref:System.Diagnostics.EventLog.WriteEvent%2A>합니다. 로그에 지역화 된 엔트리를 쓰기 위한 지정한 소스를 구성 합니다. 소스에 최소한 있어야 메시지 리소스 파일을 정의 합니다.  
  
 만들 하며 소스와 첫 번째 항목을 기록 하기 전에 이벤트 소스를 구성 합니다. 응용 프로그램의 설치 하는 동안 새 이벤트 소스를 만듭니다. 이렇게 하면 운영 체제 등록 된 이벤트 소스 목록과 구성을 새로 고칠 수 있습니다. 운영 체제에서 이벤트 소스 목록을 새로 고치지 않은 경우 새 소스를 사용 하 여 이벤트 쓰려고 쓰기 작업이 실패 합니다. 사용 하 여 새 원본을 구성할 수 있습니다는 <xref:System.Diagnostics.EventLogInstaller>, 또는 사용 하는 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 메서드. 새 이벤트 소스를 만들려면 컴퓨터에 관리자 권한이 있어야 합니다.  
  
 지역화 된 엔트리 또는 직접 문자열을 작성 하기 위한 소스를 구성 합니다. 사용 된 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 응용 프로그램 이벤트 로그에 직접 문자열 값을 쓰는 메서드.  
  
 리소스 식별자와 문자열 값을 사용 하 여 항목을 기록 하는 응용 프로그램을 두 개의 별도 소스를 등록 해야 합니다. 예를 들어 리소스 파일에 대해 하나의 소스를 구성 하 고 다음 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEvent%2A> 메서드가 이벤트 로그에 대 한 리소스 식별자를 사용 하 여 엔트리를 작성할 수 있습니다. 그런 다음 리소스 파일 없이 다른 소스를 만들고 해당 소스를 사용 하 여는 <xref:System.Diagnostics.EventLog.WriteEntry%2A> 메서드를 해당 소스를 사용 하 여 이벤트 로그에 직접 씁니다.  
  
   
  
## Examples  
 다음 예제에서는 기존 이벤트 로그에 정보 이벤트 엔트리 및 경고 이벤트 엔트리를 씁니다. 이벤트 메시지 텍스트는 리소스 식별자를 사용 하 여 리소스 파일에 지정 합니다. 이 예제에서는 해당 리소스 파일의 원본에 대 한 등록 되었다고 가정 합니다.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 이 예제에서는 리소스 라이브러리 EventLogMsgs.dll에 기본 제공 되는 다음과 같은 메시지 텍스트 파일을 사용 합니다. 메시지 텍스트 파일은 소스 메시지 리소스 파일이 만들어집니다. 메시지 텍스트 파일의 리소스 식별자와 범주, 이벤트 메시지 및 매개 변수 삽입 문자열에 대 한 텍스트를 정의합니다.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 값이 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="source" /> 값이 <see langword="null" />입니다.  
  
 \- 또는 -  
  
 <paramref name="instance.InstanceId" />가 0보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큰 경우  
  
 \- 또는 -  
  
 <paramref name="values" />의 요소가 256개가 넘는 경우  
  
 \- 또는 -  
  
 <paramref name="values" /> 요소 중 하나가 32766바이트보다 긴 경우  
  
 \- 또는 -  
  
 소스 이름 때문에 레지스트리 키 경로가 254자를 넘는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이벤트 로그의 레지스트리 키를 열 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">이벤트 로그에 이벤트 엔트리를 쓸 때 운영 체제에서 오류를 보고한 경우. Windows 오류 코드를 사용할 수 없습니다.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">컴퓨터에서 이벤트 로그 정보를 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>