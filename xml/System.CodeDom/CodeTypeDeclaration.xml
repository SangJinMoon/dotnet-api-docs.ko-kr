<Type Name="CodeTypeDeclaration" FullName="System.CodeDom.CodeTypeDeclaration">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ada939b11aca74ba85b3b6dd8b46aedfae2d91a5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36645957" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CodeTypeDeclaration : System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit CodeTypeDeclaration extends System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.CodeTypeDeclaration" />
  <TypeSignature Language="VB.NET" Value="Public Class CodeTypeDeclaration&#xA;Inherits CodeTypeMember" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeTypeDeclaration : System::CodeDom::CodeTypeMember" />
  <TypeSignature Language="F#" Value="type CodeTypeDeclaration = class&#xA;    inherit CodeTypeMember" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.CodeDom.CodeTypeMember</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>클래스, 구조체, 인터페이스 또는 열거형의 형식 선언을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.CodeTypeDeclaration> 클래스, 구조체, 인터페이스 또는 열거형을 선언 하는 코드를 나타내는 데 사용할 수 수 있습니다. <xref:System.CodeDom.CodeTypeDeclaration> 다른 형식 내에 중첩 된 형식을 선언 하 사용할 수 있습니다.  
  
 <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> 기본 형식 또는 선언 되는 형식의 기본 형식 속성을 지정 합니다. <xref:System.CodeDom.CodeTypeDeclaration.Members%2A> 속성 메서드, 필드, 속성, 설명 및 기타 형식을 포함할 수 있는 형식 멤버를 포함 합니다. <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> 속성 나타냅니다는 <xref:System.Reflection.TypeAttributes> 형식 선언에 대 한 종류의 형식 범주를 나타내는 값입니다. <xref:System.CodeDom.CodeTypeDeclaration.IsClass%2A>, <xref:System.CodeDom.CodeTypeDeclaration.IsStruct%2A>, <xref:System.CodeDom.CodeTypeDeclaration.IsEnum%2A>, 및 <xref:System.CodeDom.CodeTypeDeclaration.IsInterface%2A> 메서드 형식이 인지 클래스, 구조체, 열거형 또는 인터페이스 형식으로 각각 나타냅니다.  
  
> [!NOTE]
>  일부 프로그래밍 언어에는 참조 형식 또는 클래스의 선언을 지원합니다. 인터페이스, 열거형 또는 값 형식 선언에 대 한 지원에 대 한 언어별 CodeDOM 코드 생성기를 확인 하려면 호출는 <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> 테스트 하기 위해 적절 한 메서드 <xref:System.CodeDom.Compiler.GeneratorSupport> 플래그입니다. <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareInterfaces> 인터페이스에 대 한 지원을 나타냅니다 <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareEnums> 열거형에 대 한 지원을 나타냅니다 및 <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareValueTypes> 구조와 같은 값 형식에 대 한 지원을 나타냅니다.  
  
 클래스 또는 구조체 하나의 완전 한 선언, 구현을 작성 하거나 여러 선언으로 분할할 수 있습니다. <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> 속성 형식 선언은 전부 또는 일부 인지를 나타냅니다. 일부 코드 생성기를 호출 하 여이 지원에 대 한 테스트 해야 하므로 부분 형식 선언을 지원는 <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> 플래그로 메서드 <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>합니다.  
  
   
  
## Examples  
 사용 하 여 보여 주는이 예제는 <xref:System.CodeDom.CodeTypeDeclaration> 형식을 선언할 수 있습니다.  
  
 [!code-cpp[CodeTypeDeclarationExample#2](~/samples/snippets/cpp/VS_Snippets_CLR/CodeTypeDeclarationExample/CPP/codetypedeclarationexample.cpp#2)]
 [!code-csharp[CodeTypeDeclarationExample#2](~/samples/snippets/csharp/VS_Snippets_CLR/CodeTypeDeclarationExample/CS/codetypedeclarationexample.cs#2)]
 [!code-vb[CodeTypeDeclarationExample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeTypeDeclarationExample/VB/codetypedeclarationexample.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.CodeDom.CodeTypeDeclarationCollection" />
    <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.CodeTypeDeclaration : string -&gt; System.CodeDom.CodeTypeDeclaration" Usage="new System.CodeDom.CodeTypeDeclaration name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">새 형식의 이름입니다.</param>
        <summary>지정된 이름을 사용하여 <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseTypes">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeReferenceCollection BaseTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeReferenceCollection BaseTypes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseTypes As CodeTypeReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeReferenceCollection ^ BaseTypes { System::CodeDom::CodeTypeReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseTypes : System.CodeDom.CodeTypeReferenceCollection" Usage="System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 형식의 기본 형식을 가져옵니다.</summary>
        <value>형식의 기본 형식을 나타내는 <see cref="T:System.CodeDom.CodeTypeReferenceCollection" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 형식에서 상속 되지 않는 하나 이상의 인터페이스를 구현 하지만 Visual basic에서 클래스를 생성 하려면 포함 해야 <xref:System.Object> 의 첫 번째 항목으로는 <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> 컬렉션입니다.  
  
> [!NOTE]
>  .NET framework 버전 2.0 필요 하지 않습니다는 <xref:System.CodeDom.CodeTypeReference> 에 대 한 <xref:System.Object> 이미 구현 하는 인터페이스 존재 하 고 형식에서 참조 하는 경우. 예를 들어, 구현 하는 경우는 <xref:System.Collections.ICollection> 인터페이스 및이 문 사용 하 여 컬렉션에 추가할 `ctd.BaseTypes.Add(New CodeTypeReference(typeof(ICollection)))`, 위의 필요 하지 않습니다 `ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))` 문.  
  
 다음 코드에서는 추가 <xref:System.CodeDom.CodeTypeReference> 참조 하는 컬렉션에 <xref:System.Object>합니다.  
  
```vb  
Dim ctd As New CodeTypeDeclaration("Class1")  
ctd.IsClass = True  
ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))  
ctd.BaseTypes.Add(New CodeTypeReference("Interface1"))  
```  
  
```csharp  
CodeTypeDeclaration ctd = new CodeTypeDeclaration("Class1");  
ctd.IsClass = true;  
ctd.BaseTypes.Add(new CodeTypeReference(typeof(Object)));  
ctd.BaseTypes.Add(new CodeTypeReference("Interface1"));  
```  
  
 위의 코드는 다음 Visual Basic 코드의 해당을 생성합니다.  
  
```vb  
Public Class Class1  
Implements Interface1  
```  
  
 그러나 실제로 생성 되는 Visual Basic 코드는 다음과 같습니다.  
  
```vb  
Public Class Class1  
Inherits Object  
Implements Interface1  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeReferenceCollection" />
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 형식이 클래스인지 또는 참조 형식인지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>형식이 클래스 또는 참조 형식이면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public bool IsEnum { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 형식이 열거형인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>형식이 열거형이면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 형식이 인터페이스인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>형식이 인터페이스이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPartial">
      <MemberSignature Language="C#" Value="public bool IsPartial { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPartial" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPartial As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPartial { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPartial : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식 선언이 완전한지 또는 부분적인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>클래스 또는 구조체 선언이 부분적인 구현을 나타내면 <see langword="true" />이고, 완전한 구현이면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 작성 한 완전 한 선언, 클래스 또는 구조체 구현 하거나 여러 선언으로 분할할 수 있습니다. 구현이 하나의 완전 한 형식 선언에 일반적으로 제공 됩니다. 이 경우 형식 선언의 설정 <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> 속성을 `false`, 형식 선언의 클래스 또는 구조체 구현에 대 한 모든 세부 정보를 나타낸다는 것을 의미입니다.  
  
 부분 형식 선언 쉽게 응용 프로그램의 서로 다른 모듈에는 클래스 또는 구조체 구현의 서로 다른 부분을 빌드할 수 있습니다. 부분 형식 선언은 한 소스 파일에 저장 또는 결국 함께로 컴파일되는 조합된 형식의 구현을 구성 하는 여러 소스 파일에 분산 수 있습니다.  
  
 C# 언어 클래스의 부분 형식 선언을 지원 및 통해 구조는 `partial` 키워드입니다. Visual Basic 클래스의 부분 형식 선언을 지원 및와 구조는 `Partial` 키워드입니다. 일부 코드 생성기를 호출 하 여이 지원에 대 한 테스트 해야 하므로 부분 형식 선언을 지원는 <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> 플래그로 메서드 <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>합니다.  
  
> [!NOTE]
>  부분 형식 선언은 클래스 및 구조체에 사용할 수 있습니다. 열거형 또는 인터페이스에 대 한 부분 형식 선언을 지정 하면 생성된 된 코드는 컴파일러 오류를 생성 합니다.  
  
 여러 선언에서 클래스 또는 구조체 구현을 제공할 때 설정 된 <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> 속성을 `true` 초기 선언 및 모든 추가 선언에 대 한 합니다. 초기 선언 형식을 완전히 지정 해야 액세스 한정자를 포함 하 여 서명 형식, 상속 및 인터페이스를 구현 합니다. 추가 선언 형식 시그니처를 다시 지정할 필요가 없습니다. 추가 선언에 형식 시그니처를 재정의 하는 경우에 일반적으로 컴파일러 오류가 발생 합니다.  
  
 Visual Studio 2005 부분 형식을 사용 하 여 디자이너 코드에서 사용자에서 생성 된 코드를 구분 합니다. Visual Basic Windows 응용 프로그램 프로젝트에 사용자 코드에서 정규화 되지 않은 partial 클래스에 배치 되는 `Partial` 키워드; 디자이너에서 제공 된 partial 클래스에 코드가 표시는 `Partial` 키워드 합니다. C#에서 사용자 코드와 디자이너 코드에에서 표시로 식별 되는 partial 클래스는 `partial` 키워드입니다.  
  
   
  
## Examples  
 사용 하 여 보여 주는이 예제는 <xref:System.CodeDom.CodeTypeDeclaration> 여러 선언에서 클래스를 구현 하 합니다. 예제에는 초기 클래스 선언 문을 작성 하 고 설정의 <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> 속성을 `true`합니다.  
  
 [!code-cpp[CodeDomPartialTypeExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomPartialTypeExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#3)]
 [!code-vb[CodeDomPartialTypeExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#3)]  
  
 이 예제에서 다른 메서드는 클래스 구현을 확장합니다. 이 메서드는 기존 클래스 및 설정에 대 한 새 형식을 선언 문 작성 된 <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> 속성을 `true`합니다. 컴파일러는 완전 한 클래스 구현에 대 한 두 개의 부분 형식 선언을 결합합니다.  
  
 [!code-cpp[CodeDomPartialTypeExample#7](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#7)]
 [!code-csharp[CodeDomPartialTypeExample#7](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#7)]
 [!code-vb[CodeDomPartialTypeExample#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.CodeDom.Compiler.GeneratorSupport.PartialTypes" />
      </Docs>
    </Member>
    <Member MemberName="IsStruct">
      <MemberSignature Language="C#" Value="public bool IsStruct { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStruct" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberSignature Language="VB.NET" Value="Public Property IsStruct As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStruct { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsStruct : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식이 값 형식(구조체)인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>형식이 값 형식이면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Members">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeMemberCollection Members { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeMemberCollection Members" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Members As CodeTypeMemberCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeMemberCollection ^ Members { System::CodeDom::CodeTypeMemberCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Members : System.CodeDom.CodeTypeMemberCollection" Usage="System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeMemberCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>표시된 형식에 대한 클래스 멤버의 컬렉션을 가져옵니다.</summary>
        <value>클래스 멤버를 나타내는 <see cref="T:System.CodeDom.CodeTypeMemberCollection" /> 개체입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.CodeDom.CodeTypeMemberCollection" />
      </Docs>
    </Member>
    <Member MemberName="PopulateBaseTypes">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateBaseTypes;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateBaseTypes" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateBaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateBaseTypes As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateBaseTypes;" />
      <MemberSignature Language="F#" Value="member this.PopulateBaseTypes : EventHandler " Usage="member this.PopulateBaseTypes : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" /> 컬렉션에 처음 액세스할 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopulateMembers">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateMembers;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateMembers" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateMembers" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateMembers As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateMembers;" />
      <MemberSignature Language="F#" Value="member this.PopulateMembers : EventHandler " Usage="member this.PopulateMembers : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.CodeDom.CodeTypeDeclaration.Members" /> 컬렉션에 처음 액세스할 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAttributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes TypeAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes TypeAttributes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeAttributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes TypeAttributes { System::Reflection::TypeAttributes get(); void set(System::Reflection::TypeAttributes value); };" />
      <MemberSignature Language="F#" Value="member this.TypeAttributes : System.Reflection.TypeAttributes with get, set" Usage="System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식의 특성을 가져오거나 설정합니다.</summary>
        <value>형식의 특성을 나타내는 <see cref="T:System.Reflection.TypeAttributes" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes> 동일한 유형의 사용 하는 값을 포함 하는 속성 <xref:System.Reflection> 런타임 시 형식 조사할 때. 이러한 플래그의 대부분 일부 언어에 대 한 형식 선언 구문에 일치 하지 않습니다. 결과적으로, 다음 플래그만을 주는지 <xref:System.CodeDom.CodeTypeDeclaration> : <xref:System.Reflection.TypeAttributes.Class>, <xref:System.Reflection.TypeAttributes.Interface>, <xref:System.Reflection.TypeAttributes.Abstract>, <xref:System.Reflection.TypeAttributes.Sealed>, <xref:System.Reflection.TypeAttributes.Public>, <xref:System.Reflection.TypeAttributes.NotPublic>, <xref:System.Reflection.TypeAttributes.NestedPublic>, 및 <xref:System.Reflection.TypeAttributes.NestedPrivate>합니다.  
  
> [!NOTE]
>  일부와 같은 플래그 <xref:System.Reflection.TypeAttributes.Abstract> 의 플래그의 의미와 중복 되는 <xref:System.CodeDom.CodeTypeMember.Attributes%2A> 속성의 <xref:System.CodeDom.CodeTypeDeclaration> 에서 상속 된 <xref:System.CodeDom.CodeTypeMember>합니다. <xref:System.CodeDom.CodeTypeMember.Attributes%2A> 속성의 부작용은는 <xref:System.CodeDom.CodeTypeDeclaration> 클래스에서 상속 <xref:System.CodeDom.CodeTypeMember> 클래스에 중첩 될 수 있도록 합니다. 플래그는 <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> 속성의 플래그는 대신 사용 해야는 <xref:System.CodeDom.CodeTypeMember.Attributes%2A> 속성입니다.  
  
> [!NOTE]
>  표시 범위 플래그를 설정 하기 위한 패턴 (단어를 포함 하는 플래그 `Public` 또는 `Nested`)를 마스킹 모든 표시 범위 플래그를 사용 하 여는 <xref:System.Reflection.TypeAttributes.VisibilityMask> 원하는 표시 범위 플래그를 설정 합니다. 예를 들어 C# 코드 문을 식별 하는 <xref:System.CodeDom.CodeTypeDeclaration> (라는 `cd`)는 내부 클래스는 있는 그대로 `cd.TypeAttributes = (cd.TypeAttributes & ~TypeAttributes.VisibilityMask) | TypeAttributes.NotPublic;`합니다.  Visual Basic에서는 동일한 값을 설정 하는 코드는 `cd.TypeAttributes = (cd.TypeAttributes And (TypeAttributes.VisibilityMask Xor -1)) Or TypeAttributes.NotPublic`합니다. 설정의 <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> 표시 범위 플래그에 직접 속성 (`cd.TypeAttributes = TypeAttributes.NotPublic;`) 설정 되었을 수 있는 다른 모든 플래그를 지웁니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="TypeParameters">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeParameterCollection TypeParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeParameterCollection TypeParameters" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeParameters As CodeTypeParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeParameterCollection ^ TypeParameters { System::CodeDom::CodeTypeParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeParameters : System.CodeDom.CodeTypeParameterCollection" Usage="System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식 선언에 대한 형식 매개 변수를 가져옵니다.</summary>
        <value>형식 선언에 대한 형식 매개 변수가 들어 있는 <see cref="T:System.CodeDom.CodeTypeParameterCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식 선언에 하나 이상의 형식 매개 변수 라는 형식이 지정 되지 않은 또는 합니다. 형식 매개 변수 이름은 제네릭 선언의 본문 안에 있는 형식을 나타냅니다. 예를 들어 제네릭 선언에는 <xref:System.Collections.Generic.List%601> 클래스 형식 매개 변수를 포함 합니다. `T`합니다.  
  
 제네릭에 대 한 자세한 내용은 참조 하십시오. [.NET Framework 클래스 라이브러리의 제네릭](~/docs/csharp/programming-guide/generics/generics-in-the-net-framework-class-library.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeParameterCollection" />
        <altmember cref="T:System.CodeDom.CodeTypeParameter" />
      </Docs>
    </Member>
  </Members>
</Type>