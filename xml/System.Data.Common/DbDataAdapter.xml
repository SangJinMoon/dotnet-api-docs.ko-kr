<Type Name="DbDataAdapter" FullName="System.Data.Common.DbDataAdapter">
  <TypeSignature Language="C#" Value="public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DbDataAdapter extends System.Data.Common.DataAdapter implements class System.Data.IDataAdapter, class System.Data.IDbDataAdapter, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.DbDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DbDataAdapter&#xA;Inherits DataAdapter&#xA;Implements ICloneable, IDbDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbDataAdapter abstract : System::Data::Common::DataAdapter, ICloneable, System::Data::IDbDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DataAdapter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.IDbDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="1bf95-101"><see cref="T:System.Data.IDbDataAdapter" /> 인터페이스의 구현을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-101">Aids implementation of the <see cref="T:System.Data.IDbDataAdapter" /> interface.</span></span> <span data-ttu-id="1bf95-102"><see cref="T:System.Data.Common.DbDataAdapter" />의 상속자는 강력한 형식을 제공하기 위한 함수 집합을 구현하지만 **DataAdapter**를 완전히 구현하는 데 필요한 대부분의 기능을 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-102">Inheritors of <see cref="T:System.Data.Common.DbDataAdapter" /> implement a set of functions to provide strong typing, but inherit most of the functionality needed to fully implement a **DataAdapter**.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-103"><xref:System.Data.Common.DbDataAdapter> 클래스에서 상속 된 <xref:System.Data.Common.DataAdapter> 클래스 및 구현 하는 <xref:System.Data.IDbDataAdapter> 인터페이스.</span><span class="sxs-lookup"><span data-stu-id="1bf95-103">The <xref:System.Data.Common.DbDataAdapter> class inherits from the <xref:System.Data.Common.DataAdapter> class and implements the <xref:System.Data.IDbDataAdapter> interface.</span></span> <span data-ttu-id="1bf95-104">클래스를 구현 하는 데 도움이 **DataAdapter** 관계형 데이터베이스와 함께 사용 하기 위해 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-104">It helps a class implement a **DataAdapter** designed for use with a relational database.</span></span>  
  
 <span data-ttu-id="1bf95-105">응용 프로그램의 인스턴스를 만들지 않습니다는 <xref:System.Data.Common.DbDataAdapter> 클래스를 직접 하지만 여기에서 상속 되는 클래스의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-105">An application does not create an instance of the <xref:System.Data.Common.DbDataAdapter> class directly, but creates an instance of a class that inherits from it.</span></span>  
  
 <span data-ttu-id="1bf95-106">상속 된 클래스는 <xref:System.Data.Common.DbDataAdapter> 상속 된 멤버를 구현 해야 하며 일반적으로 공급자 특정 기능을 추가 하기 위한 추가 멤버를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-106">Classes that inherit <xref:System.Data.Common.DbDataAdapter> must implement the inherited members, and typically define additional members to add provider-specific functionality.</span></span> <span data-ttu-id="1bf95-107">예를 들어는 <xref:System.Data.Common.DbDataAdapter> 클래스 정의 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성 및 <xref:System.Data.Common.DbDataAdapter> 클래스 정의의 8 개 오버 로드는 <xref:System.Data.IDataAdapter.Fill%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-107">For example, the <xref:System.Data.Common.DbDataAdapter> class defines the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property, and the <xref:System.Data.Common.DbDataAdapter> class defines eight overloads of the <xref:System.Data.IDataAdapter.Fill%2A> method.</span></span> <span data-ttu-id="1bf95-108">차례로 <xref:System.Data.OleDb.OleDbDataAdapter> 클래스 상속의 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드를 추가 두 오버 로드를 정의 <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> 는 ADO 레코드 집합 개체를 매개 변수로 사용 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-108">In turn, the <xref:System.Data.OleDb.OleDbDataAdapter> class inherits the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method, and also defines two additional overloads of <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> that take an ADO Recordset object as a parameter.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para><span data-ttu-id="1bf95-109">상속 하는 경우는 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스인 것이 좋습니다 다음 생성자를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-109">When you inherit from the <see cref="T:System.Data.Common.DbDataAdapter" /> class, we recommend that you implement the following constructors:</span></span>  
  
 <span data-ttu-id="1bf95-110"><list type="table"><listheader><term> 항목</span><span class="sxs-lookup"><span data-stu-id="1bf95-110"><list type="table"><listheader><term> Item</span></span>  
  
 <span data-ttu-id="1bf95-111"></term><description> 설명</span><span class="sxs-lookup"><span data-stu-id="1bf95-111"></term><description> Description</span></span>  
  
 <span data-ttu-id="1bf95-112"></description></listheader><item><term> *Prv*DataAdapter()</span><span class="sxs-lookup"><span data-stu-id="1bf95-112"></description></listheader><item><term> *Prv*DataAdapter()</span></span>  
  
 <span data-ttu-id="1bf95-113"></term><description> 새 인스턴스를 초기화는 *Prv*데이터 어댑터 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-113"></term><description> Initializes a new instance of the *Prv*DataAdapter class.</span></span>  
  
 <span data-ttu-id="1bf95-114"></description></item><item><term> *Prv*DataAdapter (*Prv*명령 *selectCommand*)</span><span class="sxs-lookup"><span data-stu-id="1bf95-114"></description></item><item><term> *Prv*DataAdapter(*Prv*Command *selectCommand*)</span></span>  
  
 <span data-ttu-id="1bf95-115"></term><description> 새 인스턴스를 초기화는 *Prv*지정 된 SQL SELECT 문 사용 하 여 데이터 어댑터 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-115"></term><description> Initializes a new instance of the *Prv*DataAdapter class with the specified SQL SELECT statement.</span></span>  
  
 <span data-ttu-id="1bf95-116"></description></item><item><term> *Prv*DataAdapter(string *selectCommandText*, string *selectConnectionString*)</span><span class="sxs-lookup"><span data-stu-id="1bf95-116"></description></item><item><term> *Prv*DataAdapter(string *selectCommandText*, string *selectConnectionString*)</span></span>  
  
 <span data-ttu-id="1bf95-117"></term><description> 새 인스턴스를 초기화는 *Prv*SQL SELECT 문 및 연결 문자열을 사용 하 여 데이터 어댑터 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-117"></term><description> Initializes a new instance of the *Prv*DataAdapter class with an SQL SELECT statement and a connection string.</span></span>  
  
 <span data-ttu-id="1bf95-118"></description></item><item><term> *Prv*DataAdapter(string *selectCommandText*, *Prv*Connection *selectConnection*)</span><span class="sxs-lookup"><span data-stu-id="1bf95-118"></description></item><item><term> *Prv*DataAdapter(string *selectCommandText*, *Prv*Connection *selectConnection*)</span></span>  
  
 <span data-ttu-id="1bf95-119"></term><description> 새 인스턴스를 초기화는 *Prv*SQL SELECT 문 사용 하 여 데이터 어댑터 클래스 및 *Prv*연결 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-119"></term><description> Initializes a new instance of the *Prv*DataAdapter class with an SQL SELECT statement and a *Prv*Connection object.</span></span>  
  
 </description></item></list>  
  
 <span data-ttu-id="1bf95-120">.NET Framework 데이터 공급자 간의 일관성으로 승격 하려면 폼에서 상속 하는 클래스 이름을 지정 해야 *Prv*DataAdapter, 여기서 *Prv* 는 특정.NET의 모든 클래스에 지정 된 일정 한 접두사 프레임 워크 데이터 공급자 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-120">To promote consistency among .NET Framework data providers, you should name the inheriting class in the form *Prv*DataAdapter, where *Prv* is the uniform prefix given to all classes in a specific .NET Framework data provider namespace.</span></span> <span data-ttu-id="1bf95-121">예를 들어 "Sql"은의 접두사는 <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> 클래스에 **System.Data.SqlClient** 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-121">For example, "Sql" is the prefix of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> class in the **System.Data.SqlClient** namespace.</span></span></para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bf95-122">
          <see langword="DataAdapter" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-122">Initializes a new instance of a <see langword="DataAdapter" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bf95-123">**DataAdapter** 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-123">Initializes a new instance of a **DataAdapter** class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-124">인스턴스를 만들 때 <xref:System.Data.Common.DbDataAdapter>, 다음 읽기/쓰기 속성은 다음 초기 값으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-124">When you create an instance of <xref:System.Data.Common.DbDataAdapter>, the following read/write properties are set to the following initial values.</span></span>  
  
|<span data-ttu-id="1bf95-125">속성</span><span class="sxs-lookup"><span data-stu-id="1bf95-125">Properties</span></span>|<span data-ttu-id="1bf95-126">초기 값</span><span class="sxs-lookup"><span data-stu-id="1bf95-126">Initial value</span></span>|  
|----------------|-------------------|  
|<xref:System.Data.IDbDataAdapter.SelectCommand%2A>|<span data-ttu-id="1bf95-127">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-127">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.IDbDataAdapter.InsertCommand%2A>|<span data-ttu-id="1bf95-128">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-128">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>|<span data-ttu-id="1bf95-129">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-129">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>|<span data-ttu-id="1bf95-130">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-130">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  
|<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|  
  
 <span data-ttu-id="1bf95-131">속성에 대 한 별도 호출을 통해 이러한 속성의 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-131">You can change the value of any of these properties through a separate call to the property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter"><span data-ttu-id="1bf95-132">새 <see langword="DataAdapter" />를 만드는 데 사용되는 <see langword="DataAdapter" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-132">A <see langword="DataAdapter" /> object used to create the new <see langword="DataAdapter" />.</span></span></param>
        <summary><span data-ttu-id="1bf95-133">같은 형식의 기존 개체에서 <see langword="DataAdapter" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-133">Initializes a new instance of a <see langword="DataAdapter" /> class from an existing object of the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-134">이 오버 로드는 <xref:System.Data.Common.DbDataAdapter> 생성자는 사용 하기 위한.NET Framework 데이터 공급자에서 복제 구현에서 사용 하기 위해 비슷한 생성자를 구현 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="1bf95-134">This overload of the <xref:System.Data.Common.DbDataAdapter> constructor is designed for use by a .NET Framework data provider when implementing a similar constructor for use in a clone implementation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToBatch">
      <MemberSignature Language="C#" Value="protected virtual int AddToBatch (System.Data.IDbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 AddToBatch(class System.Data.IDbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function AddToBatch (command As IDbCommand) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int AddToBatch(System::Data::IDbCommand ^ command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.IDbCommand" />
      </Parameters>
      <Docs>
        <param name="command"><span data-ttu-id="1bf95-135">일괄 작업에 추가할 <see cref="T:System.Data.IDbCommand" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-135">The <see cref="T:System.Data.IDbCommand" /> to add to the batch.</span></span></param>
        <summary><span data-ttu-id="1bf95-136">현재 일괄 작업에 <see cref="T:System.Data.IDbCommand" />를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-136">Adds a <see cref="T:System.Data.IDbCommand" /> to the current batch.</span></span></summary>
        <returns><span data-ttu-id="1bf95-137"><see cref="T:System.Data.IDbCommand" />를 추가하기 전에 일괄 작업에 포함되어 있는 명령 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-137">The number of commands in the batch before adding the <see cref="T:System.Data.IDbCommand" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-138"><xref:System.Data.Common.DbDataAdapter>,이 메서드에서 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-138">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1bf95-139">상속 된 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-139">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1bf95-140">어댑터에서 일괄 처리를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-140">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-141">이 메서드는 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-141">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
 <span data-ttu-id="1bf95-142">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스가 사용자가 일괄 처리 명령을 추가 하도록 허용 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-142">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to add a command to a batch.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ClearBatch">
      <MemberSignature Language="C#" Value="protected virtual void ClearBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ClearBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearBatch ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bf95-143">일괄 작업에서 <see cref="T:System.Data.IDbCommand" /> 개체를 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-143">Removes all <see cref="T:System.Data.IDbCommand" /> objects from the batch.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-144"><xref:System.Data.Common.DbDataAdapter>,이 메서드에서 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-144">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1bf95-145">상속 된 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-145">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1bf95-146">어댑터에서 일괄 처리를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-146">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-147">이 메서드는 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-147">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
 <span data-ttu-id="1bf95-148">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스가 일괄 처리에서 모든 명령을 제거 하는 사용자를 허용 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-148">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to remove all commands from a batch.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatedEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatedEventArgs ^ CreateRowUpdatedEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatedEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow"><span data-ttu-id="1bf95-149">데이터 소스를 업데이트하는 데 사용된 <see cref="T:System.Data.DataRow" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-149">The <see cref="T:System.Data.DataRow" /> used to update the data source.</span></span></param>
        <param name="command"><span data-ttu-id="1bf95-150"><see cref="T:System.Data.IDbCommand" /> 도중에 실행되는 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-150">The <see cref="T:System.Data.IDbCommand" /> executed during the <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</span></span></param>
        <param name="statementType"><span data-ttu-id="1bf95-151">명령이 UPDATE, INSERT, DELETE 또는 SELECT 문인지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-151">Whether the command is an UPDATE, INSERT, DELETE, or SELECT statement.</span></span></param>
        <param name="tableMapping"><span data-ttu-id="1bf95-152"><see cref="T:System.Data.Common.DataTableMapping" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-152">A <see cref="T:System.Data.Common.DataTableMapping" /> object.</span></span></param>
        <summary><span data-ttu-id="1bf95-153"><see cref="T:System.Data.Common.RowUpdatedEventArgs" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-153">Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> class.</span></span></summary>
        <returns><span data-ttu-id="1bf95-154"><see cref="T:System.Data.Common.RowUpdatedEventArgs" /> 클래스의 새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-154">A new instance of the <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> class.</span></span></returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-155">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-155">When overriding <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatingEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatingEventArgs ^ CreateRowUpdatingEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatingEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow"><span data-ttu-id="1bf95-156">데이터 소스를 업데이트하는 <see cref="T:System.Data.DataRow" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-156">The <see cref="T:System.Data.DataRow" /> that updates the data source.</span></span></param>
        <param name="command"><span data-ttu-id="1bf95-157"><see cref="T:System.Data.IDbCommand" /> 도중 실행할 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-157">The <see cref="T:System.Data.IDbCommand" /> to execute during the <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</span></span></param>
        <param name="statementType"><span data-ttu-id="1bf95-158">명령이 UPDATE, INSERT, DELETE 또는 SELECT 문인지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-158">Whether the command is an UPDATE, INSERT, DELETE, or SELECT statement.</span></span></param>
        <param name="tableMapping"><span data-ttu-id="1bf95-159"><see cref="T:System.Data.Common.DataTableMapping" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-159">A <see cref="T:System.Data.Common.DataTableMapping" /> object.</span></span></param>
        <summary><span data-ttu-id="1bf95-160"><see cref="T:System.Data.Common.RowUpdatingEventArgs" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-160">Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> class.</span></span></summary>
        <returns><span data-ttu-id="1bf95-161"><see cref="T:System.Data.Common.RowUpdatingEventArgs" /> 클래스의 새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-161">A new instance of the <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> class.</span></span></returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-162">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-162">When overriding <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSourceTableName">
      <MemberSignature Language="C#" Value="public const string DefaultSourceTableName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultSourceTableName" />
      <MemberSignature Language="DocId" Value="F:System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultSourceTableName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ DefaultSourceTableName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-163"><see cref="T:System.Data.Common.DataAdapter" /> 개체에서 테이블 매핑에 사용하는 기본 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-163">The default name used by the <see cref="T:System.Data.Common.DataAdapter" /> object for table mappings.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-164">"Table"은 사용 되는 기본 이름을 <xref:System.Data.Common.DataAdapter> 매핑 테이블에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-164">"Table" is the default name used by the <xref:System.Data.Common.DataAdapter> object for table mappings.</span></span>  
  
 <span data-ttu-id="1bf95-165"><xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> 응용 프로그램에서 사용 되는 테이블 매핑을 추가 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A>, 하지만 지정 하지 않습니다는 <xref:System.Data.DataTable> 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-165"><xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> is when an application adds a table mapping to be used with <xref:System.Data.Common.DbDataAdapter.Fill%2A>, but does not specify a <xref:System.Data.DataTable> name.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property DeleteCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ DeleteCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-166">데이터 집합에서 레코드를 삭제하기 위한 명령을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-166">Gets or sets a command for deleting records from the data set.</span></span></summary>
        <value><span data-ttu-id="1bf95-167"><see cref="T:System.Data.IDbCommand" />을 수행하는 동안 데이터 집합의 삭제된 행에 대한 데이터 소스에서 레코드를 삭제하는 데 사용되는 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-167">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to delete records in the data source for deleted rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-168">동안 <xref:System.Data.Common.DbDataAdapter.Update%2A>경우이 속성은 설정 되지 않으며 기본 키 정보에 있는지는 <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.DeleteCommand%2A> 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-168">During <xref:System.Data.Common.DbDataAdapter.Update%2A>, if this property is not set and primary key information is present in the <xref:System.Data.DataSet>, the <xref:System.Data.IDbDataAdapter.DeleteCommand%2A> is automatically generated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-169">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-169">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="1bf95-170">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-170"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="1bf95-171"><see cref="T:System.Data.Common.DbDataAdapter" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-171">Releases the unmanaged resources used by the <see cref="T:System.Data.Common.DbDataAdapter" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteBatch">
      <MemberSignature Language="C#" Value="protected virtual int ExecuteBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 ExecuteBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ExecuteBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ExecuteBatch () As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int ExecuteBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bf95-172">현재 일괄 작업을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-172">Executes the current batch.</span></span></summary>
        <returns><span data-ttu-id="1bf95-173">일괄 작업에 있는 마지막 명령의 반환 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-173">The return value from the last command in the batch.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-174"><xref:System.Data.Common.DbDataAdapter>,이 메서드에서 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-174">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1bf95-175">상속 된 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-175">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-176">이 메서드는 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-176">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
 <span data-ttu-id="1bf95-177">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스가 사용자가 일괄 처리를 실행 하도록 허용 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-177">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to execute a batch.</span></span> <span data-ttu-id="1bf95-178">이 메서드를 구현 일괄 처리를 어댑터에 명령을 결합 되어 일괄 처리를 실행 하 고 일괄 처리의 반환 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-178">An implementation of this method combines the commands in the adapter into a batch, then executes the batch and returns the return value of the batch.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fill">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bf95-179"><see cref="T:System.Data.DataSet" /> 또는 <see cref="T:System.Data.DataTable" />을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-179">Fills a <see cref="T:System.Data.DataSet" /> or a <see cref="T:System.Data.DataTable" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public override int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Fill(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-180">레코드와 스키마(필요한 경우)로 채울 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-180">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <summary><span data-ttu-id="1bf95-181"><see cref="T:System.Data.DataSet" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-181">Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-182"><see cref="T:System.Data.DataSet" />에 성공적으로 추가했거나 새로 고친 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-182">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="1bf95-183">여기에는 행을 반환하지 않는 문의 영향을 받는 행은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-183">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-184"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-184">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="1bf95-185"><xref:System.Data.IDbConnection> select 명령의와 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-185">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-186">경우는 <xref:System.Data.IDbConnection> 전에 닫은 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열어 데이터를 검색 한 다음 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-186">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data and then closed.</span></span> <span data-ttu-id="1bf95-187">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-187">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-188">데이터 테이블을 채우는 동안 오류 또는 예외가 발생 하는 경우 오류가 발생 하기 전에 추가 된 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-188">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="1bf95-189">작업의 나머지 부분에서는 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-189">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="1bf95-190">에 테이블이 추가 명령을 모든 행을 반환 하지 않으면는 <xref:System.Data.DataSet>, 예외가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-190">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, and no exception is raised.</span></span>  
  
 <span data-ttu-id="1bf95-191">경우는 <xref:System.Data.Common.DbDataAdapter> 개체 중복 된 열을 채우는 동안 발생 한 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1","*columnname*2", " *columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-191">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-192">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-192">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="1bf95-193">지정 된 쿼리가 여러 결과 반환 하는 경우 결과 집합 쿼리를 반환 하는 각 행에 대 한 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-193">When the query specified returns multiple results, the result set for each row returning query is placed in a separate table.</span></span> <span data-ttu-id="1bf95-194">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-194">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="1bf95-195">없는 테이블이 생성 된 행을 반환 하지 않는 쿼리에 대 한 선택 쿼리 뒤에 삽입 쿼리를 처리 하는 경우 때문에 선택 쿼리에 대해 생성 된 테이블 생성 되는 첫 번째 테이블에 있기 때문에 "Table" 이라는 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-195">Because no table is created for a query that does not return rows, if you process an insert query followed by a select query, the table created for the select query is named "Table" because it is the first table created.</span></span> <span data-ttu-id="1bf95-196">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-196">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-197">채우는 데 사용 된 SELECT 문에서 <xref:System.Data.DataSet> 여러 결과 반환 일괄 처리 SQL 문과 같은 결과 중 하나에 오류가 포함 되어 있는 경우 모든 후속 결과 건너뛰고에 추가 되지 않습니다는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-197">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as batch SQL statements, if one of the results contains an error, all subsequent results are skipped and are not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="1bf95-198">다음을 사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 내용 새로 고침에 대 한 호출은 <xref:System.Data.DataSet>, 두 조건이 충족 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-198">When using subsequent <xref:System.Data.Common.DbDataAdapter.Fill%2A> calls to refresh the contents of the <xref:System.Data.DataSet>, two conditions must be met:</span></span>  
  
1.  <span data-ttu-id="1bf95-199">SQL 문을 처음 채우는 데 사용 되는 일치 해야는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-199">The SQL statement should match the one initially used to populate the <xref:System.Data.DataSet>.</span></span>  
  
2.  <span data-ttu-id="1bf95-200">**키** 열 정보가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-200">The **Key** column information must be present.</span></span>  
  
 <span data-ttu-id="1bf95-201">기본 키 정보가 있는 경우 중복 행은 조정을 한 번만는 <xref:System.Data.DataTable> 에 해당 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-201">If primary key information is present, any duplicate rows are reconciled and only appear once in the <xref:System.Data.DataTable> that corresponds to the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-202">통해 기본 키 정보가 설정할 수 있습니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 지정 하 여는 <xref:System.Data.DataTable.PrimaryKey%2A> 속성의는 <xref:System.Data.DataTable>, 또는 설정 하 여는 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 속성을 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-202">Primary key information may be set either through <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, by specifying the <xref:System.Data.DataTable.PrimaryKey%2A> property of the <xref:System.Data.DataTable>, or by setting the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> property to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-203">`SelectCommand`가 OUTER JOIN의 결과를 반환하면 `DataAdapter`는 결과 <xref:System.Data.DataTable.PrimaryKey%2A>에 대해 <xref:System.Data.DataTable> 값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-203">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-204">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-204">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="1bf95-205">자세한 내용은 참조 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-205">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-206">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-206">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-207">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-207">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataTable ^ dataTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="1bf95-208">테이블 매핑에 사용할 <see cref="T:System.Data.DataTable" />의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-208">The name of the <see cref="T:System.Data.DataTable" /> to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="1bf95-209"><see cref="T:System.Data.DataSet" /> 이름을 사용하여 지정된 범위에서 데이터 소스의 행과 일치하도록 <see cref="T:System.Data.DataTable" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-209">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataTable" /> name.</span></span></summary>
        <returns><span data-ttu-id="1bf95-210"><see cref="T:System.Data.DataSet" />에 성공적으로 추가했거나 새로 고친 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-210">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="1bf95-211">여기에는 행을 반환하지 않는 문의 영향을 받는 행은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-211">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-212"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문에서 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-212">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="1bf95-213">SELECT 문은 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-213">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-214">하기 전에 연결이 닫히거나 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-214">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-215">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-215">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-216"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 대상에 행을 추가 하는 작업을 다음 <xref:System.Data.DataTable> 개체에 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체.</span><span class="sxs-lookup"><span data-stu-id="1bf95-216">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation then adds the rows to destination <xref:System.Data.DataTable> objects in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> objects if they do not already exist.</span></span> <span data-ttu-id="1bf95-217">만들 때 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-217">When creating <xref:System.Data.DataTable> objects, the <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="1bf95-218">그러나 경우는 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-218">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="1bf95-219">경우는 <xref:System.Data.Common.DbDataAdapter> 발생할 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-219">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-220">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-220">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-221">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet> 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-221">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span>  
  
 <span data-ttu-id="1bf95-222">오버 로드가 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 생긴다는 `DataTable` 대로 매개 변수 에서만 첫 번째 결과 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-222">The overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataTable` as a parameter only obtains the first result.</span></span> <span data-ttu-id="1bf95-223">오버 로드를 사용 하 여 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 생긴다는 `DataSet` 여러 결과를 얻으려면 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-223">Use an overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataSet` as a parameter to obtain multiple results.</span></span>  
  
 <span data-ttu-id="1bf95-224"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-224">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-225">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-225">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="1bf95-226">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-226">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
 dataset.Tables.Add("AAA");  
 adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
    adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="1bf95-227">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-227">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-228">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-228">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-229">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-229">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-230">사용할 수는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드가 여러 번 같은 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-230">You can use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-231">기본 키가 있는 경우 이미 존재 하는 일치 하는 행과 들어오는 행이 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-231">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="1bf95-232">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-232">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-233">`SelectCommand`가 OUTER JOIN의 결과를 반환하면 `DataAdapter`는 결과 <xref:System.Data.DataTable.PrimaryKey%2A>에 대해 <xref:System.Data.DataTable> 값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-233">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-234">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-234">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="1bf95-235">자세한 내용은 참조 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-235">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-236">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 및 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> .NET Framework 데이터에 대 한 공급자만 첫 번째 결과 대 한 스키마 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-236">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.Fill%2A> and <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for a .NET Framework data provider retrieves schema information for only the first result.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-237">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-237">The source table is invalid.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-238">이 오버 로드는 <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> 메서드 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-238">This overload of the <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-239">레코드와 스키마(필요한 경우)로 채울 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-239">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="srcTable"><span data-ttu-id="1bf95-240">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-240">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="1bf95-241"><see cref="T:System.Data.DataSet" />과 <see cref="T:System.Data.DataSet" /> 이름을 사용하여 데이터 소스의 행과 일치하도록 <see cref="T:System.Data.DataTable" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-241">Adds or refreshes rows in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and <see cref="T:System.Data.DataTable" /> names.</span></span></summary>
        <returns><span data-ttu-id="1bf95-242"><see cref="T:System.Data.DataSet" />에 성공적으로 추가했거나 새로 고친 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-242">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="1bf95-243">여기에는 행을 반환하지 않는 문의 영향을 받는 행은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-243">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-244"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-244">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="1bf95-245"><xref:System.Data.IDbConnection> select 명령의와 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-245">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-246">경우는 <xref:System.Data.IDbConnection> 전에 닫은 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-246">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-247">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-247">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-248">에 테이블이 추가 명령을 모든 행을 반환 하지 않으면는 <xref:System.Data.DataSet>, 예외가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-248">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, and no exception is raised.</span></span>  
  
 <span data-ttu-id="1bf95-249">경우는 <xref:System.Data.Common.DbDataAdapter> 개체 중복 된 열을 채우는 동안 발생 한 <xref:System.Data.DataTable>, 패턴 "columnname1", "columnname2", "columnname3" 및 등을 사용 하 여 후속 열에 대 한 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-249">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "columnname1", "columnname2", "columnname3", and so on.</span></span> <span data-ttu-id="1bf95-250">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-250">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="1bf95-251">지정 된 쿼리가 여러 결과 반환 하는 경우 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-251">When the query specified returns multiple results, each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-252">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-252">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="1bf95-253">없는 테이블이 생성 된 행을 반환 하지 않는 쿼리에 대 한 선택 쿼리 뒤에 삽입 쿼리를 처리 하는 경우 이후 select 쿼리에 대해 생성 되는 테이블을 이름이 "Table" 생성 되는 첫 번째 테이블에 있기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-253">Since no table is created for a query that does not return rows, if you were to process an insert query followed by a select query, the table created for the select query would be named "Table", because it is the first table created.</span></span> <span data-ttu-id="1bf95-254">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-254">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-255"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-255">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-256">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-256">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="1bf95-257">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-257">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="1bf95-258">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-258">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-259">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-259">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-260">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-260">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-261">데이터 테이블을 채우는 동안 오류 또는 예외가 발생 하는 경우 오류가 발생 하기 전에 추가 된 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-261">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="1bf95-262">작업의 나머지 부분에서는 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-262">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="1bf95-263">채우는 데 사용 된 SELECT 문에서 <xref:System.Data.DataSet> 다음에 주의 SQL 문을 일괄 처리 수와 같은 여러 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-263">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as a batch SQL statement, be aware of the following:</span></span>  
  
-   <span data-ttu-id="1bf95-264">모든 후속 결과 건너뛰고에 추가 되지 오류가 있으면 결과 중 하나는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-264">If one of the results contains an error, all subsequent results are skipped and not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="1bf95-265">다음을 사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 내용 새로 고침에 대 한 호출은 <xref:System.Data.DataSet>, 두 조건이 충족 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-265">When using subsequent <xref:System.Data.Common.DbDataAdapter.Fill%2A> calls to refresh the contents of the <xref:System.Data.DataSet>, two conditions must be met:</span></span>  
  
1.  <span data-ttu-id="1bf95-266">SQL 문을 처음 채우는 데 사용 되는 일치 해야는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-266">The SQL statement should match the one initially used to populate the <xref:System.Data.DataSet>.</span></span>  
  
2.  <span data-ttu-id="1bf95-267">**키** 열 정보가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-267">The **Key** column information must be present.</span></span> <span data-ttu-id="1bf95-268">기본 키 정보가 있는 경우 중복 행은 조정을 한 번만는 <xref:System.Data.DataTable> 에 해당 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-268">If primary key information is present, any duplicate rows are reconciled and only appear once in the <xref:System.Data.DataTable> that corresponds to the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-269">통해 기본 키 정보가 설정할 수 있습니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 지정 하 여는 <xref:System.Data.DataTable.PrimaryKey%2A> 속성의는 <xref:System.Data.DataTable>, 또는 설정 하 여는 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 속성을 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-269">Primary key information may be set either through <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, by specifying the <xref:System.Data.DataTable.PrimaryKey%2A> property of the <xref:System.Data.DataTable>, or by setting the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> property to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-270">`SelectCommand`가 OUTER JOIN의 결과를 반환하면 `DataAdapter`는 결과 <xref:System.Data.DataTable.PrimaryKey%2A>에 대해 <xref:System.Data.DataTable> 값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-270">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-271">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-271">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="1bf95-272">자세한 내용은 참조[기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-272">For more information, see[Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-273">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-273">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-274">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-274">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-275">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.OleDb.OleDbDataAdapter>, 채울는 <xref:System.Data.DataSet> categories 테이블에서 행이 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-275">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with rows from the categories table.</span></span> <span data-ttu-id="1bf95-276">이 예에서는 만들었다고 가정는 <xref:System.Data.OleDb.OleDbDataAdapter> 및 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-276">This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="1bf95-277">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-277">The source table is invalid.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-278">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-278">When overriding <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="1bf95-279">레코드와 스키마(필요한 경우)로 채울 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-279">A <see cref="T:System.Data.DataTable" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="command"><span data-ttu-id="1bf95-280">데이터 소스에서 행을 검색하는 데 사용할 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-280">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="behavior"><span data-ttu-id="1bf95-281"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-281">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="1bf95-282">지정된 <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.DataTable" /> 및 <see cref="T:System.Data.IDbCommand" />를 사용하여 데이터 소스의 행과 일치하도록 <see cref="T:System.Data.CommandBehavior" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-282">Adds or refreshes rows in a <see cref="T:System.Data.DataTable" /> to match those in the data source using the specified <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.IDbCommand" /> and <see cref="T:System.Data.CommandBehavior" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-283"><see cref="T:System.Data.DataTable" />에 성공적으로 추가했거나 새로 고친 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-283">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />.</span></span> <span data-ttu-id="1bf95-284">여기에는 행을 반환하지 않는 문의 영향을 받는 행은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-284">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-285"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문에서 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-285">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="1bf95-286">SELECT 문은 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-286">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-287">하기 전에 연결이 닫히거나 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열어 데이터를 검색 한 다음 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-287">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data and then closed.</span></span> <span data-ttu-id="1bf95-288">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-288">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-289"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 지정된 된 대상에 행을 추가 하는 작업을 다음 <xref:System.Data.DataTable> 개체는 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체.</span><span class="sxs-lookup"><span data-stu-id="1bf95-289">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation then adds the rows to the specified destination <xref:System.Data.DataTable> object in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> object if it does not already exist.</span></span> <span data-ttu-id="1bf95-290">만들 때 한 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-290">When creating a <xref:System.Data.DataTable> object, the <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="1bf95-291">그러나 경우는 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-291">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="1bf95-292">경우는 <xref:System.Data.Common.DbDataAdapter> 개체 중복 된 열을 채우는 동안 발생 한 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 합니다 "*columnname*1" "*columnname*2 ","*columnname*3 "등입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-292">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-293">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-293">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="1bf95-294">오버 로드가 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 생긴다는 `DataTable` 대로 매개 변수 에서만 첫 번째 결과 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-294">The overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataTable` as a parameter only obtains the first result.</span></span> <span data-ttu-id="1bf95-295">오버 로드를 사용 하 여 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 생긴다는 `DataSet` 여러 결과를 얻으려면 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-295">Use an overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataSet` as a parameter to obtain multiple results.</span></span>  
  
 <span data-ttu-id="1bf95-296">사용할 수는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드가 여러 번 같은 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-296">You can use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-297">기본 키가 있는 경우 이미 존재 하는 일치 하는 행과 들어오는 행이 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-297">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="1bf95-298">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-298">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-299">`SelectCommand`가 OUTER JOIN의 결과를 반환하면 `DataAdapter`는 결과 <xref:System.Data.DataTable.PrimaryKey%2A>에 대해 <xref:System.Data.DataTable> 값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-299">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-300">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-300">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="1bf95-301">자세한 내용은 참조 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-301">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-302">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-302">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-303">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-303">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-304">이 오버 로드는 <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> 메서드 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-304">This overload of the <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (int startRecord, int maxRecords, params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(int32 startRecord, int32 maxRecords, class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Fill (startRecord As Integer, maxRecords As Integer, ParamArray dataTables As DataTable()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(int startRecord, int maxRecords, ... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startRecord"><span data-ttu-id="1bf95-305">0부터 시작되는 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-305">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="1bf95-306">검색할 수 있는 최대 레코드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-306">The maximum number of records to retrieve.</span></span></param>
        <param name="dataTables"><span data-ttu-id="1bf95-307">데이터 소스에서 채울 <see cref="T:System.Data.DataTable" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-307">The <see cref="T:System.Data.DataTable" /> objects to fill from the data source.</span></span></param>
        <summary><span data-ttu-id="1bf95-308">지정된 레코드에서 시작하여 지정된 최대 레코드 수까지 검색하면서 데이터 소스의 행과 일치하도록 <see cref="T:System.Data.DataTable" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-308">Adds or refreshes rows in a <see cref="T:System.Data.DataTable" /> to match those in the data source starting at the specified record and retrieving up to the specified maximum number of records.</span></span></summary>
        <returns><span data-ttu-id="1bf95-309"><see cref="T:System.Data.DataTable" />에 성공적으로 추가했거나 새로 고친 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-309">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />.</span></span> <span data-ttu-id="1bf95-310">행을 반환하지 않는 문의 영향을 받는 행은 이 값에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-310">This value does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-311"><xref:System.Data.Common.DataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문에서 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-311">The <xref:System.Data.Common.DataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="1bf95-312">SELECT 문은 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-312">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-313">연결 하기 전에 닫혀 있으면 <xref:System.Data.Common.DataAdapter.Fill%2A> 은 열 데이터를 검색 하 고 닫으면은 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-313">If the connection is closed before <xref:System.Data.Common.DataAdapter.Fill%2A> is called, it is opened to retrieve data, and then it is closed.</span></span> <span data-ttu-id="1bf95-314">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-314">If the connection is open before <xref:System.Data.Common.DataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-315"><xref:System.Data.Common.DataAdapter.Fill%2A> 대상에 행을 추가 하는 작업을 다음 <xref:System.Data.DataTable> 개체에 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체.</span><span class="sxs-lookup"><span data-stu-id="1bf95-315">The <xref:System.Data.Common.DataAdapter.Fill%2A> operation then adds the rows to destination <xref:System.Data.DataTable> objects in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> objects if they do not already exist.</span></span> <span data-ttu-id="1bf95-316">만들 때 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-316">When creating <xref:System.Data.DataTable> objects, the <xref:System.Data.Common.DataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="1bf95-317">그러나 경우는 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-317">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="1bf95-318">`SelectCommand`가 OUTER JOIN의 결과를 반환하면 `DataAdapter`는 결과 <xref:System.Data.DataTable.PrimaryKey%2A>에 대해 <xref:System.Data.DataTable> 값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-318">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-319">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-319">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="1bf95-320">자세한 내용은 참조 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-320">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="1bf95-321">데이터 어댑터를 채우는 동안 중복 된 열을 발견 하는 경우는 <xref:System.Data.DataTable>, 패턴 "columnname1", "columnname2", "columnname3" 및 등을 사용 하 여 후속 열에 대 한 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-321">If the data adapter encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "columnname1", "columnname2", "columnname3", and so on.</span></span> <span data-ttu-id="1bf95-322">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-322">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-323">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet>, 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-323">When multiple result sets are added to the <xref:System.Data.DataSet>, each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-324">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-324">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="1bf95-325">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-325">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-326">채우는 데 사용 된 SELECT 문에서 <xref:System.Data.DataSet> 여러 결과 반환 일괄 처리 SQL 문과 같은 결과 중 하나에 오류가 포함 되어 있는 경우 모든 후속 결과 건너뛰고에 추가 되지 않습니다는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-326">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as a batch SQL statements, if one of the results contains an error, all subsequent results are skipped and not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="1bf95-327">사용할 수는 <xref:System.Data.Common.DataAdapter.Fill%2A> 메서드가 여러 번 같은 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-327">You can use the <xref:System.Data.Common.DataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-328">기본 키가 있는 경우 이미 존재 하는 일치 하는 행과 들어오는 행이 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-328">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="1bf95-329">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-329">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-330">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-330">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-331">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-331">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-332">레코드와 스키마(필요한 경우)로 채울 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-332">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="startRecord"><span data-ttu-id="1bf95-333">0부터 시작되는 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-333">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="1bf95-334">검색할 수 있는 최대 레코드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-334">The maximum number of records to retrieve.</span></span></param>
        <param name="srcTable"><span data-ttu-id="1bf95-335">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-335">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="1bf95-336"><see cref="T:System.Data.DataSet" />과 <see cref="T:System.Data.DataSet" /> 이름을 사용하여 지정된 범위에서 데이터 소스의 행과 일치하도록 <see cref="T:System.Data.DataTable" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-336">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and <see cref="T:System.Data.DataTable" /> names.</span></span></summary>
        <returns><span data-ttu-id="1bf95-337"><see cref="T:System.Data.DataSet" />에 성공적으로 추가했거나 새로 고친 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-337">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="1bf95-338">여기에는 행을 반환하지 않는 문의 영향을 받는 행은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-338">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-339">A `maxRecords` 값 0은 시작 레코드 후 검색 된 모든 레코드가 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-339">A `maxRecords` value of 0 gets all records found after the start record.</span></span> <span data-ttu-id="1bf95-340">경우 `maxRecords` 보다 크면 남은 행 수가 없으면 오류가 발생 하 고 나머지 행이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-340">If `maxRecords` is greater than the number of remaining rows, only the remaining rows are returned, and no error is issued.</span></span>  
  
 <span data-ttu-id="1bf95-341">해당 select 명령이 여러 결과 반환 하는 문인 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 만 적용 됩니다 `maxRecords` 첫 번째 결과를 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-341">If the corresponding select command is a statement returning multiple results, <xref:System.Data.Common.DbDataAdapter.Fill%2A> only applies `maxRecords` to the first result.</span></span>  
  
 <span data-ttu-id="1bf95-342"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-342">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="1bf95-343"><xref:System.Data.IDbConnection> SELECT 문과 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-343">The <xref:System.Data.IDbConnection> object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-344">경우는 <xref:System.Data.IDbConnection> 전에 닫은 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열어 데이터를 검색 한 다음 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-344">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data and then closed.</span></span> <span data-ttu-id="1bf95-345">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-345">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-346">에 테이블이 추가 명령을 모든 행을 반환 하지 않으면는 <xref:System.Data.DataSet>, 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-346">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, but no exception is raised.</span></span>  
  
 <span data-ttu-id="1bf95-347">경우는 <xref:System.Data.Common.DbDataAdapter> 개체 중복 된 열을 채우는 동안 발생 한 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 합니다 "*columnname*1" "*columnname*2 ","*columnname*3 "등입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-347">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-348">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-348">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="1bf95-349">지정 된 쿼리가 여러 결과 반환 하는 경우 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-349">When the query specified returns multiple results, each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-350">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-350">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="1bf95-351">없는 테이블이 생성 된 행을 반환 하지 않는 쿼리에 대 한 선택 쿼리 뒤에 삽입 쿼리를 처리 하는 경우 때문에 선택 쿼리에 대해 생성 된 테이블 생성 되는 첫 번째 테이블에 있기 때문에 "Table" 라는 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-351">Because no table is created for a query that does not return rows, if you process an insert query followed by a select query, the table created for the select query is named "Table", because it is the first table created.</span></span> <span data-ttu-id="1bf95-352">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-352">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-353"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-353">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-354">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-354">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="1bf95-355">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-355">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="1bf95-356">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-356">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-357">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-357">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-358">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-358">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-359">데이터 테이블을 채우는 동안 오류 또는 예외가 발생 하는 경우 오류가 발생 하기 전에 추가 된 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-359">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="1bf95-360">작업의 나머지 부분에서는 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-360">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="1bf95-361">채우는 데 사용 된 SELECT 문에서 <xref:System.Data.DataSet> 일괄 처리 SQL 문과 같은 여러 결과가 반환 될 다음에 주의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-361">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as batch SQL statements, be aware of the following:</span></span>  
  
-   <span data-ttu-id="1bf95-362">SQL 문 일괄 처리에서 여러 결과 처리할 때 `maxRecords` 첫 번째 결과에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-362">When processing multiple results from a batch SQL statement, `maxRecords` only applies to the first result.</span></span> <span data-ttu-id="1bf95-363">장으로 나뉜 결과 (.NET Framework Data Provider for OLE DB만)를 포함 하는 행에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-363">The same is true for rows containing chaptered results (.NET Framework Data Provider for OLE DB only).</span></span> <span data-ttu-id="1bf95-364">최상위 결과 의해 제한 됩니다 `maxRecords`, 하지만 모든 자식 행이 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-364">The top level result is limited by `maxRecords`, but all child rows are added.</span></span>  
  
-   <span data-ttu-id="1bf95-365">모든 후속 결과 건너뛰고에 추가 되지 오류가 있으면 결과 중 하나는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-365">If one of the results contains an error, all subsequent results are skipped and not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="1bf95-366">다음을 사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 내용 새로 고침에 대 한 호출은 <xref:System.Data.DataSet>, 두 조건이 충족 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-366">When using subsequent <xref:System.Data.Common.DbDataAdapter.Fill%2A> calls to refresh the contents of the <xref:System.Data.DataSet>, two conditions must be met:</span></span>  
  
1.  <span data-ttu-id="1bf95-367">SQL 문을 처음 채우는 데 사용 되는 일치 해야는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-367">The SQL statement should match the one initially used to populate the <xref:System.Data.DataSet>.</span></span>  
  
2.  <span data-ttu-id="1bf95-368">**키** 열 정보가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-368">The **Key** column information must be present.</span></span>  
  
 <span data-ttu-id="1bf95-369">기본 키 정보가 있는 경우 중복 행은 일치을 한 번만는 <xref:System.Data.DataTable> 에 해당 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-369">If primary key information is present, any duplicate rows will be reconciled and only appear once in the <xref:System.Data.DataTable> that corresponds to the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-370">통해 기본 키 정보가 설정할 수 있습니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 지정 하 여는 <xref:System.Data.DataTable.PrimaryKey%2A> 속성의는 <xref:System.Data.DataTable>, 또는 설정 하 여는 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 속성을 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-370">Primary key information may be set either through <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, by specifying the <xref:System.Data.DataTable.PrimaryKey%2A> property of the <xref:System.Data.DataTable>, or by setting the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> property to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-371">`SelectCommand`가 OUTER JOIN의 결과를 반환하면 `DataAdapter`는 결과 <xref:System.Data.DataTable.PrimaryKey%2A>에 대해 <xref:System.Data.DataTable> 값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-371">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-372">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-372">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="1bf95-373">자세한 내용은 참조 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-373">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-374">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-374">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-375">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-375">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-376">`DataSet` 가리키는 레코드 개수 보다 많은 포함 되지 것입니다 `maxRecords`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-376">The `DataSet` will not contain more than the number of records indicated by `maxRecords`.</span></span> <span data-ttu-id="1bf95-377">하지만, 쿼리에 의해 생성 된 전체 결과 집합은 여전히 서버에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-377">However, the entire result set generated by the query is still returned from the server.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-378">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.OleDb.OleDbDataAdapter>, 채울는 <xref:System.Data.DataSet> 에서 10 행에서 시작 하는 15 개의 행으로는 **범주** 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-378">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with 15 rows, beginning at row 10, from the **Categories** table.</span></span> <span data-ttu-id="1bf95-379">이 예에서는 만들었다고 가정는 <xref:System.Data.OleDb.OleDbDataAdapter> 및 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-379">This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="1bf95-380"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-380">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-381">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-381">The source table is invalid.</span></span>  
  
 <span data-ttu-id="1bf95-382">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-382">-or-</span></span>  
  
 <span data-ttu-id="1bf95-383">연결이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-383">The connection is invalid.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="1bf95-384">연결을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-384">The connection could not be found.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1bf95-385"><paramref name="startRecord" /> 매개 변수가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-385">The <paramref name="startRecord" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="1bf95-386">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-386">-or-</span></span>  
  
 <span data-ttu-id="1bf95-387"><paramref name="maxRecords" /> 매개 변수가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-387">The <paramref name="maxRecords" /> parameter is less than 0.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-388">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-388">When overriding <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable[] dataTables, int32 startRecord, int32 maxRecords, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Fill (dataTables As DataTable(), startRecord As Integer, maxRecords As Integer, command As IDbCommand, behavior As CommandBehavior) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables, int startRecord, int maxRecords, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTables"><span data-ttu-id="1bf95-389">데이터 소스에서 채울 <see cref="T:System.Data.DataTable" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-389">The <see cref="T:System.Data.DataTable" /> objects to fill from the data source.</span></span></param>
        <param name="startRecord"><span data-ttu-id="1bf95-390">0부터 시작되는 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-390">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="1bf95-391">검색할 수 있는 최대 레코드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-391">The maximum number of records to retrieve.</span></span></param>
        <param name="command"><span data-ttu-id="1bf95-392"><see cref="T:System.Data.IDbCommand" /> 개체를 채우기 위해 실행되는 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-392">The <see cref="T:System.Data.IDbCommand" /> executed to fill the <see cref="T:System.Data.DataTable" /> objects.</span></span></param>
        <param name="behavior"><span data-ttu-id="1bf95-393"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-393">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="1bf95-394"><see cref="T:System.Data.DataSet" />과 <see cref="T:System.Data.DataSet" /> 이름을 사용하여 지정된 범위에서 데이터 소스의 행과 일치하도록 <see cref="T:System.Data.DataTable" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-394">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and <see cref="T:System.Data.DataTable" /> names.</span></span></summary>
        <returns><span data-ttu-id="1bf95-395">데이터 테이블에서 추가되거나 새로 고쳐진 행의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-395">The number of rows added to or refreshed in the data tables.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-396">A `maxRecords` 값 0은 시작 레코드 후 검색 된 모든 레코드가 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-396">A `maxRecords` value of 0 gets all records found after the start record.</span></span> <span data-ttu-id="1bf95-397">경우 `maxRecords` 보다 크면 남은 행 수가 없으면 오류가 발생 하 고 나머지 행이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-397">If `maxRecords` is greater than the number of remaining rows, only the remaining rows are returned and no error is issued.</span></span>  
  
 <span data-ttu-id="1bf95-398"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-398">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="1bf95-399"><xref:System.Data.IDbConnection> SELECT 문과 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-399">The <xref:System.Data.IDbConnection> object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-400">경우는 <xref:System.Data.IDbConnection> 전에 닫은 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-400">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-401">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-401">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-402">에 테이블이 추가 명령을 모든 행을 반환 하지 않으면는 <xref:System.Data.DataSet>, 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-402">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, but no exception is raised.</span></span>  
  
 <span data-ttu-id="1bf95-403">경우는 <xref:System.Data.Common.DbDataAdapter> 개체 중복 된 열을 채우는 동안 발생 한 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 합니다 "*columnname*1" "*columnname*2 ","*columnname*3 "등입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-403">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-404">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-404">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="1bf95-405">지정 된 쿼리가 여러 결과 반환 하는 경우 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-405">When the query specified returns multiple results, each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-406">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-406">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="1bf95-407">없는 테이블이 생성 된 행을 반환 하지 않는 쿼리에 대 한 선택 쿼리 뒤에 삽입 쿼리를 처리 하는 경우 이후 select 쿼리에 대해 생성 되는 테이블을 이름이 "Table" 생성 되는 첫 번째 테이블에 있기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-407">Since no table is created for a query that does not return rows, if you were to process an insert query followed by a select query, the table created for the select query would be named "Table", because it is the first table created.</span></span> <span data-ttu-id="1bf95-408">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-408">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-409"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-409">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-410">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-410">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="1bf95-411">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-411">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="1bf95-412">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-412">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-413">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-413">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-414">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-414">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-415">데이터 테이블을 채우는 동안 오류 또는 예외가 발생 하는 경우 오류가 발생 하기 전에 추가 된 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-415">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="1bf95-416">작업의 나머지 부분에서는 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-416">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="1bf95-417">채우는 데 사용 된 SELECT 문에서 <xref:System.Data.DataTable> 개체 다음에 주의 SQL 문을 일괄 처리 수와 같은 여러 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-417">When the SELECT statement used to populate the <xref:System.Data.DataTable> objects returns multiple results, such as a batch SQL statement, be aware of the following:</span></span>  
  
-   <span data-ttu-id="1bf95-418">SQL 문 일괄 처리에서 여러 결과 처리할 때 `maxRecords` 첫 번째 결과에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-418">When processing multiple results from a batch SQL statement, `maxRecords` only applies to the first result.</span></span> <span data-ttu-id="1bf95-419">장으로 나뉜 결과 (.NET Framework Data Provider for OLE DB만)를 포함 하는 행에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-419">The same is true for rows containing chaptered results (.NET Framework Data Provider for OLE DB only).</span></span> <span data-ttu-id="1bf95-420">최상위 결과 의해 제한 됩니다 `maxRecords`, 하지만 모든 자식 행이 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-420">The top level result is limited by `maxRecords`, but all child rows are added.</span></span>  
  
-   <span data-ttu-id="1bf95-421">결과 중 하나에 오류가 포함 되어, 모든 후속 결과 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-421">If one of the results contains an error, all subsequent results are skipped.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-422">`DataSet` 가리키는 레코드 개수 보다 많은 포함 되지 것입니다 `maxRecords`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-422">The `DataSet` will not contain more than the number of records indicated by `maxRecords`.</span></span> <span data-ttu-id="1bf95-423">그러나 쿼리에 의해 생성 되는 전체 결과 집합은 여전히 서버에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-423">However, the entire resultset generated by the query is still returned from the server.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="1bf95-424"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-424">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-425">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-425">The source table is invalid.</span></span>  
  
 <span data-ttu-id="1bf95-426">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-426">-or-</span></span>  
  
 <span data-ttu-id="1bf95-427">연결이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-427">The connection is invalid.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="1bf95-428">연결을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-428">The connection could not be found.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1bf95-429"><paramref name="startRecord" /> 매개 변수가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-429">The <paramref name="startRecord" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="1bf95-430">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-430">-or-</span></span>  
  
 <span data-ttu-id="1bf95-431"><paramref name="maxRecords" /> 매개 변수가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-431">The <paramref name="maxRecords" /> parameter is less than 0.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-432">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-432">When overriding <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-433">레코드와 스키마(필요한 경우)로 채울 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-433">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="startRecord"><span data-ttu-id="1bf95-434">0부터 시작되는 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-434">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="1bf95-435">검색할 수 있는 최대 레코드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-435">The maximum number of records to retrieve.</span></span></param>
        <param name="srcTable"><span data-ttu-id="1bf95-436">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-436">The name of the source table to use for table mapping.</span></span></param>
        <param name="command"><span data-ttu-id="1bf95-437">데이터 소스에서 행을 검색하는 데 사용할 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-437">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="behavior"><span data-ttu-id="1bf95-438"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-438">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="1bf95-439"><see cref="T:System.Data.DataSet" />과 소스 테이블 이름, 명령 문자열과 명령 동작을 사용하여 지정된 범위에서 데이터 소스의 행과 일치하도록 <see cref="T:System.Data.DataSet" />의 행을 추가하거나 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-439">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and source table names, command string, and command behavior.</span></span></summary>
        <returns><span data-ttu-id="1bf95-440"><see cref="T:System.Data.DataSet" />에 성공적으로 추가했거나 새로 고친 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-440">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="1bf95-441">여기에는 행을 반환하지 않는 문의 영향을 받는 행은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-441">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-442"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문에서 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-442">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="1bf95-443">SELECT 문은 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-443">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-444">하기 전에 연결이 닫히거나 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-444">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-445">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-445">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-446"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 대상에 행을 추가 하는 작업을 다음 <xref:System.Data.DataTable> 개체에 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체.</span><span class="sxs-lookup"><span data-stu-id="1bf95-446">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation then adds the rows to destination <xref:System.Data.DataTable> objects in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> objects if they do not already exist.</span></span> <span data-ttu-id="1bf95-447">만들 때 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-447">When creating <xref:System.Data.DataTable> objects, the <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="1bf95-448">그러나 경우는 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-448">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="1bf95-449">경우는 <xref:System.Data.Common.DbDataAdapter> 발생할 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-449">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-450">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-450">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-451">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet> 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-451">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-452">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-452">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="1bf95-453">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-453">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-454"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-454">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-455">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-455">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="1bf95-456">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-456">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="1bf95-457">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-457">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-458">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-458">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-459">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-459">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-460">사용할 수는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드가 여러 번 같은 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-460">You can use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-461">기본 키가 있는 경우 이미 존재 하는 일치 하는 행과 들어오는 행이 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-461">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="1bf95-462">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-462">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-463">`SelectCommand`가 OUTER JOIN의 결과를 반환하면 `DataAdapter`는 결과 <xref:System.Data.DataTable.PrimaryKey%2A>에 대해 <xref:System.Data.DataTable> 값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-463">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-464">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-464">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="1bf95-465">자세한 내용은 참조[기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-465">For more information, see[Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-466">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 및 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> .NET Framework 데이터에 대 한 공급자만 첫 번째 결과 대 한 스키마 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-466">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.Fill%2A> and <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for a .NET Framework data provider retrieves schema information for only the first result.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-467">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-467">The source table is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1bf95-468"><paramref name="startRecord" /> 매개 변수가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-468">The <paramref name="startRecord" /> parameter is less than 0.</span></span>  
  
 <span data-ttu-id="1bf95-469">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-469">-or-</span></span>  
  
 <span data-ttu-id="1bf95-470"><paramref name="maxRecords" /> 매개 변수가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-470">The <paramref name="maxRecords" /> parameter is less than 0.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-471">이 오버 로드는 <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> 메서드 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-471">This overload of the <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillCommandBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Data.CommandBehavior FillCommandBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.CommandBehavior FillCommandBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property FillCommandBehavior As CommandBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Data::CommandBehavior FillCommandBehavior { System::Data::CommandBehavior get(); void set(System::Data::CommandBehavior value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.CommandBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-472">데이터 어댑터를 채우는 데 사용되는 명령의 동작을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-472">Gets or sets the behavior of the command used to fill the data adapter.</span></span></summary>
        <value><span data-ttu-id="1bf95-473">데이터 어댑터를 채우는 데 사용되는 명령의 <see cref="T:System.Data.CommandBehavior" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-473">The <see cref="T:System.Data.CommandBehavior" /> of the command used to fill the data adapter.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bf95-474"><see cref="T:System.Data.DataTable" />에 <see cref="T:System.Data.DataSet" />을 추가하고 데이터 소스의 스키마와 일치하도록 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-474">Adds a <see cref="T:System.Data.DataTable" /> to a <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-475">스키마를 삽입할 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-475">A <see cref="T:System.Data.DataSet" /> to insert the schema in.</span></span></param>
        <param name="schemaType"><span data-ttu-id="1bf95-476">스키마 삽입 방법을 지정하는 <see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-476">One of the <see cref="T:System.Data.SchemaType" /> values that specify how to insert the schema.</span></span></param>
        <summary><span data-ttu-id="1bf95-477">지정된 <see cref="T:System.Data.DataTable" />에 "Table"이라는 <see cref="T:System.Data.DataSet" />을 추가하고 지정된 <see cref="T:System.Data.SchemaType" />을 기반으로 데이터 소스의 스키마와 일치하도록 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-477">Adds a <see cref="T:System.Data.DataTable" /> named "Table" to the specified <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-478"><see cref="T:System.Data.DataTable" />에 추가된 <see cref="T:System.Data.DataSet" /> 개체의 컬렉션에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-478">A reference to a collection of <see cref="T:System.Data.DataTable" /> objects that were added to the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-479">사용 하 여 데이터 원본에서 스키마 정보를 검색 하는이 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-479">This method retrieves the schema information from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span>  
  
 <span data-ttu-id="1bf95-480">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-480">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-481">그런 다음 열을 추가 <xref:System.Data.DataColumnCollection> 의 <xref:System.Data.DataTable>, 다음을 구성 하 고 <xref:System.Data.DataColumn> 속성 데이터 원본에 존재 하는 경우:</span><span class="sxs-lookup"><span data-stu-id="1bf95-481">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="1bf95-482"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-482"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="1bf95-483">설정 해야 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 및 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 별도로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-483">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="1bf95-484"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 된 <xref:System.Data.DataTable.PrimaryKey%2A> 및 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="1bf95-484"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="1bf95-485">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용 되는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-485">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="1bf95-486">기본 키 열이 반환 되지 고유 열이 표시 되지만 고유한 열 경우, 그리고 모든 고유 열이 null이 아닌 경우에 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-486">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="1bf95-487">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-487">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="1bf95-488">기본 키 열과 고유 열이 모두 반환 되는 기본 키 열에 대 한 기본 키 열으로 사용 됩니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-488">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-489">기본 키와 unique 제약 조건에 추가 된 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 형식이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-489">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="1bf95-490">고유 클러스터형 인덱스가 하나 이상의 SQL Server 테이블의 열에 정의 된 및 기본 키 제약 조건을 별도의 열 집합에 정의 되어 클러스터형된 인덱스에 있는 열의 이름이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-490">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="1bf95-491">기본 키 열 이름으로를 반환 하려면 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-491">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="1bf95-492">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 [쿼리 힌트 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-492">For more information about specifying query hints, see [Query Hint (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="1bf95-493">기본 키 정보 중에 사용 되 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 찾기 및 바꾸기 키 열과 일치 하는 모든 행에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-493">Primary key information is used during <xref:System.Data.Common.DbDataAdapter.Fill%2A> to find and replace any rows whose key columns match.</span></span> <span data-ttu-id="1bf95-494">이것이 원하는 동작을 사용 하 여 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 스키마 정보를 요청 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-494">If this is not the desired behavior, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> without requesting schema information.</span></span>  
  
 <span data-ttu-id="1bf95-495">경우는 <xref:System.Data.IDataAdapter> 발생할 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-495">If the <xref:System.Data.IDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-496">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-496">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-497">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet> 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-497">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-498">추가 결과 집합이 지정한 테이블 이름 (예를 들어 "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-498">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="1bf95-499">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-499">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-500"><xref:System.Data.IDbConnection> select 명령의와 연결 된 개체는 유효 해야 합니다. 하지만 열 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-500">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to open.</span></span> <span data-ttu-id="1bf95-501">경우는 <xref:System.Data.IDbConnection> 전에 닫은 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-501">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-502">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출 것가 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-502">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is left open.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-503">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-503">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-504">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-504">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-505"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 사용하는 경우 .NET Framework Data Provider for SQL Server는 실행 중인 문에 FOR BROWSE 절을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-505">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="1bf95-506">사용자는 의도하지 않은 결과, 즉 SET FMTONLY ON 문을 사용하는 데 문제가 발생할 수 있다는 사실을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-506">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="1bf95-507">자세한 내용은 SQL Server 온라인 설명서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1bf95-507">See SQL Server Books Online for more information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-508">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.SqlClient.SqlDataAdapter>, 채울는 <xref:System.Data.DataSet> 스키마 및 반환 된 한 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-508">The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="1bf95-509">데이터 소스에서 스키마로 채울 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-509">The <see cref="T:System.Data.DataTable" /> to be filled with the schema from the data source.</span></span></param>
        <param name="schemaType"><span data-ttu-id="1bf95-510"><see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-510">One of the <see cref="T:System.Data.SchemaType" /> values.</span></span></param>
        <summary><span data-ttu-id="1bf95-511"><see cref="T:System.Data.DataTable" />을 기반으로 지정된 <see cref="T:System.Data.SchemaType" />의 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-511">Configures the schema of the specified <see cref="T:System.Data.DataTable" /> based on the specified <see cref="T:System.Data.SchemaType" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-512">데이터 소스에서 반환된 스키마 정보가 들어 있는 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-512">A <see cref="T:System.Data.DataTable" /> that contains schema information returned from the data source.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-513"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 사용 하 여 데이터 원본에서 스키마를 검색 하는 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-513">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method retrieves the schema from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span> <span data-ttu-id="1bf95-514">와 연결 된 연결 개체는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 유효 해야 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-514">The connection object associated with the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-515">하기 전에 연결이 닫히거나 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-515">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-516">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-516">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-517">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업이 반환 된 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-517">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation returns a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="1bf95-518">그런 다음 열을 추가 <xref:System.Data.DataColumnCollection> 의 <xref:System.Data.DataTable>, 다음을 구성 하 고 <xref:System.Data.DataColumn> 속성 데이터 원본에 존재 하는 경우:</span><span class="sxs-lookup"><span data-stu-id="1bf95-518">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="1bf95-519"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-519"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="1bf95-520">설정 해야 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 및 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 별도로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-520">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="1bf95-521"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 된 <xref:System.Data.DataTable.PrimaryKey%2A> 및 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="1bf95-521"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="1bf95-522">경우는 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 이미 정의 `DataTable`, 또는 `DataTable` 데이터를 포함 된 `PrimaryKey` 속성을 설정 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-522">If a <xref:System.Data.DataTable.PrimaryKey%2A> has already been defined for the `DataTable`, or the `DataTable` contains data, the `PrimaryKey` property will not be set.</span></span>  
  
-   <span data-ttu-id="1bf95-523">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용 되는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-523">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the `DataTable`.</span></span>  
  
-   <span data-ttu-id="1bf95-524">기본 키 열이 반환 되지 고유 열이 표시 되지만 고유한 열 경우, 그리고 모든 고유 열이 null이 아닌 경우에 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-524">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="1bf95-525">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 `PrimaryKey` 속성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-525">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the `PrimaryKey` property is not set.</span></span>  
  
-   <span data-ttu-id="1bf95-526">기본 키 열과 고유 열이 모두 반환 되는 기본 키 열에 대 한 기본 키 열으로 사용 됩니다는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-526">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the `DataTable`.</span></span>  
  
 <span data-ttu-id="1bf95-527">기본 키와 unique 제약 조건에 추가 된 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 형식이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-527">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span> <span data-ttu-id="1bf95-528">이 프로세스 서버에 여러 번 왕복 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-528">This process may require several round-trips to the server.</span></span>  
  
 <span data-ttu-id="1bf95-529">고유 클러스터형 인덱스가 하나 이상의 SQL Server 테이블의 열에 정의 된 및 기본 키 제약 조건을 별도의 열 집합에 정의 되어 클러스터형된 인덱스에 있는 열의 이름이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-529">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="1bf95-530">기본 키 열 이름으로를 반환 하려면 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-530">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="1bf95-531">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 [쿼리 힌트 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-531">For more information about specifying query hints, see [Query Hint (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="1bf95-532">경우는 <xref:System.Data.Common.DbDataAdapter> 발생할 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-532">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-533">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-533">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-534">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet> 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-534">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-535">추가 결과 집합이 지정한 테이블 이름 (예를 들어 "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-535">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="1bf95-536">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-536">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-537"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 모든 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-537"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> does not return any rows.</span></span> <span data-ttu-id="1bf95-538">사용 하 여는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 에 행을 추가 하는 메서드는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-538">Use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method to add rows to a <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-539">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-539">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-540">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-540">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-541"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 사용하는 경우 .NET Framework Data Provider for SQL Server는 실행 중인 문에 FOR BROWSE 절을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-541">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="1bf95-542">사용자는 의도하지 않은 결과, 즉 SET FMTONLY ON 문을 사용하는 데 문제가 발생할 수 있다는 사실을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-542">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="1bf95-543">자세한 내용은 SQL Server 온라인 설명서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1bf95-543">See SQL Server Books Online for more information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-544">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.SqlClient.SqlDataAdapter>, 채울는 <xref:System.Data.DataSet> 스키마 및 반환 된 한 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-544">The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataTable>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-545">스키마를 삽입할 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-545">A <see cref="T:System.Data.DataSet" /> to insert the schema in.</span></span></param>
        <param name="schemaType"><span data-ttu-id="1bf95-546">스키마 삽입 방법을 지정하는 <see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-546">One of the <see cref="T:System.Data.SchemaType" /> values that specify how to insert the schema.</span></span></param>
        <param name="srcTable"><span data-ttu-id="1bf95-547">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-547">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="1bf95-548">지정된 <see cref="T:System.Data.DataTable" />에 <see cref="T:System.Data.DataSet" />을 추가하고 지정된 <see cref="T:System.Data.SchemaType" />과 <see cref="T:System.Data.DataTable" />을 기반으로 데이터 소스의 스키마와 일치하도록 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-548">Adds a <see cref="T:System.Data.DataTable" /> to the specified <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source based upon the specified <see cref="T:System.Data.SchemaType" /> and <see cref="T:System.Data.DataTable" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-549"><see cref="T:System.Data.DataTable" />에 추가된 <see cref="T:System.Data.DataSet" /> 개체의 컬렉션에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-549">A reference to a collection of <see cref="T:System.Data.DataTable" /> objects that were added to the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-550">사용 하 여 데이터 원본에서 스키마 정보를 검색 하는이 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-550">This method retrieves the schema information from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span>  
  
 <span data-ttu-id="1bf95-551">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-551">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-552">그런 다음 열을 추가 <xref:System.Data.DataColumnCollection> 의 <xref:System.Data.DataTable>, 다음을 구성 하 고 <xref:System.Data.DataColumn> 속성 데이터 원본에 존재 하는 경우:</span><span class="sxs-lookup"><span data-stu-id="1bf95-552">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="1bf95-553"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-553"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="1bf95-554">설정 해야 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 및 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 별도로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-554">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="1bf95-555"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 된 <xref:System.Data.DataTable.PrimaryKey%2A> 및 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="1bf95-555"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="1bf95-556">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용 되는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-556">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="1bf95-557">기본 키 열이 반환 되지 고유 열이 표시 되지만 고유한 열 경우, 그리고 모든 고유 열이 null이 아닌 경우에 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-557">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="1bf95-558">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-558">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="1bf95-559">기본 키 열과 고유 열이 모두 반환 되는 기본 키 열에 대 한 기본 키 열으로 사용 됩니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-559">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-560">기본 키와 unique 제약 조건에 추가 된 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 형식이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-560">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="1bf95-561">고유 클러스터형 인덱스가 하나 이상의 SQL Server 테이블의 열에 정의 된 및 기본 키 제약 조건을 별도의 열 집합에 정의 되어 클러스터형된 인덱스에 있는 열의 이름이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-561">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="1bf95-562">기본 키 열 이름으로를 반환 하려면 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-562">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="1bf95-563">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 [쿼리 힌트 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-563">For more information about specifying query hints, see [Query Hint (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="1bf95-564">기본 키 정보 중에 사용 되 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 찾기 및 바꾸기 키 열과 일치 하는 모든 행에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-564">Primary key information is used during <xref:System.Data.Common.DbDataAdapter.Fill%2A> to find and replace any rows whose key columns match.</span></span> <span data-ttu-id="1bf95-565">이것이 원하는 동작을 사용 하 여 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 스키마 정보를 요청 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-565">If this is not the desired behavior, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> without requesting schema information.</span></span>  
  
 <span data-ttu-id="1bf95-566">경우는 <xref:System.Data.Common.DbDataAdapter> 발생할 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-566">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-567">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-567">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-568">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet> 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-568">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-569">추가 결과 집합이 지정한 테이블 이름 (예를 들어 "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-569">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="1bf95-570">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-570">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-571"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-571">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-572">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-572">In such situations, <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="1bf95-573">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-573">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="1bf95-574">경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-574">If <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-575">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-575">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-576">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-576">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-577"><xref:System.Data.IDbConnection> select 명령의와 연결 된 개체는 유효 해야 합니다. 하지만 열 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-577">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to open.</span></span> <span data-ttu-id="1bf95-578">경우는 <xref:System.Data.IDbConnection> 전에 닫은 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-578">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-579">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출 것가 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-579">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is left open.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-580">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-580">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-581">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-581">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-582"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 사용하는 경우 .NET Framework Data Provider for SQL Server는 실행 중인 문에 FOR BROWSE 절을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-582">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="1bf95-583">사용자는 의도하지 않은 결과, 즉 SET FMTONLY ON 문을 사용하는 데 문제가 발생할 수 있다는 사실을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-583">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="1bf95-584">자세한 내용은 SQL Server 온라인 설명서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1bf95-584">See SQL Server Books Online for more information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-585">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.SqlClient.SqlDataAdapter>, 채울는 <xref:System.Data.DataSet> 스키마 및 반환 된 한 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-585">The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1bf95-586">스키마를 가져올 원본 테이블이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-586">A source table from which to get the schema could not be found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="1bf95-587">데이터 소스에서 스키마로 채울 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-587">The <see cref="T:System.Data.DataTable" /> to be filled with the schema from the data source.</span></span></param>
        <param name="schemaType"><span data-ttu-id="1bf95-588"><see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-588">One of the <see cref="T:System.Data.SchemaType" /> values.</span></span></param>
        <param name="command"><span data-ttu-id="1bf95-589">데이터 소스에서 행을 검색하는 데 사용할 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-589">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="behavior"><span data-ttu-id="1bf95-590"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-590">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="1bf95-591">지정된 <see cref="T:System.Data.DataTable" />, 명령 문자열 및 <see cref="T:System.Data.SchemaType" /> 값을 기반으로 지정된 <see cref="T:System.Data.CommandBehavior" />의 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-591">Configures the schema of the specified <see cref="T:System.Data.DataTable" /> based on the specified <see cref="T:System.Data.SchemaType" />, command string, and <see cref="T:System.Data.CommandBehavior" /> values.</span></span></summary>
        <returns><span data-ttu-id="1bf95-592">데이터 소스에서 반환된 스키마 정보가 들어 있는 <see cref="T:System.Data.DataTable" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-592">A of <see cref="T:System.Data.DataTable" /> object that contains schema information returned from the data source.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-593"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 사용 하 여 데이터 원본에서 스키마를 검색 하는 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-593">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method retrieves the schema from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span> <span data-ttu-id="1bf95-594">와 연결 된 연결 개체는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 유효 해야 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-594">The connection object associated with the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-595">하기 전에 연결이 닫히거나 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-595">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-596">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-596">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-597">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-597">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-598">그런 다음 열을 추가 <xref:System.Data.DataColumnCollection> 의 <xref:System.Data.DataTable>, 다음을 구성 하 고 <xref:System.Data.DataColumn> 속성 데이터 원본에 존재 하는 경우:</span><span class="sxs-lookup"><span data-stu-id="1bf95-598">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="1bf95-599"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-599"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="1bf95-600">설정 해야 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 및 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 별도로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-600">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="1bf95-601"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 된 <xref:System.Data.DataTable.PrimaryKey%2A> 및 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="1bf95-601"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="1bf95-602">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용 되는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-602">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="1bf95-603">기본 키 열이 반환 되지 고유 열이 표시 되지만 고유한 열 경우, 그리고 모든 고유 열이 null이 아닌 경우에 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-603">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="1bf95-604">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-604">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="1bf95-605">기본 키 열과 고유 열이 모두 반환 되는 기본 키 열에 대 한 기본 키 열으로 사용 됩니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-605">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-606">기본 키와 unique 제약 조건에 추가 된 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 형식이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-606">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="1bf95-607">고유 클러스터형 인덱스가 하나 이상의 SQL Server 테이블의 열에 정의 된 및 기본 키 제약 조건을 별도의 열 집합에 정의 되어 클러스터형된 인덱스에 있는 열의 이름이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-607">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="1bf95-608">기본 키 열 이름으로를 반환 하려면 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-608">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="1bf95-609">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 [쿼리 힌트 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-609">For more information about specifying query hints, see [Query Hint (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="1bf95-610">경우는 <xref:System.Data.IDataAdapter> 발생할 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-610">If the <xref:System.Data.IDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-611">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-611">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-612">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet> 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-612">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-613">추가 결과 집합이 지정한 테이블 이름 (예를 들어 "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-613">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="1bf95-614">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-614">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-615"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 모든 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-615"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> does not return any rows.</span></span> <span data-ttu-id="1bf95-616">사용 하 여는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 에 행을 추가 하는 메서드는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-616">Use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method to add rows to a <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-617">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-617">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-618">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-618">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-619"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 사용하는 경우 .NET Framework Data Provider for SQL Server는 실행 중인 문에 FOR BROWSE 절을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-619">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="1bf95-620">사용자는 의도하지 않은 결과, 즉 SET FMTONLY ON 문을 사용하는 데 문제가 발생할 수 있다는 사실을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-620">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="1bf95-621">자세한 내용은 SQL Server 온라인 설명서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1bf95-621">See SQL Server Books Online for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-622">이 구현에서 <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> 메서드 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-622">This implementation of the <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, string srcTable, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::String ^ srcTable, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-623">데이터 소스에서 스키마로 채울 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-623">The <see cref="T:System.Data.DataSet" /> to be filled with the schema from the data source.</span></span></param>
        <param name="schemaType"><span data-ttu-id="1bf95-624"><see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-624">One of the <see cref="T:System.Data.SchemaType" /> values.</span></span></param>
        <param name="command"><span data-ttu-id="1bf95-625">데이터 소스에서 행을 검색하는 데 사용할 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-625">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="srcTable"><span data-ttu-id="1bf95-626">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-626">The name of the source table to use for table mapping.</span></span></param>
        <param name="behavior"><span data-ttu-id="1bf95-627"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-627">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="1bf95-628">지정된 <see cref="T:System.Data.DataTable" />에 <see cref="T:System.Data.DataSet" />을 추가하고 지정된 <see cref="T:System.Data.SchemaType" />을 기반으로 데이터 소스의 스키마와 일치하도록 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-628">Adds a <see cref="T:System.Data.DataTable" /> to the specified <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-629">데이터 소스에서 반환된 스키마 정보가 들어 있는 <see cref="T:System.Data.DataTable" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-629">An array of <see cref="T:System.Data.DataTable" /> objects that contain schema information returned from the data source.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-630"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 사용 하 여 데이터 원본에서 스키마를 검색 하는 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-630">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method retrieves the schema from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span> <span data-ttu-id="1bf95-631">와 연결 된 연결 개체는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 유효 해야 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-631">The connection object associated with the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> must be valid, but it does not need to be open.</span></span> <span data-ttu-id="1bf95-632">하기 전에 연결이 닫히거나 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출은 열 데이터를 검색 하려면 다음 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-632">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="1bf95-633">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-633">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="1bf95-634">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-634">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-635">그런 다음 열을 추가 <xref:System.Data.DataColumnCollection> 의 <xref:System.Data.DataTable>, 다음을 구성 하 고 <xref:System.Data.DataColumn> 속성 데이터 원본에 존재 하는 경우:</span><span class="sxs-lookup"><span data-stu-id="1bf95-635">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="1bf95-636"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-636"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="1bf95-637">설정 해야 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 및 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 별도로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-637">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="1bf95-638"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 된 <xref:System.Data.DataTable.PrimaryKey%2A> 및 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="1bf95-638"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="1bf95-639">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용 되는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-639">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="1bf95-640">기본 키 열이 반환 되지 고유 열이 표시 되지만 고유한 열 경우, 그리고 모든 고유 열이 null이 아닌 경우에 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-640">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="1bf95-641">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-641">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="1bf95-642">기본 키 열과 고유 열이 모두 반환 되는 기본 키 열에 대 한 기본 키 열으로 사용 됩니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-642">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-643">기본 키와 unique 제약 조건에 추가 된 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 형식이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-643">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="1bf95-644">고유 클러스터형 인덱스가 하나 이상의 SQL Server 테이블의 열에 정의 된 및 기본 키 제약 조건을 별도의 열 집합에 정의 되어 클러스터형된 인덱스에 있는 열의 이름이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-644">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="1bf95-645">기본 키 열 이름으로를 반환 하려면 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-645">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="1bf95-646">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 [쿼리 힌트 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-646">For more information about specifying query hints, see [Query Hint (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="1bf95-647">경우는 <xref:System.Data.IDataAdapter> 발생할 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="1bf95-647">If the <xref:System.Data.IDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="1bf95-648">에 지정 되므로 들어오는 데이터에 명명 되지 않은 열이 포함 된 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-648">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="1bf95-649">여러 결과 집합에 추가 될 때는 <xref:System.Data.DataSet> 각 결과 집합은 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-649">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="1bf95-650">추가 결과 집합이 지정한 테이블 이름 (예를 들어 "Table", "Table1", "Table2" 및 등)에 정수 계열 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-650">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="1bf95-651">열 및 테이블 이름을 사용 하 여 응용 프로그램 명명 패턴과 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-651">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="1bf95-652"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-652">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-653">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-653">In such situations, <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="1bf95-654">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-654">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="1bf95-655">경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-655">If <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-656">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-656">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-657">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-657">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-658"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 모든 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-658"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> does not return any rows.</span></span> <span data-ttu-id="1bf95-659">사용 하 여는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 에 행을 추가 하는 메서드는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-659">Use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method to add rows to a <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-660">구현 하는 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 만 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-660">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="1bf95-661">여러 결과 대 한 스키마 정보를 검색 하려면 사용 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 와 <xref:System.Data.MissingSchemaAction> 로 설정 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-661">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="1bf95-662"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>를 사용하는 경우 .NET Framework Data Provider for SQL Server는 실행 중인 문에 FOR BROWSE 절을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-662">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="1bf95-663">사용자는 의도하지 않은 결과, 즉 SET FMTONLY ON 문을 사용하는 데 문제가 발생할 수 있다는 사실을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-663">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="1bf95-664">자세한 내용은 SQL Server 온라인 설명서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1bf95-664">See SQL Server Books Online for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-665">이 구현에서 <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> 메서드 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-665">This implementation of the <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedParameter">
      <MemberSignature Language="C#" Value="protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.IDataParameter GetBatchedParameter(int32 commandIdentifier, int32 parameterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedParameter (commandIdentifier As Integer, parameterIndex As Integer) As IDataParameter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::IDataParameter ^ GetBatchedParameter(int commandIdentifier, int parameterIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="parameterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier"><span data-ttu-id="1bf95-666">매개 변수를 검색할 명령의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-666">The index of the command to retrieve the parameter from.</span></span></param>
        <param name="parameterIndex"><span data-ttu-id="1bf95-667">명령에 있는 매개 변수의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-667">The index of the parameter within the command.</span></span></param>
        <summary><span data-ttu-id="1bf95-668">현재 일괄 작업의 명령 중 하나에서 <see cref="T:System.Data.IDataParameter" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-668">Returns a <see cref="T:System.Data.IDataParameter" /> from one of the commands in the current batch.</span></span></summary>
        <returns><span data-ttu-id="1bf95-669">지정된 <see cref="T:System.Data.IDataParameter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-669">The <see cref="T:System.Data.IDataParameter" /> specified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-670"><xref:System.Data.Common.DbDataAdapter>,이 메서드에서 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-670">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1bf95-671">상속 된 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-671">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1bf95-672">어댑터에서 일괄 처리를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-672">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-673">이 메서드는 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-673">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
 <span data-ttu-id="1bf95-674">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스가 사용자가 일괄 처리를 실행 하도록 허용 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-674">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to execute a batch.</span></span> <span data-ttu-id="1bf95-675">구현을 사용 하 여는 <paramref name="commandIdentifier" /> 을 사용 하 여 요청 된 명령을 찾기 위해 제공 된는 <paramref name="parameterIndex" /> 요청한 매개 변수를 찾기 위해 제공 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-675">An implementation uses the <paramref name="commandIdentifier" /> provided to locate the requested command, then uses the <paramref name="parameterIndex" /> provided to locate the requested parameter.</span></span> <span data-ttu-id="1bf95-676">예를 들어 한 <paramref name="commandIdentifier" /> 0 및 <paramref name="parameterIndex" /> 0에서 일괄 처리의 첫 번째 명령은 첫 번째 매개 변수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-676">For example, a <paramref name="commandIdentifier" /> of 0 and a <paramref name="parameterIndex" /> of 0 returns the first parameter from the first command in the batch.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedRecordsAffected">
      <MemberSignature Language="C#" Value="protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetBatchedRecordsAffected(int32 commandIdentifier, [out] int32&amp; recordsAffected, [out] class System.Exception&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedRecordsAffected (commandIdentifier As Integer, ByRef recordsAffected As Integer, ByRef error As Exception) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GetBatchedRecordsAffected(int commandIdentifier, [Runtime::InteropServices::Out] int % recordsAffected, [Runtime::InteropServices::Out] Exception ^ % error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="recordsAffected" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="System.Exception&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier"><span data-ttu-id="1bf95-677">일괄 작업 내에서 개별 명령의 열 서수(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-677">The zero-based column ordinal of the individual command within the batch.</span></span></param>
        <param name="recordsAffected"><span data-ttu-id="1bf95-678">일괄 작업 내에서 지정된 명령의 영향을 받는 데이터 저장소의 행 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-678">The number of rows affected in the data store by the specified command within the batch.</span></span></param>
        <param name="error"><span data-ttu-id="1bf95-679">지정된 명령을 실행하는 도중 throw된 <see cref="T:System.Exception" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-679">An <see cref="T:System.Exception" /> thrown during execution of the specified command.</span></span> <span data-ttu-id="1bf95-680">예외가 throw되지 않은 경우 <see langword="null" />(Visual Basic의 경우 <see langword="Nothing" />)을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-680">Returns <see langword="null" /> (<see langword="Nothing" /> in Visual Basic) if no exception is thrown.</span></span></param>
        <summary><span data-ttu-id="1bf95-681">보다 큰 일괄 처리 업데이트 내에서 개별 업데이트 시도에 대한 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-681">Returns information about an individual update attempt within a larger batched update.</span></span></summary>
        <returns><span data-ttu-id="1bf95-682">보다 큰 일괄 처리 업데이트 내에서 개별 업데이트 시도에 대한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-682">Information about an individual update attempt within a larger batched update.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-683">일괄 처리 업데이트 논리를 지 원하는 데이터 공급자에 일련의 가상 메서드를 재정의 해야 합니다는 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-683">Data providers that support batched updating logic must override a series of virtual methods on the <xref:System.Data.Common.DbDataAdapter> class.</span></span> <span data-ttu-id="1bf95-684">`GetBatchedRecordsAffected` 이러한 가상 메서드 중 하나를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-684">`GetBatchedRecordsAffected` represents one of those virtual methods.</span></span> <span data-ttu-id="1bf95-685">`DbDataAdapter` 클래스가 의존 `GetBatchedRecordsAffected` 해당 표시는 일괄 처리 내에서 개별 업데이트 시도의 성공 여부를 확인 하려면 <xref:System.Data.DataRow> 적절 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-685">The `DbDataAdapter` class relies on `GetBatchedRecordsAffected` to determine the success or failure of individual update attempts within a batch so it can mark each corresponding <xref:System.Data.DataRow> accordingly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public override System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.GetFillParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bf95-686">SQL SELECT 문을 실행할 때 사용자가 설정한 매개 변수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-686">Gets the parameters set by the user when executing an SQL SELECT statement.</span></span></summary>
        <returns><span data-ttu-id="1bf95-687">사용자가 설정한 매개 변수를 포함하는 <see cref="T:System.Data.IDataParameter" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-687">An array of <see cref="T:System.Data.IDataParameter" /> objects that contains the parameters set by the user.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeBatching">
      <MemberSignature Language="C#" Value="protected virtual void InitializeBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.InitializeBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeBatching();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bf95-688"><see cref="T:System.Data.Common.DbDataAdapter" />의 일괄 처리를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-688">Initializes batching for the <see cref="T:System.Data.Common.DbDataAdapter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-689"><xref:System.Data.Common.DbDataAdapter>,이 메서드에서 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-689">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1bf95-690">상속 된 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-690">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1bf95-691">어댑터에서 일괄 처리를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-691">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-692">이 메서드는 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-692">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
 <span data-ttu-id="1bf95-693">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스가이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-693">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method.</span></span> <span data-ttu-id="1bf95-694">이 메서드는 일괄 처리를 지원 하는 데 필요한 모든 리소스를 초기화할 수 있도록 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-694">This method gives the class the opportunity to initialize any resources necessary to support batching.</span></span> <span data-ttu-id="1bf95-695">예를 들어 클래스 일괄 처리의 명령 집합을 보유 하기 위한 데이터 구조를 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-695">For example, a class may allocate a data structure to hold the set of commands in the batch.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="InsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property InsertCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ InsertCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-696">데이터 소스에 새 레코드를 삽입하는 데 사용되는 명령을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-696">Gets or sets a command used to insert new records into the data source.</span></span></summary>
        <value><span data-ttu-id="1bf95-697"><see cref="T:System.Data.IDbCommand" />를 수행하는 동안 데이터 집합의 새 행에 대한 레코드를 데이터 소스에 삽입하는 데 사용되는 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-697">A <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to insert records in the data source for new rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-698">동안 <xref:System.Data.Common.DbDataAdapter.Update%2A>경우이 속성은 설정 되지 않으며 기본 키 정보에 있는지는 <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.InsertCommand%2A> 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-698">During <xref:System.Data.Common.DbDataAdapter.Update%2A>, if this property is not set and primary key information is present in the <xref:System.Data.DataSet>, the <xref:System.Data.IDbDataAdapter.InsertCommand%2A> will be automatically generated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-699">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-699">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdated">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdated(class System.Data.Common.RowUpdatedEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdated (value As RowUpdatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdated(System::Data::Common::RowUpdatedEventArgs ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1bf95-700">이벤트 데이터를 포함하는 <see cref="T:System.Data.Common.RowUpdatedEventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-700">A <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="1bf95-701">.NET Framework 데이터 공급자의 <see langword="RowUpdated" /> 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-701">Raises the <see langword="RowUpdated" /> event of a .NET Framework data provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-702">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-702">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="1bf95-703">에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-703">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-704">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-704">When overriding <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdating">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdating(class System.Data.Common.RowUpdatingEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdating (value As RowUpdatingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdating(System::Data::Common::RowUpdatingEventArgs ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatingEventArgs" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1bf95-705">이벤트 데이터를 포함하는 <see cref="T:System.Data.Common.RowUpdatingEventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-705">An <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="1bf95-706">.NET Framework 데이터 공급자의 <see langword="RowUpdating" /> 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-706">Raises the <see langword="RowUpdating" /> event of a .NET Framework data provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-707">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-707">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="1bf95-708">에 대 한 개요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-708">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-709">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="1bf95-709">When overriding <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> in a derived class, be sure to call the bases class's <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SelectCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ SelectCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-710">데이터 소스에서 레코드를 선택하는 데 사용되는 명령을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-710">Gets or sets a command used to select records in the data source.</span></span></summary>
        <value><span data-ttu-id="1bf95-711"><see cref="T:System.Data.IDbCommand" />를 수행하는 동안 데이터 집합에 배치할 레코드를 데이터 소스에서 선택하는 데 사용되는 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-711">A <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to select records from data source for placement in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1bf95-712">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-712">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.DeleteCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand" />
      <MemberSignature Language="VB.NET" Value=" Property DeleteCommand As IDbCommand Implements IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.DeleteCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.DeleteCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-713">데이터 집합에서 레코드를 삭제하기 위한 SQL 문을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-713">Gets or sets an SQL statement for deleting records from the data set.</span></span></summary>
        <value><span data-ttu-id="1bf95-714"><see cref="T:System.Data.IDbCommand" />을 수행하는 동안 데이터 집합의 삭제된 행에 대한 데이터 소스에서 레코드를 삭제하는 데 사용되는 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-714">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to delete records in the data source for deleted rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-715">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="1bf95-715">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1bf95-716"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-716">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="1bf95-717">자세한 내용은 <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1bf95-717">For more information, see <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.InsertCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand" />
      <MemberSignature Language="VB.NET" Value=" Property InsertCommand As IDbCommand Implements IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.InsertCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.InsertCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-718">데이터 소스에 새 레코드를 삽입하는 데 사용되는 SQL 문을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-718">Gets or sets an SQL statement used to insert new records into the data source.</span></span></summary>
        <value><span data-ttu-id="1bf95-719"><see cref="T:System.Data.IDbCommand" />을 수행하는 동안 데이터 집합의 새 행에 대한 데이터 소스에 레코드를 삽입하는 데 사용되는 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-719">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to insert records in the data source for new rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-720">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="1bf95-720">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1bf95-721"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-721">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="1bf95-722">자세한 내용은 <xref:System.Data.IDbDataAdapter.InsertCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1bf95-722">For more information, see <xref:System.Data.IDbDataAdapter.InsertCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.SelectCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand" />
      <MemberSignature Language="VB.NET" Value=" Property SelectCommand As IDbCommand Implements IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.SelectCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.SelectCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-723">데이터 소스에서 레코드를 선택하는 데 사용되는 SQL 문을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-723">Gets or sets an SQL statement used to select records in the data source.</span></span></summary>
        <value><span data-ttu-id="1bf95-724"><see cref="T:System.Data.IDbCommand" />을 수행하는 동안 데이터 소스에서 데이터 집합에 배치할 레코드를 선택하는 데 사용되는 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-724">An <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to select records from data source for placement in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-725">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="1bf95-725">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1bf95-726"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-726">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="1bf95-727">자세한 내용은 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1bf95-727">For more information, see <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.UpdateCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand" />
      <MemberSignature Language="VB.NET" Value=" Property UpdateCommand As IDbCommand Implements IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.UpdateCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.UpdateCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-728">데이터 소스에서 레코드를 업데이트하는 데 사용되는 SQL 문을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-728">Gets or sets an SQL statement used to update records in the data source.</span></span></summary>
        <value><span data-ttu-id="1bf95-729"><see cref="T:System.Data.IDbCommand" />을 수행하는 동안 데이터 집합의 수정된 행에 대한 데이터 소스에서 레코드를 업데이트하는 데 사용되는 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-729">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to update records in the data source for modified rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-730">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="1bf95-730">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1bf95-731"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-731">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="1bf95-732">자세한 내용은 <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1bf95-732">For more information, see <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bf95-733">현재 인스턴스의 복사본인 새 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-733">Creates a new object that is a copy of the current instance.</span></span></summary>
        <returns><span data-ttu-id="1bf95-734">이 인스턴스의 복사본인 새 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-734">A new object that is a copy of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-735">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="1bf95-735">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="1bf95-736"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.ICloneable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-736">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.ICloneable> interface.</span></span>  
  
 <span data-ttu-id="1bf95-737">자세한 내용은 <xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1bf95-737">For more information, see <xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TerminateBatching">
      <MemberSignature Language="C#" Value="protected virtual void TerminateBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TerminateBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.TerminateBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TerminateBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TerminateBatching();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bf95-738"><see cref="T:System.Data.Common.DbDataAdapter" />의 일괄 처리를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-738">Ends batching for the <see cref="T:System.Data.Common.DbDataAdapter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-739"><xref:System.Data.Common.DbDataAdapter>,이 메서드에서 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-739">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1bf95-740">상속 된 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-740">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1bf95-741">어댑터에서 일괄 처리를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-741">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="1bf95-742">이 메서드는 보호 되 고.NET Framework 데이터 공급자에서 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-742">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
 <span data-ttu-id="1bf95-743">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스가이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-743">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method.</span></span> <span data-ttu-id="1bf95-744">이 메서드를 통해 클래스 일괄 처리를 지원 하기 위해 할당 된 모든 리소스를 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-744">This method gives the class the opportunity to dispose of any resources allocated to support batching.</span></span> <span data-ttu-id="1bf95-745">예를 들어 클래스 명령을 일괄 처리에서 보유 하는 데이터 구조를 할당을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-745">For example, the class may deallocate the data structure that holds the commands in the batch.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bf95-746"><see cref="T:System.Data.DataSet" />에서 삽입, 업데이트 또는 삭제된 각 행마다 INSERT, UPDATE 또는 DELETE 문을 각각 실행하여 데이터베이스에 있는 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-746">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataRow[] dataRows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataRow[] dataRows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (dataRows As DataRow()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="dataRows"><span data-ttu-id="1bf95-747">데이터 소스를 업데이트하는 데 사용되는 <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-747">An array of <see cref="T:System.Data.DataRow" /> objects used to update the data source.</span></span></param>
        <summary><span data-ttu-id="1bf95-748"><see cref="T:System.Data.DataSet" />의 지정된 배열에서 삽입, 업데이트 또는 삭제된 각 행마다 INSERT, UPDATE 또는 DELETE 문을 각각 실행하여 데이터베이스의 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-748">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array in the <see cref="T:System.Data.DataSet" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-749"><see cref="T:System.Data.DataSet" />에서 성공적으로 업데이트된 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-749">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-750">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를는 <xref:System.Data.Common.DbDataAdapter> 검사 하는 <xref:System.Data.DataRow.RowState%2A> 속성을 반복적으로 에구성된인덱스순서에따라각행에대한필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-750">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-751">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 옵니다 INSERT 문에서 다른 DELETE 문은 때문에 있는 행의 순서는 DELETE 문이 실행 될 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-751">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-752">이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다 용도로 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-752">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="1bf95-753">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 명령문 (예를 들어 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-753">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="1bf95-754">자세한 내용은 참조 [Dataadapter로 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-754">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="1bf95-755">경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-755">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="1bf95-756">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-756">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="1bf95-757">를 설정 하지 않는 추가적인 모든 SQL 문을 그러면는 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-757">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="1bf95-758">이 생성 논리는 키 열에 대 한 정보가 필요는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-758">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-759">자세한 내용은 참조 [commandbuilder 생성 명령을](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-759">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="1bf95-760"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드는 업데이트를 수행 하기 전에 첫 번째 매핑에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-760">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="1bf95-761"><xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-761">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="1bf95-762">반환 된 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-762">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="1bf95-763">모든 데이터에 다시 로드 되는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령에서 반환 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-763">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="1bf95-764">행이 성공적으로 업데이트 한 후 해당 행에 변경 내용은 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-764">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="1bf95-765">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-765">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="1bf95-766">값은 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-766">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="1bf95-767"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-767">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="1bf95-768">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-768">The command executes.</span></span>  
  
4.  <span data-ttu-id="1bf95-769">명령으로 설정 되어 있으면 `FirstReturnedRecord`, 첫 번째 반환 결과에 배치 되는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-769">If the command is set to `FirstReturnedRecord`, the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="1bf95-770">에 지정 되므로 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-770">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="1bf95-771"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-771">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="1bf95-772"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-772"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="1bf95-773">와 연결 된 각 명령에서 <xref:System.Data.Common.DbDataAdapter> 은 일반적으로 관련 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-773">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="1bf95-774">매개 변수를 통해 현재 행에 매핑됩니다.는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-774">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="1bf95-775">`SourceColumn` 참조 하는 <xref:System.Data.DataTable> 열 하는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-775">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="1bf95-776">`SourceColumn` 테이블 매핑이 적용 되기 전에 매핑되지 않은 열 이름을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-776">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="1bf95-777">경우 `SourceColumn` 참조 존재 하지 않는 열에는 다음 중 하나에 따라 다른 동작이 수행 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-777">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="1bf95-778">열거형 값</span><span class="sxs-lookup"><span data-stu-id="1bf95-778">Enumeration value</span></span>|<span data-ttu-id="1bf95-779">수행 작업</span><span class="sxs-lookup"><span data-stu-id="1bf95-779">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="1bf95-780">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="1bf95-780">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="1bf95-781">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-781">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="1bf95-782">매핑을 명시적으로 설정 하는 경우 입력 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-782">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="1bf95-783">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-783">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="1bf95-784">`SourceColumn` 속성은 또한 출력에 대 한 값에 매핑할 사용 입/출력 매개 변수를 또는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-784">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="1bf95-785">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-785">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="1bf95-786">`SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 Original, Current 또는 Proposed 버전 열 값의 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-786">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="1bf95-787">낙관적 동시성 위반을 확인 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하려면이 기능은 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-787">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-788">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단.</span><span class="sxs-lookup"><span data-stu-id="1bf95-788">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="1bf95-789">설정 오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-789">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="1bf95-790">내에서 각 행 마다 별로 오류를 선택할 수 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-790">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="1bf95-791">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 `RowUpdated` 이벤트를 설정는 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성은 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-791">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-792">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.OleDb.OleDbDataAdapter>, 데이터 소스를 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-792">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1bf95-793"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-793">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-794">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-794">The source table is invalid.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="1bf95-795">업데이트할 <see cref="T:System.Data.DataRow" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-795">No <see cref="T:System.Data.DataRow" /> exists to update.</span></span>  
  
 <span data-ttu-id="1bf95-796">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-796">-or-</span></span>  
  
 <span data-ttu-id="1bf95-797">업데이트할 <see cref="T:System.Data.DataTable" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-797">No <see cref="T:System.Data.DataTable" /> exists to update.</span></span>  
  
 <span data-ttu-id="1bf95-798">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-798">-or-</span></span>  
  
 <span data-ttu-id="1bf95-799">소스로 사용할 <see cref="T:System.Data.DataSet" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-799">No <see cref="T:System.Data.DataSet" /> exists to use as a source.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="1bf95-800">INSERT, UPDATE 또는 DELETE 문을 실행한 결과 영향을 받은 레코드가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-800">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public override int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Update(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Update(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-801">데이터 소스를 업데이트하는 데 사용된 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-801">The <see cref="T:System.Data.DataSet" /> used to update the data source.</span></span></param>
        <summary><span data-ttu-id="1bf95-802">지정된 <see cref="T:System.Data.DataSet" />에서 삽입, 업데이트 또는 삭제된 각 행마다 INSERT, UPDATE 또는 DELETE 문을 각각 실행하여 데이터베이스에 있는 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-802">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-803"><see cref="T:System.Data.DataSet" />에서 성공적으로 업데이트된 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-803">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-804">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를는 <xref:System.Data.Common.DbDataAdapter> 검사 하는 <xref:System.Data.DataRow.RowState%2A> 속성을 반복적으로 에구성된인덱스순서에따라각행에대한필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-804">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-805">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 옵니다 INSERT 문에서 다른 DELETE 문은 때문에 있는 행의 순서는 DELETE 문이 실행 될 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-805">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-806">이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다 용도로 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-806">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="1bf95-807">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 명령문 (예를 들어 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-807">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="1bf95-808">자세한 내용은 참조 [Dataadapter로 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-808">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="1bf95-809">경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-809">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="1bf95-810">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-810">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="1bf95-811">를 설정 하지 않는 추가적인 모든 SQL 문을 그러면는 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-811">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="1bf95-812">이 생성 논리는 키 열에 대 한 정보가 필요는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-812">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-813">자세한 내용은 참조 [commandbuilder 생성 명령을](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-813">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="1bf95-814"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드는 업데이트를 수행 하기 전에 첫 번째 매핑에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-814">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="1bf95-815"><xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-815">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="1bf95-816">반환 된 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-816">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="1bf95-817">모든 데이터에 다시 로드 되는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령에서 반환 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-817">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="1bf95-818">행이 성공적으로 업데이트 한 후 해당 행에 변경 내용은 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-818">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="1bf95-819">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-819">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="1bf95-820">값은 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-820">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="1bf95-821"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-821">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="1bf95-822">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-822">The command executes.</span></span>  
  
4.  <span data-ttu-id="1bf95-823">명령으로 설정 되어 있으면 `FirstReturnedRecord`는 첫 번째 반환 결과에 배치 되는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-823">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="1bf95-824">에 지정 되므로 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-824">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="1bf95-825"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-825">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="1bf95-826"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-826"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="1bf95-827">와 연결 된 각 명령에서 <xref:System.Data.Common.DbDataAdapter> 은 일반적으로 관련 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-827">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="1bf95-828">매개 변수를 통해 현재 행에 매핑됩니다.는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-828">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="1bf95-829">`SourceColumn` 참조 하는 <xref:System.Data.DataTable> 열 하는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-829">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="1bf95-830">`SourceColumn` 테이블 매핑이 적용 되기 전에 매핑되지 않은 열 이름을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-830">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="1bf95-831">경우 `SourceColumn` 참조 존재 하지 않는 열에는 다음 중 하나에 따라 다른 동작이 수행 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-831">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="1bf95-832">열거형 값</span><span class="sxs-lookup"><span data-stu-id="1bf95-832">Enumeration value</span></span>|<span data-ttu-id="1bf95-833">수행 작업</span><span class="sxs-lookup"><span data-stu-id="1bf95-833">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="1bf95-834">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="1bf95-834">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="1bf95-835">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-835">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="1bf95-836">매핑을 명시적으로 설정 하는 경우 입력 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-836">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="1bf95-837">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-837">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="1bf95-838">`SourceColumn` 속성은 또한 출력에 대 한 값에 매핑할 사용 입/출력 매개 변수를 또는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-838">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="1bf95-839">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-839">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="1bf95-840">`SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 Original, Current 또는 Proposed 버전 열 값의 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-840">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="1bf95-841">낙관적 동시성 위반을 확인 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하려면이 기능은 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-841">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-842">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단.</span><span class="sxs-lookup"><span data-stu-id="1bf95-842">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="1bf95-843">설정 오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-843">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="1bf95-844">내에서 각 행 마다 별로 오류를 선택할 수 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-844">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="1bf95-845">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 `RowUpdated` 이벤트를 설정는 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성은 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-845">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-846">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.OleDb.OleDbDataAdapter>, 데이터 소스를 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-846">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-847">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-847">The source table is invalid.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="1bf95-848">INSERT, UPDATE 또는 DELETE 문을 실행한 결과 영향을 받은 레코드가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-848">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataTable ^ dataTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="1bf95-849">데이터 소스를 업데이트하는 데 사용된 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-849">The <see cref="T:System.Data.DataTable" /> used to update the data source.</span></span></param>
        <summary><span data-ttu-id="1bf95-850">지정된 <see cref="T:System.Data.DataTable" />에서 삽입, 업데이트 또는 삭제된 각 행마다 INSERT, UPDATE 또는 DELETE 문을 각각 실행하여 데이터베이스에 있는 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-850">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataTable" />.</span></span></summary>
        <returns><span data-ttu-id="1bf95-851"><see cref="T:System.Data.DataTable" />에서 성공적으로 업데이트된 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-851">The number of rows successfully updated from the <see cref="T:System.Data.DataTable" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-852">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를는 <xref:System.Data.Common.DbDataAdapter> 검사 하는 <xref:System.Data.DataRow.RowState%2A> 속성을 반복적으로 에구성된인덱스순서에따라각행에대한필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-852">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-853">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 옵니다 INSERT 문에서 다른 DELETE 문은 때문에 있는 행의 순서는 DELETE 문이 실행 될 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-853">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-854">이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다 용도로 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-854">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="1bf95-855">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 명령문 (예를 들어 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-855">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="1bf95-856">자세한 내용은 참조 [Dataadapter로 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-856">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="1bf95-857">경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-857">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="1bf95-858">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-858">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="1bf95-859">를 설정 하지 않는 추가적인 모든 SQL 문을 그러면는 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-859">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="1bf95-860">이 생성 논리는 키 열에 대 한 정보가 필요는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-860">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-861">자세한 내용은 참조 [commandbuilder 생성 명령을](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-861">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="1bf95-862"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드는 업데이트를 수행 하기 전에 첫 번째 매핑에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-862">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="1bf95-863"><xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-863">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="1bf95-864">반환 된 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-864">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="1bf95-865">모든 데이터에 다시 로드 되는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령에서 반환 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-865">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="1bf95-866">행이 성공적으로 업데이트 한 후 해당 행에 변경 내용은 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-866">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="1bf95-867">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-867">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="1bf95-868">값은 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-868">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="1bf95-869"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-869">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="1bf95-870">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-870">The command executes.</span></span>  
  
4.  <span data-ttu-id="1bf95-871">명령으로 설정 되어 있으면 `FirstReturnedRecord`는 첫 번째 반환 결과에 배치 되는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-871">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="1bf95-872">에 지정 되므로 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-872">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="1bf95-873"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-873">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="1bf95-874"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-874"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="1bf95-875">와 연결 된 각 명령에서 <xref:System.Data.Common.DbDataAdapter> 은 일반적으로 관련 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-875">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="1bf95-876">매개 변수를 통해 현재 행에 매핑됩니다.는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-876">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="1bf95-877">`SourceColumn` 참조 하는 <xref:System.Data.DataTable> 열 하는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-877">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="1bf95-878">`SourceColumn` 테이블 매핑이 적용 되기 전에 매핑되지 않은 열 이름을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-878">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="1bf95-879">경우 `SourceColumn` 참조 존재 하지 않는 열에는 다음 중 하나에 따라 다른 동작이 수행 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-879">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="1bf95-880">열거형 값</span><span class="sxs-lookup"><span data-stu-id="1bf95-880">Enumeration value</span></span>|<span data-ttu-id="1bf95-881">수행 작업</span><span class="sxs-lookup"><span data-stu-id="1bf95-881">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="1bf95-882">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="1bf95-882">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="1bf95-883">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-883">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="1bf95-884">매핑을 명시적으로 설정 하는 경우 입력 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-884">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="1bf95-885">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-885">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="1bf95-886">`SourceColumn` 속성은 또한 출력에 대 한 값에 매핑할 사용 입/출력 매개 변수를 또는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-886">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="1bf95-887">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-887">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="1bf95-888">`SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 Original, Current 또는 Proposed 버전 열 값의 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-888">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="1bf95-889">낙관적 동시성 위반을 확인 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하려면이 기능은 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-889">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-890">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단.</span><span class="sxs-lookup"><span data-stu-id="1bf95-890">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="1bf95-891">설정 오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-891">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="1bf95-892">내에서 각 행 마다 별로 오류를 선택할 수 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-892">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="1bf95-893">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 `RowUpdated` 이벤트를 설정는 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성은 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-893">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-894">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.OleDb.OleDbDataAdapter>, 데이터 소스를 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-894">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1bf95-895"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-895">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-896">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-896">The source table is invalid.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="1bf95-897">업데이트할 <see cref="T:System.Data.DataRow" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-897">No <see cref="T:System.Data.DataRow" /> exists to update.</span></span>  
  
 <span data-ttu-id="1bf95-898">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-898">-or-</span></span>  
  
 <span data-ttu-id="1bf95-899">업데이트할 <see cref="T:System.Data.DataTable" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-899">No <see cref="T:System.Data.DataTable" /> exists to update.</span></span>  
  
 <span data-ttu-id="1bf95-900">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-900">-or-</span></span>  
  
 <span data-ttu-id="1bf95-901">소스로 사용할 <see cref="T:System.Data.DataSet" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-901">No <see cref="T:System.Data.DataSet" /> exists to use as a source.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="1bf95-902">INSERT, UPDATE 또는 DELETE 문을 실행한 결과 영향을 받은 레코드가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-902">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Update(class System.Data.DataRow[] dataRows, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Update (dataRows As DataRow(), tableMapping As DataTableMapping) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRows"><span data-ttu-id="1bf95-903">데이터 소스를 업데이트하는 데 사용되는 <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-903">An array of <see cref="T:System.Data.DataRow" /> objects used to update the data source.</span></span></param>
        <param name="tableMapping"><span data-ttu-id="1bf95-904">사용할 <see cref="P:System.Data.IDataAdapter.TableMappings" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-904">The <see cref="P:System.Data.IDataAdapter.TableMappings" /> collection to use.</span></span></param>
        <summary><span data-ttu-id="1bf95-905">지정된 <see cref="T:System.Data.DataSet" /> 개체 배열에서 삽입, 업데이트 또는 삭제된 각 행마다 INSERT, UPDATE 또는 DELETE 문을 각각 실행하여 데이터베이스에 있는 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-905">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array of <see cref="T:System.Data.DataSet" /> objects.</span></span></summary>
        <returns><span data-ttu-id="1bf95-906"><see cref="T:System.Data.DataSet" />에서 성공적으로 업데이트된 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-906">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-907">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를는 <xref:System.Data.Common.DbDataAdapter> 검사 하는 <xref:System.Data.DataRow.RowState%2A> 속성을 반복적으로 에구성된인덱스순서에따라각행에대한필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-907">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-908">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 옵니다 INSERT 문에서 다른 DELETE 문은 때문에 있는 행의 순서는 DELETE 문이 실행 될 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-908">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-909">이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다 용도로 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-909">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="1bf95-910">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 명령문 (예를 들어 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-910">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="1bf95-911">자세한 내용은 참조 [Dataadapter로 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-911">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="1bf95-912">경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-912">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="1bf95-913">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-913">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="1bf95-914">를 설정 하지 않는 추가적인 모든 SQL 문을 그러면는 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-914">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="1bf95-915">이 생성 논리는 키 열에 대 한 정보가 필요는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-915">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-916">자세한 내용은 참조 [commandbuilder 생성 명령을](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-916">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="1bf95-917"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드는 업데이트를 수행 하기 전에 첫 번째 매핑에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-917">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="1bf95-918"><xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-918">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="1bf95-919">반환 된 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-919">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="1bf95-920">모든 데이터에 다시 로드 되는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령에서 반환 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-920">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="1bf95-921">행이 성공적으로 업데이트 한 후 해당 행에 변경 내용은 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-921">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="1bf95-922">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-922">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="1bf95-923">값은 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-923">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="1bf95-924"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-924">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="1bf95-925">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-925">The command executes.</span></span>  
  
4.  <span data-ttu-id="1bf95-926">명령으로 설정 되어 있으면 `FirstReturnedRecord`는 첫 번째 반환 결과에 배치 되는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-926">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="1bf95-927">에 지정 되므로 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-927">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="1bf95-928"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-928">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="1bf95-929"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-929"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="1bf95-930">와 연결 된 각 명령에서 <xref:System.Data.Common.DbDataAdapter> 은 일반적으로 관련 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-930">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="1bf95-931">매개 변수를 통해 현재 행에 매핑됩니다.는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-931">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="1bf95-932">`SourceColumn` 참조 하는 <xref:System.Data.DataTable> 열 하는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-932">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="1bf95-933">`SourceColumn` 테이블 매핑이 적용 되기 전에 매핑되지 않은 열 이름을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-933">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="1bf95-934">경우 `SourceColumn` 참조 존재 하지 않는 열에는 다음 중 하나에 따라 다른 동작이 수행 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-934">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="1bf95-935">열거형 값</span><span class="sxs-lookup"><span data-stu-id="1bf95-935">Enumeration value</span></span>|<span data-ttu-id="1bf95-936">수행 작업</span><span class="sxs-lookup"><span data-stu-id="1bf95-936">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="1bf95-937">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="1bf95-937">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="1bf95-938">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-938">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="1bf95-939">매핑을 명시적으로 설정 하는 경우 입력 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-939">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="1bf95-940">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-940">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="1bf95-941">`SourceColumn` 속성은 또한 출력에 대 한 값에 매핑할 사용 입/출력 매개 변수를 또는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-941">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="1bf95-942">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-942">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="1bf95-943">`SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 Original, Current 또는 Proposed 버전 열 값의 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-943">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="1bf95-944">낙관적 동시성 위반을 확인 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하려면이 기능은 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-944">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-945">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단.</span><span class="sxs-lookup"><span data-stu-id="1bf95-945">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="1bf95-946">설정 오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-946">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="1bf95-947">내에서 각 행 마다 별로 오류를 선택할 수 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-947">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="1bf95-948">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 `RowUpdated` 이벤트를 설정는 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성은 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-948">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1bf95-949"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-949">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-950">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-950">The source table is invalid.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="1bf95-951">업데이트할 <see cref="T:System.Data.DataRow" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-951">No <see cref="T:System.Data.DataRow" /> exists to update.</span></span>  
  
 <span data-ttu-id="1bf95-952">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-952">-or-</span></span>  
  
 <span data-ttu-id="1bf95-953">업데이트할 <see cref="T:System.Data.DataTable" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-953">No <see cref="T:System.Data.DataTable" /> exists to update.</span></span>  
  
 <span data-ttu-id="1bf95-954">또는</span><span class="sxs-lookup"><span data-stu-id="1bf95-954">-or-</span></span>  
  
 <span data-ttu-id="1bf95-955">소스로 사용할 <see cref="T:System.Data.DataSet" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-955">No <see cref="T:System.Data.DataSet" /> exists to use as a source.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="1bf95-956">INSERT, UPDATE 또는 DELETE 문을 실행한 결과 영향을 받은 레코드가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-956">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="1bf95-957">데이터 소스를 업데이트하는 데 사용할 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-957">The <see cref="T:System.Data.DataSet" /> to use to update the data source.</span></span></param>
        <param name="srcTable"><span data-ttu-id="1bf95-958">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-958">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="1bf95-959"><see cref="T:System.Data.DataTable" /> 이름이 지정된 <see cref="T:System.Data.DataSet" />에서 삽입, 업데이트 또는 삭제된 각 행마다 INSERT, UPDATE 또는 DELETE 문을 각각 실행하여 데이터베이스에 있는 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-959">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" /> with the specified <see cref="T:System.Data.DataTable" /> name.</span></span></summary>
        <returns><span data-ttu-id="1bf95-960"><see cref="T:System.Data.DataSet" />에서 성공적으로 업데이트된 행의 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-960">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-961">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를는 <xref:System.Data.Common.DbDataAdapter> 검사 하는 <xref:System.Data.DataRow.RowState%2A> 속성을 반복적으로 에구성된인덱스순서에따라각행에대한필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="1bf95-961">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-962">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 옵니다 INSERT 문에서 다른 DELETE 문은 때문에 있는 행의 순서는 DELETE 문이 실행 될 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-962">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="1bf95-963">이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다 용도로 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-963">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="1bf95-964">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 명령문의 시퀀스를 제어 해야 할 경우에 (예를 들어 업데이트 하기 전에 삽입).</span><span class="sxs-lookup"><span data-stu-id="1bf95-964">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERT before UPDATE).</span></span> <span data-ttu-id="1bf95-965">자세한 내용은 참조 [Dataadapter로 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-965">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="1bf95-966">경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-966">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="1bf95-967">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-967">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="1bf95-968">를 설정 하지 않는 추가적인 모든 SQL 문을 그러면는 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-968">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="1bf95-969">이 생성 논리는 키 열에 대 한 정보가 필요는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-969">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-970">자세한 내용은 참조 [commandbuilder 생성 명령을](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-970">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="1bf95-971"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-971">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="1bf95-972">여러 테이블을 이름이 같지만 서로 다른 경우에 존재 하는 경우는 `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A> 해당 테이블을 찾지 대/소문자 구분 비교를 수행 하 고 있는 정확한 일치 항목이 없는 경우 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-972">When multiple tables with the same name, but different case, exist in a `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A> performs a case-sensitive comparison to find the corresponding table, and generates an exception if no exact match exists.</span></span> <span data-ttu-id="1bf95-973">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-973">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet ds = new DataSet();  
 ds.Tables.Add("aaa");  
 ds.Tables.Add("AAA");  
 adapter.Update(ds, "aaa"); // Updates "aaa", which already exists in the DataSet.  
 adapter.Update(ds, "AAA"); // Updates "AAA", which already exists in the DataSet.  
    adapter.Update(ds, "Aaa"); // Results in an exception.  
```  
  
 <span data-ttu-id="1bf95-974">경우 <xref:System.Data.Common.DbDataAdapter.Update%2A> 라고 및 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이만 대/소문자는 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-974">If <xref:System.Data.Common.DbDataAdapter.Update%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="1bf95-975">이 시나리오에서는 비교는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-975">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="1bf95-976">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-976">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Update(dataset, "AAA"); // Updates table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="1bf95-977"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드는 업데이트를 수행 하기 전에 첫 번째 매핑에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-977">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="1bf95-978"><xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-978">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="1bf95-979">반환 된 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-979">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="1bf95-980">모든 데이터에 다시 로드 되는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령에서 반환 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-980">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="1bf95-981">행이 성공적으로 업데이트 한 후 해당 행에 변경 내용은 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-981">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="1bf95-982">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-982">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="1bf95-983">값은 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-983">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="1bf95-984"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-984">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="1bf95-985">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-985">The command executes.</span></span>  
  
4.  <span data-ttu-id="1bf95-986">명령으로 설정 되어 있으면 `FirstReturnedRecord`는 첫 번째 반환 결과에 배치 되는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-986">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="1bf95-987">에 지정 되므로 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-987">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="1bf95-988"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-988">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="1bf95-989"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-989"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="1bf95-990">와 연결 된 각 명령에서 <xref:System.Data.Common.DbDataAdapter> 은 일반적으로 관련 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-990">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="1bf95-991">매개 변수를 통해 현재 행에 매핑됩니다.는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-991">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="1bf95-992">`SourceColumn` 참조 하는 <xref:System.Data.DataTable> 열 하는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-992">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="1bf95-993">`SourceColumn` 테이블 매핑이 적용 되기 전에 매핑되지 않은 열 이름을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-993">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="1bf95-994">경우 `SourceColumn` 참조 존재 하지 않는 열에는 다음 중 하나에 따라 다른 동작이 수행 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-994">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="1bf95-995">열거형 값</span><span class="sxs-lookup"><span data-stu-id="1bf95-995">Enumeration value</span></span>|<span data-ttu-id="1bf95-996">수행 작업</span><span class="sxs-lookup"><span data-stu-id="1bf95-996">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="1bf95-997">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="1bf95-997">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="1bf95-998">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-998">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="1bf95-999">매핑을 명시적으로 설정 하는 경우 입력 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-999">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="1bf95-1000">A <xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1000">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="1bf95-1001">`SourceColumn` 속성은 또한 출력에 대 한 값에 매핑할 사용 입/출력 매개 변수를 또는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1001">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="1bf95-1002">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1002">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="1bf95-1003">`SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 Original, Current 또는 Proposed 버전 열 값의 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1003">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="1bf95-1004">낙관적 동시성 위반을 확인 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하려면이 기능은 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1004">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bf95-1005">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1005">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="1bf95-1006">설정 오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1006">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="1bf95-1007">내에서 각 행 마다 별로 오류를 선택할 수 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1007">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="1bf95-1008">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면는 `RowUpdated` 이벤트를 설정는 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성은 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1008">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-1009">다음 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Data.OleDb.OleDbDataAdapter>, 데이터 소스를 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1009">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1bf95-1010"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1010">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bf95-1011">소스 테이블이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-1011">The source table is invalid.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="1bf95-1012">INSERT, UPDATE 또는 DELETE 문을 실행한 결과 영향을 받은 레코드가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="1bf95-1012">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateBatchSize">
      <MemberSignature Language="C#" Value="public virtual int UpdateBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UpdateBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property UpdateBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int UpdateBatchSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-1013">일괄 작업 처리 지원을 활성화하거나 비활성화하는 값을 가져오거나 설정하고 일괄 작업에서 실행할 수 있는 명령의 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1013">Gets or sets a value that enables or disables batch processing support, and specifies the number of commands that can be executed in a batch.</span></span></summary>
        <value><span data-ttu-id="1bf95-1014">일괄 작업당 처리할 행의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1014">The number of rows to process per batch.</span></span>  
  
 <span data-ttu-id="1bf95-1015"><list type="table"><listheader><term> 값은</span><span class="sxs-lookup"><span data-stu-id="1bf95-1015"><list type="table"><listheader><term> Value is</span></span>  
  
 <span data-ttu-id="1bf95-1016"></term><description> 효과</span><span class="sxs-lookup"><span data-stu-id="1bf95-1016"></term><description> Effect</span></span>  
  
 <span data-ttu-id="1bf95-1017"></description></listheader><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="1bf95-1017"></description></listheader><item><term> 0</span></span>  
  
 <span data-ttu-id="1bf95-1018"></term><description> 일괄 처리 크기에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1018"></term><description> There is no limit on the batch size.</span></span>  
  
 <span data-ttu-id="1bf95-1019"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="1bf95-1019"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="1bf95-1020"></term><description> 일괄 처리 업데이트를 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1020"></term><description> Disables batch updating.</span></span>  
  
 <span data-ttu-id="1bf95-1021"></description></item><item><term> &gt; 1</span><span class="sxs-lookup"><span data-stu-id="1bf95-1021"></description></item><item><term> &gt; 1</span></span>  
  
 <span data-ttu-id="1bf95-1022"></term><description> 변경 내용의 일괄 처리를 사용 하 여 전송 되므로 <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" /> 한 번에 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1022"></term><description> Changes are sent using batches of <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" /> operations at a time.</span></span>  
  
 </description></item></list>  
  
 <span data-ttu-id="1bf95-1023">연결 된 모든 명령을이 값 1이 아닌 값을 설정 하는 경우는 <see cref="T:System.Data.Common.DbDataAdapter" /> 있어야 해당 <see cref="P:System.Data.IDbCommand.UpdatedRowSource" /> 속성이로 설정 **None** 또는 **출력 매개 변수**합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1023">When setting this to a value other than 1, all the commands associated with the <see cref="T:System.Data.Common.DbDataAdapter" /> must have their <see cref="P:System.Data.IDbCommand.UpdatedRowSource" /> property set to **None** or **OutputParameters**.</span></span> <span data-ttu-id="1bf95-1024">그렇지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1024">An exception will be thrown otherwise.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-1025">사용 하 여는 <xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A> 속성 변경 내용으로 데이터 소스를 업데이트 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1025">Use the <xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A> property to update a data source with changes from a <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="1bf95-1026">데이터 공급자가 일괄 처리를 지 원하는 서버에 왕복 횟수를 줄여 응용 프로그램 성능을 향상 시킬 수이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1026">If the data provider supports batch processing, this can increase application performance by reducing the number of round-trips to the server.</span></span> <span data-ttu-id="1bf95-1027">ADO.NET 2.0에서는이 속성은 SQL Server (SqlClient) 및 Oracle (OracleClient)에 대 한.NET 데이터 공급자에 대 한 지원.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1027">In ADO.NET 2.0, this property is supported for the .NET data providers for SQL Server (SqlClient) and Oracle (OracleClient).</span></span>  
  
 <span data-ttu-id="1bf95-1028">너무 큰 배치를 실행하면 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1028">Executing an extremely large batch could decrease performance.</span></span> <span data-ttu-id="1bf95-1029">따라서 응용 프로그램을 구현하기 전에 최적의 배치 크기 설정을 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1029">Therefore, you should test for the optimum batch size setting before implementing your application.</span></span>  
  
 <span data-ttu-id="1bf95-1030"><xref:System.ArgumentOutOfRangeException> 0 보다 작은 값은 숫자로 설정 되 면 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1030">An <xref:System.ArgumentOutOfRangeException> will be thrown if the value is set to a number less than zero.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ UpdateCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bf95-1031">데이터 소스에서 레코드를 업데이트하는 데 사용되는 명령을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1031">Gets or sets a command used to update records in the data source.</span></span></summary>
        <value><span data-ttu-id="1bf95-1032"><see cref="T:System.Data.IDbCommand" />를 수행하는 동안 데이터 집합의 수정된 행에 대한 레코드를 데이터 소스에서 업데이트하는 데 사용되는 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1032">A <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to update records in the data source for modified rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bf95-1033">동안 <xref:System.Data.Common.DbDataAdapter.Update%2A>경우이 속성은 설정 되지 않으며 기본 키 정보에 있는지는 <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.UpdateCommand%2A> 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1033">During <xref:System.Data.Common.DbDataAdapter.Update%2A>, if this property is not set and primary key information is present in the <xref:System.Data.DataSet>, the <xref:System.Data.IDbDataAdapter.UpdateCommand%2A> will be automatically generated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bf95-1034">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="1bf95-1034">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>