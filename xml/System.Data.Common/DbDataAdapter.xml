<Type Name="DbDataAdapter" FullName="System.Data.Common.DbDataAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="584da0f66c3d9c8fc0bbeefea9b060904faf1cb2" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52735027" /></Metadata><TypeSignature Language="C#" Value="public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DbDataAdapter extends System.Data.Common.DataAdapter implements class System.Data.IDataAdapter, class System.Data.IDbDataAdapter, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.DbDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DbDataAdapter&#xA;Inherits DataAdapter&#xA;Implements ICloneable, IDbDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbDataAdapter abstract : System::Data::Common::DataAdapter, ICloneable, System::Data::IDbDataAdapter" />
  <TypeSignature Language="F#" Value="type DbDataAdapter = class&#xA;    inherit DataAdapter&#xA;    interface IDbDataAdapter&#xA;    interface ICloneable&#xA;    interface IDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DataAdapter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.IDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Data.IDbDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="77579-101"><see cref="T:System.Data.IDbDataAdapter" /> 인터페이스의 구현을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-101">Aids implementation of the <see cref="T:System.Data.IDbDataAdapter" /> interface.</span></span> <span data-ttu-id="77579-102"><see cref="T:System.Data.Common.DbDataAdapter" />의 상속자는 강력한 형식을 제공하기 위한 함수 집합을 구현하지만 **DataAdapter**를 완전히 구현하는 데 필요한 대부분의 기능을 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-102">Inheritors of <see cref="T:System.Data.Common.DbDataAdapter" /> implement a set of functions to provide strong typing, but inherit most of the functionality needed to fully implement a **DataAdapter**.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-103"><xref:System.Data.Common.DbDataAdapter> 클래스에서 상속 합니다 <xref:System.Data.Common.DataAdapter> 클래스를 구현 합니다 <xref:System.Data.IDbDataAdapter> 인터페이스.</span><span class="sxs-lookup"><span data-stu-id="77579-103">The <xref:System.Data.Common.DbDataAdapter> class inherits from the <xref:System.Data.Common.DataAdapter> class and implements the <xref:System.Data.IDbDataAdapter> interface.</span></span> <span data-ttu-id="77579-104">클래스를 구현 하는 데 도움이 된 **DataAdapter** 관계형 데이터베이스를 사용 하 여 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-104">It helps a class implement a **DataAdapter** designed for use with a relational database.</span></span>  
  
 <span data-ttu-id="77579-105">응용 프로그램의 인스턴스를 만들지 않습니다는 <xref:System.Data.Common.DbDataAdapter> 클래스를 직접 하지만에서 상속 된 클래스의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-105">An application does not create an instance of the <xref:System.Data.Common.DbDataAdapter> class directly, but creates an instance of a class that inherits from it.</span></span>  
  
 <span data-ttu-id="77579-106">상속 된 클래스 <xref:System.Data.Common.DbDataAdapter> 상속 된 멤버를 구현 해야 하며 일반적으로 공급자 특정 기능을 추가 하기 위한 추가 멤버를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-106">Classes that inherit <xref:System.Data.Common.DbDataAdapter> must implement the inherited members, and typically define additional members to add provider-specific functionality.</span></span> <span data-ttu-id="77579-107">예를 들어,를 <xref:System.Data.Common.DbDataAdapter> 클래스를 정의 합니다 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성 및 <xref:System.Data.Common.DbDataAdapter> 의 8 개 오버 로드를 정의 하는 클래스를 <xref:System.Data.IDataAdapter.Fill%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-107">For example, the <xref:System.Data.Common.DbDataAdapter> class defines the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property, and the <xref:System.Data.Common.DbDataAdapter> class defines eight overloads of the <xref:System.Data.IDataAdapter.Fill%2A> method.</span></span> <span data-ttu-id="77579-108">차례로 <xref:System.Data.OleDb.OleDbDataAdapter> 클래스를 상속 합니다 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드를도 추가 두 오버 로드를 정의 하 고 <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> 매개 변수로 ADO 레코드 집합 개체를 사용 하는.</span><span class="sxs-lookup"><span data-stu-id="77579-108">In turn, the <xref:System.Data.OleDb.OleDbDataAdapter> class inherits the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method, and also defines two additional overloads of <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> that take an ADO Recordset object as a parameter.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="77579-109">상속 하는 경우는 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스인 것이 좋습니다 다음 생성자를 구현 하는:</span><span class="sxs-lookup"><span data-stu-id="77579-109">When you inherit from the <see cref="T:System.Data.Common.DbDataAdapter" /> class, we recommend that you implement the following constructors:</span></span> 
 <list type="table"><listheader><term> <span data-ttu-id="77579-110">항목</span><span class="sxs-lookup"><span data-stu-id="77579-110">Item</span></span> 
 </term><description> <span data-ttu-id="77579-111">설명</span><span class="sxs-lookup"><span data-stu-id="77579-111">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="77579-112">*Prv*DataAdapter()</span><span class="sxs-lookup"><span data-stu-id="77579-112">*Prv*DataAdapter()</span></span> 
 </term><description> <span data-ttu-id="77579-113">새 인스턴스를 초기화 합니다 *Prv*DataAdapter 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-113">Initializes a new instance of the *Prv*DataAdapter class.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="77579-114">*Prv*DataAdapter (*Prv*명령 *selectCommand*)</span><span class="sxs-lookup"><span data-stu-id="77579-114">*Prv*DataAdapter(*Prv*Command *selectCommand*)</span></span> 
 </term><description> <span data-ttu-id="77579-115">새 인스턴스를 초기화 합니다 *Prv*지정 된 SQL SELECT 문 사용 하 여 DataAdapter 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-115">Initializes a new instance of the *Prv*DataAdapter class with the specified SQL SELECT statement.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="77579-116">*Prv*DataAdapter (문자열 *selectCommandText*, 문자열 *selectConnectionString*)</span><span class="sxs-lookup"><span data-stu-id="77579-116">*Prv*DataAdapter(string *selectCommandText*, string *selectConnectionString*)</span></span> 
 </term><description> <span data-ttu-id="77579-117">새 인스턴스를 초기화 합니다 *Prv*SQL SELECT 문 및 연결 문자열을 사용 하 여 DataAdapter 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-117">Initializes a new instance of the *Prv*DataAdapter class with an SQL SELECT statement and a connection string.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="77579-118">*Prv*DataAdapter (문자열 *selectCommandText*하십시오 *Prv*연결 *selectConnection*)</span><span class="sxs-lookup"><span data-stu-id="77579-118">*Prv*DataAdapter(string *selectCommandText*, *Prv*Connection *selectConnection*)</span></span> 
 </term><description> <span data-ttu-id="77579-119">새 인스턴스를 초기화 합니다 *Prv*SQL SELECT 문 사용 하 여 DataAdapter 클래스와 *Prv*연결 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-119">Initializes a new instance of the *Prv*DataAdapter class with an SQL SELECT statement and a *Prv*Connection object.</span></span>  
  
 </description></item></list>  

 <span data-ttu-id="77579-120">.NET Framework 데이터 공급자의 일관성 수준을 올릴 폼에서 상속 하는 클래스 이름을 지정 해야 *Prv*DataAdapter, 여기서 *Prv* 는 특정.NET의 모든 클래스에 지정 된 일관 된 접두사 Framework 데이터 공급자 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-120">To promote consistency among .NET Framework data providers, you should name the inheriting class in the form *Prv*DataAdapter, where *Prv* is the uniform prefix given to all classes in a specific .NET Framework data provider namespace.</span></span> <span data-ttu-id="77579-121">예를 들어, "Sql"은의 접두사는 <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> 클래스를 **System.Data.SqlClient** 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-121">For example, "Sql" is the prefix of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> class in the **System.Data.SqlClient** namespace.</span></span></para></block>
    <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-122">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-122">DbProviderFactories (ADO.NET)</span></span></related>
    <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-123">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-123">ADO.NET Overview</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="77579-124"><see langword="DataAdapter" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-124">Initializes a new instance of a <see langword="DataAdapter" /> class.</span></span></summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-125">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-125">ADO.NET Overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="77579-126">**DataAdapter** 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-126">Initializes a new instance of a **DataAdapter** class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-127">인스턴스를 만들면 <xref:System.Data.Common.DbDataAdapter>, 다음 읽기/쓰기 속성은 다음 초기 값으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-127">When you create an instance of <xref:System.Data.Common.DbDataAdapter>, the following read/write properties are set to the following initial values.</span></span>  
  
|<span data-ttu-id="77579-128">속성</span><span class="sxs-lookup"><span data-stu-id="77579-128">Properties</span></span>|<span data-ttu-id="77579-129">초기 값</span><span class="sxs-lookup"><span data-stu-id="77579-129">Initial value</span></span>|  
|----------------|-------------------|  
|<xref:System.Data.IDbDataAdapter.SelectCommand%2A>|<span data-ttu-id="77579-130">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-130">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.IDbDataAdapter.InsertCommand%2A>|<span data-ttu-id="77579-131">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-131">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>|<span data-ttu-id="77579-132">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-132">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>|<span data-ttu-id="77579-133">새 <xref:System.Data.IDbCommand>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-133">A new <xref:System.Data.IDbCommand>.</span></span>|  
|<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  
|<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|  
  
 <span data-ttu-id="77579-134">속성에 별도 호출을 통해 이러한 속성의 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-134">You can change the value of any of these properties through a separate call to the property.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-135">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-135">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-136">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-136">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="new System.Data.Common.DbDataAdapter : System.Data.Common.DbDataAdapter -&gt; System.Data.Common.DbDataAdapter" Usage="new System.Data.Common.DbDataAdapter adapter" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter"><span data-ttu-id="77579-137">A <see langword="DataAdapter" /> 개체를 새로 만드는 데 <see langword="DataAdapter" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-137">A <see langword="DataAdapter" /> object used to create the new <see langword="DataAdapter" />.</span></span></param>
        <summary><span data-ttu-id="77579-138">새 인스턴스를 초기화 한 <see langword="DataAdapter" /> 같은 형식의 기존 개체에서 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-138">Initializes a new instance of a <see langword="DataAdapter" /> class from an existing object of the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-139">이 오버 로드는 <xref:System.Data.Common.DbDataAdapter> 생성자 사용 하도록 설계 된.NET Framework 데이터 공급자가 복제 구현에서 사용 하 여 비슷한 생성자를 구현 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="77579-139">This overload of the <xref:System.Data.Common.DbDataAdapter> constructor is designed for use by a .NET Framework data provider when implementing a similar constructor for use in a clone implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-140">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-140">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-141">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-141">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddToBatch">
      <MemberSignature Language="C#" Value="protected virtual int AddToBatch (System.Data.IDbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 AddToBatch(class System.Data.IDbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function AddToBatch (command As IDbCommand) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int AddToBatch(System::Data::IDbCommand ^ command);" />
      <MemberSignature Language="F#" Value="abstract member AddToBatch : System.Data.IDbCommand -&gt; int&#xA;override this.AddToBatch : System.Data.IDbCommand -&gt; int" Usage="dbDataAdapter.AddToBatch command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.IDbCommand" />
      </Parameters>
      <Docs>
        <param name="command"><span data-ttu-id="77579-142"><see cref="T:System.Data.IDbCommand" /> 일괄 처리에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-142">The <see cref="T:System.Data.IDbCommand" /> to add to the batch.</span></span></param>
        <summary><span data-ttu-id="77579-143">추가 된 <see cref="T:System.Data.IDbCommand" /> 현재 일괄 처리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-143">Adds a <see cref="T:System.Data.IDbCommand" /> to the current batch.</span></span></summary>
        <returns><span data-ttu-id="77579-144">추가 하기 전에 일괄 처리에서 명령의 수를 <see cref="T:System.Data.IDbCommand" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-144">The number of commands in the batch before adding the <see cref="T:System.Data.IDbCommand" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-145"><xref:System.Data.Common.DbDataAdapter>,이 메서드는 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-145">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="77579-146">상속한 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-146">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="77579-147">어댑터는 일괄 처리를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-147">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-148">이 메서드는 보호 되 고.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-148">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
<span data-ttu-id="77579-149">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스 명령 일괄 처리에 추가할 수 있도록 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-149">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to add a command to a batch.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-150">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-150">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-151">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-151">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ClearBatch">
      <MemberSignature Language="C#" Value="protected virtual void ClearBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ClearBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearBatch ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearBatch();" />
      <MemberSignature Language="F#" Value="abstract member ClearBatch : unit -&gt; unit&#xA;override this.ClearBatch : unit -&gt; unit" Usage="dbDataAdapter.ClearBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="77579-152">모두 제거 <see cref="T:System.Data.IDbCommand" /> 일괄 처리에서는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-152">Removes all <see cref="T:System.Data.IDbCommand" /> objects from the batch.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-153"><xref:System.Data.Common.DbDataAdapter>,이 메서드는 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-153">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="77579-154">상속한 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-154">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="77579-155">어댑터는 일괄 처리를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-155">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-156">이 메서드는 보호 되 고.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-156">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
<span data-ttu-id="77579-157">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스 일괄 처리에서 모든 명령을 제거 하는 사용자를 허용 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-157">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to remove all commands from a batch.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-158">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-158">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-159">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-159">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatedEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatedEventArgs ^ CreateRowUpdatedEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="abstract member CreateRowUpdatedEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatedEventArgs&#xA;override this.CreateRowUpdatedEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatedEventArgs" Usage="dbDataAdapter.CreateRowUpdatedEvent (dataRow, command, statementType, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatedEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow"><span data-ttu-id="77579-160"><see cref="T:System.Data.DataRow" /> 데이터 소스를 업데이트 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-160">The <see cref="T:System.Data.DataRow" /> used to update the data source.</span></span></param>
        <param name="command"><span data-ttu-id="77579-161"><see cref="T:System.Data.IDbCommand" /> 중에 실행 된 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-161">The <see cref="T:System.Data.IDbCommand" /> executed during the <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</span></span></param>
        <param name="statementType"><span data-ttu-id="77579-162">명령은 업데이트 인지 삽입, 삭제 또는 SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-162">Whether the command is an UPDATE, INSERT, DELETE, or SELECT statement.</span></span></param>
        <param name="tableMapping"><span data-ttu-id="77579-163"><see cref="T:System.Data.Common.DataTableMapping" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-163">A <see cref="T:System.Data.Common.DataTableMapping" /> object.</span></span></param>
        <summary><span data-ttu-id="77579-164"><see cref="T:System.Data.Common.RowUpdatedEventArgs" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-164">Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> class.</span></span></summary>
        <returns><span data-ttu-id="77579-165"><see cref="T:System.Data.Common.RowUpdatedEventArgs" /> 클래스의 새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-165">A new instance of the <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> class.</span></span></returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-166">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-166">When overriding <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> method.</span></span></para></block>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-167">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-167">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatingEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatingEventArgs ^ CreateRowUpdatingEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="abstract member CreateRowUpdatingEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatingEventArgs&#xA;override this.CreateRowUpdatingEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatingEventArgs" Usage="dbDataAdapter.CreateRowUpdatingEvent (dataRow, command, statementType, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatingEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow"><span data-ttu-id="77579-168"><see cref="T:System.Data.DataRow" /> 데이터 소스를 업데이트 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-168">The <see cref="T:System.Data.DataRow" /> that updates the data source.</span></span></param>
        <param name="command"><span data-ttu-id="77579-169"><see cref="T:System.Data.IDbCommand" /> 동안 실행 하는 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-169">The <see cref="T:System.Data.IDbCommand" /> to execute during the <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</span></span></param>
        <param name="statementType"><span data-ttu-id="77579-170">명령은 업데이트 인지 삽입, 삭제 또는 SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-170">Whether the command is an UPDATE, INSERT, DELETE, or SELECT statement.</span></span></param>
        <param name="tableMapping"><span data-ttu-id="77579-171"><see cref="T:System.Data.Common.DataTableMapping" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-171">A <see cref="T:System.Data.Common.DataTableMapping" /> object.</span></span></param>
        <summary><span data-ttu-id="77579-172"><see cref="T:System.Data.Common.RowUpdatingEventArgs" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-172">Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> class.</span></span></summary>
        <returns><span data-ttu-id="77579-173"><see cref="T:System.Data.Common.RowUpdatingEventArgs" /> 클래스의 새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-173">A new instance of the <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> class.</span></span></returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-174">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-174">When overriding <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> method.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-175">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-175">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-176">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-176">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DefaultSourceTableName">
      <MemberSignature Language="C#" Value="public const string DefaultSourceTableName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultSourceTableName" />
      <MemberSignature Language="DocId" Value="F:System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultSourceTableName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ DefaultSourceTableName;" />
      <MemberSignature Language="F#" Value="val mutable DefaultSourceTableName : string" Usage="System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-177">사용 된 기본 이름을 <see cref="T:System.Data.Common.DataAdapter" /> 테이블 매핑에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-177">The default name used by the <see cref="T:System.Data.Common.DataAdapter" /> object for table mappings.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-178">"Table"가 사용 된 기본 이름을 <xref:System.Data.Common.DataAdapter> 테이블 매핑에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-178">"Table" is the default name used by the <xref:System.Data.Common.DataAdapter> object for table mappings.</span></span>  
  
 <span data-ttu-id="77579-179"><xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> 응용 프로그램에 사용할 테이블 매핑을 추가 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A>, 하지만 지정 하지 않습니다는 <xref:System.Data.DataTable> 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-179"><xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> is when an application adds a table mapping to be used with <xref:System.Data.Common.DbDataAdapter.Fill%2A>, but does not specify a <xref:System.Data.DataTable> name.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-180">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-180">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-181">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-181">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property DeleteCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ DeleteCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-182">데이터 집합에서 레코드를 삭제 하기 위한 명령을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-182">Gets or sets a command for deleting records from the data set.</span></span></summary>
        <value><span data-ttu-id="77579-183"><see cref="T:System.Data.IDbCommand" /> 중에 사용 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합의 삭제 된 행에 대 한 데이터 원본에서 레코드를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-183">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to delete records in the data source for deleted rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-184">하는 동안 <xref:System.Data.Common.DbDataAdapter.Update%2A>이면이 속성은 설정 되지 않으며 기본 키 정보에 있으면 합니다 <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.DeleteCommand%2A> 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-184">During <xref:System.Data.Common.DbDataAdapter.Update%2A>, if this property is not set and primary key information is present in the <xref:System.Data.DataSet>, the <xref:System.Data.IDbDataAdapter.DeleteCommand%2A> is automatically generated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-185">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-185">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-186">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-186">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-187">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-187">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-188">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-188">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="dbDataAdapter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="77579-189">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-189"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="77579-190"><see cref="T:System.Data.Common.DbDataAdapter" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-190">Releases the unmanaged resources used by the <see cref="T:System.Data.Common.DbDataAdapter" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-191">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-191">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-192">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-192">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteBatch">
      <MemberSignature Language="C#" Value="protected virtual int ExecuteBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 ExecuteBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ExecuteBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ExecuteBatch () As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int ExecuteBatch();" />
      <MemberSignature Language="F#" Value="abstract member ExecuteBatch : unit -&gt; int&#xA;override this.ExecuteBatch : unit -&gt; int" Usage="dbDataAdapter.ExecuteBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="77579-193">현재 일괄 처리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-193">Executes the current batch.</span></span></summary>
        <returns><span data-ttu-id="77579-194">일괄 처리의 마지막 명령에서 반환 하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-194">The return value from the last command in the batch.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-195"><xref:System.Data.Common.DbDataAdapter>,이 메서드는 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-195">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="77579-196">상속한 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-196">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-197">이 메서드는 보호 되 고.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-197">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
<span data-ttu-id="77579-198">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스 사용자가 일괄 처리를 실행 하도록 허용 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-198">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to execute a batch.</span></span> <span data-ttu-id="77579-199">이 메서드의 구현을 일괄 처리를 어댑터에 명령을 결합 되어 일괄 처리를 실행 하 고 일괄 처리의 반환 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-199">An implementation of this method combines the commands in the adapter into a batch, then executes the batch and returns the return value of the batch.</span></span></para></block>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-200">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-200">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-201">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-201">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-202">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-202">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fill">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="77579-203">채웁니다를 <see cref="T:System.Data.DataSet" /> 또는 <see cref="T:System.Data.DataTable" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-203">Fills a <see cref="T:System.Data.DataSet" /> or a <see cref="T:System.Data.DataTable" />.</span></span></summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-204">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-204">ADO.NET Overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public override int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet -&gt; int" Usage="dbDataAdapter.Fill dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Fill(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-205"><see cref="T:System.Data.DataSet" /> 레코드를 사용 하 여 입력 하 고 필요한 경우 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-205">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <summary><span data-ttu-id="77579-206">추가 하거나 행을 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-206">Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />.</span></span></summary>
        <returns><span data-ttu-id="77579-207">행 수가 성공적으로 추가 되거나 새로 고치는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-207">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="77579-208">이 행을 반환 하지 않는 문의 영향을 받는 행을 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-208">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-209"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드는 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-209">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="77579-210"><xref:System.Data.IDbConnection> 선택 명령과 사용 하 여 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-210">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-211">경우는 <xref:System.Data.IDbConnection> 닫은 후 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 은 호출,이 열어 데이터를 검색 하 고 닫으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-211">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data and then closed.</span></span> <span data-ttu-id="77579-212">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-212">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-213">오류 또는 예외가 발생 하는 경우 데이터 테이블을 채우는 동안 오류가 발생 하기 전에 추가 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-213">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="77579-214">작업의 나머지 부분을 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-214">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="77579-215">명령에서 모든 행을 반환 하지 않는, 테이블에 추가 됩니다는 <xref:System.Data.DataSet>, 예외가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-215">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, and no exception is raised.</span></span>  
  
 <span data-ttu-id="77579-216">경우는 <xref:System.Data.Common.DbDataAdapter> 개체를 채우는 동안 중복 된 열을 발견 한 <xref:System.Data.DataTable>, 패턴을 사용 하 고 후속 열의 이름을 생성 "*columnname*1","*columnname*2" " *columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-216">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-217">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-217">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="77579-218">지정 된 쿼리가 여러 결과 반환 하는 경우 결과 집합 쿼리를 반환 하는 각 행에 대해 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-218">When the query specified returns multiple results, the result set for each row returning query is placed in a separate table.</span></span> <span data-ttu-id="77579-219">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-219">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="77579-220">만들어지므로 테이블 행을 반환 하지 않는 쿼리에 대 한 select 쿼리 뒤에 삽입 쿼리를 처리 하는 경우, select 쿼리에 대해 생성 된 테이블 생성 되는 첫 번째 테이블 이기 때문에 "Table" 이라는 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-220">Because no table is created for a query that does not return rows, if you process an insert query followed by a select query, the table created for the select query is named "Table" because it is the first table created.</span></span> <span data-ttu-id="77579-221">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-221">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-222">채우는 SELECT 문을 사용 하는 경우는 <xref:System.Data.DataSet> 여러 결과가 반환 일괄 처리 SQL 문과 같은 결과 중 하나에 오류가 포함 되어 있는 경우 모든 후속 결과 건너뛰고에 추가 되지 않습니다는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-222">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as batch SQL statements, if one of the results contains an error, all subsequent results are skipped and are not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="77579-223">후속을 사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 내용 새로 고침에 대 한 호출을 <xref:System.Data.DataSet>, 두 조건이 충족 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-223">When using subsequent <xref:System.Data.Common.DbDataAdapter.Fill%2A> calls to refresh the contents of the <xref:System.Data.DataSet>, two conditions must be met:</span></span>  
  
1.  <span data-ttu-id="77579-224">SQL 문을 처음 채우는 데 사용 되는 일치 해야 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-224">The SQL statement should match the one initially used to populate the <xref:System.Data.DataSet>.</span></span>  
  
2.  <span data-ttu-id="77579-225">합니다 **키** 열 정보 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-225">The **Key** column information must be present.</span></span>  
  
 <span data-ttu-id="77579-226">기본 키 정보가 있는 경우 중복 행 조정 되며 한 번만 표시에 <xref:System.Data.DataTable> 에 해당 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-226">If primary key information is present, any duplicate rows are reconciled and only appear once in the <xref:System.Data.DataTable> that corresponds to the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-227">통해 기본 키 정보를 설정할 수 있습니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, 지정 하 여는 <xref:System.Data.DataTable.PrimaryKey%2A> 의 속성을 <xref:System.Data.DataTable>, 하거나 설정 하 여를 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 속성을 `AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="77579-227">Primary key information may be set either through <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, by specifying the <xref:System.Data.DataTable.PrimaryKey%2A> property of the <xref:System.Data.DataTable>, or by setting the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> property to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-228">`SelectCommand` 가 OUTER JOIN의 결과를 반환하면 `DataAdapter` 는 결과 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 <xref:System.Data.DataTable>값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-228">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-229">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-229">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="77579-230">자세한 내용은 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-230">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-231">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-231">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-232">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-232">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-233">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-233">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-234">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-234">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable -&gt; int" Usage="dbDataAdapter.Fill dataTable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="77579-235">이름을 합니다 <see cref="T:System.Data.DataTable" /> 테이블 매핑에 사용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-235">The name of the <see cref="T:System.Data.DataTable" /> to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="77579-236">추가 하거나 지정된 된 범위에서의 행을 새로 고칩니다 합니다 <see cref="T:System.Data.DataSet" /> 사용 하 여 데이터 원본에 맞게는 <see cref="T:System.Data.DataTable" /> 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-236">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataTable" /> name.</span></span></summary>
        <returns><span data-ttu-id="77579-237">행 수가 성공적으로 추가 되거나 새로 고치는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-237">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="77579-238">이 행을 반환 하지 않는 문의 영향을 받는 행을 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-238">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-239">합니다 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문을 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-239">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="77579-240">SELECT 문과 사용 하 여 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-240">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-241">전에 연결이 닫히면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-241">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-242">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-242">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-243"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업이 대상에 행 추가 <xref:System.Data.DataTable> 개체를 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-243">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation then adds the rows to destination <xref:System.Data.DataTable> objects in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> objects if they do not already exist.</span></span> <span data-ttu-id="77579-244">만들면 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-244">When creating <xref:System.Data.DataTable> objects, the <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="77579-245">그러나 경우 합니다 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="77579-245">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="77579-246">경우는 <xref:System.Data.Common.DbDataAdapter> 에서 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-246">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-247">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-247">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-248">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet> 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-248">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span>  
  
 <span data-ttu-id="77579-249">오버 로드 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 를 사용 하는 `DataTable` 대로 매개 변수 에서만 첫 번째 결과 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="77579-249">The overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataTable` as a parameter only obtains the first result.</span></span> <span data-ttu-id="77579-250">오버 로드를 사용 하 여 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 를 사용 하는 `DataSet` 여러 결과를 얻으려면 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-250">Use an overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataSet` as a parameter to obtain multiple results.</span></span>  
  
 <span data-ttu-id="77579-251"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-251">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-252">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-252">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="77579-253">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-253">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
 dataset.Tables.Add("AAA");  
 adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
    adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="77579-254">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-254">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-255">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-255">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-256">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-256">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-257">사용할 수는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드를 여러 번에 동일한 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-257">You can use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-258">기본 키가 있는 경우 들어오는 행이 이미 존재 하는 일치 하는 행과 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-258">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="77579-259">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-259">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-260">`SelectCommand` 가 OUTER JOIN의 결과를 반환하면 `DataAdapter` 는 결과 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 <xref:System.Data.DataTable>값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-260">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-261">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-261">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="77579-262">자세한 내용은 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-262">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-263">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 고 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> .NET Framework 데이터 공급자는 결과 대해서만 첫 번째 스키마 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-263">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.Fill%2A> and <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for a .NET Framework data provider retrieves schema information for only the first result.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-264">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-264">The source table is invalid.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-265">이 오버 로드는 <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> 메서드는 보호 되므로.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-265">This overload of the <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-266">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-266">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-267">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-267">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * string -&gt; int" Usage="dbDataAdapter.Fill (dataSet, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-268"><see cref="T:System.Data.DataSet" /> 레코드를 사용 하 여 입력 하 고 필요한 경우 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-268">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="srcTable"><span data-ttu-id="77579-269">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-269">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="77579-270">추가 하거나 행을 새로 고칩니다 합니다 <see cref="T:System.Data.DataSet" /> 사용 하 여 데이터 원본에 맞게 합니다 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.Data.DataTable" /> 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-270">Adds or refreshes rows in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and <see cref="T:System.Data.DataTable" /> names.</span></span></summary>
        <returns><span data-ttu-id="77579-271">행 수가 성공적으로 추가 되거나 새로 고치는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-271">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="77579-272">이 행을 반환 하지 않는 문의 영향을 받는 행을 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-272">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-273"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드는 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-273">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="77579-274"><xref:System.Data.IDbConnection> 선택 명령과 사용 하 여 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-274">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-275">경우는 <xref:System.Data.IDbConnection> 닫은 후 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-275">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-276">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-276">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-277">명령에서 모든 행을 반환 하지 않는, 테이블에 추가 됩니다는 <xref:System.Data.DataSet>, 예외가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-277">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, and no exception is raised.</span></span>  
  
 <span data-ttu-id="77579-278">경우는 <xref:System.Data.Common.DbDataAdapter> 개체를 채우는 동안 중복 된 열을 발견을 <xref:System.Data.DataTable>, 패턴 "columnname1", "columnname2", "columnname3", 및 등을 사용 하 여 후속 열에 대 한 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-278">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "columnname1", "columnname2", "columnname3", and so on.</span></span> <span data-ttu-id="77579-279">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-279">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="77579-280">지정 된 쿼리가 여러 결과 반환 하는 경우 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-280">When the query specified returns multiple results, each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-281">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-281">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="77579-282">테이블이 만들어지면 행을 반환 하지 않는 쿼리에 대 한 select 쿼리 뒤에 삽입 쿼리를 처리 하는 경우 이후 select 쿼리에 대해 생성 된 테이블은 수 "Table" 이라는, 생성 된 첫 번째 테이블 이기 때문에.</span><span class="sxs-lookup"><span data-stu-id="77579-282">Since no table is created for a query that does not return rows, if you were to process an insert query followed by a select query, the table created for the select query would be named "Table", because it is the first table created.</span></span> <span data-ttu-id="77579-283">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-283">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-284"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-284">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-285">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-285">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="77579-286">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-286">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="77579-287">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-287">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-288">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-288">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-289">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-289">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-290">오류 또는 예외가 발생 하는 경우 데이터 테이블을 채우는 동안 오류가 발생 하기 전에 추가 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-290">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="77579-291">작업의 나머지 부분을 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-291">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="77579-292">채우는 SELECT 문을 사용 하는 경우는 <xref:System.Data.DataSet> 일괄 처리 SQL 문 다음에 유의 같은 여러 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-292">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as a batch SQL statement, be aware of the following:</span></span>  
  
-   <span data-ttu-id="77579-293">모든 후속 결과 생략 되 고 추가할 없습니다 오류가 있으면 결과 중 하나는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-293">If one of the results contains an error, all subsequent results are skipped and not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="77579-294">후속을 사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 내용 새로 고침에 대 한 호출을 <xref:System.Data.DataSet>, 두 조건이 충족 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-294">When using subsequent <xref:System.Data.Common.DbDataAdapter.Fill%2A> calls to refresh the contents of the <xref:System.Data.DataSet>, two conditions must be met:</span></span>  
  
1.  <span data-ttu-id="77579-295">SQL 문을 처음 채우는 데 사용 되는 일치 해야 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-295">The SQL statement should match the one initially used to populate the <xref:System.Data.DataSet>.</span></span>  
  
2.  <span data-ttu-id="77579-296">합니다 **키** 열 정보 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-296">The **Key** column information must be present.</span></span> <span data-ttu-id="77579-297">기본 키 정보가 있는 경우 중복 행 조정 되며 한 번만 표시에 <xref:System.Data.DataTable> 에 해당 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-297">If primary key information is present, any duplicate rows are reconciled and only appear once in the <xref:System.Data.DataTable> that corresponds to the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-298">통해 기본 키 정보를 설정할 수 있습니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, 지정 하 여는 <xref:System.Data.DataTable.PrimaryKey%2A> 의 속성을 <xref:System.Data.DataTable>, 하거나 설정 하 여를 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 속성을 `AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="77579-298">Primary key information may be set either through <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, by specifying the <xref:System.Data.DataTable.PrimaryKey%2A> property of the <xref:System.Data.DataTable>, or by setting the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> property to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-299">`SelectCommand` 가 OUTER JOIN의 결과를 반환하면 `DataAdapter` 는 결과 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 <xref:System.Data.DataTable>값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-299">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-300">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-300">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="77579-301">자세한 내용은 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-301">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-302">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-302">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-303">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-303">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-304">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter>를 입력 하는 <xref:System.Data.DataSet> categories 테이블에서 행을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-304">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with rows from the categories table.</span></span> <span data-ttu-id="77579-305">이 예에서는 만들었다고 가정를 <xref:System.Data.OleDb.OleDbDataAdapter> 및 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-305">This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="77579-306">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-306">The source table is invalid.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-307">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-307">When overriding <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> method.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-308">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-308">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-309">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-309">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDataReader dataReader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDataReader dataReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDataReader ^ dataReader);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable * System.Data.IDataReader -&gt; int" Usage="dbDataAdapter.Fill (dataTable, dataReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="dataTable">To be added.</param>
        <param name="dataReader">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataTable, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="77579-310"><see cref="T:System.Data.DataTable" /> 레코드를 사용 하 여 입력 하 고 필요한 경우 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-310">A <see cref="T:System.Data.DataTable" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="command"><span data-ttu-id="77579-311">데이터 원본에서 행을 검색 하는 데 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-311">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="behavior"><span data-ttu-id="77579-312"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-312">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="77579-313">추가 하거나 행을 <see cref="T:System.Data.DataTable" /> 지정 된 데이터 소스에 맞게 <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.IDbCommand" /> 및 <see cref="T:System.Data.CommandBehavior" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-313">Adds or refreshes rows in a <see cref="T:System.Data.DataTable" /> to match those in the data source using the specified <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.IDbCommand" /> and <see cref="T:System.Data.CommandBehavior" />.</span></span></summary>
        <returns><span data-ttu-id="77579-314">행 수가 성공적으로 추가 되거나 새로 고치는 <see cref="T:System.Data.DataTable" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-314">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />.</span></span> <span data-ttu-id="77579-315">이 행을 반환 하지 않는 문의 영향을 받는 행을 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-315">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-316">합니다 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문을 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-316">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="77579-317">SELECT 문과 사용 하 여 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-317">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-318">연결 하기 전에 닫히면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출 하기를 열어 데이터를 검색 하 고 닫으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-318">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data and then closed.</span></span> <span data-ttu-id="77579-319">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-319">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-320"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 지정된 된 대상에 행을 추가 하는 작업이 <xref:System.Data.DataTable> 개체를 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-320">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation then adds the rows to the specified destination <xref:System.Data.DataTable> object in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> object if it does not already exist.</span></span> <span data-ttu-id="77579-321">만들 때를 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-321">When creating a <xref:System.Data.DataTable> object, the <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="77579-322">그러나 경우 합니다 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="77579-322">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="77579-323">경우는 <xref:System.Data.Common.DbDataAdapter> 개체를 채우는 동안 중복 된 열을 발생을 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2 ","*columnname*3 "등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-323">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-324">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-324">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="77579-325">오버 로드 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 를 사용 하는 `DataTable` 대로 매개 변수 에서만 첫 번째 결과 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="77579-325">The overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataTable` as a parameter only obtains the first result.</span></span> <span data-ttu-id="77579-326">오버 로드를 사용 하 여 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 를 사용 하는 `DataSet` 여러 결과를 얻으려면 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-326">Use an overload of <xref:System.Data.Common.DbDataAdapter.Fill%2A> that takes `DataSet` as a parameter to obtain multiple results.</span></span>  
  
 <span data-ttu-id="77579-327">사용할 수는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드를 여러 번에 동일한 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-327">You can use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-328">기본 키가 있는 경우 들어오는 행이 이미 존재 하는 일치 하는 행과 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-328">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="77579-329">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-329">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-330">`SelectCommand` 가 OUTER JOIN의 결과를 반환하면 `DataAdapter` 는 결과 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 <xref:System.Data.DataTable>값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-330">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-331">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-331">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="77579-332">자세한 내용은 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-332">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-333">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-333">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-334">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-334">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-335">이 오버 로드는 <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> 메서드는 보호 되므로.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-335">This overload of the <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-336">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-336">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-337">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-337">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (int startRecord, int maxRecords, params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(int32 startRecord, int32 maxRecords, class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Fill (startRecord As Integer, maxRecords As Integer, ParamArray dataTables As DataTable()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(int startRecord, int maxRecords, ... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="override this.Fill : int * int * System.Data.DataTable[] -&gt; int" Usage="dbDataAdapter.Fill (startRecord, maxRecords, dataTables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startRecord"><span data-ttu-id="77579-338">시작 하려면 0부터 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-338">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="77579-339">검색할 레코드의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-339">The maximum number of records to retrieve.</span></span></param>
        <param name="dataTables"><span data-ttu-id="77579-340"><see cref="T:System.Data.DataTable" /> 데이터 소스에서 채울 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-340">The <see cref="T:System.Data.DataTable" /> objects to fill from the data source.</span></span></param>
        <summary><span data-ttu-id="77579-341">추가 하거나 행을 새로 고칩니다는 <see cref="T:System.Data.DataTable" /> 데이터 소스의 지정된 된 레코드에서 시작 하 고 지정 된 최대 레코드 수가 최대 검색 일치 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-341">Adds or refreshes rows in a <see cref="T:System.Data.DataTable" /> to match those in the data source starting at the specified record and retrieving up to the specified maximum number of records.</span></span></summary>
        <returns><span data-ttu-id="77579-342">행 수가 성공적으로 추가 되거나 새로 고치는 <see cref="T:System.Data.DataTable" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-342">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />.</span></span> <span data-ttu-id="77579-343">이 값에서 행을 반환 하지 않는 문의 영향을 받는 행을 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-343">This value does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-344">합니다 <xref:System.Data.Common.DataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문을 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-344">The <xref:System.Data.Common.DataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="77579-345">SELECT 문과 사용 하 여 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-345">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-346">연결 하기 전에 닫히면 <xref:System.Data.Common.DataAdapter.Fill%2A> 는 데이터를 검색 하는 것이 열려 있고 닫혀 다음 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-346">If the connection is closed before <xref:System.Data.Common.DataAdapter.Fill%2A> is called, it is opened to retrieve data, and then it is closed.</span></span> <span data-ttu-id="77579-347">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-347">If the connection is open before <xref:System.Data.Common.DataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-348"><xref:System.Data.Common.DataAdapter.Fill%2A> 작업이 대상에 행 추가 <xref:System.Data.DataTable> 개체를 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-348">The <xref:System.Data.Common.DataAdapter.Fill%2A> operation then adds the rows to destination <xref:System.Data.DataTable> objects in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> objects if they do not already exist.</span></span> <span data-ttu-id="77579-349">만들면 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-349">When creating <xref:System.Data.DataTable> objects, the <xref:System.Data.Common.DataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="77579-350">그러나 경우 합니다 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="77579-350">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="77579-351">`SelectCommand` 가 OUTER JOIN의 결과를 반환하면 `DataAdapter` 는 결과 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 <xref:System.Data.DataTable>값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-351">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-352">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-352">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="77579-353">자세한 내용은 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-353">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="77579-354">데이터 어댑터를 채우는 동안 중복 된 열을 발견 하는 경우는 <xref:System.Data.DataTable>, 패턴 "columnname1", "columnname2", "columnname3", 및 등을 사용 하 여 후속 열에 대 한 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-354">If the data adapter encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "columnname1", "columnname2", "columnname3", and so on.</span></span> <span data-ttu-id="77579-355">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-355">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-356">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet>, 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-356">When multiple result sets are added to the <xref:System.Data.DataSet>, each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-357">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-357">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="77579-358">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-358">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-359">채우는 SELECT 문을 사용 하는 경우는 <xref:System.Data.DataSet> 여러 결과 반환을 일괄 처리 SQL 문과 같은 결과 중 하나에 오류가 포함 되어 있는 경우 모든 후속 결과 생략 되 고에 추가 되지 않습니다는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-359">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as a batch SQL statements, if one of the results contains an error, all subsequent results are skipped and not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="77579-360">사용할 수는 <xref:System.Data.Common.DataAdapter.Fill%2A> 메서드를 여러 번에 동일한 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-360">You can use the <xref:System.Data.Common.DataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-361">기본 키가 있는 경우 들어오는 행이 이미 존재 하는 일치 하는 행과 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-361">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="77579-362">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-362">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-363">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-363">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-364">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-364">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-365">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-365">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-366">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-366">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * int * int * string -&gt; int" Usage="dbDataAdapter.Fill (dataSet, startRecord, maxRecords, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-367"><see cref="T:System.Data.DataSet" /> 레코드를 사용 하 여 입력 하 고 필요한 경우 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-367">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="startRecord"><span data-ttu-id="77579-368">시작 하려면 0부터 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-368">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="77579-369">검색할 레코드의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-369">The maximum number of records to retrieve.</span></span></param>
        <param name="srcTable"><span data-ttu-id="77579-370">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-370">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="77579-371">추가 하거나 지정된 된 범위에서의 행을 새로 고칩니다 합니다 <see cref="T:System.Data.DataSet" /> 사용 하 여 데이터 원본에 맞게 합니다 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.Data.DataTable" /> 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-371">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and <see cref="T:System.Data.DataTable" /> names.</span></span></summary>
        <returns><span data-ttu-id="77579-372">행 수가 성공적으로 추가 되거나 새로 고치는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-372">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="77579-373">이 행을 반환 하지 않는 문의 영향을 받는 행을 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-373">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-374">`maxRecords` 값이 0 시작 레코드 뒤에서 발견 되는 모든 레코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="77579-374">A `maxRecords` value of 0 gets all records found after the start record.</span></span> <span data-ttu-id="77579-375">경우 `maxRecords` 보다 크면 나머지 행 수가 나머지 행이 반환 하 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-375">If `maxRecords` is greater than the number of remaining rows, only the remaining rows are returned, and no error is issued.</span></span>  
  
 <span data-ttu-id="77579-376">해당 select 명령이 여러 결과 반환 하는 문의 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 에 적용 됩니다 `maxRecords` 첫 번째 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-376">If the corresponding select command is a statement returning multiple results, <xref:System.Data.Common.DbDataAdapter.Fill%2A> only applies `maxRecords` to the first result.</span></span>  
  
 <span data-ttu-id="77579-377"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드는 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-377">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="77579-378"><xref:System.Data.IDbConnection> SELECT 문과 사용 하 여 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-378">The <xref:System.Data.IDbConnection> object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-379">경우는 <xref:System.Data.IDbConnection> 닫은 후 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 은 호출,이 열어 데이터를 검색 하 고 닫으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-379">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data and then closed.</span></span> <span data-ttu-id="77579-380">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-380">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-381">명령에서 모든 행을 반환 하지 않는, 테이블에 추가 됩니다는 <xref:System.Data.DataSet>, 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-381">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, but no exception is raised.</span></span>  
  
 <span data-ttu-id="77579-382">경우는 <xref:System.Data.Common.DbDataAdapter> 개체를 채우는 동안 중복 된 열을 발생을 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2 ","*columnname*3 "등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-382">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-383">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-383">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="77579-384">지정 된 쿼리가 여러 결과 반환 하는 경우 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-384">When the query specified returns multiple results, each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-385">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-385">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="77579-386">만들어지므로 테이블 행을 반환 하지 않는 쿼리에 대 한 select 쿼리 뒤에 삽입 쿼리를 처리 하는 경우, 생성 된 첫 번째 테이블 이기 때문에 선택 쿼리에 대해 생성 된 테이블이 "Table"을 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-386">Because no table is created for a query that does not return rows, if you process an insert query followed by a select query, the table created for the select query is named "Table", because it is the first table created.</span></span> <span data-ttu-id="77579-387">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-387">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-388"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-388">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-389">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-389">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="77579-390">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-390">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="77579-391">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-391">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-392">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-392">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-393">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-393">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-394">오류 또는 예외가 발생 하는 경우 데이터 테이블을 채우는 동안 오류가 발생 하기 전에 추가 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-394">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="77579-395">작업의 나머지 부분을 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-395">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="77579-396">채우는 SELECT 문을 사용 하는 경우는 <xref:System.Data.DataSet> 일괄 처리 SQL 문과 같은 여러 결과 반환 합니다. 다음에 유의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-396">When the SELECT statement used to populate the <xref:System.Data.DataSet> returns multiple results, such as batch SQL statements, be aware of the following:</span></span>  
  
-   <span data-ttu-id="77579-397">SQL 문 일괄 처리에서 여러 결과 처리할 때 `maxRecords` 첫 번째 결과에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-397">When processing multiple results from a batch SQL statement, `maxRecords` only applies to the first result.</span></span> <span data-ttu-id="77579-398">장으로 구성 된 결과 (.NET Framework Data Provider for OLE DB만)이 포함 된 행에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-398">The same is true for rows containing chaptered results (.NET Framework Data Provider for OLE DB only).</span></span> <span data-ttu-id="77579-399">최상위 결과 따라 제한 됩니다 `maxRecords`, 하지만 모든 자식 행이 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-399">The top level result is limited by `maxRecords`, but all child rows are added.</span></span>  
  
-   <span data-ttu-id="77579-400">모든 후속 결과 생략 되 고 추가할 없습니다 오류가 있으면 결과 중 하나는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-400">If one of the results contains an error, all subsequent results are skipped and not added to the <xref:System.Data.DataSet>.</span></span>  
  
 <span data-ttu-id="77579-401">후속을 사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 내용 새로 고침에 대 한 호출을 <xref:System.Data.DataSet>, 두 조건이 충족 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-401">When using subsequent <xref:System.Data.Common.DbDataAdapter.Fill%2A> calls to refresh the contents of the <xref:System.Data.DataSet>, two conditions must be met:</span></span>  
  
1.  <span data-ttu-id="77579-402">SQL 문을 처음 채우는 데 사용 되는 일치 해야 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-402">The SQL statement should match the one initially used to populate the <xref:System.Data.DataSet>.</span></span>  
  
2.  <span data-ttu-id="77579-403">합니다 **키** 열 정보 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-403">The **Key** column information must be present.</span></span>  
  
 <span data-ttu-id="77579-404">기본 키 정보가 있는 경우 중복 행 조정 되며 한 번만 표시에 <xref:System.Data.DataTable> 에 해당 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-404">If primary key information is present, any duplicate rows will be reconciled and only appear once in the <xref:System.Data.DataTable> that corresponds to the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-405">통해 기본 키 정보를 설정할 수 있습니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, 지정 하 여는 <xref:System.Data.DataTable.PrimaryKey%2A> 의 속성을 <xref:System.Data.DataTable>, 하거나 설정 하 여를 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 속성을 `AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="77579-405">Primary key information may be set either through <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, by specifying the <xref:System.Data.DataTable.PrimaryKey%2A> property of the <xref:System.Data.DataTable>, or by setting the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> property to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-406">`SelectCommand` 가 OUTER JOIN의 결과를 반환하면 `DataAdapter` 는 결과 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 <xref:System.Data.DataTable>값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-406">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-407">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-407">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="77579-408">자세한 내용은 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-408">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-409">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-409">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-410">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-410">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-411">합니다 `DataSet` 나타난 레코드 개수 보다 많은 포함 되지 것입니다 `maxRecords`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-411">The `DataSet` will not contain more than the number of records indicated by `maxRecords`.</span></span> <span data-ttu-id="77579-412">하지만, 쿼리에서 생성 한 전체 결과 집합은 여전히 서버에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-412">However, the entire result set generated by the query is still returned from the server.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-413">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter>를 입력 하는 <xref:System.Data.DataSet> 에서 행을 10부터 15 개의 행을 사용 하 여는 **범주** 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-413">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with 15 rows, beginning at row 10, from the **Categories** table.</span></span> <span data-ttu-id="77579-414">이 예에서는 만들었다고 가정를 <xref:System.Data.OleDb.OleDbDataAdapter> 및 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-414">This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="77579-415"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-415">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-416">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-416">The source table is invalid.</span></span>  
  
<span data-ttu-id="77579-417">또는</span><span class="sxs-lookup"><span data-stu-id="77579-417">-or-</span></span> 
<span data-ttu-id="77579-418">연결이 잘못 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-418">The connection is invalid.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="77579-419">연결을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-419">The connection could not be found.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="77579-420"><paramref name="startRecord" /> 매개 변수가 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-420">The <paramref name="startRecord" /> parameter is less than 0.</span></span>  
  
<span data-ttu-id="77579-421">또는</span><span class="sxs-lookup"><span data-stu-id="77579-421">-or-</span></span> 
<span data-ttu-id="77579-422"><paramref name="maxRecords" /> 매개 변수가 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-422">The <paramref name="maxRecords" /> parameter is less than 0.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-423">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-423">When overriding <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> method.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-424">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-424">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-425">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-425">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, string srcTable, System.Data.IDataReader dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, string srcTable, class System.Data.IDataReader dataReader, int32 startRecord, int32 maxRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String,System.Data.IDataReader,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable, System::Data::IDataReader ^ dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * string * System.Data.IDataReader * int * int -&gt; int" Usage="dbDataAdapter.Fill (dataSet, srcTable, dataReader, startRecord, maxRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dataSet">To be added.</param>
        <param name="srcTable">To be added.</param>
        <param name="dataReader">To be added.</param>
        <param name="startRecord">To be added.</param>
        <param name="maxRecords">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable[] dataTables, int32 startRecord, int32 maxRecords, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Fill (dataTables As DataTable(), startRecord As Integer, maxRecords As Integer, command As IDbCommand, behavior As CommandBehavior) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables, int startRecord, int maxRecords, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable[] * int * int * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataTables, startRecord, maxRecords, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTables"><span data-ttu-id="77579-426"><see cref="T:System.Data.DataTable" /> 데이터 소스에서 채울 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-426">The <see cref="T:System.Data.DataTable" /> objects to fill from the data source.</span></span></param>
        <param name="startRecord"><span data-ttu-id="77579-427">시작 하려면 0부터 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-427">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="77579-428">검색할 레코드의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-428">The maximum number of records to retrieve.</span></span></param>
        <param name="command"><span data-ttu-id="77579-429">합니다 <see cref="T:System.Data.IDbCommand" /> 채우기 위해 실행 되는 <see cref="T:System.Data.DataTable" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-429">The <see cref="T:System.Data.IDbCommand" /> executed to fill the <see cref="T:System.Data.DataTable" /> objects.</span></span></param>
        <param name="behavior"><span data-ttu-id="77579-430"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-430">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="77579-431">추가 하거나 지정된 된 범위에서의 행을 새로 고칩니다 합니다 <see cref="T:System.Data.DataSet" /> 사용 하 여 데이터 원본에 맞게 합니다 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.Data.DataTable" /> 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-431">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and <see cref="T:System.Data.DataTable" /> names.</span></span></summary>
        <returns><span data-ttu-id="77579-432">행의 수에 추가 하거나 데이터 테이블에서 새로 고쳐집니다.</span><span class="sxs-lookup"><span data-stu-id="77579-432">The number of rows added to or refreshed in the data tables.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-433">`maxRecords` 값이 0 시작 레코드 뒤에서 발견 되는 모든 레코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="77579-433">A `maxRecords` value of 0 gets all records found after the start record.</span></span> <span data-ttu-id="77579-434">경우 `maxRecords` 보다 크면 나머지 행 수가 없으면 오류가 발생 하 고 나머지 행이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-434">If `maxRecords` is greater than the number of remaining rows, only the remaining rows are returned and no error is issued.</span></span>  
  
 <span data-ttu-id="77579-435"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드는 SELECT 문을 사용 하 여 데이터 원본에서 데이터를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-435">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves the data from the data source using a SELECT statement.</span></span> <span data-ttu-id="77579-436"><xref:System.Data.IDbConnection> SELECT 문과 사용 하 여 연결 된 개체는 유효 해야 합니다. 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-436">The <xref:System.Data.IDbConnection> object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-437">경우는 <xref:System.Data.IDbConnection> 닫은 후 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-437">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-438">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-438">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-439">명령에서 모든 행을 반환 하지 않는, 테이블에 추가 됩니다는 <xref:System.Data.DataSet>, 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-439">If a command does not return any rows, no tables are added to the <xref:System.Data.DataSet>, but no exception is raised.</span></span>  
  
 <span data-ttu-id="77579-440">경우는 <xref:System.Data.Common.DbDataAdapter> 개체를 채우는 동안 중복 된 열을 발생을 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2 ","*columnname*3 "등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-440">If the <xref:System.Data.Common.DbDataAdapter> object encounters duplicate columns while populating a <xref:System.Data.DataTable>, it will generate names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-441">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-441">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span>  
  
 <span data-ttu-id="77579-442">지정 된 쿼리가 여러 결과 반환 하는 경우 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-442">When the query specified returns multiple results, each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-443">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-443">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="77579-444">테이블이 만들어지면 행을 반환 하지 않는 쿼리에 대 한 select 쿼리 뒤에 삽입 쿼리를 처리 하는 경우 이후 select 쿼리에 대해 생성 된 테이블은 수 "Table" 이라는, 생성 된 첫 번째 테이블 이기 때문에.</span><span class="sxs-lookup"><span data-stu-id="77579-444">Since no table is created for a query that does not return rows, if you were to process an insert query followed by a select query, the table created for the select query would be named "Table", because it is the first table created.</span></span> <span data-ttu-id="77579-445">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-445">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-446"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-446">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-447">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-447">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="77579-448">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-448">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="77579-449">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-449">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-450">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-450">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-451">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-451">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-452">오류 또는 예외가 발생 하는 경우 데이터 테이블을 채우는 동안 오류가 발생 하기 전에 추가 행은 데이터 테이블에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-452">If an error or an exception is encountered while populating the data tables, rows added prior to the occurrence of the error remain in the data tables.</span></span> <span data-ttu-id="77579-453">작업의 나머지 부분을 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-453">The remainder of the operation is aborted.</span></span>  
  
 <span data-ttu-id="77579-454">채우는 SELECT 문을 사용 하는 경우는 <xref:System.Data.DataTable> 개체 일괄 처리 SQL 문 다음에 유의 같은 여러 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-454">When the SELECT statement used to populate the <xref:System.Data.DataTable> objects returns multiple results, such as a batch SQL statement, be aware of the following:</span></span>  
  
-   <span data-ttu-id="77579-455">SQL 문 일괄 처리에서 여러 결과 처리할 때 `maxRecords` 첫 번째 결과에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-455">When processing multiple results from a batch SQL statement, `maxRecords` only applies to the first result.</span></span> <span data-ttu-id="77579-456">장으로 구성 된 결과 (.NET Framework Data Provider for OLE DB만)이 포함 된 행에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-456">The same is true for rows containing chaptered results (.NET Framework Data Provider for OLE DB only).</span></span> <span data-ttu-id="77579-457">최상위 결과 따라 제한 됩니다 `maxRecords`, 하지만 모든 자식 행이 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-457">The top level result is limited by `maxRecords`, but all child rows are added.</span></span>  
  
-   <span data-ttu-id="77579-458">결과 중 하나에 오류가 포함 되어, 모든 후속 결과 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="77579-458">If one of the results contains an error, all subsequent results are skipped.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-459">합니다 `DataSet` 나타난 레코드 개수 보다 많은 포함 되지 것입니다 `maxRecords`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-459">The `DataSet` will not contain more than the number of records indicated by `maxRecords`.</span></span> <span data-ttu-id="77579-460">그러나 쿼리에 의해 생성 된 전체 결과 집합은 여전히 서버에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-460">However, the entire resultset generated by the query is still returned from the server.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="77579-461"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-461">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-462">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-462">The source table is invalid.</span></span>  
  
<span data-ttu-id="77579-463">또는</span><span class="sxs-lookup"><span data-stu-id="77579-463">-or-</span></span> 
<span data-ttu-id="77579-464">연결이 잘못 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-464">The connection is invalid.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="77579-465">연결을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-465">The connection could not be found.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="77579-466"><paramref name="startRecord" /> 매개 변수가 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-466">The <paramref name="startRecord" /> parameter is less than 0.</span></span>  
  
<span data-ttu-id="77579-467">또는</span><span class="sxs-lookup"><span data-stu-id="77579-467">-or-</span></span> 
<span data-ttu-id="77579-468"><paramref name="maxRecords" /> 매개 변수가 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-468">The <paramref name="maxRecords" /> parameter is less than 0.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-469">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-469">When overriding <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> method.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-470">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-470">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-471">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-471">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * int * int * string * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataSet, startRecord, maxRecords, srcTable, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-472"><see cref="T:System.Data.DataSet" /> 레코드를 사용 하 여 입력 하 고 필요한 경우 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-472">A <see cref="T:System.Data.DataSet" /> to fill with records and, if necessary, schema.</span></span></param>
        <param name="startRecord"><span data-ttu-id="77579-473">시작 하려면 0부터 시작 레코드 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-473">The zero-based record number to start with.</span></span></param>
        <param name="maxRecords"><span data-ttu-id="77579-474">검색할 레코드의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-474">The maximum number of records to retrieve.</span></span></param>
        <param name="srcTable"><span data-ttu-id="77579-475">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-475">The name of the source table to use for table mapping.</span></span></param>
        <param name="command"><span data-ttu-id="77579-476">데이터 원본에서 행을 검색 하는 데 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-476">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="behavior"><span data-ttu-id="77579-477"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-477">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="77579-478">추가 하거나 지정된 된 범위에서의 행을 새로 고칩니다 합니다 <see cref="T:System.Data.DataSet" /> 사용 하 여 데이터 원본에 맞게는 <see cref="T:System.Data.DataSet" /> 및 원본 테이블 이름, 명령 문자열과 명령 동작 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-478">Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" /> to match those in the data source using the <see cref="T:System.Data.DataSet" /> and source table names, command string, and command behavior.</span></span></summary>
        <returns><span data-ttu-id="77579-479">행 수가 성공적으로 추가 되거나 새로 고치는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-479">The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />.</span></span> <span data-ttu-id="77579-480">이 행을 반환 하지 않는 문의 영향을 받는 행을 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-480">This does not include rows affected by statements that do not return rows.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-481">합니다 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 연결 된 지정 된 SELECT 문을 사용 하 여 데이터 원본에서 행을 검색 하는 메서드 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-481">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method retrieves rows from the data source using the SELECT statement specified by an associated <xref:System.Data.IDbDataAdapter.SelectCommand%2A> property.</span></span> <span data-ttu-id="77579-482">SELECT 문과 사용 하 여 연결 된 연결 개체는 유효 해야 합니다. 하지만 열려 있이 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-482">The connection object associated with the SELECT statement must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-483">전에 연결이 닫히면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-483">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-484">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-484">If the connection is open before <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-485"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업이 대상에 행 추가 <xref:System.Data.DataTable> 개체를 <xref:System.Data.DataSet>만들기는 <xref:System.Data.DataTable> 경우 이미 없는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-485">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation then adds the rows to destination <xref:System.Data.DataTable> objects in the <xref:System.Data.DataSet>, creating the <xref:System.Data.DataTable> objects if they do not already exist.</span></span> <span data-ttu-id="77579-486">만들면 <xref:System.Data.DataTable> 개체는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 작업은 일반적으로 열 이름 메타 데이터만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-486">When creating <xref:System.Data.DataTable> objects, the <xref:System.Data.Common.DbDataAdapter.Fill%2A> operation normally creates only column name metadata.</span></span> <span data-ttu-id="77579-487">그러나 경우 합니다 <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> 속성이 `AddWithKey`, 적절 한 기본 키와 제약 조건도 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="77579-487">However, if the <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> property is set to `AddWithKey`, appropriate primary keys and constraints are also created.</span></span>  
  
 <span data-ttu-id="77579-488">경우는 <xref:System.Data.Common.DbDataAdapter> 에서 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-488">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-489">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-489">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-490">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet> 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-490">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-491">추가 결과 집합이 지정한 테이블 이름 (예: "Table", "Table1", "Table2" 및 등)에 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-491">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on).</span></span> <span data-ttu-id="77579-492">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-492">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-493"><xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-493">The <xref:System.Data.Common.DbDataAdapter.Fill%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-494">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-494">In such situations, <xref:System.Data.Common.DbDataAdapter.Fill%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="77579-495">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-495">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="77579-496">경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-496">If <xref:System.Data.Common.DbDataAdapter.Fill%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-497">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-497">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-498">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-498">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-499">사용할 수는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드를 여러 번에 동일한 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-499">You can use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method multiple times on the same <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-500">기본 키가 있는 경우 들어오는 행이 이미 존재 하는 일치 하는 행과 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-500">If a primary key exists, incoming rows are merged with matching rows that already exist.</span></span> <span data-ttu-id="77579-501">들어오는 행에 추가 된 기본 키가 없으면는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-501">If no primary key exists, incoming rows are appended to the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-502">`SelectCommand` 가 OUTER JOIN의 결과를 반환하면 `DataAdapter` 는 결과 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 <xref:System.Data.DataTable>값을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-502">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a <xref:System.Data.DataTable.PrimaryKey%2A> value for the resulting <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-503">중복 행을 올바르게 확인할 수 있도록 기본 키를 명시적으로 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-503">You must explicitly define the primary key to ensure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="77579-504">자세한 내용은 [기본 키 정의](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-504">For more information, see [Defining Primary Keys](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-505">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 고 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> .NET Framework 데이터 공급자는 결과 대해서만 첫 번째 스키마 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-505">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.Fill%2A> and <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for a .NET Framework data provider retrieves schema information for only the first result.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-506">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-506">The source table is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="77579-507"><paramref name="startRecord" /> 매개 변수가 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-507">The <paramref name="startRecord" /> parameter is less than 0.</span></span>  
  
<span data-ttu-id="77579-508">또는</span><span class="sxs-lookup"><span data-stu-id="77579-508">-or-</span></span> 
<span data-ttu-id="77579-509"><paramref name="maxRecords" /> 매개 변수가 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-509">The <paramref name="maxRecords" /> parameter is less than 0.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-510">이 오버 로드는 <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> 메서드는 보호 되므로.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-510">This overload of the <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-511">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-511">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-512">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-512">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FillCommandBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Data.CommandBehavior FillCommandBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.CommandBehavior FillCommandBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property FillCommandBehavior As CommandBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Data::CommandBehavior FillCommandBehavior { System::Data::CommandBehavior get(); void set(System::Data::CommandBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.FillCommandBehavior : System.Data.CommandBehavior with get, set" Usage="System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.CommandBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-513">데이터 어댑터를 채우는 데 사용 되는 명령의 동작을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-513">Gets or sets the behavior of the command used to fill the data adapter.</span></span></summary>
        <value><span data-ttu-id="77579-514"><see cref="T:System.Data.CommandBehavior" /> 데이터 어댑터를 채우는 데 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-514">The <see cref="T:System.Data.CommandBehavior" /> of the command used to fill the data adapter.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-515">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-515">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-516">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-516">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FillError">
      <MemberSignature Language="C#" Value="public event System.Data.FillErrorEventHandler FillError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.FillErrorEventHandler FillError" />
      <MemberSignature Language="DocId" Value="E:System.Data.Common.DbDataAdapter.FillError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FillError As FillErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::FillErrorEventHandler ^ FillError;" />
      <MemberSignature Language="F#" Value="member this.FillError : System.Data.FillErrorEventHandler " Usage="member this.FillError : System.Data.FillErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DbDataAdapter_FillError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.FillErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="77579-517">추가 <see cref="T:System.Data.DataTable" /> 에 <see cref="T:System.Data.DataSet" /> 데이터 소스의 일치 하도록 스키마를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-517">Adds a <see cref="T:System.Data.DataTable" /> to a <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source.</span></span></summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-518">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-518">ADO.NET Overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-519">스키마를 삽입할 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-519">A <see cref="T:System.Data.DataSet" /> to insert the schema in.</span></span></param>
        <param name="schemaType"><span data-ttu-id="77579-520">스키마를 삽입할 방법을 지정하는 <see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-520">One of the <see cref="T:System.Data.SchemaType" /> values that specify how to insert the schema.</span></span></param>
        <summary><span data-ttu-id="77579-521">지정된 <see cref="T:System.Data.DataSet" />에 "Table"이라는 <see cref="T:System.Data.DataTable" />을 추가하고 지정된 <see cref="T:System.Data.SchemaType" />에 따라 데이터 원본의 스키마와 일치하도록 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-521">Adds a <see cref="T:System.Data.DataTable" /> named "Table" to the specified <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />.</span></span></summary>
        <returns><span data-ttu-id="77579-522"><see cref="T:System.Data.DataSet" />에 추가된 <see cref="T:System.Data.DataTable" /> 개체의 컬렉션에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-522">A reference to a collection of <see cref="T:System.Data.DataTable" /> objects that were added to the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-523">사용 하 여 데이터 원본에서 스키마 정보를 검색 하는이 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-523">This method retrieves the schema information from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span>  
  
 <span data-ttu-id="77579-524">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-524">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-525">그런 다음 열을 추가 합니다 <xref:System.Data.DataColumnCollection> 의 합니다 <xref:System.Data.DataTable>, 하 고 다음 구성 <xref:System.Data.DataColumn> 데이터 원본에 존재 하는 경우 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-525">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="77579-526"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="77579-526"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="77579-527">설정 해야 합니다 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 고 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 개별적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-527">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="77579-528"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 합니다 <xref:System.Data.DataTable.PrimaryKey%2A> 고 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-528"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="77579-529">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용할는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-529">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="77579-530">기본 키 열이 없으면 반환 됩니다. 고유한 열은 하지만 모든 고유한 열이 null이 아닌 경우에 고유 열 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-530">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="77579-531">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-531">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="77579-532">기본 키 열에 대 한 기본 키 열으로 사용 된 기본 키 열 및 고유 열을 모두 반환 되는 경우는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-532">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-533">기본 키 및 unique 제약 조건에 추가 됩니다는 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 유형이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-533">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="77579-534">고유한 클러스터형 SQL Server 테이블에서 열 또는 열에 인덱스가 정의 되 고 클러스터형된 인덱스의 열 이름을 반환 됩니다 primary key 제약 별도 열 집합에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-534">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="77579-535">기본 키 열의 이름을 반환할 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-535">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="77579-536">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 하십시오 [쿼리 힌트 (Transact SQL)](https://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-536">For more information about specifying query hints, see [Query Hint (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="77579-537">중 기본 키 정보는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 를 찾고 키 열과 일치 하는 모든 행을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-537">Primary key information is used during <xref:System.Data.Common.DbDataAdapter.Fill%2A> to find and replace any rows whose key columns match.</span></span> <span data-ttu-id="77579-538">원하는 동작이 없는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 스키마 정보를 요청 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-538">If this is not the desired behavior, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> without requesting schema information.</span></span>  
  
 <span data-ttu-id="77579-539">경우는 <xref:System.Data.IDataAdapter> 에서 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-539">If the <xref:System.Data.IDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-540">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-540">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-541">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet> 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-541">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-542">추가 결과 집합이 지정한 테이블 이름 (예를 들어, "Table", "Table1", "Table2", 및 등입니다.)를 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-542">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="77579-543">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-543">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-544"><xref:System.Data.IDbConnection> 선택 명령과 사용 하 여 연결 된 개체는 유효 해야 합니다. 하지만 열 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-544">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to open.</span></span> <span data-ttu-id="77579-545">경우는 <xref:System.Data.IDbConnection> 닫은 후 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-545">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-546">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출 하는 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-546">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is left open.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-547">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-547">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-548">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-548">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-549">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>,.NET Framework Data Provider for SQL Server를 실행 중인 문에 FOR BROWSE 절을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-549">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="77579-550">사용자는 SET FMTONLY ON 문 사용 하의 잠재적인 부작용을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-550">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="77579-551">자세한 내용은 [SET FMTONLY(Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-551">For more information, see [SET FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).</span></span>
  
   
  
## Examples  
 <span data-ttu-id="77579-552">다음 예제에서는 파생된 클래스 <xref:System.Data.SqlClient.SqlDataAdapter>를 입력 하는 <xref:System.Data.DataSet> 반환 고 스키마를 사용 하 여를 <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="77579-552">The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-553">DbProviderFactory</span><span class="sxs-lookup"><span data-stu-id="77579-553">DbProviderFactories</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-554">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-554">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataTable * System.Data.SchemaType -&gt; System.Data.DataTable" Usage="dbDataAdapter.FillSchema (dataTable, schemaType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="77579-555">데이터 원본의 스키마로 채울 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-555">The <see cref="T:System.Data.DataTable" /> to be filled with the schema from the data source.</span></span></param>
        <param name="schemaType"><span data-ttu-id="77579-556"><see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-556">One of the <see cref="T:System.Data.SchemaType" /> values.</span></span></param>
        <summary><span data-ttu-id="77579-557">지정된 <see cref="T:System.Data.SchemaType" />을 기반으로 하여 지정된 <see cref="T:System.Data.DataTable" />의 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-557">Configures the schema of the specified <see cref="T:System.Data.DataTable" /> based on the specified <see cref="T:System.Data.SchemaType" />.</span></span></summary>
        <returns><span data-ttu-id="77579-558">데이터 원본에서 반환된 스키마 정보를 포함하는 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-558">A <see cref="T:System.Data.DataTable" /> that contains schema information returned from the data source.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-559">합니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 사용 하 여 데이터 원본에서 스키마를 검색 하는 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-559">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method retrieves the schema from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span> <span data-ttu-id="77579-560">와 연결 된 연결 개체는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 유효 해야 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-560">The connection object associated with the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-561">전에 연결이 닫히면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-561">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-562">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-562">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-563">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업이 반환 된 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-563">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation returns a <xref:System.Data.DataTable>.</span></span> <span data-ttu-id="77579-564">그런 다음 열을 추가 합니다 <xref:System.Data.DataColumnCollection> 의 합니다 <xref:System.Data.DataTable>, 하 고 다음 구성 <xref:System.Data.DataColumn> 데이터 원본에 존재 하는 경우 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-564">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="77579-565"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="77579-565"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="77579-566">설정 해야 합니다 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 고 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 개별적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-566">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="77579-567"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 합니다 <xref:System.Data.DataTable.PrimaryKey%2A> 고 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-567"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="77579-568">경우는 <xref:System.Data.DataTable.PrimaryKey%2A> 에 대해 이미 정의 `DataTable`, 또는 `DataTable` 데이터를 포함 합니다 `PrimaryKey` 속성이 설정 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-568">If a <xref:System.Data.DataTable.PrimaryKey%2A> has already been defined for the `DataTable`, or the `DataTable` contains data, the `PrimaryKey` property will not be set.</span></span>  
  
-   <span data-ttu-id="77579-569">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용할는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-569">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the `DataTable`.</span></span>  
  
-   <span data-ttu-id="77579-570">기본 키 열이 없으면 반환 됩니다. 고유한 열은 하지만 모든 고유한 열이 null이 아닌 경우에 고유 열 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-570">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="77579-571">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 `PrimaryKey` 속성이 설정 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-571">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the `PrimaryKey` property is not set.</span></span>  
  
-   <span data-ttu-id="77579-572">기본 키 열에 대 한 기본 키 열으로 사용 된 기본 키 열 및 고유 열을 모두 반환 되는 경우는 `DataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-572">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the `DataTable`.</span></span>  
  
 <span data-ttu-id="77579-573">기본 키 및 unique 제약 조건에 추가 됩니다는 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 유형이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-573">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span> <span data-ttu-id="77579-574">이 프로세스 서버에 여러 번 왕복 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-574">This process may require several round-trips to the server.</span></span>  
  
 <span data-ttu-id="77579-575">고유한 클러스터형 SQL Server 테이블에서 열 또는 열에 인덱스가 정의 되 고 클러스터형된 인덱스의 열 이름을 반환 됩니다 primary key 제약 별도 열 집합에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-575">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="77579-576">기본 키 열의 이름을 반환할 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-576">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="77579-577">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 하십시오 [쿼리 힌트 (Transact SQL)](https://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-577">For more information about specifying query hints, see [Query Hint (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="77579-578">경우는 <xref:System.Data.Common.DbDataAdapter> 에서 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-578">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-579">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-579">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-580">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet> 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-580">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-581">추가 결과 집합이 지정한 테이블 이름 (예를 들어, "Table", "Table1", "Table2", 및 등입니다.)를 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-581">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="77579-582">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-582">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-583"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 모든 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-583"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> does not return any rows.</span></span> <span data-ttu-id="77579-584">사용 된 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 에 행을 추가 하는 방법을 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-584">Use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method to add rows to a <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-585">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-585">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-586">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-586">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-587">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>,.NET Framework Data Provider for SQL Server를 실행 중인 문에 FOR BROWSE 절을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-587">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="77579-588">사용자는 SET FMTONLY ON 문 사용 하의 잠재적인 부작용을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-588">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="77579-589">자세한 내용은 [SET FMTONLY(Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-589">For more information, see [SET FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).</span></span>
  
   
  
## Examples  
 <span data-ttu-id="77579-590">다음 예제에서는 파생된 클래스 <xref:System.Data.SqlClient.SqlDataAdapter>를 입력 하는 <xref:System.Data.DataSet> 반환 고 스키마를 사용 하 여를 <xref:System.Data.DataTable>.</span><span class="sxs-lookup"><span data-stu-id="77579-590">The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataTable>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-591">DbProviderFactory</span><span class="sxs-lookup"><span data-stu-id="77579-591">DbProviderFactories</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-592">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-592">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType * string -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-593">스키마를 삽입할 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-593">A <see cref="T:System.Data.DataSet" /> to insert the schema in.</span></span></param>
        <param name="schemaType"><span data-ttu-id="77579-594">스키마를 삽입할 방법을 지정하는 <see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-594">One of the <see cref="T:System.Data.SchemaType" /> values that specify how to insert the schema.</span></span></param>
        <param name="srcTable"><span data-ttu-id="77579-595">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-595">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="77579-596">지정된 <see cref="T:System.Data.DataSet" />에 <see cref="T:System.Data.DataTable" />을 추가하고 지정된 <see cref="T:System.Data.SchemaType" /> 및 <see cref="T:System.Data.DataTable" />에 따라 데이터 원본의 스키마와 일치하도록 스키마를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-596">Adds a <see cref="T:System.Data.DataTable" /> to the specified <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source based upon the specified <see cref="T:System.Data.SchemaType" /> and <see cref="T:System.Data.DataTable" />.</span></span></summary>
        <returns><span data-ttu-id="77579-597"><see cref="T:System.Data.DataSet" />에 추가된 <see cref="T:System.Data.DataTable" /> 개체의 컬렉션에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-597">A reference to a collection of <see cref="T:System.Data.DataTable" /> objects that were added to the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-598">사용 하 여 데이터 원본에서 스키마 정보를 검색 하는이 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-598">This method retrieves the schema information from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span>  
  
 <span data-ttu-id="77579-599">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-599">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-600">그런 다음 열을 추가 합니다 <xref:System.Data.DataColumnCollection> 의 합니다 <xref:System.Data.DataTable>, 하 고 다음 구성 <xref:System.Data.DataColumn> 데이터 원본에 존재 하는 경우 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-600">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="77579-601"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="77579-601"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="77579-602">설정 해야 합니다 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 고 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 개별적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-602">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="77579-603"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 합니다 <xref:System.Data.DataTable.PrimaryKey%2A> 고 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-603"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="77579-604">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용할는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-604">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="77579-605">기본 키 열이 없으면 반환 됩니다. 고유한 열은 하지만 모든 고유한 열이 null이 아닌 경우에 고유 열 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-605">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="77579-606">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-606">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="77579-607">기본 키 열에 대 한 기본 키 열으로 사용 된 기본 키 열 및 고유 열을 모두 반환 되는 경우는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-607">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-608">기본 키 및 unique 제약 조건에 추가 됩니다는 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 유형이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-608">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="77579-609">고유한 클러스터형 SQL Server 테이블에서 열 또는 열에 인덱스가 정의 되 고 클러스터형된 인덱스의 열 이름을 반환 됩니다 primary key 제약 별도 열 집합에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-609">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="77579-610">기본 키 열의 이름을 반환할 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-610">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="77579-611">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 하십시오 [쿼리 힌트 (Transact SQL)](https://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-611">For more information about specifying query hints, see [Query Hint (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="77579-612">중 기본 키 정보는 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 를 찾고 키 열과 일치 하는 모든 행을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-612">Primary key information is used during <xref:System.Data.Common.DbDataAdapter.Fill%2A> to find and replace any rows whose key columns match.</span></span> <span data-ttu-id="77579-613">원하는 동작이 없는 경우 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 스키마 정보를 요청 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-613">If this is not the desired behavior, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> without requesting schema information.</span></span>  
  
 <span data-ttu-id="77579-614">경우는 <xref:System.Data.Common.DbDataAdapter> 에서 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-614">If the <xref:System.Data.Common.DbDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-615">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-615">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-616">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet> 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-616">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-617">추가 결과 집합이 지정한 테이블 이름 (예를 들어, "Table", "Table1", "Table2", 및 등입니다.)를 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-617">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="77579-618">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-618">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-619"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-619">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-620">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-620">In such situations, <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="77579-621">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-621">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="77579-622">경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-622">If <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-623">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-623">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-624">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-624">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-625"><xref:System.Data.IDbConnection> 선택 명령과 사용 하 여 연결 된 개체는 유효 해야 합니다. 하지만 열 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-625">The <xref:System.Data.IDbConnection> object associated with the select command must be valid, but it does not need to open.</span></span> <span data-ttu-id="77579-626">경우는 <xref:System.Data.IDbConnection> 닫은 후 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-626">If the <xref:System.Data.IDbConnection> is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-627">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 은 호출 하는 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-627">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is left open.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-628">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-628">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-629">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-629">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-630">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>,.NET Framework Data Provider for SQL Server를 실행 중인 문에 FOR BROWSE 절을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-630">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="77579-631">사용자는 SET FMTONLY ON 문 사용 하의 잠재적인 부작용을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-631">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="77579-632">자세한 내용은 [SET FMTONLY(Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-632">For more information, see [SET FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).</span></span>
  
   
  
## Examples  
 <span data-ttu-id="77579-633">다음 예제에서는 파생된 클래스 <xref:System.Data.SqlClient.SqlDataAdapter>를 입력 하는 <xref:System.Data.DataSet> 반환 고 스키마를 사용 하 여를 <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="77579-633">The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="77579-634">스키마를 가져올 원본 테이블이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="77579-634">A source table from which to get the schema could not be found.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-635">DbProviderFactory</span><span class="sxs-lookup"><span data-stu-id="77579-635">DbProviderFactories</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-636">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-636">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataTable * System.Data.SchemaType * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; System.Data.DataTable" Usage="dbDataAdapter.FillSchema (dataTable, schemaType, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="77579-637">데이터 원본의 스키마로 채울 <see cref="T:System.Data.DataTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-637">The <see cref="T:System.Data.DataTable" /> to be filled with the schema from the data source.</span></span></param>
        <param name="schemaType"><span data-ttu-id="77579-638"><see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-638">One of the <see cref="T:System.Data.SchemaType" /> values.</span></span></param>
        <param name="command"><span data-ttu-id="77579-639">데이터 원본에서 행을 검색 하는 데 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-639">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="behavior"><span data-ttu-id="77579-640"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-640">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="77579-641">지정 된 스키마를 구성 <see cref="T:System.Data.DataTable" /> 지정한 <see cref="T:System.Data.SchemaType" />, 명령 문자열 및 <see cref="T:System.Data.CommandBehavior" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-641">Configures the schema of the specified <see cref="T:System.Data.DataTable" /> based on the specified <see cref="T:System.Data.SchemaType" />, command string, and <see cref="T:System.Data.CommandBehavior" /> values.</span></span></summary>
        <returns><span data-ttu-id="77579-642"><see cref="T:System.Data.DataTable" /> 데이터 원본에서 스키마 정보를 포함 하는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-642">A of <see cref="T:System.Data.DataTable" /> object that contains schema information returned from the data source.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-643">합니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 사용 하 여 데이터 원본에서 스키마를 검색 하는 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-643">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method retrieves the schema from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span> <span data-ttu-id="77579-644">와 연결 된 연결 개체는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 유효 해야 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-644">The connection object associated with the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-645">전에 연결이 닫히면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-645">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-646">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-646">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-647">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-647">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-648">그런 다음 열을 추가 합니다 <xref:System.Data.DataColumnCollection> 의 합니다 <xref:System.Data.DataTable>, 하 고 다음 구성 <xref:System.Data.DataColumn> 데이터 원본에 존재 하는 경우 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-648">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="77579-649"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="77579-649"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="77579-650">설정 해야 합니다 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 고 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 개별적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-650">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="77579-651"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 합니다 <xref:System.Data.DataTable.PrimaryKey%2A> 고 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-651"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="77579-652">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용할는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-652">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="77579-653">기본 키 열이 없으면 반환 됩니다. 고유한 열은 하지만 모든 고유한 열이 null이 아닌 경우에 고유 열 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-653">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="77579-654">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-654">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="77579-655">기본 키 열에 대 한 기본 키 열으로 사용 된 기본 키 열 및 고유 열을 모두 반환 되는 경우는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-655">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-656">기본 키 및 unique 제약 조건에 추가 됩니다는 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 유형이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-656">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="77579-657">고유한 클러스터형 SQL Server 테이블에서 열 또는 열에 인덱스가 정의 되 고 클러스터형된 인덱스의 열 이름을 반환 됩니다 primary key 제약 별도 열 집합에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-657">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="77579-658">기본 키 열의 이름을 반환할 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-658">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="77579-659">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 하십시오 [쿼리 힌트 (Transact SQL)](https://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-659">For more information about specifying query hints, see [Query Hint (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="77579-660">경우는 <xref:System.Data.IDataAdapter> 에서 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-660">If the <xref:System.Data.IDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-661">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-661">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-662">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet> 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-662">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-663">추가 결과 집합이 지정한 테이블 이름 (예를 들어, "Table", "Table1", "Table2", 및 등입니다.)를 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-663">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="77579-664">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-664">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-665"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 모든 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-665"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> does not return any rows.</span></span> <span data-ttu-id="77579-666">사용 된 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 에 행을 추가 하는 방법을 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-666">Use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method to add rows to a <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-667">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-667">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-668">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-668">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-669">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>,.NET Framework Data Provider for SQL Server를 실행 중인 문에 FOR BROWSE 절을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-669">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="77579-670">사용자는 SET FMTONLY ON 문 사용 하의 잠재적인 부작용을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-670">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="77579-671">자세한 내용은 [SET FMTONLY(Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-671">For more information, see [SET FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).</span></span>
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-672">이 구현 된 <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> 메서드는 보호 되므로.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-672">This implementation of the <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-673">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-673">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-674">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-674">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, string srcTable, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::String ^ srcTable, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType * System.Data.IDbCommand * string * System.Data.CommandBehavior -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType, command, srcTable, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-675">데이터 원본의 스키마로 채울 <see cref="T:System.Data.DataSet" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-675">The <see cref="T:System.Data.DataSet" /> to be filled with the schema from the data source.</span></span></param>
        <param name="schemaType"><span data-ttu-id="77579-676"><see cref="T:System.Data.SchemaType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-676">One of the <see cref="T:System.Data.SchemaType" /> values.</span></span></param>
        <param name="command"><span data-ttu-id="77579-677">데이터 원본에서 행을 검색 하는 데 SQL SELECT 문입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-677">The SQL SELECT statement used to retrieve rows from the data source.</span></span></param>
        <param name="srcTable"><span data-ttu-id="77579-678">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-678">The name of the source table to use for table mapping.</span></span></param>
        <param name="behavior"><span data-ttu-id="77579-679"><see cref="T:System.Data.CommandBehavior" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-679">One of the <see cref="T:System.Data.CommandBehavior" /> values.</span></span></param>
        <summary><span data-ttu-id="77579-680">추가 된 <see cref="T:System.Data.DataTable" /> 지정 된 <see cref="T:System.Data.DataSet" /> 데이터 원본의 기반으로 지정 하는 일치 하도록 스키마를 구성 하 고 <see cref="T:System.Data.SchemaType" />.</span><span class="sxs-lookup"><span data-stu-id="77579-680">Adds a <see cref="T:System.Data.DataTable" /> to the specified <see cref="T:System.Data.DataSet" /> and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />.</span></span></summary>
        <returns><span data-ttu-id="77579-681">배열을 <see cref="T:System.Data.DataTable" /> 데이터 원본에서 스키마 정보를 포함 하는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-681">An array of <see cref="T:System.Data.DataTable" /> objects that contain schema information returned from the data source.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-682">합니다 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 사용 하 여 데이터 원본에서 스키마를 검색 하는 메서드는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-682">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method retrieves the schema from the data source using the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span> <span data-ttu-id="77579-683">와 연결 된 연결 개체는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A> 유효 해야 하지만 열려 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-683">The connection object associated with the <xref:System.Data.IDbDataAdapter.SelectCommand%2A> must be valid, but it does not need to be open.</span></span> <span data-ttu-id="77579-684">전에 연결이 닫히면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 데이터를 검색 하려면을 열고 다음 닫는 하는를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-684">If the connection is closed before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it is opened to retrieve data, then closed.</span></span> <span data-ttu-id="77579-685">연결 하기 전에 열려 있으면 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 는 호출을 열린 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-685">If the connection is open before <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called, it remains open.</span></span>  
  
 <span data-ttu-id="77579-686">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 작업 추가 <xref:System.Data.DataTable> 대상 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-686">A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operation adds a <xref:System.Data.DataTable> to the destination <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-687">그런 다음 열을 추가 합니다 <xref:System.Data.DataColumnCollection> 의 합니다 <xref:System.Data.DataTable>, 하 고 다음 구성 <xref:System.Data.DataColumn> 데이터 원본에 존재 하는 경우 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-687">It then adds columns to the <xref:System.Data.DataColumnCollection> of the <xref:System.Data.DataTable>, and configures the following <xref:System.Data.DataColumn> properties if they exist at the data source:</span></span>  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <span data-ttu-id="77579-688"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span><span class="sxs-lookup"><span data-stu-id="77579-688"><xref:System.Data.DataColumn.AutoIncrement%2A>.</span></span> <span data-ttu-id="77579-689">설정 해야 합니다 <xref:System.Data.DataColumn.AutoIncrementStep%2A> 고 <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 개별적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-689">You must set <xref:System.Data.DataColumn.AutoIncrementStep%2A> and <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separately.</span></span>  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <span data-ttu-id="77579-690"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 또한 구성 합니다 <xref:System.Data.DataTable.PrimaryKey%2A> 고 <xref:System.Data.DataTable.Constraints%2A> 다음 규칙에 따라 속성:</span><span class="sxs-lookup"><span data-stu-id="77579-690"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> also configures the <xref:System.Data.DataTable.PrimaryKey%2A> and <xref:System.Data.DataTable.Constraints%2A> properties according to the following rules:</span></span>  
  
-   <span data-ttu-id="77579-691">하나 이상의 기본 키 열에서 반환 되는 경우는 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>에 대 한 기본 키 열으로 사용할는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-691">If one or more primary key columns are returned by the <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, they are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
-   <span data-ttu-id="77579-692">기본 키 열이 없으면 반환 됩니다. 고유한 열은 하지만 모든 고유한 열이 null이 아닌 경우에 고유 열 기본 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-692">If no primary key columns are returned but unique columns are, the unique columns are used as the primary key if, and only if, all the unique columns are nonnullable.</span></span> <span data-ttu-id="77579-693">열이 null을 허용 하는 경우는 <xref:System.Data.UniqueConstraint> 에 추가 됩니다는 <xref:System.Data.ConstraintCollection>, 하지만 <xref:System.Data.DataTable.PrimaryKey%2A> 속성이 설정 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-693">If any of the columns are nullable, a <xref:System.Data.UniqueConstraint> is added to the <xref:System.Data.ConstraintCollection>, but the <xref:System.Data.DataTable.PrimaryKey%2A> property is not set.</span></span>  
  
-   <span data-ttu-id="77579-694">기본 키 열에 대 한 기본 키 열으로 사용 된 기본 키 열 및 고유 열을 모두 반환 되는 경우는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-694">If both primary key columns and unique columns are returned, the primary key columns are used as the primary key columns for the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-695">기본 키 및 unique 제약 조건에 추가 됩니다는 <xref:System.Data.ConstraintCollection> 선행 규칙에 있지만 다른 제약 조건에 따라 유형이 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-695">Note that primary keys and unique constraints are added to the <xref:System.Data.ConstraintCollection> according to the preceding rules, but other constraint types are not added.</span></span>  
  
 <span data-ttu-id="77579-696">고유한 클러스터형 SQL Server 테이블에서 열 또는 열에 인덱스가 정의 되 고 클러스터형된 인덱스의 열 이름을 반환 됩니다 primary key 제약 별도 열 집합에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-696">If a unique clustered index is defined on a column or columns in a SQL Server table and the primary key constraint is defined on a separate set of columns, then the names of the columns in the clustered index will be returned.</span></span> <span data-ttu-id="77579-697">기본 키 열의 이름을 반환할 기본 키 인덱스의 이름을 지정 하는 SELECT 문을 사용 하 여 쿼리 힌트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-697">To return the name or names of the primary key columns, use a query hint with the SELECT statement that specifies the name of the primary key index.</span></span> <span data-ttu-id="77579-698">쿼리 힌트를 지정 하는 방법에 대 한 자세한 내용은 참조 하십시오 [쿼리 힌트 (Transact SQL)](https://msdn.microsoft.com/library/ms181714.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-698">For more information about specifying query hints, see [Query Hint (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).</span></span>  
  
 <span data-ttu-id="77579-699">경우는 <xref:System.Data.IDataAdapter> 에서 중복 열을 채우는 동안는 <xref:System.Data.DataTable>, 패턴을 사용 하 여 후속 열에 대 한 이름을 생성 "*columnname*1", "*columnname*2", "*columnname*3", 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-699">If the <xref:System.Data.IDataAdapter> encounters duplicate columns while populating a <xref:System.Data.DataTable>, it generates names for the subsequent columns, using the pattern "*columnname*1", "*columnname*2", "*columnname*3", and so on.</span></span> <span data-ttu-id="77579-700">놓 이기는 들어오는 데이터에 명명 되지 않은 열을 포함 하는 경우는 <xref:System.Data.DataSet> "column1", "Column2" 등에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-700">If the incoming data contains unnamed columns, they are placed in the <xref:System.Data.DataSet> according to the pattern "Column1", "Column2", and so on.</span></span> <span data-ttu-id="77579-701">여러 결과 집합에 추가 될 때를 <xref:System.Data.DataSet> 각 결과 집합을 별도 테이블에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-701">When multiple result sets are added to the <xref:System.Data.DataSet> each result set is placed in a separate table.</span></span> <span data-ttu-id="77579-702">추가 결과 집합이 지정한 테이블 이름 (예를 들어, "Table", "Table1", "Table2", 및 등입니다.)를 정수 값을 추가 하 여 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-702">Additional result sets are named by appending integral values to the specified table name (for example, "Table", "Table1", "Table2", and so on.).</span></span> <span data-ttu-id="77579-703">열 및 테이블 이름을 사용 하 여 응용 프로그램은 이러한 명명 패턴을 사용 하 여 충돌 하지 않도록 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-703">Applications using column and table names should ensure that conflicts with these naming patterns does not occur.</span></span>  
  
 <span data-ttu-id="77579-704"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-704">The <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-705">이러한 상황에서는 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 새 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-705">In such situations, <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> performs a case-sensitive comparison to find the corresponding table, and creates a new table if no exact match exists.</span></span> <span data-ttu-id="77579-706">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-706">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 <span data-ttu-id="77579-707">경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-707">If <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-708">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-708">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-709">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-709">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-710"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 모든 행을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-710"><xref:System.Data.Common.DbDataAdapter.FillSchema%2A> does not return any rows.</span></span> <span data-ttu-id="77579-711">사용 된 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 에 행을 추가 하는 방법을 <xref:System.Data.DataTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-711">Use the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method to add rows to a <xref:System.Data.DataTable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-712">구현의 여러 결과 반환 하는 SQL 문을 일괄 처리할 때 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 첫 번째 결과 대 한 스키마 정보를 검색 하는.NET Framework Data Provider for OLE DB에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-712">When handling batch SQL statements that return multiple results, the implementation of <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> for the .NET Framework Data Provider for OLE DB retrieves schema information for only the first result.</span></span> <span data-ttu-id="77579-713">사용 하 여 여러 결과 대 한 스키마 정보를 검색할 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 사용 하 여는 <xref:System.Data.MissingSchemaAction> 로 `AddWithKey`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-713">To retrieve schema information for multiple results, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> with the <xref:System.Data.MissingSchemaAction> set to `AddWithKey`.</span></span>  
  
 <span data-ttu-id="77579-714">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>,.NET Framework Data Provider for SQL Server를 실행 중인 문에 FOR BROWSE 절을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-714">When using <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed.</span></span> <span data-ttu-id="77579-715">사용자는 SET FMTONLY ON 문 사용 하의 잠재적인 부작용을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-715">The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements.</span></span> <span data-ttu-id="77579-716">자세한 내용은 [SET FMTONLY(Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-716">For more information, see [SET FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).</span></span>
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-717">이 구현 된 <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> 메서드는 보호 되므로.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-717">This implementation of the <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> method is protected and is designed for use by a .NET Framework data provider.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-718">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-718">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-719">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-719">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedParameter">
      <MemberSignature Language="C#" Value="protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.IDataParameter GetBatchedParameter(int32 commandIdentifier, int32 parameterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedParameter (commandIdentifier As Integer, parameterIndex As Integer) As IDataParameter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::IDataParameter ^ GetBatchedParameter(int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBatchedParameter : int * int -&gt; System.Data.IDataParameter&#xA;override this.GetBatchedParameter : int * int -&gt; System.Data.IDataParameter" Usage="dbDataAdapter.GetBatchedParameter (commandIdentifier, parameterIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="parameterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier"><span data-ttu-id="77579-720">매개 변수에서 검색할 명령의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-720">The index of the command to retrieve the parameter from.</span></span></param>
        <param name="parameterIndex"><span data-ttu-id="77579-721">명령에 매개 변수의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-721">The index of the parameter within the command.</span></span></param>
        <summary><span data-ttu-id="77579-722">반환 된 <see cref="T:System.Data.IDataParameter" /> 에서 현재 일괄 처리에서 명령 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-722">Returns a <see cref="T:System.Data.IDataParameter" /> from one of the commands in the current batch.</span></span></summary>
        <returns><span data-ttu-id="77579-723"><see cref="T:System.Data.IDataParameter" /> 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-723">The <see cref="T:System.Data.IDataParameter" /> specified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-724"><xref:System.Data.Common.DbDataAdapter>,이 메서드는 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-724">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="77579-725">상속한 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-725">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="77579-726">어댑터는 일괄 처리를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-726">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-727">이 메서드는 보호 되 고.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-727">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
<span data-ttu-id="77579-728">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스 사용자가 일괄 처리를 실행 하도록 허용 하려면이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-728">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method to allow users to execute a batch.</span></span> <span data-ttu-id="77579-729">구현을 사용 하는 <paramref name="commandIdentifier" /> 요청된 된 명령을 찾습니다 제공을 사용 하 여는 <paramref name="parameterIndex" /> 요청 된 매개 변수를 찾으려는 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-729">An implementation uses the <paramref name="commandIdentifier" /> provided to locate the requested command, then uses the <paramref name="parameterIndex" /> provided to locate the requested parameter.</span></span> <span data-ttu-id="77579-730">예를 들어, 한 <paramref name="commandIdentifier" /> 0 및 <paramref name="parameterIndex" /> 0에서 일괄 처리의 첫 번째 명령은 첫 번째 매개 변수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-730">For example, a <paramref name="commandIdentifier" /> of 0 and a <paramref name="parameterIndex" /> of 0 returns the first parameter from the first command in the batch.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-731">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-731">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-732">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-732">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedRecordsAffected">
      <MemberSignature Language="C#" Value="protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetBatchedRecordsAffected(int32 commandIdentifier, [out] int32&amp; recordsAffected, [out] class System.Exception&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedRecordsAffected (commandIdentifier As Integer, ByRef recordsAffected As Integer, ByRef error As Exception) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GetBatchedRecordsAffected(int commandIdentifier, [Runtime::InteropServices::Out] int % recordsAffected, [Runtime::InteropServices::Out] Exception ^ % error);" />
      <MemberSignature Language="F#" Value="abstract member GetBatchedRecordsAffected : int *  *  -&gt; bool&#xA;override this.GetBatchedRecordsAffected : int *  *  -&gt; bool" Usage="dbDataAdapter.GetBatchedRecordsAffected (commandIdentifier, recordsAffected, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="recordsAffected" Type="System.Int32" RefType="out" />
        <Parameter Name="error" Type="System.Exception" RefType="out" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier"><span data-ttu-id="77579-733">일괄 처리 내의 개별 명령의 0부터 시작 하는 열 서 수입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-733">The zero-based column ordinal of the individual command within the batch.</span></span></param>
        <param name="recordsAffected"><span data-ttu-id="77579-734">지정된 된 명령 일괄 처리 내 데이터 저장소에 영향을 받는 행의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-734">The number of rows affected in the data store by the specified command within the batch.</span></span></param>
        <param name="error"><span data-ttu-id="77579-735"><see cref="T:System.Exception" /> 지정 된 명령 실행 하는 동안 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-735">An <see cref="T:System.Exception" /> thrown during execution of the specified command.</span></span> <span data-ttu-id="77579-736">반환 <see langword="null" /> (<see langword="Nothing" /> Visual basic에서) 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-736">Returns <see langword="null" /> (<see langword="Nothing" /> in Visual Basic) if no exception is thrown.</span></span></param>
        <summary><span data-ttu-id="77579-737">더 큰 일괄 처리 업데이트 내에서 개별 업데이트 시도 대 한 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-737">Returns information about an individual update attempt within a larger batched update.</span></span></summary>
        <returns><span data-ttu-id="77579-738">더 큰 일괄 처리 업데이트 내에서 개별 업데이트 시도 대 한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-738">Information about an individual update attempt within a larger batched update.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-739">일괄 처리 업데이트 논리를 지 원하는 데이터 공급자에는 일련의 가상 메서드를 재정의 해야 합니다는 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-739">Data providers that support batched updating logic must override a series of virtual methods on the <xref:System.Data.Common.DbDataAdapter> class.</span></span> <span data-ttu-id="77579-740">`GetBatchedRecordsAffected` 이러한 가상 메서드 중 하나를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="77579-740">`GetBatchedRecordsAffected` represents one of those virtual methods.</span></span> <span data-ttu-id="77579-741">합니다 `DbDataAdapter` 클래스가 의존 `GetBatchedRecordsAffected` 해당 표시 일괄 처리 내의 개별 업데이트 시도의 성공 여부를 확인 하려면 <xref:System.Data.DataRow> 적절 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-741">The `DbDataAdapter` class relies on `GetBatchedRecordsAffected` to determine the success or failure of individual update attempts within a batch so it can mark each corresponding <xref:System.Data.DataRow> accordingly.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-742">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-742">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public override System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberSignature Language="F#" Value="override this.GetFillParameters : unit -&gt; System.Data.IDataParameter[]" Usage="dbDataAdapter.GetFillParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.GetFillParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="77579-743">SQL SELECT 문을 실행할 때 사용자가 설정한 매개 변수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="77579-743">Gets the parameters set by the user when executing an SQL SELECT statement.</span></span></summary>
        <returns><span data-ttu-id="77579-744">배열을 <see cref="T:System.Data.IDataParameter" /> 사용자가 설정한 매개 변수를 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-744">An array of <see cref="T:System.Data.IDataParameter" /> objects that contains the parameters set by the user.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-745">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-745">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InitializeBatching">
      <MemberSignature Language="C#" Value="protected virtual void InitializeBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.InitializeBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeBatching();" />
      <MemberSignature Language="F#" Value="abstract member InitializeBatching : unit -&gt; unit&#xA;override this.InitializeBatching : unit -&gt; unit" Usage="dbDataAdapter.InitializeBatching " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="77579-746">일괄 처리를 초기화 합니다 <see cref="T:System.Data.Common.DbDataAdapter" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-746">Initializes batching for the <see cref="T:System.Data.Common.DbDataAdapter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-747"><xref:System.Data.Common.DbDataAdapter>,이 메서드는 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-747">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="77579-748">상속한 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-748">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="77579-749">어댑터는 일괄 처리를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-749">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-750">이 메서드는 보호 되 고.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-750">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
<span data-ttu-id="77579-751">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스를이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-751">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method.</span></span> <span data-ttu-id="77579-752">이 메서드는 일괄 처리를 지 원하는 데 필요한 모든 리소스를 초기화할 수 있도록 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-752">This method gives the class the opportunity to initialize any resources necessary to support batching.</span></span> <span data-ttu-id="77579-753">예를 들어, 클래스는 명령 집합을 일괄 처리에서 보유 하는 데이터 구조를 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-753">For example, a class may allocate a data structure to hold the set of commands in the batch.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-754">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-754">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-755">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-755">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property InsertCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ InsertCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InsertCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-756">데이터 원본에 새 레코드를 삽입 하는 데 사용 하는 명령을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-756">Gets or sets a command used to insert new records into the data source.</span></span></summary>
        <value><span data-ttu-id="77579-757">A <see cref="T:System.Data.IDbCommand" /> 하는 동안 사용 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합에 새 행에 대 한 데이터 원본에서 레코드를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-757">A <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to insert records in the data source for new rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-758">하는 동안 <xref:System.Data.Common.DbDataAdapter.Update%2A>이면이 속성은 설정 되지 않으며 기본 키 정보에 있으면 합니다 <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.InsertCommand%2A> 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-758">During <xref:System.Data.Common.DbDataAdapter.Update%2A>, if this property is not set and primary key information is present in the <xref:System.Data.DataSet>, the <xref:System.Data.IDbDataAdapter.InsertCommand%2A> will be automatically generated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-759">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-759">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-760">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-760">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-761">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-761">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-762">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-762">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OnFillError">
      <MemberSignature Language="C#" Value="protected virtual void OnFillError (System.Data.FillErrorEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFillError(class System.Data.FillErrorEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnFillError(System.Data.FillErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFillError (value As FillErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFillError(System::Data::FillErrorEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnFillError : System.Data.FillErrorEventArgs -&gt; unit&#xA;override this.OnFillError : System.Data.FillErrorEventArgs -&gt; unit" Usage="dbDataAdapter.OnFillError value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.FillErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdated">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdated(class System.Data.Common.RowUpdatedEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdated (value As RowUpdatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdated(System::Data::Common::RowUpdatedEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRowUpdated : System.Data.Common.RowUpdatedEventArgs -&gt; unit&#xA;override this.OnRowUpdated : System.Data.Common.RowUpdatedEventArgs -&gt; unit" Usage="dbDataAdapter.OnRowUpdated value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="77579-763">이벤트 데이터를 포함하는 <see cref="T:System.Data.Common.RowUpdatedEventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-763">A <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="77579-764">발생 된 <see langword="RowUpdated" /> .NET Framework 데이터 공급자의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-764">Raises the <see langword="RowUpdated" /> event of a .NET Framework data provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-765">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-765">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="77579-766">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-766">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-767">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-767">When overriding <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> method.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-768">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-768">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-769">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-769">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdating">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdating(class System.Data.Common.RowUpdatingEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdating (value As RowUpdatingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdating(System::Data::Common::RowUpdatingEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRowUpdating : System.Data.Common.RowUpdatingEventArgs -&gt; unit&#xA;override this.OnRowUpdating : System.Data.Common.RowUpdatingEventArgs -&gt; unit" Usage="dbDataAdapter.OnRowUpdating value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatingEventArgs" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="77579-770">이벤트 데이터를 포함하는 <see cref="T:System.Data.Common.RowUpdatingEventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-770">An <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="77579-771">발생 된 <see langword="RowUpdating" /> .NET Framework 데이터 공급자의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-771">Raises the <see langword="RowUpdating" /> event of a .NET Framework data provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-772">이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-772">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="77579-773">개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-773">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-774">재정의 하는 경우 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="77579-774">When overriding <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> in a derived class, be sure to call the bases class's <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> method.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-775">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-775">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-776">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-776">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SelectCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ SelectCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-777">데이터 원본에서 레코드를 선택 하는 데 사용 하는 명령을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-777">Gets or sets a command used to select records in the data source.</span></span></summary>
        <value><span data-ttu-id="77579-778">A <see cref="T:System.Data.IDbCommand" /> 하는 동안 사용 되는 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합에 배치 하기 위해 데이터 원본에서 레코드를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-778">A <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to select records from data source for placement in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="77579-779">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-779">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-780">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-780">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-781">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-781">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-782">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-782">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.DeleteCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand" />
      <MemberSignature Language="VB.NET" Value=" Property DeleteCommand As IDbCommand Implements IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::DeleteCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.DeleteCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-783">데이터 집합에서 레코드를 삭제 하는 것에 대 한 SQL 문을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-783">Gets or sets an SQL statement for deleting records from the data set.</span></span></summary>
        <value><span data-ttu-id="77579-784"><see cref="T:System.Data.IDbCommand" /> 중에 사용 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합의 삭제 된 행에 대 한 데이터 원본에서 레코드를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-784">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to delete records in the data source for deleted rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-785">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="77579-785">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="77579-786"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-786">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="77579-787">자세한 내용은 <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-787">For more information, see <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-788">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-788">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.InsertCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand" />
      <MemberSignature Language="VB.NET" Value=" Property InsertCommand As IDbCommand Implements IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::InsertCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.InsertCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.InsertCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-789">데이터 원본에 새 레코드를 삽입 하는 데 사용 되는 SQL 문을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-789">Gets or sets an SQL statement used to insert new records into the data source.</span></span></summary>
        <value><span data-ttu-id="77579-790"><see cref="T:System.Data.IDbCommand" /> 하는 동안 사용 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합에 새 행에 대 한 데이터 원본에서 레코드를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-790">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to insert records in the data source for new rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-791">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="77579-791">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="77579-792"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-792">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="77579-793">자세한 내용은 <xref:System.Data.IDbDataAdapter.InsertCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-793">For more information, see <xref:System.Data.IDbDataAdapter.InsertCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-794">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-794">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.SelectCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand" />
      <MemberSignature Language="VB.NET" Value=" Property SelectCommand As IDbCommand Implements IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::SelectCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.SelectCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.SelectCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-795">데이터 원본에서 레코드를 선택 하는 데 사용 하는 SQL 문을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-795">Gets or sets an SQL statement used to select records in the data source.</span></span></summary>
        <value><span data-ttu-id="77579-796"><see cref="T:System.Data.IDbCommand" /> 하는 동안 사용 되는 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합에 배치 하기 위해 데이터 원본에서 레코드를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-796">An <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to select records from data source for placement in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-797">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="77579-797">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="77579-798"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-798">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="77579-799">자세한 내용은 <xref:System.Data.IDbDataAdapter.SelectCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-799">For more information, see <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-800">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-800">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.UpdateCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand" />
      <MemberSignature Language="VB.NET" Value=" Property UpdateCommand As IDbCommand Implements IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::UpdateCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.UpdateCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-801">데이터 원본에서 레코드를 업데이트 하는 데 사용 하는 SQL 문을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-801">Gets or sets an SQL statement used to update records in the data source.</span></span></summary>
        <value><span data-ttu-id="77579-802"><see cref="T:System.Data.IDbCommand" /> 하는 동안 사용 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합의 수정 된 행에 대 한 데이터 원본에서 레코드를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-802">An <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to update records in the data source for modified rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-803">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="77579-803">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="77579-804"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.Data.IDbDataAdapter> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-804">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.Data.IDbDataAdapter> interface.</span></span>  
  
 <span data-ttu-id="77579-805">자세한 내용은 <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-805">For more information, see <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-806">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-806">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("use 'protected DbDataAdapter(DbDataAdapter)' ctor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="77579-807">현재 인스턴스의 복사본인 새 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="77579-807">Creates a new object that is a copy of the current instance.</span></span></summary>
        <returns><span data-ttu-id="77579-808">이 인스턴스의 복사본인 새 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-808">A new object that is a copy of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-809">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="77579-809">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="77579-810"><xref:System.Data.Common.DbDataAdapter> 인스턴스가 <xref:System.ICloneable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-810">It can be used only when the <xref:System.Data.Common.DbDataAdapter> instance is cast to an <xref:System.ICloneable> interface.</span></span>  
  
 <span data-ttu-id="77579-811">자세한 내용은 <xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="77579-811">For more information, see <xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-812">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-812">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TerminateBatching">
      <MemberSignature Language="C#" Value="protected virtual void TerminateBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TerminateBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.TerminateBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TerminateBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TerminateBatching();" />
      <MemberSignature Language="F#" Value="abstract member TerminateBatching : unit -&gt; unit&#xA;override this.TerminateBatching : unit -&gt; unit" Usage="dbDataAdapter.TerminateBatching " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="77579-813">일괄 처리를 종료 합니다 <see cref="T:System.Data.Common.DbDataAdapter" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-813">Ends batching for the <see cref="T:System.Data.Common.DbDataAdapter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-814"><xref:System.Data.Common.DbDataAdapter>,이 메서드는 throw <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-814">In <xref:System.Data.Common.DbDataAdapter>, this method throws <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="77579-815">상속한 클래스 <xref:System.Data.Common.DbDataAdapter> 일괄 처리에 대 한 지원을 제공 하려면이 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-815">Classes that inherit from <xref:System.Data.Common.DbDataAdapter> override this method to provide support for batches.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="77579-816">어댑터는 일괄 처리를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-816">The adapter does not support batches.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="77579-817">이 메서드는 보호 되 고.NET Framework 데이터 공급자가 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-817">This method is protected and is designed for use by a .NET Framework data provider.</span></span>  
  
<span data-ttu-id="77579-818">클래스에서 상속 되는 경우 <see cref="T:System.Data.Common.DbDataAdapter" /> 클래스를이 메서드를 재정의 하는 일괄 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-818">If a class that inherits from <see cref="T:System.Data.Common.DbDataAdapter" /> supports batches, that class overrides this method.</span></span> <span data-ttu-id="77579-819">이 메서드를 통해 클래스의 일괄 처리를 지원 하기 위해 할당 된 모든 리소스를 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-819">This method gives the class the opportunity to dispose of any resources allocated to support batching.</span></span> <span data-ttu-id="77579-820">예를 들어, 클래스 명령 일괄 처리에서 보유 하는 데이터 구조 할당을 취소 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-820">For example, the class may deallocate the data structure that holds the commands in the batch.</span></span></para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-821">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-821">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-822">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-822">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="77579-823">삽입, 업데이트 또는 삭제에 대 한 행 각각에 대 한 INSERT, UPDATE 또는 DELETE 문을 각각 실행 하 여 데이터베이스의 값을 업데이트 합니다 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-823">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" />.</span></span></summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-824">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-824">ADO.NET Overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataRow[] dataRows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataRow[] dataRows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (dataRows As DataRow()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataRow[] -&gt; int" Usage="dbDataAdapter.Update dataRows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="dataRows"><span data-ttu-id="77579-825">배열을 <see cref="T:System.Data.DataRow" /> 개체 데이터 소스를 업데이트 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-825">An array of <see cref="T:System.Data.DataRow" /> objects used to update the data source.</span></span></param>
        <summary><span data-ttu-id="77579-826">삽입, 업데이트 또는 삭제할 행에서 지정 된 배열의 각에 대 한 INSERT, UPDATE 또는 DELETE 문을 각각 실행 하 여 데이터베이스의 값을 업데이트 합니다 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-826">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array in the <see cref="T:System.Data.DataSet" />.</span></span></summary>
        <returns><span data-ttu-id="77579-827">성공적으로 업데이트 된 행의 수는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-827">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-828">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를 <xref:System.Data.Common.DbDataAdapter> 검사를 <xref:System.Data.DataRow.RowState%2A> 속성 합니다 에서구성된인덱스순서에따라각행에대해반복적으로필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="77579-828">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-829">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 뒤에 INSERT 문과 DELETE 문의 다른 인해의 행 순서는 DELETE 문을 실행할 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-829">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-830">유의 해야 이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다. 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-830">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="77579-831">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 문 형식 (예: 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-831">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="77579-832">자세한 내용은 [Dataadapter 사용 하 여 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-832">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="77579-833">하는 경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-833">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="77579-834">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-834">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="77579-835">설정 하지 않으면 추가적인 모든 SQL 문을에서 생성 된 후에 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-835">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="77579-836">이 세대 논리에 키 열 정보가 필요 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-836">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-837">자세한 내용은 참조 [commandbuilder를 사용 하를 사용 하 여 명령 생성](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-837">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="77579-838"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 업데이트를 수행 하기 전에 첫 번째 매핑의에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-838">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="77579-839">합니다 <xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-839">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="77579-840">반환 되는 모든 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-840">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="77579-841">모든 데이터에 다시 로드 된 후는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사할 수 있도록 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령으로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-841">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="77579-842">행을 성공적으로 업데이트 한 후 해당 행 변경 내용이 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-842">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="77579-843">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-843">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="77579-844">값을 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-844">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="77579-845"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-845">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="77579-846">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-846">The command executes.</span></span>  
  
4.  <span data-ttu-id="77579-847">명령으로 설정 되어 있으면 `FirstReturnedRecord`, 첫 번째 반환 결과에 위치한는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-847">If the command is set to `FirstReturnedRecord`, the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="77579-848">에 배치 됩니다 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-848">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="77579-849"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-849">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="77579-850"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="77579-850"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="77579-851">와 연결 된 각 명령을 <xref:System.Data.Common.DbDataAdapter> 일반적으로 연결 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-851">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="77579-852">매개 변수를 통해 현재 행에 매핑되는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-852">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="77579-853">`SourceColumn` 참조를 <xref:System.Data.DataTable> 열은는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-853">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="77579-854">`SourceColumn` 테이블 매핑을 적용 하려면 먼저 매핑되지 않은 열 이름으로 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-854">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="77579-855">하는 경우 `SourceColumn` 참조를 존재 하지 않는 열에 수행 되는 동작에 따라 달라 집니다 다음 중 하나 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-855">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="77579-856">열거형 값</span><span class="sxs-lookup"><span data-stu-id="77579-856">Enumeration value</span></span>|<span data-ttu-id="77579-857">수행한 작업</span><span class="sxs-lookup"><span data-stu-id="77579-857">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="77579-858">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="77579-858">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="77579-859"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-859">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="77579-860">매핑을 명시적으로 설정 하는 경우 입력된 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-860">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="77579-861"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-861">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="77579-862">합니다 `SourceColumn` 속성은 또한 출력에 대 한 값을 매핑할 사용 또는 입/출력 매개 변수를는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-862">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="77579-863">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-863">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="77579-864">합니다 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 열 값의 원본, 현재 또는 제안 버전 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-864">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="77579-865">이 기능은 낙관적 동시성 위반을 검사 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하도록 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-865">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-866">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-866">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="77579-867">오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면 설정 합니다 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-867">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="77579-868">내에서 행당 별로 오류에 응답할 수도 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-868">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="77579-869">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면를 `RowUpdated` 이벤트를 설정 합니다 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성을 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-869">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-870">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter>데이터 소스를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-870">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="77579-871"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-871">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-872">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-872">The source table is invalid.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="77579-873">이상 <see cref="T:System.Data.DataRow" /> 업데이트 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-873">No <see cref="T:System.Data.DataRow" /> exists to update.</span></span>  
  
<span data-ttu-id="77579-874">또는</span><span class="sxs-lookup"><span data-stu-id="77579-874">-or-</span></span> 
<span data-ttu-id="77579-875">이상 <see cref="T:System.Data.DataTable" /> 업데이트 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-875">No <see cref="T:System.Data.DataTable" /> exists to update.</span></span>  
  
<span data-ttu-id="77579-876">또는</span><span class="sxs-lookup"><span data-stu-id="77579-876">-or-</span></span> 
<span data-ttu-id="77579-877">이상 <see cref="T:System.Data.DataSet" /> 원본으로 사용 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-877">No <see cref="T:System.Data.DataSet" /> exists to use as a source.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="77579-878">영향을 받는 0 개 레코드에서 INSERT, UPDATE 또는 DELETE 문을 실행 하려고가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-878">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-879">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-879">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-880">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-880">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-881">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-881">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public override int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Update(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataSet -&gt; int" Usage="dbDataAdapter.Update dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Update(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-882"><see cref="T:System.Data.DataSet" /> 데이터 소스를 업데이트 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-882">The <see cref="T:System.Data.DataSet" /> used to update the data source.</span></span></param>
        <summary><span data-ttu-id="77579-883">삽입, 업데이트 또는 지정 된 행을 삭제 각각에 대 한 INSERT, UPDATE 또는 DELETE 문을 각각 실행 하 여 데이터베이스의 값을 업데이트 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-883">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />.</span></span></summary>
        <returns><span data-ttu-id="77579-884">성공적으로 업데이트 된 행의 수는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-884">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-885">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를 <xref:System.Data.Common.DbDataAdapter> 검사를 <xref:System.Data.DataRow.RowState%2A> 속성 합니다 에서구성된인덱스순서에따라각행에대해반복적으로필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="77579-885">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-886">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 뒤에 INSERT 문과 DELETE 문의 다른 인해의 행 순서는 DELETE 문을 실행할 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-886">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-887">유의 해야 이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다. 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-887">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="77579-888">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 문 형식 (예: 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-888">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="77579-889">자세한 내용은 [Dataadapter 사용 하 여 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-889">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="77579-890">하는 경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-890">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="77579-891">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-891">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="77579-892">설정 하지 않으면 추가적인 모든 SQL 문을에서 생성 된 후에 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-892">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="77579-893">이 세대 논리에 키 열 정보가 필요 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-893">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-894">자세한 내용은 참조 [commandbuilder를 사용 하를 사용 하 여 명령 생성](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-894">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="77579-895"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 업데이트를 수행 하기 전에 첫 번째 매핑의에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-895">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="77579-896">합니다 <xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-896">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="77579-897">반환 되는 모든 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-897">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="77579-898">모든 데이터에 다시 로드 된 후는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사할 수 있도록 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령으로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-898">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="77579-899">행을 성공적으로 업데이트 한 후 해당 행 변경 내용이 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-899">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="77579-900">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-900">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="77579-901">값을 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-901">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="77579-902"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-902">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="77579-903">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-903">The command executes.</span></span>  
  
4.  <span data-ttu-id="77579-904">명령으로 설정 되어 있으면 `FirstReturnedRecord`, 첫 번째 반환 결과에 위치한는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-904">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="77579-905">에 배치 됩니다 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-905">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="77579-906"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-906">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="77579-907"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="77579-907"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="77579-908">와 연결 된 각 명령을 <xref:System.Data.Common.DbDataAdapter> 일반적으로 연결 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-908">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="77579-909">매개 변수를 통해 현재 행에 매핑되는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-909">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="77579-910">`SourceColumn` 참조를 <xref:System.Data.DataTable> 열은는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-910">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="77579-911">`SourceColumn` 테이블 매핑을 적용 하려면 먼저 매핑되지 않은 열 이름으로 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-911">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="77579-912">하는 경우 `SourceColumn` 참조를 존재 하지 않는 열에 수행 되는 동작에 따라 달라 집니다 다음 중 하나 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-912">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="77579-913">열거형 값</span><span class="sxs-lookup"><span data-stu-id="77579-913">Enumeration value</span></span>|<span data-ttu-id="77579-914">수행한 작업</span><span class="sxs-lookup"><span data-stu-id="77579-914">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="77579-915">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="77579-915">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="77579-916"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-916">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="77579-917">매핑을 명시적으로 설정 하는 경우 입력된 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-917">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="77579-918"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-918">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="77579-919">합니다 `SourceColumn` 속성은 또한 출력에 대 한 값을 매핑할 사용 또는 입/출력 매개 변수를는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-919">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="77579-920">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-920">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="77579-921">합니다 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 열 값의 원본, 현재 또는 제안 버전 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-921">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="77579-922">이 기능은 낙관적 동시성 위반을 검사 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하도록 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-922">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-923">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-923">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="77579-924">오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면 설정 합니다 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-924">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="77579-925">내에서 행당 별로 오류에 응답할 수도 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-925">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="77579-926">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면를 `RowUpdated` 이벤트를 설정 합니다 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성을 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-926">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-927">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter>데이터 소스를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-927">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-928">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-928">The source table is invalid.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="77579-929">영향을 받는 0 개 레코드에서 INSERT, UPDATE 또는 DELETE 문을 실행 하려고가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-929">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-930">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-930">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-931">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-931">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-932">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-932">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataTable -&gt; int" Usage="dbDataAdapter.Update dataTable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable"><span data-ttu-id="77579-933"><see cref="T:System.Data.DataTable" /> 데이터 소스를 업데이트 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-933">The <see cref="T:System.Data.DataTable" /> used to update the data source.</span></span></param>
        <summary><span data-ttu-id="77579-934">삽입, 업데이트 또는 지정 된 행을 삭제 각각에 대 한 INSERT, UPDATE 또는 DELETE 문을 각각 실행 하 여 데이터베이스의 값을 업데이트 <see cref="T:System.Data.DataTable" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-934">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataTable" />.</span></span></summary>
        <returns><span data-ttu-id="77579-935">성공적으로 업데이트 된 행의 수는 <see cref="T:System.Data.DataTable" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-935">The number of rows successfully updated from the <see cref="T:System.Data.DataTable" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-936">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를 <xref:System.Data.Common.DbDataAdapter> 검사를 <xref:System.Data.DataRow.RowState%2A> 속성 합니다 에서구성된인덱스순서에따라각행에대해반복적으로필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="77579-936">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-937">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 뒤에 INSERT 문과 DELETE 문의 다른 인해의 행 순서는 DELETE 문을 실행할 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-937">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-938">유의 해야 이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다. 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-938">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="77579-939">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 문 형식 (예: 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-939">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="77579-940">자세한 내용은 [Dataadapter 사용 하 여 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-940">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="77579-941">하는 경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-941">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="77579-942">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-942">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="77579-943">설정 하지 않으면 추가적인 모든 SQL 문을에서 생성 된 후에 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-943">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="77579-944">이 세대 논리에 키 열 정보가 필요 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-944">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-945">자세한 내용은 참조 [commandbuilder를 사용 하를 사용 하 여 명령 생성](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-945">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="77579-946"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 업데이트를 수행 하기 전에 첫 번째 매핑의에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-946">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="77579-947">합니다 <xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-947">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="77579-948">반환 되는 모든 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-948">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="77579-949">모든 데이터에 다시 로드 된 후는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사할 수 있도록 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령으로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-949">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="77579-950">행을 성공적으로 업데이트 한 후 해당 행 변경 내용이 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-950">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="77579-951">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-951">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="77579-952">값을 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-952">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="77579-953"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-953">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="77579-954">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-954">The command executes.</span></span>  
  
4.  <span data-ttu-id="77579-955">명령으로 설정 되어 있으면 `FirstReturnedRecord`, 첫 번째 반환 결과에 위치한는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-955">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="77579-956">에 배치 됩니다 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-956">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="77579-957"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-957">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="77579-958"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="77579-958"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="77579-959">와 연결 된 각 명령을 <xref:System.Data.Common.DbDataAdapter> 일반적으로 연결 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-959">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="77579-960">매개 변수를 통해 현재 행에 매핑되는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-960">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="77579-961">`SourceColumn` 참조를 <xref:System.Data.DataTable> 열은는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-961">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="77579-962">`SourceColumn` 테이블 매핑을 적용 하려면 먼저 매핑되지 않은 열 이름으로 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-962">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="77579-963">하는 경우 `SourceColumn` 참조를 존재 하지 않는 열에 수행 되는 동작에 따라 달라 집니다 다음 중 하나 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-963">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="77579-964">열거형 값</span><span class="sxs-lookup"><span data-stu-id="77579-964">Enumeration value</span></span>|<span data-ttu-id="77579-965">수행한 작업</span><span class="sxs-lookup"><span data-stu-id="77579-965">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="77579-966">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="77579-966">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="77579-967"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-967">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="77579-968">매핑을 명시적으로 설정 하는 경우 입력된 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-968">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="77579-969"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-969">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="77579-970">합니다 `SourceColumn` 속성은 또한 출력에 대 한 값을 매핑할 사용 또는 입/출력 매개 변수를는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-970">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="77579-971">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-971">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="77579-972">합니다 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 열 값의 원본, 현재 또는 제안 버전 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-972">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="77579-973">이 기능은 낙관적 동시성 위반을 검사 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하도록 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-973">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-974">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-974">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="77579-975">오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면 설정 합니다 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-975">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="77579-976">내에서 행당 별로 오류에 응답할 수도 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-976">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="77579-977">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면를 `RowUpdated` 이벤트를 설정 합니다 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성을 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-977">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-978">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter>데이터 소스를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-978">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="77579-979"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-979">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-980">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-980">The source table is invalid.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="77579-981">이상 <see cref="T:System.Data.DataRow" /> 업데이트 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-981">No <see cref="T:System.Data.DataRow" /> exists to update.</span></span>  
  
<span data-ttu-id="77579-982">또는</span><span class="sxs-lookup"><span data-stu-id="77579-982">-or-</span></span> 
<span data-ttu-id="77579-983">이상 <see cref="T:System.Data.DataTable" /> 업데이트 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-983">No <see cref="T:System.Data.DataTable" /> exists to update.</span></span>  
  
<span data-ttu-id="77579-984">또는</span><span class="sxs-lookup"><span data-stu-id="77579-984">-or-</span></span> 
<span data-ttu-id="77579-985">이상 <see cref="T:System.Data.DataSet" /> 원본으로 사용 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-985">No <see cref="T:System.Data.DataSet" /> exists to use as a source.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="77579-986">영향을 받는 0 개 레코드에서 INSERT, UPDATE 또는 DELETE 문을 실행 하려고가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-986">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-987">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-987">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-988">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-988">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-989">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-989">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Update(class System.Data.DataRow[] dataRows, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Update (dataRows As DataRow(), tableMapping As DataTableMapping) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataRow[] * System.Data.Common.DataTableMapping -&gt; int" Usage="dbDataAdapter.Update (dataRows, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRows"><span data-ttu-id="77579-990">배열을 <see cref="T:System.Data.DataRow" /> 개체 데이터 소스를 업데이트 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-990">An array of <see cref="T:System.Data.DataRow" /> objects used to update the data source.</span></span></param>
        <param name="tableMapping"><span data-ttu-id="77579-991"><see cref="P:System.Data.IDataAdapter.TableMappings" /> 사용할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-991">The <see cref="P:System.Data.IDataAdapter.TableMappings" /> collection to use.</span></span></param>
        <summary><span data-ttu-id="77579-992">삽입, 업데이트 또는 삭제할 행의 지정 된 배열의 각에 대 한 INSERT, UPDATE 또는 DELETE 문을 각각 실행 하 여 데이터베이스의 값을 업데이트 <see cref="T:System.Data.DataSet" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-992">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array of <see cref="T:System.Data.DataSet" /> objects.</span></span></summary>
        <returns><span data-ttu-id="77579-993">성공적으로 업데이트 된 행의 수는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-993">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-994">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를 <xref:System.Data.Common.DbDataAdapter> 검사를 <xref:System.Data.DataRow.RowState%2A> 속성 합니다 에서구성된인덱스순서에따라각행에대해반복적으로필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="77579-994">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-995">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 뒤에 INSERT 문과 DELETE 문의 다른 인해의 행 순서는 DELETE 문을 실행할 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-995">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-996">유의 해야 이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다. 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-996">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="77579-997">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 문 형식 (예: 업데이트 하기 전에 삽입)의 시퀀스를 제어 해야 할 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-997">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERTs before UPDATEs).</span></span> <span data-ttu-id="77579-998">자세한 내용은 [Dataadapter 사용 하 여 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-998">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="77579-999">하는 경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-999">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="77579-1000">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1000">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="77579-1001">설정 하지 않으면 추가적인 모든 SQL 문을에서 생성 된 후에 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1001">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="77579-1002">이 세대 논리에 키 열 정보가 필요 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1002">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-1003">자세한 내용은 참조 [commandbuilder를 사용 하를 사용 하 여 명령 생성](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1003">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="77579-1004"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 업데이트를 수행 하기 전에 첫 번째 매핑의에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1004">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="77579-1005">합니다 <xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1005">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="77579-1006">반환 되는 모든 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1006">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="77579-1007">모든 데이터에 다시 로드 된 후는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사할 수 있도록 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령으로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1007">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="77579-1008">행을 성공적으로 업데이트 한 후 해당 행 변경 내용이 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1008">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="77579-1009">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1009">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="77579-1010">값을 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1010">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="77579-1011"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1011">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="77579-1012">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1012">The command executes.</span></span>  
  
4.  <span data-ttu-id="77579-1013">명령으로 설정 되어 있으면 `FirstReturnedRecord`, 첫 번째 반환 결과에 위치한는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1013">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="77579-1014">에 배치 됩니다 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1014">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="77579-1015"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1015">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="77579-1016"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="77579-1016"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="77579-1017">와 연결 된 각 명령을 <xref:System.Data.Common.DbDataAdapter> 일반적으로 연결 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1017">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="77579-1018">매개 변수를 통해 현재 행에 매핑되는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1018">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="77579-1019">`SourceColumn` 참조를 <xref:System.Data.DataTable> 열은는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1019">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="77579-1020">`SourceColumn` 테이블 매핑을 적용 하려면 먼저 매핑되지 않은 열 이름으로 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1020">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="77579-1021">하는 경우 `SourceColumn` 참조를 존재 하지 않는 열에 수행 되는 동작에 따라 달라 집니다 다음 중 하나 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1021">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="77579-1022">열거형 값</span><span class="sxs-lookup"><span data-stu-id="77579-1022">Enumeration value</span></span>|<span data-ttu-id="77579-1023">수행한 작업</span><span class="sxs-lookup"><span data-stu-id="77579-1023">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="77579-1024">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="77579-1024">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="77579-1025"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1025">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="77579-1026">매핑을 명시적으로 설정 하는 경우 입력된 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1026">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="77579-1027"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1027">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="77579-1028">합니다 `SourceColumn` 속성은 또한 출력에 대 한 값을 매핑할 사용 또는 입/출력 매개 변수를는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1028">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="77579-1029">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1029">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="77579-1030">합니다 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 열 값의 원본, 현재 또는 제안 버전 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1030">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="77579-1031">이 기능은 낙관적 동시성 위반을 검사 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하도록 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1031">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-1032">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1032">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="77579-1033">오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면 설정 합니다 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1033">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="77579-1034">내에서 행당 별로 오류에 응답할 수도 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1034">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="77579-1035">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면를 `RowUpdated` 이벤트를 설정 합니다 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성을 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1035">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="77579-1036"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1036">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-1037">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1037">The source table is invalid.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="77579-1038">이상 <see cref="T:System.Data.DataRow" /> 업데이트 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1038">No <see cref="T:System.Data.DataRow" /> exists to update.</span></span>  
  
<span data-ttu-id="77579-1039">또는</span><span class="sxs-lookup"><span data-stu-id="77579-1039">-or-</span></span> 
<span data-ttu-id="77579-1040">이상 <see cref="T:System.Data.DataTable" /> 업데이트 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1040">No <see cref="T:System.Data.DataTable" /> exists to update.</span></span>  
  
<span data-ttu-id="77579-1041">또는</span><span class="sxs-lookup"><span data-stu-id="77579-1041">-or-</span></span> 
<span data-ttu-id="77579-1042">이상 <see cref="T:System.Data.DataSet" /> 원본으로 사용 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1042">No <see cref="T:System.Data.DataSet" /> exists to use as a source.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="77579-1043">영향을 받는 0 개 레코드에서 INSERT, UPDATE 또는 DELETE 문을 실행 하려고가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1043">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-1044">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1044">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-1045">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1045">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-1046">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-1046">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataSet * string -&gt; int" Usage="dbDataAdapter.Update (dataSet, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><span data-ttu-id="77579-1047"><see cref="T:System.Data.DataSet" /> 데이터 소스를 업데이트 하는 데 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1047">The <see cref="T:System.Data.DataSet" /> to use to update the data source.</span></span></param>
        <param name="srcTable"><span data-ttu-id="77579-1048">테이블 매핑에 사용할 원본 테이블의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1048">The name of the source table to use for table mapping.</span></span></param>
        <summary><span data-ttu-id="77579-1049"><see cref="T:System.Data.DataTable" /> 이름이 지정된 <see cref="T:System.Data.DataSet" />에서 삽입, 업데이트 또는 삭제된 각 행마다 INSERT, UPDATE 또는 DELETE 문을 각각 실행하여 데이터베이스에 있는 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1049">Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" /> with the specified <see cref="T:System.Data.DataTable" /> name.</span></span></summary>
        <returns><span data-ttu-id="77579-1050">성공적으로 업데이트 된 행의 수는 <see cref="T:System.Data.DataSet" />합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1050">The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-1051">응용 프로그램 호출 하는 경우는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드를 <xref:System.Data.Common.DbDataAdapter> 검사를 <xref:System.Data.DataRow.RowState%2A> 속성 합니다 에서구성된인덱스순서에따라각행에대해반복적으로필요한INSERT,UPDATE또는DELETE문을실행하고<xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="77579-1051">When an application calls the <xref:System.Data.Common.DbDataAdapter.Update%2A> method, the <xref:System.Data.Common.DbDataAdapter> examines the <xref:System.Data.DataRow.RowState%2A> property, and executes the required INSERT, UPDATE, or DELETE statements iteratively for each row, based on the order of the indexes configured in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-1052">예를 들어 <xref:System.Data.Common.DbDataAdapter.Update%2A> 뒤에 INSERT 문과 DELETE 문의 다른 인해의 행 순서는 DELETE 문을 실행할 수 있습니다는 <xref:System.Data.DataTable>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1052">For example, <xref:System.Data.Common.DbDataAdapter.Update%2A> might execute a DELETE statement, followed by an INSERT statement, and then another DELETE statement, due to the ordering of the rows in the <xref:System.Data.DataTable>.</span></span>  
  
 <span data-ttu-id="77579-1053">유의 해야 이러한 문은 일괄 처리 프로세스로 수행 되지 않습니다. 각 행은 개별적으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1053">It should be noted that these statements are not performed as a batch process; each row is updated individually.</span></span> <span data-ttu-id="77579-1054">응용 프로그램에서 호출할 수는 <xref:System.Data.DataSet.GetChanges%2A> 명령문의 시퀀스를 제어 해야 하는 경우에 메서드 (예를 들어 업데이트 하기 전에 삽입).</span><span class="sxs-lookup"><span data-stu-id="77579-1054">An application can call the <xref:System.Data.DataSet.GetChanges%2A> method in situations where you must control the sequence of statement types (for example, INSERT before UPDATE).</span></span> <span data-ttu-id="77579-1055">자세한 내용은 [Dataadapter 사용 하 여 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1055">For more information, see [Updating Data Sources with DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="77579-1056">하는 경우 INSERT, UPDATE 또는 DELETE 문이 지정 되지 않았습니다는 <xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1056">If INSERT, UPDATE, or DELETE statements have not been specified, the <xref:System.Data.Common.DbDataAdapter.Update%2A> method generates an exception.</span></span> <span data-ttu-id="77579-1057">만들 수 있습니다는 <xref:System.Data.SqlClient.SqlCommandBuilder> 또는 <xref:System.Data.OleDb.OleDbCommandBuilder> 설정 하는 경우 단일 테이블 업데이트에 대 한 SQL 문을 자동으로 생성 하는 개체는 `SelectCommand` .NET Framework 데이터 공급자의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1057">However, you can create a <xref:System.Data.SqlClient.SqlCommandBuilder> or <xref:System.Data.OleDb.OleDbCommandBuilder> object to automatically generate SQL statements for single-table updates if you set the `SelectCommand` property of a .NET Framework data provider.</span></span> <span data-ttu-id="77579-1058">설정 하지 않으면 추가적인 모든 SQL 문을에서 생성 된 후에 **CommandBuilder**합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1058">Then, any additional SQL statements that you do not set are generated by the **CommandBuilder**.</span></span> <span data-ttu-id="77579-1059">이 세대 논리에 키 열 정보가 필요 합니다 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1059">This generation logic requires key column information to be present in the <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-1060">자세한 내용은 참조 [commandbuilder를 사용 하를 사용 하 여 명령 생성](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1060">For more information see [Generating Commands with CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).</span></span>  
  
 <span data-ttu-id="77579-1061"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 시나리오를 지원 합니다. 여기서는 <xref:System.Data.DataSet> 여러 개 포함 된 <xref:System.Data.DataTable> 개체 이름이 대/소문자만 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1061">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method supports scenarios where the <xref:System.Data.DataSet> contains multiple <xref:System.Data.DataTable> objects whose names differ only by case.</span></span> <span data-ttu-id="77579-1062">이름이 같지만 서로 다른 경우를 사용 하 여 여러 테이블에 존재 하는 경우는 `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A> 해당 테이블을 찾을 대/소문자 구분 비교를 수행 하 고 정확히 일치 하는 경우 예외를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1062">When multiple tables with the same name, but different case, exist in a `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A> performs a case-sensitive comparison to find the corresponding table, and generates an exception if no exact match exists.</span></span> <span data-ttu-id="77579-1063">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1063">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet ds = new DataSet();  
 ds.Tables.Add("aaa");  
 ds.Tables.Add("AAA");  
 adapter.Update(ds, "aaa"); // Updates "aaa", which already exists in the DataSet.  
 adapter.Update(ds, "AAA"); // Updates "AAA", which already exists in the DataSet.  
    adapter.Update(ds, "Aaa"); // Results in an exception.  
```  
  
 <span data-ttu-id="77579-1064">경우 <xref:System.Data.Common.DbDataAdapter.Update%2A> 라고 하며 <xref:System.Data.DataSet> 하나만 포함 되어 <xref:System.Data.DataTable> 이름이 다른 경우에 의해서만 <xref:System.Data.DataTable> 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1064">If <xref:System.Data.Common.DbDataAdapter.Update%2A> is called and the <xref:System.Data.DataSet> contains only one <xref:System.Data.DataTable> whose name differs only by case, that <xref:System.Data.DataTable> is updated.</span></span> <span data-ttu-id="77579-1065">이 시나리오에서는 비교는 대/소문자 구분.</span><span class="sxs-lookup"><span data-stu-id="77579-1065">In this scenario, the comparison is case insensitive.</span></span> <span data-ttu-id="77579-1066">다음 C# 코드는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1066">The following C# code illustrates this behavior.</span></span>  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Update(dataset, "AAA"); // Updates table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <span data-ttu-id="77579-1067"><xref:System.Data.Common.DbDataAdapter.Update%2A> 메서드 업데이트를 수행 하기 전에 첫 번째 매핑의에 나열 된 테이블에서 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1067">The <xref:System.Data.Common.DbDataAdapter.Update%2A> method retrieves rows from the table listed in the first mapping before performing an update.</span></span> <span data-ttu-id="77579-1068">합니다 <xref:System.Data.Common.DbDataAdapter.Update%2A> 다음의 값을 사용 하 여 행을 새로 고치는 <xref:System.Data.IDbCommand.UpdatedRowSource%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1068">The <xref:System.Data.Common.DbDataAdapter.Update%2A> then refreshes the row using the value of the <xref:System.Data.IDbCommand.UpdatedRowSource%2A> property.</span></span> <span data-ttu-id="77579-1069">반환 되는 모든 추가 행은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1069">Any additional rows returned are ignored.</span></span>  
  
 <span data-ttu-id="77579-1070">모든 데이터에 다시 로드 된 후는 <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생 하는 조정 된 검사할 수 있도록 <xref:System.Data.DataSet> 행 및 모든 출력 매개 변수는 명령으로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1070">After any data is loaded back into the <xref:System.Data.DataSet>, the <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised, allowing the user to inspect the reconciled <xref:System.Data.DataSet> row and any output parameters returned by the command.</span></span> <span data-ttu-id="77579-1071">행을 성공적으로 업데이트 한 후 해당 행 변경 내용이 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1071">After a row updates successfully, the changes to that row are accepted.</span></span>  
  
 <span data-ttu-id="77579-1072">사용 하는 경우 <xref:System.Data.Common.DbDataAdapter.Update%2A>, 실행 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1072">When using <xref:System.Data.Common.DbDataAdapter.Update%2A>, the order of execution is as follows:</span></span>  
  
1.  <span data-ttu-id="77579-1073">값을 <xref:System.Data.DataRow> 매개 변수 값으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1073">The values in the <xref:System.Data.DataRow> are moved to the parameter values.</span></span>  
  
2.  <span data-ttu-id="77579-1074"><xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1074">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> event is raised.</span></span>  
  
3.  <span data-ttu-id="77579-1075">명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1075">The command executes.</span></span>  
  
4.  <span data-ttu-id="77579-1076">명령으로 설정 되어 있으면 `FirstReturnedRecord`, 첫 번째 반환 결과에 위치한는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1076">If the command is set to `FirstReturnedRecord`, then the first returned result is placed in the <xref:System.Data.DataRow>.</span></span>  
  
5.  <span data-ttu-id="77579-1077">에 배치 됩니다 출력 매개 변수가 있는 경우는 <xref:System.Data.DataRow>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1077">If there are output parameters, they are placed in the <xref:System.Data.DataRow>.</span></span>  
  
6.  <span data-ttu-id="77579-1078"><xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1078">The <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> event is raised.</span></span>  
  
7.  <span data-ttu-id="77579-1079"><xref:System.Data.DataRow.AcceptChanges%2A>가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="77579-1079"><xref:System.Data.DataRow.AcceptChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="77579-1080">와 연결 된 각 명령을 <xref:System.Data.Common.DbDataAdapter> 일반적으로 연결 된 매개 변수 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1080">Each command associated with the <xref:System.Data.Common.DbDataAdapter> usually has a parameters collection associated with it.</span></span> <span data-ttu-id="77579-1081">매개 변수를 통해 현재 행에 매핑되는 `SourceColumn` 및 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1081">Parameters are mapped to the current row through the `SourceColumn` and `SourceVersion` properties of a .NET Framework data provider's `Parameter` class.</span></span> <span data-ttu-id="77579-1082">`SourceColumn` 참조를 <xref:System.Data.DataTable> 열은는 <xref:System.Data.Common.DbDataAdapter> 현재 행에 대 한 매개 변수 값을 가져오기에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1082">`SourceColumn` refers to a <xref:System.Data.DataTable> column that the <xref:System.Data.Common.DbDataAdapter> references to obtain parameter values for the current row.</span></span>  
  
 <span data-ttu-id="77579-1083">`SourceColumn` 테이블 매핑을 적용 하려면 먼저 매핑되지 않은 열 이름으로 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1083">`SourceColumn` refers to the unmapped column name before any table mappings have been applied.</span></span> <span data-ttu-id="77579-1084">하는 경우 `SourceColumn` 참조를 존재 하지 않는 열에 수행 되는 동작에 따라 달라 집니다 다음 중 하나 <xref:System.Data.MissingMappingAction> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1084">If `SourceColumn` refers to a nonexistent column, the action taken depends on one of the following <xref:System.Data.MissingMappingAction> values.</span></span>  
  
|<span data-ttu-id="77579-1085">열거형 값</span><span class="sxs-lookup"><span data-stu-id="77579-1085">Enumeration value</span></span>|<span data-ttu-id="77579-1086">수행한 작업</span><span class="sxs-lookup"><span data-stu-id="77579-1086">Action taken</span></span>|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|<span data-ttu-id="77579-1087">원본 열 이름 및 테이블 이름을 사용 하 여는 <xref:System.Data.DataSet> 매핑이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="77579-1087">Use the source column names and table names in the <xref:System.Data.DataSet> if no mapping is present.</span></span>|  
|`MissingMappingAction.Ignore`|<span data-ttu-id="77579-1088"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1088">A <xref:System.SystemException> is generated.</span></span> <span data-ttu-id="77579-1089">매핑을 명시적으로 설정 하는 경우 입력된 매개 변수의 매핑이 없을 일반적으로 오류의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1089">When the mappings are explicitly set, a missing mapping for an input parameter is usually the result of an error.</span></span>|  
|`MissingMappingAction.Error`|<span data-ttu-id="77579-1090"><xref:System.SystemException> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1090">A <xref:System.SystemException> is generated.</span></span>|  
  
 <span data-ttu-id="77579-1091">합니다 `SourceColumn` 속성은 또한 출력에 대 한 값을 매핑할 사용 또는 입/출력 매개 변수를는 `DataSet`합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1091">The `SourceColumn` property is also used to map the value for output or input/output parameters back to the `DataSet`.</span></span> <span data-ttu-id="77579-1092">존재 하지 않는 열을 참조 하는 경우 예외가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1092">An exception is generated if it refers to a nonexistent column.</span></span>  
  
 <span data-ttu-id="77579-1093">합니다 `SourceVersion` .NET Framework 데이터 공급자의 속성 `Parameter` 클래스 열 값의 원본, 현재 또는 제안 버전 사용 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1093">The `SourceVersion` property of a .NET Framework data provider's `Parameter` class determines whether to use the Original, Current, or Proposed version of the column value.</span></span> <span data-ttu-id="77579-1094">이 기능은 낙관적 동시성 위반을 검사 하는 UPDATE 문의 WHERE 절에 원래 값을 포함 하도록 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1094">This capability is often used to include original values in the WHERE clause of an UPDATE statement to check for optimistic concurrency violations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="77579-1095">행을 업데이트 하는 동안 오류가 발생 하는 경우 예외가 throw 되 고 업데이트의 실행이 중단 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1095">If an error occurs while updating a row, an exception is thrown and execution of the update is discontinued.</span></span> <span data-ttu-id="77579-1096">오류가 발생 하는 경우 예외를 생성 하지 않고 업데이트 작업을 계속 하려면 설정 합니다 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 속성을 `true` 호출 하기 전에 <xref:System.Data.Common.DbDataAdapter.Update%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1096">To continue the update operation without generating exceptions when an error is encountered, set the <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> property to `true` before calling <xref:System.Data.Common.DbDataAdapter.Update%2A>.</span></span> <span data-ttu-id="77579-1097">내에서 행당 별로 오류에 응답할 수도 있습니다는 `RowUpdated` DataAdapter의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1097">You may also respond to errors on a per-row basis within the `RowUpdated` event of a DataAdapter.</span></span> <span data-ttu-id="77579-1098">내에서 예외를 생성 하지 않고 업데이트 작업을 계속 하려면를 `RowUpdated` 이벤트를 설정 합니다 <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> 의 속성을 <xref:System.Data.Common.RowUpdatedEventArgs> 를 <xref:System.Data.UpdateStatus.Continue>입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1098">To continue the update operation without generating an exception within the `RowUpdated` event, set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property of the <xref:System.Data.Common.RowUpdatedEventArgs> to <xref:System.Data.UpdateStatus.Continue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-1099">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter>데이터 소스를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1099">The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="77579-1100"><see cref="T:System.Data.DataSet" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1100">The <see cref="T:System.Data.DataSet" /> is invalid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="77579-1101">원본 테이블에 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1101">The source table is invalid.</span></span></exception>
        <exception cref="T:System.Data.DBConcurrencyException"><span data-ttu-id="77579-1102">영향을 받는 0 개 레코드에서 INSERT, UPDATE 또는 DELETE 문을 실행 하려고가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1102">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected.</span></span></exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-1103">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1103">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-1104">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1104">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-1105">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-1105">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UpdateBatchSize">
      <MemberSignature Language="C#" Value="public virtual int UpdateBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UpdateBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property UpdateBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int UpdateBatchSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateBatchSize : int with get, set" Usage="System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-1106">가져옵니다 또는 일괄 처리 지원을 사용 하지 않도록 설정 하거나 값을 설정 하 고 일괄 처리에서 실행 될 수 있는 명령 수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1106">Gets or sets a value that enables or disables batch processing support, and specifies the number of commands that can be executed in a batch.</span></span></summary>
        <value><span data-ttu-id="77579-1107">일괄 작업당 처리할 행 수입니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1107">The number of rows to process per batch.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="77579-1108">값은</span><span class="sxs-lookup"><span data-stu-id="77579-1108">Value is</span></span> 
 </term><description> <span data-ttu-id="77579-1109">효과</span><span class="sxs-lookup"><span data-stu-id="77579-1109">Effect</span></span> 
 </description></listheader><item><term> <span data-ttu-id="77579-1110">0</span><span class="sxs-lookup"><span data-stu-id="77579-1110">0</span></span> 
 </term><description> <span data-ttu-id="77579-1111">일괄 작업 크기에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1111">There is no limit on the batch size.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="77579-1112">1</span><span class="sxs-lookup"><span data-stu-id="77579-1112">1</span></span> 
 </term><description> <span data-ttu-id="77579-1113">일괄 처리 업데이트는 사용 하지 않도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1113">Disables batch updating.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="77579-1114">&gt; 1</span><span class="sxs-lookup"><span data-stu-id="77579-1114">&gt; 1</span></span> 
 </term><description> <span data-ttu-id="77579-1115">변경 내용이 일괄 처리를 사용 하 여 전송 됩니다 <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" /> 번 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1115">Changes are sent using batches of <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" /> operations at a time.</span></span>  
  
 </description></item></list>  

 <span data-ttu-id="77579-1116">이 1이 아닌 값으로 설정 하는 경우 모든 명령이 연결 된 합니다 <see cref="T:System.Data.Common.DbDataAdapter" /> 있어야 해당 <see cref="P:System.Data.IDbCommand.UpdatedRowSource" /> 속성이로 설정 **None** 또는 **OutputParameters**합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1116">When setting this to a value other than 1, all the commands associated with the <see cref="T:System.Data.Common.DbDataAdapter" /> must have their <see cref="P:System.Data.IDbCommand.UpdatedRowSource" /> property set to **None** or **OutputParameters**.</span></span> <span data-ttu-id="77579-1117">그렇지 않으면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1117">An exception will be thrown otherwise.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-1118">사용 합니다 <xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A> 속성에서 변경 된 데이터 소스를 업데이트 하는 <xref:System.Data.DataSet>합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1118">Use the <xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A> property to update a data source with changes from a <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="77579-1119">데이터 공급자가 일괄 처리를 지 원하는 경우 서버에 왕복 횟수를 줄여 응용 프로그램 성능을 향상 시킬 수이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1119">If the data provider supports batch processing, this can increase application performance by reducing the number of round-trips to the server.</span></span> <span data-ttu-id="77579-1120">ADO.NET 2.0에서는이 속성은 SQL Server (SqlClient) 및 Oracle (OracleClient) 용.NET 데이터 공급자에 대 한 지원.</span><span class="sxs-lookup"><span data-stu-id="77579-1120">In ADO.NET 2.0, this property is supported for the .NET data providers for SQL Server (SqlClient) and Oracle (OracleClient).</span></span>  
  
 <span data-ttu-id="77579-1121">너무 큰 배치를 실행하면 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1121">Executing an extremely large batch could decrease performance.</span></span> <span data-ttu-id="77579-1122">따라서 응용 프로그램을 구현하기 전에 최적의 배치 크기 설정을 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1122">Therefore, you should test for the optimum batch size setting before implementing your application.</span></span>  
  
 <span data-ttu-id="77579-1123"><xref:System.ArgumentOutOfRangeException> 0 보다 작은 값을 숫자로 설정 된 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1123">An <xref:System.ArgumentOutOfRangeException> will be thrown if the value is set to a number less than zero.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-1124">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1124">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-1125">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1125">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-1126">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-1126">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ UpdateCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="77579-1127">데이터 원본에서 레코드를 업데이트 하는 데 사용 하는 명령을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1127">Gets or sets a command used to update records in the data source.</span></span></summary>
        <value><span data-ttu-id="77579-1128">A <see cref="T:System.Data.IDbCommand" /> 하는 동안 사용 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 데이터 집합의 수정 된 행에 대 한 데이터 원본에서 레코드를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1128">A <see cref="T:System.Data.IDbCommand" /> used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> to update records in the data source for modified rows in the data set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="77579-1129">하는 동안 <xref:System.Data.Common.DbDataAdapter.Update%2A>이면이 속성은 설정 되지 않으며 기본 키 정보에 있으면 합니다 <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.UpdateCommand%2A> 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1129">During <xref:System.Data.Common.DbDataAdapter.Update%2A>, if this property is not set and primary key information is present in the <xref:System.Data.DataSet>, the <xref:System.Data.IDbDataAdapter.UpdateCommand%2A> will be automatically generated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="77579-1130">다음 예제에서는 파생된 클래스 <xref:System.Data.OleDb.OleDbDataAdapter> 속성 중 일부를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="77579-1130">The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.</span></span>  
  
 [!code-csharp[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md"><span data-ttu-id="77579-1131">데이터 조작(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1131">Manipulating Data (ADO.NET)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1"><span data-ttu-id="77579-1132">DbProviderFactory(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="77579-1132">DbProviderFactories (ADO.NET)</span></span></related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md"><span data-ttu-id="77579-1133">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="77579-1133">ADO.NET Overview</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>