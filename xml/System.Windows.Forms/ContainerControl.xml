<Type Name="ContainerControl" FullName="System.Windows.Forms.ContainerControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3a7dadb514f0520d08b7dd706963b46dfae309e9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30640457" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContainerControl : System.Windows.Forms.ScrollableControl, System.Windows.Forms.IContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerControl extends System.Windows.Forms.ScrollableControl implements class System.Windows.Forms.IContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerControl&#xA;Inherits ScrollableControl&#xA;Implements IContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerControl : System::Windows::Forms::ScrollableControl, System::Windows::Forms::IContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ScrollableControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Forms.IContainerControl</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>다른 컨트롤의 컨테이너로 작동할 수 있는 컨트롤에 대한 포커스 관리 기능을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Forms.ContainerControl> 제어 하 고 포커스 관리 기능을 제공 하는 다른 컨테이너 처럼 기능 할 수 있는 컨트롤을 나타냅니다. 이 클래스에서 상속 하는 컨트롤 포함 하는 다른 컨테이너 내에서 포커스를 어딘가에 이동 하는 경우에 활성 컨트롤을 추적할 수 있습니다.  
  
 <xref:System.Windows.Forms.ContainerControl> 개체는 포함 된 컨트롤에 대 한 논리적 경계를 제공합니다. 컨테이너 컨트롤 수 탭 키 누름 캡처하고 컬렉션의 다음 컨트롤로 포커스를 이동 합니다.  
  
> [!NOTE]
>  컨테이너 컨트롤이 포커스를 받을 하지 않습니다. 포함 된 컨트롤의 컬렉션에서 첫 번째 자식 컨트롤에 포커스가 항상 설정 됩니다.  
  
 직접 일반적으로 상속 하지 않습니다는 <xref:System.Windows.Forms.ContainerControl> 클래스입니다. <xref:System.Windows.Forms.Form><xref:System.Windows.Forms.UserControl>, 및 <xref:System.Windows.Forms.UpDownBase> 클래스에서 상속 <xref:System.Windows.Forms.ContainerControl>합니다.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.UserControl" />
    <altmember cref="T:System.Windows.Forms.UpDownBase" />
    <altmember cref="T:System.Windows.Forms.IContainerControl" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.ContainerControl" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 상속 되는 <xref:System.Windows.Forms.ScrollableControl> 클래스 및 구현 하는 <xref:System.Windows.Forms.IContainerControl> 인터페이스입니다. 구현에 추가 되 고 <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> 속성 및 <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> 메서드.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control ActiveControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control ActiveControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.ActiveControl" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ ActiveControl { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IContainerControl.ActiveControl</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨테이너 컨트롤에 있는 활성 컨트롤을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Control" />에서 현재 활성 상태에 있는 <see cref="T:System.Windows.Forms.ContainerControl" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> 속성 활성화 하거나 컨테이너 컨트롤에 있는 활성 컨트롤을 검색 합니다.  
  
 이 속성에서 올바른 값을 받으려면이 클래스를 호출 하는 개체 포함 하거나 또는 호출 하는 컨트롤에 포함 되어야 합니다. 한 가지 형태에서 다른 폼을 호출 하려고 하는 경우 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> 속성을 정의 되지 않은 값을 받게 됩니다. 이 경우이 데이터를 전달 하는 형식 간 통신 메커니즘을 직접를 정의 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 상속 되는 <xref:System.Windows.Forms.ScrollableControl> 클래스 및 구현 하는 <xref:System.Windows.Forms.IContainerControl> 인터페이스입니다. 구현에 추가 되 고 <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> 속성 및 <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> 메서드.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">할당된 <see cref="T:System.Windows.Forms.Control" />을 활성화할 수 없는 경우</exception>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
        <altmember cref="T:System.Windows.Forms.Control" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          스크롤 막대를 표시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>현재 컨트롤 위치 및 현재 선택된 컨트롤에 따라 컨테이너의 스크롤 막대를 조정합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ScrollableControl.AdjustFormScrollbars(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleDimensions">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF AutoScaleDimensions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF AutoScaleDimensions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScaleDimensions As SizeF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::SizeF AutoScaleDimensions { System::Drawing::SizeF get(); void set(System::Drawing::SizeF value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디자인된 컨트롤의 크기를 가져오거나 설정합니다.</summary>
        <value>디자인된 컨트롤의 <see cref="T:System.Drawing.SizeF" /> 크기 또는 DPI(Dots Per Inch)를 포함하는 <see cref="T:System.Drawing.Font" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> 속성은 컨트롤에 맞게 크기가 조정 되었거나 하기 위한 화면 DPI 또는 글꼴 설정을 나타냅니다. 특히, 디자인 타임이이 속성은 Windows Forms 디자이너에서 값으로 설정할 수는 모니터 현재 사용 중입니다. 그런 다음 폼을 로드를 실행 하는 경우는 <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> 속성 간에 차이가 있는 <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A>, <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> 메서드 및 모든 자식 컨트롤의 크기를 조정 하기 위해 호출 되 합니다. 이후에 <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> 새 크기 조정 값을 반영 하도록 업데이트 됩니다.  
  
 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 값을 설정할 때 <see cref="T:System.Drawing.SizeF" /> 값의 너비 또는 높이가 0보다 작은 경우</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleFactor">
      <MemberSignature Language="C#" Value="protected System.Drawing.SizeF AutoScaleFactor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF AutoScaleFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property AutoScaleFactor As SizeF" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::SizeF AutoScaleFactor { System::Drawing::SizeF get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 자동 크기 조정 값과 디자인 타임의 자동 크기 조정 값 사이의 배율 인수를 가져옵니다.</summary>
        <value>현재 자동 크기 조정 값과 디자인 타임 자동 크기 조정 값 사이의 크기 조정 비율을 포함하는 <see cref="T:System.Drawing.SizeF" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> 속성 간의 배율 인수를 나타내는 <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> 및 <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> 속성입니다. 필요한 경우이 값은 계산 됩니다. 예를 들어 경우 <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> 는 (192, 144) 및 <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> 는 (96, 96)는 다음 <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> 는 (2.0, 1.5).  
  
 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoScaleMode AutoScaleMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoScaleMode AutoScaleMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScaleMode As AutoScaleMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoScaleMode AutoScaleMode { System::Windows::Forms::AutoScaleMode get(); void set(System::Windows::Forms::AutoScaleMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoScaleMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 자동 크기 조정 모드를 가져오거나 설정합니다.</summary>
        <value>현재 크기 조정 모드를 나타내는 <see cref="T:System.Windows.Forms.AutoScaleMode" />입니다. 기본값은 <see cref="F:System.Windows.Forms.AutoScaleMode.None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> 속성이이 컨트롤의 현재 자동 크기 조정 모드를 지정 합니다. 통해 크기 조정 <xref:System.Windows.Forms.AutoScaleMode.Font> 은 확장 되거나 운영 체제의 글꼴 크기에 따라 축소 하려면 컨트롤이 나 폼의 크기에 상관 없이 때 사용 해야 하는 경우 유용 합니다. 통해 크기 조정 <xref:System.Windows.Forms.AutoScaleMode.Dpi> 컨트롤이 나 폼 화면을 기준으로 크기를 조정 하려는 경우 유용 합니다. 예를 들어, 다음에 항상 특정 화면 비율을 차지 하는 차트 또는 기타 그래픽을 표시 하는 컨트롤 크기 조정 (인치당 도트 수) 인을 사용 하는 것이 좋습니다.  
  
 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">유효하지 않은 <see cref="T:System.Windows.Forms.AutoScaleMode" /> 값을 사용하여 이 속성을 설정한 경우</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>포커스가 변경될 때 이 컨테이너의 컨트롤에 대한 유효성 검사가 자동으로 수행되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>포커스가 변경될 때 암시적으로 포함된 컨트롤의 유효성을 검사할지 여부를 나타내는 <see cref="T:System.Windows.Forms.AutoValidate" /> 열거형 값입니다. 기본값은 <see cref="F:System.Windows.Forms.AutoValidate.Inherit" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 기본값 <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> 각 컨트롤에 따라 달라 집니다. 암시적 유효성 검사에 대 한 자세한 내용은 참조 하십시오. [Windows Forms에서 사용자 입력 유효성 검사](~/docs/framework/winforms/user-input-validation-in-windows-forms.md)합니다.  
  
 이 속성을 새 값을 설정에서 발생 된 <xref:System.Windows.Forms.ContainerControl.AutoValidateChanged> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 양식 및 포함된 된 컨트롤의 모든 암시적 유효성 검사를 해제 하 고 마우스 단추를 클릭할 때 대신 유효성 검사의 모든 폼의 자식을 수동으로 수행 합니다.  
  
 [!code-csharp[ValidateChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildren/CS/Form1.cs#1)]
 [!code-vb[ValidateChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildren/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">유효하지 않은 <see cref="T:System.Windows.Forms.AutoValidate" /> 값을 사용하여 이 속성을 설정한 경우</exception>
        <altmember cref="T:System.Windows.Forms.AutoValidate" />
        <altmember cref="Overload:System.Windows.Forms.ContainerControl.Validate" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.ContainerControl.AutoValidate" /> 속성이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A>  
  
 <xref:System.Windows.Forms.ContainerControl.OnAutoValidateChanged%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 <see cref="T:System.Windows.Forms.BindingContext" />를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 <see cref="T:System.Windows.Forms.BindingContext" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected override bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IME 지원을 사용하도록 <see cref="P:System.Windows.Forms.Control.ImeMode" /> 속성을 활성 값으로 설정할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          모든 경우에 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 및 이상 버전에서는 IME 기능 프레임 워크에 의해 처리 되 고 개별 컨트롤에 대 한 기본 입력기 지원을 사용할 수 없습니다.  
  
 사용자 정의 컨트롤에서 파생 되는 <xref:System.Windows.Forms.ContainerControl> 클래스 반환 하도록이 속성을 재정의 하 여 네이티브 IME 지원을 사용 하도록 설정할 수 `true`합니다. 응용 프로그램은 네이티브 IME 및 Windows Forms IME 간에 충돌이 발생 하지 않았는지 확인 해야 합니다. 이 시나리오는 지원 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 핸들이 만들어지는 경우 필요한 작성 매개 변수를 가져옵니다.</summary>
        <value>컨트롤 핸들을 만들 때 필요한 작성 매개 변수가 포함된 <see cref="T:System.Windows.Forms.CreateParams" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentAutoScaleDimensions">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF CurrentAutoScaleDimensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF CurrentAutoScaleDimensions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentAutoScaleDimensions As SizeF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::SizeF CurrentAutoScaleDimensions { System::Drawing::SizeF get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>화면의 현재 런타임 크기를 가져옵니다.</summary>
        <value>화면의 현재 DPI(Dots Per Inch) 또는 <see cref="T:System.Drawing.SizeF" /> 크기를 포함하는 <see cref="T:System.Drawing.Font" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> 현재 화면에 참조 차원 속성을 나타냅니다. 반면,는 <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> 속성 디자인 환경은 현재 컨트롤의 디자인 타임 참조 크기를 나타내는 동안는 <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> 속성은 둘의 비율입니다.  
  
 차원 값의 해석에 따라 달라 집니다는 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> 다음과 같은 방법으로 속성:  
  
-   모드가 이면 <xref:System.Windows.Forms.AutoScaleMode.Dpi>,이 속성은 인치당 도트 수 화면 해상도 나타냅니다.  
  
-   모드가 이면 <xref:System.Windows.Forms.AutoScaleMode.Font>,이 속성은 평균 글꼴 문자 크기 (픽셀)를 나타냅니다.  
  
 경우는 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> 속성이 <xref:System.Windows.Forms.AutoScaleMode.None>, <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> 같게 설정 된 <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A>합니다.  
  
 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">현재 화면에 대해 Win32 장치 컨텍스트를 만들 수 없는 경우</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.Control" />과 해당 자식 컨트롤에서 사용하는 관리되지 않는 리소스를 해제하고, 필요에 따라 관리되는 리소스를 해제할 수도 있습니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OnAutoValidateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoValidateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoValidateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoValidateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoValidateChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.ContainerControl.OnAutoValidateChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.Control.CreateControl" /> 메서드를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.FontChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 글꼴 변경는 <xref:System.Windows.Forms.ContainerControl> 레이아웃을 다시 계산 하는 경우 포함 된 컨트롤에 다시 적용 하면는 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> 속성의 값은 <xref:System.Windows.Forms.AutoScaleMode.Font>합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.ContainerControl.OnFontChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (e As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.LayoutEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Layout" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnParentChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ParentChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ParentForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ParentForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ParentForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.ParentForm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ParentForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨테이너 컨트롤이 할당된 폼을 가져옵니다.</summary>
        <value>컨테이너 컨트롤이 할당된 <see cref="T:System.Windows.Forms.Form" />입니다. 컨트롤이 Internet Explorer 내부에 호스팅되어 있거나 부모 폼이 없는 다른 호스팅 컨텍스트에 호스팅되어 있는 경우 이 속성은 null을 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 두 개의 폼을 만드는 방법을 보여 줍니다: `Form1` 및 `Form2`합니다. 설정의 <xref:System.Windows.Forms.Form.IsMdiContainer%2A> 속성 `Form1` 를 `true` 있도록는 <xref:System.Windows.Forms.Form.MdiParent%2A> 의 `Form2`합니다. 다음으로 단추를 만듭니다 `button1`, 각 폼에 있습니다. 부모 폼에 단추를 클릭 하면 이벤트 처리기는 자식 폼을 표시 합니다. 자식 폼에 단추를 클릭 하면 이벤트 처리기 표시는 <xref:System.Windows.Forms.Control.Name%2A> 부모 폼의 속성입니다. 다음 두 코드 세그먼트를 사용 하 여 덮어쓸 `button1` 두 형태 모두에서 이벤트 처리기입니다.  
  
 [!code-cpp[ParentForm2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentForm2/CPP/form1.cpp#1)]
 [!code-csharp[ParentForm2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentForm2/CS/form1.cs#1)]
 [!code-vb[ParentForm2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentForm2/VB/form1.vb#1)]  
  
 [!code-cpp[ParentForm2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentForm2/CPP/form2.cpp#2)]
 [!code-csharp[ParentForm2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentForm2/CS/form2.cs#2)]
 [!code-vb[ParentForm2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentForm2/VB/form2.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성 값을 가져오는 모든 창입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="PerformAutoScale">
      <MemberSignature Language="C#" Value="public void PerformAutoScale ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformAutoScale() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformAutoScale ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformAutoScale();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨테이너 컨트롤과 해당 자식 컨트롤의 크기를 조정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명시적으로 호출 된 <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> 메서드는 일반적으로 런타임 동안 레이아웃에 프로그래밍 방식으로 변경 된 후에 필요 합니다. <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> 암시적으로 호출 되는 <xref:System.Windows.Forms.ContainerControl.OnLayout%2A> 메서드.  
  
 <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> 재귀적;입니다. 각 하위 컨트롤과 컨테이너, 경우에 호출 컨테이너의 버전을 실행 하는 경우이 메서드의 버전이 있습니다.  
  
 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <param name="keyData">처리할 키를 나타내는 <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>명령 키를 처리합니다.</summary>
        <returns>
          컨트롤이 문자를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">처리할 문자입니다.</param>
        <summary>대화 상자 문자를 처리합니다.</summary>
        <returns>
          컨트롤이 문자를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">처리할 키를 나타내는 <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>대화 상자 키를 처리합니다.</summary>
        <returns>
          컨트롤이 키를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">처리할 문자입니다.</param>
        <summary>니모닉 문자를 처리합니다.</summary>
        <returns>
          컨트롤이 문자를 니모닉으로 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessTabKey(bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          <see cref="T:System.Windows.Forms.ContainerControl" />의 컨트롤 전체를 순환하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>사용 가능한 다음 컨트롤을 선택하여 활성 컨트롤로 만듭니다.</summary>
        <returns>
          컨트롤이 선택되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤과 해당 <xref:System.Windows.Forms.Control.TabStop%2A> 속성이로 설정 `false` 되므로 사용 가능한 다음 컨트롤을 선택할 수는 선택할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">
          선택할 컨트롤의 방향을 지정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="forward">
          탭 순서에서 앞으로 이동하려면 <see langword="true" />이고, 뒤로 이동하려면 <see langword="false" />입니다.</param>
        <summary>자식 컨트롤을 활성화합니다. 또한 필요에 따라 컨트롤을 선택할 탭 순서의 방향을 지정합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IContainerControl.ActivateControl">
      <MemberSignature Language="C#" Value="bool IContainerControl.ActivateControl (System.Windows.Forms.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Forms.IContainerControl.ActivateControl(class System.Windows.Forms.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.System#Windows#Forms#IContainerControl#ActivateControl(System.Windows.Forms.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Forms.IContainerControl.ActivateControl(System::Windows::Forms::Control ^ control) = System::Windows::Forms::IContainerControl::ActivateControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IContainerControl.ActivateControl(System.Windows.Forms.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="control">활성화할 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <summary>지정된 컨트롤을 활성화합니다.</summary>
        <returns>
          컨트롤이 제대로 활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `control` 매개 변수는 컨테이너 컨트롤의 자식 이어야 합니다.  
  
   
  
## Examples  
 상속 하는 방법은 다음 코드 예제는 <xref:System.Windows.Forms.ScrollableControl> 클래스 및 구현에서 <xref:System.Windows.Forms.IContainerControl> 인터페이스입니다. 구현에 추가 되 고 <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> 속성 및 <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> 메서드.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected virtual void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void UpdateDefaultButton();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 기본 단추를 업데이트합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl> 클래스에 대 한 구현을 제공 하지 않습니다는 <xref:System.Windows.Forms.ContainerControl.UpdateDefaultButton%2A> 메서드. 이 메서드를 상속 하는 클래스를 구현 해야 <xref:System.Windows.Forms.ContainerControl.UpdateDefaultButton%2A> 기본 단추를 업데이트 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Validating" /> 및 <see cref="E:System.Windows.Forms.Control.Validated" /> 이벤트를 순서대로 발생시켜 포커스를 잃는 컨트롤의 값을 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public bool Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Function Validate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Validate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Validating" /> 및 <see cref="E:System.Windows.Forms.Control.Validated" /> 이벤트를 순서대로 발생시켜 포커스를 잃는 컨트롤의 값을 확인합니다.</summary>
        <returns>
          유효성 검사가 성공하는 경우 <see langword="true" />, 아닌 경우 <see langword="false" />입니다. 이 메서드는 <see cref="E:System.Windows.Forms.Control.Validating" /> 또는 <see cref="E:System.Windows.Forms.Control.Validated" /> 이벤트 처리기에서 호출된 경우 항상 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.Validate%2A> 메서드 유효성이 검사 되지 않은 마지막 자식 컨트롤 및 해당 상위, 포함 하지 않고, 현재 컨테이너 컨트롤의 유효성을 검사 합니다. 이 오버 로드 된 버전의 값에 관계 없이 유효성 검사를 항상 수행는 <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> 부모 컨트롤의 속성입니다. 따라서 무조건 유효성 검사를 강제로 사용 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public bool Validate (bool checkAutoValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Validate(bool checkAutoValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Validate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Validate (checkAutoValidate As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Validate(bool checkAutoValidate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkAutoValidate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="checkAutoValidate">
          <see langword="true" />인 경우 <see cref="P:System.Windows.Forms.ContainerControl.AutoValidate" /> 속성 값을 사용하여 유효성 검사의 수행 여부를 결정하고, <see langword="false" />인 경우 무조건 유효성 검사를 수행합니다.</param>
        <summary>자동 유효성 검사가 켜져 있는지 여부에 따라 포커스를 잃는 컨트롤의 값을 확인합니다.</summary>
        <returns>
          유효성 검사가 성공하는 경우 <see langword="true" />, 아닌 경우 <see langword="false" />입니다. 이 메서드는 <see cref="E:System.Windows.Forms.Control.Validating" /> 또는 <see cref="E:System.Windows.Forms.Control.Validated" /> 이벤트 처리기에서 호출된 경우 항상 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.Validate%2A> 메서드 유효성이 검사 되지 않은 마지막 자식 컨트롤 및 해당 상위, 포함 하지 않고, 현재 컨테이너 컨트롤의 유효성을 검사 합니다. 이 오버 로드 된 버전은 다음 조건에 따라 유효성 검사를 수행 합니다.  
  
-   경우는 `checkAutoValidate` 매개 변수는 `true`, 유효성 검사는 항상 자식 컨트롤의 유효성은 검사에 대해 발생 합니다.  
  
-   경우는 `checkAutoValidate` 매개 변수는 `false`, 경우에 유효성 검사가 수행는 <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> 부모 컨트롤의 속성을 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤 내에서 유효성 검사를 지원하는 모든 자식 컨트롤이 해당 데이터의 유효성을 검사하도록 합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public virtual bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ValidateChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤 내에서 유효성 검사를 지원하는 모든 자식 컨트롤이 해당 데이터의 유효성을 검사하도록 합니다.</summary>
        <returns>
          모든 자식의 유효성을 검사했으면 <see langword="true" />이고, 검사하지 못했으면 <see langword="false" />입니다. 이 메서드는 <see cref="E:System.Windows.Forms.Control.Validating" /> 또는 <see cref="E:System.Windows.Forms.Control.Validated" /> 이벤트 처리기에서 호출된 경우 항상 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> 컨트롤의 계층 구조를 상속 되며 유효성 검사를 지원 하는지 확인 하려면 각 컨트롤을 검사 합니다. 사용자가 컨트롤을 선택할 수 있으면 해당 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성은 `true`, <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> 하면는 <xref:System.Windows.Forms.Control.Validating> 이벤트를 발생 합니다. 컨트롤을 취소 하는 경우는 <xref:System.Windows.Forms.Control.Validating> 이벤트의 경우이 메서드는 반환 `false`, 그렇지 않으면 반환 됩니다 `true`합니다.  
  
 컨트롤을 데이터 원본에 바인딩되는지 여부 및 <xref:System.Windows.Forms.Control.Validating> 컨트롤에서 현재 데이터를 데이터 원본에 다시 푸시을 하면 이벤트가 발생 합니다.  
  
 호출 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> 호출과 같습니다 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> 와 <xref:System.Windows.Forms.ValidationConstraints> 의 <xref:System.Windows.Forms.ValidationConstraints.None>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 양식 및 포함된 된 컨트롤의 모든 암시적 유효성 검사를 해제 하 고 마우스 단추를 클릭할 때 대신 유효성 검사의 모든 폼의 자식을 수동으로 수행 합니다.  
  
 [!code-csharp[ValidateChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildren/CS/Form1.cs#1)]
 [!code-vb[ValidateChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildren/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public virtual bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">
          <see cref="E:System.Windows.Forms.Control.Validating" /> 이벤트가 발생한 컨트롤을 제한합니다.</param>
        <summary>컨트롤 내에서 유효성 검사를 지원하는 모든 자식 컨트롤이 해당 데이터의 유효성을 검사하도록 합니다.</summary>
        <returns>
          모든 자식의 유효성을 검사했으면 <see langword="true" />이고, 검사하지 못했으면 <see langword="false" />입니다. 이 메서드는 <see cref="E:System.Windows.Forms.Control.Validating" /> 또는 <see cref="E:System.Windows.Forms.Control.Validated" /> 이벤트 처리기에서 호출된 경우 항상 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> 현재 컨트롤의 모든 자식 항목을 검토 하는 원인이 <xref:System.Windows.Forms.Control.Validating> 이벤트의 조건을 충족 하는 경우 컨트롤에서 발생을 정확 하 게 입력 하 여 <xref:System.Windows.Forms.ValidationConstraints>합니다.  
  
 여러를 사용할 수 있습니다 <xref:System.Windows.Forms.ValidationConstraints> 비트 OR 연산자를 결합 하 여 한 번에 매개 변수입니다. 비트 OR 연산자와 매개 변수를 결합 한 논리적 AND 연산을 발생 합니다. 예를 들어 호출 `ValidateChildren(ValidationConstraints.ImmediateChildren | ValidationConstraints.Enabled)` 만 발생 합니다는 <xref:System.Windows.Forms.Control.Validating> 컨테이너의 직계 자식이 고 설정 된 컨트롤에는 이벤트입니다.  
  
 이 메서드에 대해 지정 하는 매개 변수에 관계 없이 컨트롤 있어야 해당 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이로 설정 `true` 되려면에서 해당 <xref:System.Windows.Forms.Control.Validating> 이벤트를 발생 합니다. 설정 해야는 <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> 컨트롤 또는 컨트롤의 컨테이너 속성 `false` 호출할 때만 발생 하는 유효성 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A>, 하지 사용자 이동할 때 포커스 컨트롤에서 및 합니다.  
  
 컨트롤을 데이터 원본에 바인딩되는지 여부 및 <xref:System.Windows.Forms.Control.Validating> 컨트롤에서 현재 데이터를 데이터 원본에 다시 푸시을 하면 이벤트가 발생 합니다.  
  
 반대의 결과 얻을 수 없는 <xref:System.Windows.Forms.ValidationConstraints> 비트 부정 연산자를 적용 하 여 매개 변수입니다. 예를 들어의 음수 값을 제공 하는 경우는 <xref:System.Windows.Forms.ValidationConstraints.Visible> 필드를 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A>, 컨테이너에서 볼 수 없는 모든 자식 항목을 검사 하지 것입니다. 에 음수 매개 변수를 제공 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> 컨테이너 또는 해당 자식에 영향을 미치지 것입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 하면는 <xref:System.Windows.Forms.Control.Validating> 이벤트를 폼의 직계 자식을 갖는 발생 <xref:System.Windows.Forms.Control.Enabled%2A> 속성은 `true`합니다.  
  
 [!code-csharp[ValidateChildrenWithConstraints#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildrenWithConstraints/CS/Form1.cs#1)]
 [!code-vb[ValidateChildrenWithConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildrenWithConstraints/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">처리할 Windows <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>Windows 메시지를 처리합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>