<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c88f8672a65894ced1dff6fde3334fb2d268fec2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30651287" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows의 RichTextBox 컨트롤을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 <xref:System.Windows.Forms.RichTextBox> 컨트롤, 사용자를 입력 하 고 텍스트를 편집할 수 있습니다. 컨트롤의 표준 보다 향상된 된 서식 기능을 제공 <xref:System.Windows.Forms.TextBox> 제어 합니다. 텍스트는 컨트롤에 직접 할당할 수 또는 서식 있는 텍스트 형식 (RTF) 또는 일반 텍스트 파일에서 로드할 수 있습니다. 문자 및 단락 서식을 컨트롤 내의 텍스트를 할당할 수 있습니다.  
  
 <xref:System.Windows.Forms.RichTextBox> 컨트롤은 다양 한 일부 컨트롤에서 텍스트에 서식을 적용 하려면 사용할 수 있는 속성을 제공 합니다. 텍스트의 서식을 변경할 것을 먼저 선택 해야 합니다. 문자 및 단락 서식을 선택한 텍스트를 할당할 수 있습니다. 선택한 텍스트의 섹션으로 설정을 수행 되지 않은 되 면 컨트롤의 문서의 다른 섹션 이나 선택 포맷 동일한 설정을 사용 하 여 설정을 변경 될 때까지 다음에 입력 한 모든 텍스트 선택 되어 있습니다. <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> 속성 굵게, 기울임꼴 텍스트를 만들 수 있습니다. 또한 크기 및 텍스트의 서체 변경 하려면이 속성을 사용할 수 있습니다. <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 속성을 사용 하면 텍스트의 색을 변경할 수 있습니다. 사용할 수 있습니다 글머리 기호 목록을 만드는 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성입니다. 단락 서식 설정 하 여 조정할 수도 있습니다는 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성입니다.  
  
 <xref:System.Windows.Forms.RichTextBox> 컨트롤은 파일 열기 및 저장에 대 한 기능을 제공 하는 방법을 제공 합니다. <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드를 사용 하면 컨트롤에 기존 서식 있는 텍스트 또는 ASCII 텍스트 파일을 로드할 수 있습니다. 열린된 데이터 스트림에서 데이터를 로드할 수도 있습니다. <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 서식 있는 텍스트 또는 ASCII 텍스트 파일을 저장할 수 있습니다. 비슷합니다는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드를 사용할 수도 있습니다는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 개방형 데이터 스트림으로 저장 하는 메서드. <xref:System.Windows.Forms.RichTextBox> 컨트롤 텍스트 문자열을 찾기 위한 기능을 제공 합니다. <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드는 오버 로드도 특정 문자는 컨트롤의 텍스트 내에서 텍스트 문자열을 찾으려고 합니다.  
  
 초기화할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 메모리에 저장 된 데이터를 제어 합니다. 예를 들어 초기화할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성의 텍스트 서식을 방법을 결정 하는 RTF 코드를 포함 하 여, 표시할 텍스트를 포함 하는 문자열을 합니다.  
  
 컨트롤 내의 텍스트를 웹 사이트에 대 한 링크와 같은 링크를 포함 하는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> 속성을 컨트롤의 텍스트에 링크를 적절 하 게 표시 합니다. 그런 다음 처리할 수는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 링크와 관련 된 작업을 수행 하는 이벤트입니다. <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> 속성을 사용 하면 사용자가 조작에서 컨트롤 내의 텍스트를 보호할 수 있습니다. 컨트롤의 보호 된 텍스트를 처리할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트를 사용자가 보호 된 텍스트를 수정 하려고 하 고 텍스트 보호 되어 있거나 사용자에 게 보호 된 텍스트를 조작할 수 있는 표준 방법을 제공 하거나 사용자를 알림 시기를 결정 합니다.  
  
 이미 사용 하는 응용 프로그램 <xref:System.Windows.Forms.TextBox> 컨트롤 쉽게 되도록 조정할 수 활용 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다. 그러나는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에는의 동일한 64k 문자 용량 제한은 <xref:System.Windows.Forms.TextBox> 제어 합니다. <xref:System.Windows.Forms.RichTextBox> 일반적으로 텍스트를 조작 하 고 Microsoft Word와 같은 워드 프로세싱 응용 프로그램과 유사한 기능을 표시 하는 데 사용 됩니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType> 메서드는 사용 하지는 <xref:System.Windows.Forms.Control.KeyPress> 또는 <xref:System.Windows.Forms.Control.TextChanged> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> "Text" 라는 단어의 첫 번째 인스턴스를 검색 및 컨트롤에 RTF 파일을 로드 하는 컨트롤 코드 글꼴 스타일, 글꼴 크기 및 선택한 텍스트의 글꼴 색을 변경 하 고 원본 파일에 변경 내용을 저장 합니다. 예제 코드에 컨트롤을 추가 하 여이 완료 되는 경우 해당 <xref:System.Windows.Forms.Form>합니다. 이 예제는 예제 코드에서 만든 메서드를 추가 하려면 한 <xref:System.Windows.Forms.Form> 클래스 및 폼의 생성자에서 호출 합니다. 또한이 예제 "Text" 단어를 포함 하는 C 드라이브의 루트에 RTF 파일 생성  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로는 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 컨트롤의 속성이로 설정 되어 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> "Text" 라는 단어의 첫 번째 인스턴스를 검색 및 컨트롤에 RTF 파일을 로드 하는 컨트롤 코드 글꼴 스타일, 글꼴 크기 및 선택한 텍스트의 글꼴 색을 변경 하 고 원본 파일에 변경 내용을 저장 합니다. 예제 코드에 컨트롤을 추가 하 여이 완료 되는 경우 해당 <xref:System.Windows.Forms.Form>합니다. 이 예제는 예제 코드에서 만든 메서드를 추가 하려면 한 <xref:System.Windows.Forms.Form> 클래스 및 폼의 생성자에서 호출 합니다. 또한이 예제 "Text" 단어를 포함 하는 C 드라이브의 루트에 RTF 파일 생성  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 끌어서 놓기 작업을 수행할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤에서 끌어서 놓기 작업을 수행할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에 사용 하 여 끌어서 놓기 작업을 수행 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 에 놓을 항목이 포함 된 컨트롤을 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 폼 집합의 생성자는 <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> 속성을 `true` 에 끌어서 놓기 작업을 사용 하도록는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Control.MouseDown> 의 이벤트는 <xref:System.Windows.Forms.ListBox> 호출 하 여 끌기 작업을 시작 하는 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드. 이 예제에서는 사용는 <xref:System.Windows.Forms.Control.DragEnter> 항목으로 끌어 온 경우를 결정 하기 위해 이벤트는 <xref:System.Windows.Forms.RichTextBox> 유효한 데이터 형식입니다. <xref:System.Windows.Forms.Control.DragDrop> 으로 끌어 온된 항목의 실제 삭제를 수행 하는 이벤트는 <xref:System.Windows.Forms.RichTextBox> 컨트롤 내에서 현재 커서 위치에는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 <xref:System.Windows.Forms.Control.DragDrop> 및 <xref:System.Windows.Forms.Control.DragEnter> 예에서 정의 된 이벤트 처리기에 연결 된 이벤트입니다.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>
          사용하도록 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>단어 단위로 선택 기능이 활성화되어 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          단어 단위로 선택 기능이 활성화되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 `true`, 컨트롤에서 텍스트의 일부를 선택 하면 전체 단어를 선택 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만드는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.RichTextBox> 텍스트를 확대 하는, 단어를 두 번와 컨트롤의 클라이언트 영역 오른쪽에 여백이 때 컨트롤의 텍스트에서 단어를 자동으로 선택 합니다. 경우는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 작은 폭이이 코드를 사용 하 여 만들어집니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트의 각 문자를 별도 줄에 표시 되는 위치입니다. 이 세로 표시 위치에서 작업 하는 동안 단어의 모든 부분을 클릭 하는 텍스트가 세로로 표시 됩니다 팩트에 관계 없이 단어의 모든 문자 선택 됩니다. 이 예제에서는 포함 된 폼이 있어야는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>컨트롤에 표시된 배경 이미지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>컨트롤에 표시할 배경 이미지의 레이아웃입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>글머리 기호 스타일이 텍스트에 적용될 때 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에 사용된 들여쓰기를 가져오거나 설정합니다.</summary>
        <value>글머리 기호 다음에 들여쓰기로 삽입된 픽셀의 수입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정에 텍스트 단락을 글머리 기호 스타일을 적용 하려면는 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을 `true` 로 설정한는 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> 속성의 텍스트를 들여쓸 픽셀 수입니다. 단락이는 글머리 기호 스타일 지정된 된 양의 글머리 기호 다음에 들여쓰기를 사용 하 여 적용 해야 합니다. 이 속성은 컨트롤의 텍스트 및 글머리 기호 항목의 목록에서 현재 선택 된 글머리 기호 내에서 현재 단락을만 영향을 줍니다. 글머리 기호 항목의 전체 목록에 다른 들여쓰기 수준을 적용할 글머리 기호 항목의 모든 텍스트를 설정 하기 전에 선택 해야 합니다는 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을는 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 속성에 글머리 기호 목록을 만드는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 폼에 만들어집니다.  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 들여쓰기가 0보다 작은 경우</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">
          <see cref="T:System.Windows.Forms.DataFormats.Format" /> 값 중 하나입니다.</param>
        <summary>지정된 데이터 형식으로 클립보드의 정보를 붙여넣을 수 있는지 여부를 확인합니다.</summary>
        <returns>
          지정된 데이터 형식으로 클립보드의 데이터를 붙여넣을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 있는지를 확인 하는 클립보드의 현재 내용을 지정 클립보드 데이터 형식에서에 정보를 붙여넣을 수 있도록 하기 전에 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 예를 들어에 대 한 이벤트 처리기를 만들 수 있습니다는 <xref:System.Windows.Forms.MenuItem.Popup> 붙여넣기 명령의 이벤트 <xref:System.Windows.Forms.MenuItem> 확인 하려면이 메서드를 사용 하 고 있는지 여부를 붙여넣기 <xref:System.Windows.Forms.MenuItem> 클립보드의 데이터 형식에 따라 활성화 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 에 비트맵을 붙여 메서드는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 파일에서 비트맵을 연 다음 예제에서는 <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> 메서드 비트맵 Windows 클립보드에 복사 합니다. 이 예제에서는 형식을 검색 하는 마지막으로 <xref:System.Drawing.Bitmap> 개체를 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> 형식에 붙여 넣을 수 있는지 확인 하기 위해 메서드는 <xref:System.Windows.Forms.RichTextBox> 제어 및 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 메서드 데이터를 붙여 합니다.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" />에서 발생된 동작 중 다시 적용될 수 있는 동작이 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤의 내용에 다시 적용할 수 있는 실행 취소된 작업이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 확인 하려면이 속성을 사용할 수 있는지 여부를 마지막 작업에서 실행 취소는 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여 다시 적용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 및 <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> 속성, 및 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 방법에서 텍스트의 삭제를 제외 하 고 모든 작업을 다시 실행 작업을 제한 합니다. 이 예제에서는 포함 된 폼이 있어야는 <xref:System.Windows.Forms.RichTextBox> 컨트롤과 내에서 작업의 <xref:System.Windows.Forms.RichTextBox> 수행 되 고이 예제의 코드를 호출 하기 전에 실행을 취소 합니다.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 있는 내용의 크기가 조정될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.RichTextBox.ContentsResized> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.RichTextBox.ContentsResized> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 핸들이 만들어지는 경우 필요한 작성 매개 변수를 가져옵니다.</summary>
        <value>컨트롤 핸들을 만들 때 필요한 작성 매개 변수가 포함된 <see cref="T:System.Windows.Forms.CreateParams" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>RichEdit 콜백 작업을 처리하는 데 사용할 <see langword="IRichEditOleCallback" /> 호환 개체를 만듭니다.</summary>
        <returns>
          <see langword="IRichEditOleCallback" /> 인터페이스를 구현하는 개체</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 직접 실행 호출자입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>기본 서식 있는 편집 기능에 액세스할 수 있도록 하려면 파생된 클래스에서이 메서드를 재정의할 수 있습니다. 이 메서드를 재정의 하는 경우 모든 끌어서 놓기 이벤트 발생 하지 않습니다. 결과적으로, 끌어서 놓기 작업에 대 한 사용자 고유의 지원을 제공 해야 합니다. 에 대 한 자세한 내용은 <see langword="IRichEditOleCallback" /> 인터페이스에 있는 Platform SDK 설명서를 참조 하십시오 http://msdn.microsoft.com합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 크기를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> 값입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URL(Uniform Resource Locator)이 컨트롤에 입력될 때 <see cref="T:System.Windows.Forms.RichTextBox" />에서 해당 URL의 서식을 자동으로 지정할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBox" />에서 컨트롤에 링크로 입력된 URL의 서식을 자동으로 지정하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 `true`, 의해 결정 되는 컨트롤에 입력 한 텍스트는 <xref:System.Windows.Forms.RichTextBox> URL을 자동으로 링크로 서식이 지정 되도록 합니다. 에 대 한 이벤트 처리기를 만들 수는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 컨트롤에서 이벤트 처리에서 모든 링크를 클릭 합니다. <xref:System.Windows.Forms.LinkClickedEventArgs> 제공 하는 그룹에 대 한 이벤트 처리기에는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 링크는 링크를 처리 하기 위해 컨트롤에서 클릭 했는지 확인할 수 있도록 데이터를 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 이벤트 처리기가 포함 되어는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 이벤트입니다. 문서 내 링크 클릭을 처리 하는 이벤트 처리기는 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 기본 브라우저의 인스턴스를 시작 (사용 하는 <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> 메서드)를 클릭 된 링크에 대 한 페이지를 표시 합니다. 이 예제에서는 이벤트 처리기에 연결 되어 있다고는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 에 대 한 이벤트는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>끌어서 놓기 작업을 완료하면 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개체를 컨트롤의 범위 안으로 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.RichTextBox.DragEnter> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.RichTextBox.DragEnter> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 범위 밖으로 개체를 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다. 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개체를 컨트롤의 범위 위로 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다. 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">
          <see cref="T:System.Drawing.Bitmap" />
        </param>
        <param name="targetBounds">
          <see cref="T:System.Drawing.Rectangle" />
        </param>
        <summary>이 메서드는 이 클래스와 관련이 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>텍스트, 그림 및 기타 데이터에서 끌어서 놓기 작업을 사용할 수 있게 하는 값을 가져오거나 설정합니다.</summary>
        <value>
          끌어서 놓기 작업을 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" />의 내용에서 텍스트를 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">검색할 문자 배열입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 문자 목록의 문자가 처음 나오는 경우를 검색합니다.</summary>
        <returns>검색 문자가 발견된 컨트롤 내의 위치이거나, 검색 문자를 찾지 못했거나 <paramref name="char" /> 매개 변수에 빈 검색 문자 집합을 지정한 경우에는 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 검색 목록에 지정 된 문자에서 문자의 첫 번째 인스턴스는 `characterSet` 매개 변수 문자의 위치를 반환 합니다. 예를 들어 'Q' 문자를 포함 하는 문자 배열을 전달 합니다. 컨트롤 텍스트의 빠른 Brown "Fox"를 포함 하는 경우는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드는 4 개의 값을 반환 합니다. \T-소문자 및 대문자 문자에는 검색에 다른 값으로 간주 됩니다.  
  
 음수 값이 반환 하는 경우 검색 되는 문자 된 컨트롤의 내용에서 찾을 수 없습니다. 컨트롤 내에서 문자 그룹을 검색 하려면이 메서드를 사용할 수 있습니다. 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 사용 하려면 전체 문서 컨트롤에 포함 된 문자에 대 한 검색 됩니다. 메서드의에 제공 된 문자 목록에서 문자가 `characterSet` 매개 변수가 발견 되,이 메서드에 의해 반환 된 값이 컨트롤에서 해당 문자의의 0부터 시작 인덱스입니다. 공백 문자 위치를 결정할 때 메서드에 의해 문자로 간주 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 내용을 검색 한 <xref:System.Windows.Forms.RichTextBox> 의 메서드에 전달 되는 문자에 대 한는 `text` 매개 변수입니다. 하는 경우의 콘텐츠는 `text` 배열에서 발견 되는 <xref:System.Windows.Forms.RichTextBox>, 그렇지 않으면 값의 인덱스를 반환 하는 메서드,-1을 반환 합니다. 이 예제에서는이 메서드가의 클래스가 포함 되어는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 및 <xref:System.Windows.Forms.Button> 라는 컨트롤 `button1`, 즉에 연결 된 `Click` 에 정의 된 이벤트 처리기 예입니다.  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 문자열을 검색합니다.</summary>
        <returns>검색 텍스트가 발견된 컨트롤 내의 위치이거나, 검색 문자열을 찾지 못했거나 <paramref name="str" /> 매개 변수에 빈 검색 문자열을 지정한 경우에는 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 검색에 지정 된 텍스트는 `str` 매개 변수 컨트롤 내에서 첫 번째 문자의 위치를 반환 합니다. 음수 값이 반환 하는 경우에 컨트롤의 콘텐츠 내에서 검색 되는 텍스트 문자열 찾지 못했습니다. 컨트롤의 사용자에 게 제공 될 수 있는 검색 기능을 만드는이 메서드를 사용할 수 있습니다. 또한 특정 형식을 지닌 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어 사용자 컨트롤을 컨트롤에 날짜를 입력 하는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜를 검색 하 고 사용 하기 전에 적절 한 서식으로 대체 하는 메서드는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> 사용할 수 있는 한 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 된 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 검색을 수행할 음수 값을 반환 합니다 (-1).  
  
   
  
## Examples  
 다음 코드 예제에서는 검색의 전체 내용을 한 <xref:System.Windows.Forms.RichTextBox> 메서드의 텍스트 매개 변수에 전달 된 첫 번째 인스턴스의 검색 문자열입니다. 검색 문자열에 있으면는 <xref:System.Windows.Forms.RichTextBox>의 값을 반환 하는 메서드가 `true` 그렇지 않으면 반환 검색 텍스트를 강조 표시 `false`합니다. 이 예제에서는이 메서드가의 클래스가 포함 되어는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">검색할 문자 배열입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 특정 시작 지점부터 문자 목록의 문자가 처음 나오는 경우를 검색합니다.</summary>
        <returns>검색 문자를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 방법으로 목록에 지정 된 문자에서 문자의 첫 번째 인스턴스에 대 한 검색는 `characterSet` 매개 변수 문자 위치를 반환 합니다. 예를 들어 'Q' 문자를 포함 하는 문자 배열을 전달 합니다. 컨트롤 텍스트의 빠른 Brown "Fox"를 포함 하는 경우는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드는 4 개의 값을 반환 합니다. \T-소문자 및 대문자 문자에는 검색에 다른 값으로 간주 됩니다.  
  
 음수 값이 반환 하는 경우 검색 되는 문자 된 컨트롤의 내용에서 찾을 수 없습니다. 컨트롤 내에서 문자 그룹을 검색 하려면이 메서드를 사용할 수 있습니다. 메서드의에 제공 된 문자 목록에서 문자가 `characterSet` 매개 변수가 발견 되,이 메서드에 의해 반환 된 값이 컨트롤에서 해당 문자의의 0부터 시작 인덱스입니다. 공백 문자 위치를 결정할 때 메서드에 의해 문자로 간주 됩니다.  
  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 사용 하는 문자에 대 한 값을 지정 하 여 컨트롤의 텍스트 내에서 지정 된 시작 위치에서 집합에 대 한 검색할 수 있습니다는 `start` 매개 변수입니다. 0 값을 검색 컨트롤의 문서의 시작 부분에서 시작 해야 함을 나타냅니다. 이 버전의를 사용할 수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 방법을 이미 알고 있는 텍스트를 방지 하기 위해 검색 범위를 좁히려면 검색 하는 또는 검색에 중요 하지 않은 지정된 된 문자는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 내용을 검색 한 <xref:System.Windows.Forms.RichTextBox> 의 메서드에 전달 되는 문자에 대 한는 `text` 매개 변수입니다. 내에서 위치에서 검색이 시작 되는 <xref:System.Windows.Forms.RichTextBox> 에 지정 된는 `start` 의 매개 변수는 `FindMyText` 메서드. 텍스트 배열의 내용을에서 발견 되는 경우는 <xref:System.Windows.Forms.RichTextBox>, 그렇지 않으면 값의 인덱스를 반환 하는 메서드,-1을 반환 합니다. 이 예제에서는이 메서드가의 클래스가 포함 되어는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 및 <xref:System.Windows.Forms.Button> 라는 컨트롤 `button1` 에 연결 되는 <xref:System.Windows.Forms.Control.Click> 에 정의 된 이벤트 처리기는 예입니다.  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 값의 비트 조합입니다.</param>
        <summary>검색에 특정 옵션을 적용하여 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 문자열을 검색합니다.</summary>
        <returns>검색 텍스트를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 검색에 지정 된 텍스트는 `str` 매개 변수 컨트롤 내에서 첫 번째 문자의 위치를 반환 합니다. 음수 값이 반환 하는 경우에 컨트롤의 콘텐츠 내에서 검색 되는 텍스트 문자열 찾지 못했습니다. 컨트롤의 사용자에 게 제공 될 수 있는 검색 기능을 만드는이 메서드를 사용할 수 있습니다. 또한 특정 형식을 지닌 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어 사용자 컨트롤을 컨트롤에 날짜를 입력 하는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜를 검색 하 고 사용 하기 전에 적절 한 서식으로 대체 하는 메서드는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
 이 버전의 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 확장 하거나 검색 범위를 좁힐 수 있도록 하는 옵션을 지정할 수 있습니다. 검색 단어의 대/소문자와 일치 하도록 하거나 부분 단어 대신 전체 단어를 검색할 수 있는 옵션을 지정할 수 있습니다. 지정 하 여는 `RichTextBoxFinds.Reverse` 열거형에는 `options` 매개 변수를 문서의 맨 아래에서 텍스트를 아래쪽 검색 메서드에 기본 위쪽이 아니라 위쪽에 대 한 검색할 수 있습니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> 사용할 수 있는 한 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 된 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 검색을 수행할 음수 값을 반환 합니다 (-1).  
  
   
  
## Examples  
 다음 코드 예제에서는 검색의 전체 내용을 한 <xref:System.Windows.Forms.RichTextBox> 메서드의 텍스트 매개 변수에 전달 된 첫 번째 인스턴스의 검색 문자열입니다. 검색 문자열에 있으면는 <xref:System.Windows.Forms.RichTextBox>의 값을 반환 하는 메서드 `true` ; 텍스트를 강조 표시 하 고 그렇지 않으면 반환 `false`합니다. 또한이 예제에서는 지정 된 검색 문자열의 대/소문자를 구분 하는 검색에서 옵션을 지정 합니다. 이 예제에서는이 메서드가의 클래스가 포함 되어는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">검색할 문자 배열입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <param name="end">컨트롤의 텍스트에서 검색이 끝날 위치입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트 범위에서 문자 목록의 문자가 처음 나오는 경우를 검색합니다.</summary>
        <returns>검색 문자를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 검색 목록에 지정 된 문자에서 문자의 첫 번째 인스턴스는 `characterSet` 매개 변수 문자의 위치를 반환 합니다. 예를 들어 'Q' 문자를 포함 하는 문자 배열을 전달 합니다. 컨트롤 텍스트의 빠른 Brown "Fox"를 포함 하는 경우는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드는 4 개의 값을 반환 합니다. \T-소문자 및 대문자 문자에는 검색에 다른 값으로 간주 됩니다.  
  
 음수 값이 반환 하는 경우 검색 되는 문자 된 컨트롤의 내용에서 찾을 수 없습니다. 컨트롤 내에서 문자 그룹을 검색 하려면이 메서드를 사용할 수 있습니다. 메서드의에 제공 된 문자 목록에서 문자가 `characterSet` 매개 변수가 발견 되,이 메서드에 의해 반환 된 값은 0부터 시작 하는 컨트롤에는 문자 위치의 인덱스입니다. 공백 문자 위치를 결정할 때 메서드에 의해 문자로 간주 됩니다.  
  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 사용 하는 문자에 대 한 값을 지정 하 여 컨트롤의에서 텍스트 범위에서 집합에 대 한 검색할 수 있습니다는 `start` 및 `end` 매개 변수입니다. 값이 0에서 `start` 매개 변수 검색 컨트롤의 문서의 시작 부분에서 시작 해야 함을 나타냅니다. 에 대 한-1 값은 `end` 매개 변수 지정 검색 컨트롤 내의 텍스트의 끝에 끝납니다. 이 버전의를 사용할 수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 응용 프로그램의 요구 사항을 충족 하는 것이 중요 하지 않은 문서 영역을 검색 하지 않으려면 컨트롤 내의 텍스트의 특정 범위로 검색 범위를 좁히세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="characterSet" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" />가 0보다 작거나 컨트롤의 텍스트 길이보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 값의 비트 조합입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 특정 옵션을 적용하여 컨트롤 내의 특정 위치에 있는 문자열을 검색합니다.</summary>
        <returns>검색 텍스트를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 검색에 지정 된 텍스트는 `str` 매개 변수 및 컨트롤 내에서 검색의 첫 번째 문자의 위치 문자열을 반환 합니다. 음수 값이 반환 하는 경우에 컨트롤의 콘텐츠 내에서 검색 되는 텍스트 문자열 찾지 못했습니다. 컨트롤의 사용자에 게 제공 될 수 있는 검색 기능을 만드는이 메서드를 사용할 수 있습니다. 또한 특정 형식을 지닌 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어 사용자 컨트롤을 컨트롤에 날짜를 입력 하는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜를 검색 하 고 사용 하기 전에 적절 한 서식으로 대체 하는 메서드는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
 이 버전의 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 확장 하거나 검색 범위를 좁힐 수 있도록 하는 옵션을 지정할 수 있습니다. 검색 단어의 대/소문자와 일치 하도록 하거나 부분 단어 대신 전체 단어를 검색할 수 있는 옵션을 지정할 수 있습니다. 지정 하 여는 `RichTextBoxFinds.Reverse` 열거형에는 `options` 매개 변수를 문서의 맨 아래에서 텍스트를 아래쪽 검색 메서드에 기본 위쪽이 아니라 위쪽에 대 한 검색할 수 있습니다. 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 또한 컨트롤의 텍스트 내에서 특정 시작 위치를 선택 하 여 텍스트에 대 한 검색 범위를 좁힐 수 있습니다. 이 기능을 사용 하는 수에 대 한 이미 검색이 또는 검색 하는 특정 텍스트 없는 것으로 알려져 있는 제외할 수 수 있습니다. 때는 `RichTextBoxFinds.Reverse` 값에 지정 된는 `options` 값, 매개 변수는 `start` 역방향 검색의이 버전을 사용 하는 경우 문서 맨 아래에 검색을 시작할 이후 종료 됩니다 있는 위치를 표시 하는 매개 변수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> 사용할 수 있는 한 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 된 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 검색을 수행할 음수 값을 반환 합니다 (-1).  
  
   
  
## Examples  
 다음 코드 예제에서는 검색의 전체 내용을 한 <xref:System.Windows.Forms.RichTextBox> 메서드의 텍스트 매개 변수에 전달 된 첫 번째 인스턴스의 검색 문자열입니다. 검색 시작 위치는 메서드에서 시작 매개 변수에 의해 지정 됩니다. 검색 문자열에 있으면는 <xref:System.Windows.Forms.RichTextBox>, 메서드는 검색된 된 텍스트의 첫 번째 문자의 인덱스 위치를 반환 하 고 강조 표시; 그러지 않으면-1 값을 반환 합니다. 또한이 예제에서는 지정 된 검색 문자열의 대/소문자를 구분 하는 검색에서 옵션을 지정 합니다. 이 예제에서는이 메서드가의 클래스가 포함 되어는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 `richTextBox1`합니다. 이 예제에서는 "다음 찾기" 유형의 작업을 수행 하려면 사용할 수 있습니다. 값을 변경 하 여 텍스트의 다른 인스턴스를 찾을 수 검색 텍스트의 인스턴스를 찾으면는 `start` 매개 변수를 현재 일치 항목의 위치 이후의 위치에서 검색 합니다.  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <param name="end">컨트롤의 텍스트에서 검색이 끝날 위치입니다. 이 값은 음수 1(-1)과 같거나 <c>start</c> 매개 변수보다 크거나 같아야 합니다.</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 값의 비트 조합입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 특정 옵션을 적용하여 컨트롤의 텍스트 범위 내에 있는 문자열을 검색합니다.</summary>
        <returns>검색 텍스트를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 검색에 지정 된 텍스트는 `str` 매개 변수 및 컨트롤 내에서 검색의 첫 번째 문자의 위치 문자열을 반환 합니다. 음수 값이 반환 하는 경우에 컨트롤의 콘텐츠 내에서 검색 되는 텍스트 문자열 찾지 못했습니다. 컨트롤의 사용자에 게 제공 될 수 있는 검색 기능을 만드는이 메서드를 사용할 수 있습니다. 또한 특정 형식을 지닌 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어 사용자 컨트롤을 컨트롤에 날짜를 입력 하는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜를 검색 하 고 사용 하기 전에 적절 한 서식으로 대체 하는 메서드는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
 이 버전의 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 확장 하거나 검색 범위를 좁힐 수 있도록 하는 옵션을 지정할 수 있습니다. 검색 단어의 대/소문자와 일치 하도록 하거나 부분 단어 대신 전체 단어를 검색할 수 있는 옵션을 지정할 수 있습니다. 지정 하 여는 `RichTextBoxFinds.Reverse` 열거형에는 `options` 매개 변수를 문서의 맨 아래에서 텍스트를 아래쪽 검색 메서드에 기본 위쪽이 아니라 위쪽에 대 한 검색할 수 있습니다. 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 또한 컨트롤의 텍스트 내에서 특정 시작 및 끝 위치를 선택 하 여 텍스트에 대 한 검색 범위를 좁힐 수 있습니다. 이 기능은 컨트롤의 텍스트의 특정 섹션에 대 한 검색 범위를 제한할 수 있도록 합니다. 에 할당 된 값이 음수 (-1) 경우는 `end` 에 있는 텍스트의 끝까지 메서드는 검색 매개 변수는 <xref:System.Windows.Forms.RichTextBox> 정방향으로 검색 합니다. 역방향 검색에 대 한 값이 음수 1 (-1)에 할당 된는 `end` 매개 변수에서 정의 된 위치에 텍스트 (아래) 텍스트의 끝에서 검색 되도록 됩니다 지정 `start` 매개 변수입니다. 경우는 `start` 및 `end` 매개 변수가 제공 정방향으로 검색에 대 한 동일한 값 전체 컨트롤 검색 됩니다. 역방향 검색의 경우에 대 한 전체 컨트롤을 검색 하지만 검색 문서 맨 아래에 시작 하 고 문서의 맨 위로 검색.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> 사용할 수 있는 한 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 된 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 검색을 수행할 음수 값을 반환 합니다 (-1).  
  
   
  
## Examples  
 다음 코드 예제에서는 텍스트에의 한 섹션을 검색 한 <xref:System.Windows.Forms.RichTextBox> 에 전달 된 첫 번째 인스턴스의 검색 문자열에 대 한는 `searchText` 는 메서드의 매개 변수입니다. 범위 검색으로 컨트롤 내에서 텍스트를 지정 하는 `searchStart` 및 `searchEnd` 메서드의 매개 변수입니다. 검색 문자열에 있으면는 <xref:System.Windows.Forms.RichTextBox>, 메서드는 검색된 된 텍스트의 첫 번째 문자의 인덱스 위치를 반환 하 고 강조 표시; 그러지 않으면-1 값을 반환 합니다. 또한이 예제에서는 `options` 의 매개 변수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 찾은 텍스트 검색 문자열의 대/소문자와 일치 해야 함을 지정 합니다. 이 예제에서는이 메서드가의 클래스가 포함 되어는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다. 첫 번째 이후 검색 문자열의 인스턴스 발견 되었습니다,이 예제에서는 사용 하 여 텍스트의 다른 인스턴스를 찾습니다.  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 매개 변수가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="end" /> 매개 변수가 <paramref name="start" /> 매개 변수보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 표시되는 텍스트의 글꼴을 가져오거나 설정합니다.</summary>
        <value>컨트롤에 표시되는 텍스트에 적용되는 <see cref="T:System.Drawing.Font" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultFont" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 전경색을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 전경색을 나타내는 <see cref="T:System.Drawing.Color" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">검색할 위치입니다.</param>
        <summary>지정된 위치에 가장 가까운 문자의 인덱스를 검색합니다.</summary>
        <returns>지정된 위치의 0부터 시작하는 문자 인덱스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 위치와 가장 가까운 문자 인덱스를 반환 하는이 메서드는 `pt` 매개 변수입니다. 문자 인덱스에는 공백을 포함 하 여 컨트롤의에서 텍스트의 0부터 시작 인덱스가입니다. 텍스트에는 사용자에이 메서드를 마우스 좌표를 전달 하 여 마우스를 확인 하려면이 메서드를 사용할 수 있습니다. 이 컨트롤의 텍스트에 포함 된 단어 위에 마우스 포인터를 놓을 때 작업을 수행 하려는 경우에 유용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A> 메서드는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 내에서 특정 문자열을 검색 하려면는 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 검색된 된 문자열 내에 문자 인덱스 표시는 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다. 이 예제에서는 컨트롤의 내용 안에 "brown" 라는 단어를 검색 하 고 검색 문자열이 발견 되는 문자 인덱스 위치를 반환 합니다. 이 예제에서는 포함 된 폼이 있어야는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 텍스트가 포함 된 합니다. 또한 예제에서 코드에 연결 되어 있는지 필요는 <xref:System.Windows.Forms.Control.MouseDown> 의 이벤트는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">검색할 문자 인덱스 위치입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트 내에서 지정된 문자 위치의 줄 번호를 검색합니다.</summary>
        <returns>문자 인덱스가 있는 0부터 시작하는 줄 번호입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면에 지정 된 문자 인덱스를 기반으로 하는 줄 번호를 확인 하는 `index` 는 메서드의 매개 변수입니다. 컨트롤의에서 텍스트의 첫 번째 줄 0 값을 반환합니다. <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 메서드 인덱싱된 문자는 컨트롤 내에 있는 실제 줄 번호 반환 합니다. 다음 줄으로 된 컨트롤이 래핑될 만큼 하는 경우에 텍스트의 첫 번째 논리 줄의 일부 예를 들어는 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 메서드 두 번째 실제 줄을 지정된 된 문자 인덱스에 있는 문자가 래핑하면 경우 1을 반환 합니다. 경우 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 로 설정 된 `false`, 다음 줄의 없습니다 일부가 래핑하면 및 메서드가 지정된 된 문자 인덱스에 대 한 0을 반환 합니다. 이 메서드를 확인 하려면 줄 특정 문자 인덱스 내에서 사용할 수 있습니다. 예를 들어 호출한 후는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 텍스트를 검색할 수 있는 메서드는 검색 결과 찾을 위치에 문자 인덱스를 가져올 수 있습니다. 반환 된 문자 인덱스에 있는이 메서드를 호출할 수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 단어 줄을 확인할 메서드를 찾을 수 있습니다.  
  
 경우에 따라 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 예외를 throw 하지 않는 경우는 `index` 매개 변수는 잘못 된 값입니다. 예:  
  
-   경우는 `index` 매개 변수는 <xref:System.Int32.MinValue> 또는-1 이면 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 0을 반환 합니다.  
  
-   경우는 `index` 매개 변수는 텍스트 길이 또는 <xref:System.Int32.MaxValue>, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 필요가 없는 동일한 텍스트의 마지막 줄의 번호를 반환로 `Lines.Length-1`의 값에 따라는 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성입니다.  
  
 이러한 경우에 호출 하기 전에 입력의 유효성을 검사 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>합니다.  
  
> [!NOTE]
>  문자 인덱스에 지정 된 경우는 `index` 매개 변수를 사용할 수 있는 컨트롤에 포함 된 줄 수가 이외의 않으면 마지막 줄 번호가 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 메서드. 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `RichTextBox1`, 이라는 단추 `Button1` 및 이라는 두 개의 텍스트 상자 `TextBox1` 및 `TextBox2`합니다. 이 예제에서는 실행 중인 경우에 검색 문자열 입력 `TextBox2` 검색 결과 얻기 위해 단추를 클릭 합니다.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">위치를 검색할 문자의 인덱스입니다.</param>
        <summary>컨트롤 내에서 지정된 문자 인덱스의 위치를 검색합니다.</summary>
        <returns>지정된 문자의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 컨트롤에 특정 문자 인덱스가 위치한 확인할 수 있습니다. 컨트롤에는 단어에 대 한 바로 가기 메뉴 항목 또는 도움말 정보를 표시 하는 등의 작업에 대 한이 메서드를 사용할 수 있습니다. 예를 들어 사용자 컨트롤의 단어 마우스 오른쪽 단추로 클릭할 때 사용자에 게 옵션 메뉴를 표시 하려는이 메서드를 사용 하 여 제대로 표시 하려면 word의 위치를 결정할 수 있습니다는 <xref:System.Windows.Forms.ContextMenu> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>끌기 작업을 수행하는 동안 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 가로 스크롤 막대를 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.RichTextBox.HScroll> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.RichTextBox.HScroll> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>한글 버전의 Windows 운영 체제에서 입력 방법을 전환할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.RichTextBox.ImeChange> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.RichTextBox.ImeChange> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IME(입력기) 및 한국어 지원을 위한 <see cref="T:System.Windows.Forms.RichTextBox" /> 설정을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 텍스트 내에 있는 링크를 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤 내에서 클릭 된 링크를 처리 하려면이 이벤트에 대 한 이벤트 처리기를 만들 수 있습니다. 이벤트 처리기에 제공 된 정보를 사용 하 여 문서에 클릭 한 링크를 확인할 수 있습니다.  
  
> [!IMPORTANT]
>  기본적으로 링크 텍스트로 표시 되 고 클릭 가능 하지 않습니다. 클릭할 수 있는 설정 하면는 <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> 속성을 `true`합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 이벤트 처리기가 포함 되어는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 이벤트입니다. 문서 내 링크 클릭을 처리 하는 이벤트 처리기는 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 기본 브라우저의 인스턴스를 시작 (사용 하는 <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> 메서드)를 클릭 된 링크에 대 한 페이지를 표시 합니다. 이 예제에서는 이벤트 처리기에 연결 되어 있다고는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 에 대 한 이벤트는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파일의 내용을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">컨트롤로 로드할 파일의 이름 및 위치입니다.</param>
        <summary>RTF(서식 있는 텍스트 형식) 또는 표준 ASCII 텍스트 파일을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일을 로드할 때의 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드, 로드 되는 파일의 내용을 대체의 전체 내용을 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이렇게 하면 값의 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 및 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성을 변경 합니다. 조작에 대 한 컨트롤에는 이전에 만든된 텍스트 또는 RTF 문서를 로드 하려면이 메서드를 사용할 수 있습니다. 파일을 저장 하려는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드.  
  
> [!NOTE]
>  이 버전의 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드, 로드 되는 파일 RTF 문서 없으면 예외가 발생 합니다. 값을 허용 하는이 방법의 다른 버전을 사용 하는 다른 형식으로 ASCII 텍스트 파일 같은 파일을 로드 하려면는 <xref:System.Windows.Forms.RichTextBoxStreamType> 열거형을 매개 변수로 합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드는 파일을 열에 대 한 핸들을 만들 때까지 <xref:System.Windows.Forms.RichTextBox>합니다. 컨트롤의 핸들이 호출 하기 전에 만들어졌는지 확인는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 RTF 파일을 엽니다는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 사용은 <xref:System.Windows.Forms.OpenFileDialog> 클래스 파일 사용자를에서 요청 하는 대화 상자를 표시 합니다. 다음 코드를 로드 하는 것으로 가정는 RTF 파일 파일을 문서화 합니다. 파일이 없으면 예제 코드는 예외가 throw 됩니다. 이 예제에서는 코드에 배치 됩니다는 <xref:System.Windows.Forms.Form> 가 있는 클래스는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤에 파일을 로드하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentException">로드되는 파일이 RTF 문서가 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">으로 파일을 엽니다. 연관 된 열거형:는 <see langword="Read" /> 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드할 데이터 스트림입니다.</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary>기존 데이터 스트림의 내용을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의를 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 개체에 대 한는 <xref:System.Windows.Forms.RichTextBox> 데이터의 기존 스트림에서 데이터를 사용 합니다. 컨트롤에 로드 된 데이터의 전체 내용을 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이렇게 하면 값의 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 및 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성을 변경 합니다. 조작의 컨트롤로 데이터 스트림으로 이전에 연 파일을 로드 하려면이 메서드를 사용할 수 있습니다. 스트림으로 다시 컨트롤의 콘텐츠를 저장 하려는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 허용 하는 메서드는 <xref:System.IO.Stream> 개체를 매개 변수로 합니다.  
  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드 또한 컨트롤을 컨트롤에 로드 되는 데이터의 형식을 지정할 수 있습니다. 이 기능을 사용 하면 컨트롤에 RTF (형식) 문서 서식 있는 텍스트 이외의 데이터를 포함 하는 데이터 스트림을 사용할 수 있습니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드는 파일을 열에 대 한 핸들을 만들 때까지 <xref:System.Windows.Forms.RichTextBox>합니다. 컨트롤의 핸들이 호출 하기 전에 만들어졌는지 확인는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 및 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 스트림 사용 하 여 메서드. 사용 하는 방법도 보여 줍니다는 <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, 및 <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> 멤버입니다.  
  
 프로젝트에 복사할 때 실행할 준비가 되는 전체 예제입니다.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤에 파일을 로드하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentException">로드되는 파일이 RTF 문서가 아닌 경우</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">컨트롤로 로드할 파일의 이름 및 위치입니다.</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary>특정 형식의 파일을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일을 로드할 때의 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드, 로드 되는 파일의 내용을 대체의 전체 내용을 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이렇게 하면 값의 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 및 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성을 변경 합니다. 조작에 대 한 컨트롤에는 이전에 만든된 텍스트 또는 서식 있는 텍스트 (rtf) 문서를 로드 하려면이 메서드를 사용할 수 있습니다. 파일을 저장 하려는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드.  
  
 이 버전의를 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드 로드 되는 파일의 파일 형식을 지정할 수 있습니다. 이 기능을 사용 하면 컨트롤에 RTF 문서 이외의 파일을 로드할 수 있습니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드는 파일을 열에 대 한 핸들을 만들 때까지 <xref:System.Windows.Forms.RichTextBox>합니다. 컨트롤의 핸들이 호출 하기 전에 만들어졌는지 확인는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 텍스트 파일을 열고는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 사용은 <xref:System.Windows.Forms.OpenFileDialog> 클래스 파일 사용자를에서 요청 하는 대화 상자를 표시 합니다. 코드는 다음에 해당 파일을 로드는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는이 버전의 사용은 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 표준 서식 있는 텍스트 형식 대신 ASCII 텍스트 파일로 파일을 열 수를 지정 하는 메서드. 이 예제에서는 코드에 배치 됩니다는 <xref:System.Windows.Forms.Form> 가 있는 클래스는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤에 파일을 로드하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentException">로드되는 파일이 RTF 문서가 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">으로 파일을 엽니다. 연관 된 열거형:는 <see langword="Read" /> 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>RichTextBox 컨트롤에 입력하거나 붙여넣을 수 있는 최대 문자 수를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 입력할 수 있는 문자 수입니다. 기본값은 <see cref="F:System.Int32.MaxValue" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 0으로 설정 하는 경우 컨트롤에 입력할 수 있는 텍스트의 최대 길이 문자의 64KB입니다. 이 속성은 일반적으로 때 사용 되는 <xref:System.Windows.Forms.RichTextBox> 서식 있는 텍스트 (rtf) 텍스트 한 줄을 표시 하는 데 사용 됩니다. 이 속성을 우편 번호 및 전화 번호 등의 값에 대 한 컨트롤에 입력 된 텍스트의 길이 제한 하거나 데이터를 데이터베이스에 입력 해야 할 때 입력 한 텍스트의 길이 제한 수에 사용할 수 있습니다. 데이터베이스의 해당 필드의 최대 길이 컨트롤에 입력 한 텍스트를 제한할 수 있습니다.  
  
> [!NOTE]
>  코드에서의 값을 설정할 수는 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성에는 지정 된 값 보다 큰 값으로는 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 속성입니다. 이 속성은 런타임 시 컨트롤에 입력 된 텍스트를만 영향을 줍니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> 속성에 텍스트 할당 되는 경우를 확인 하는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 할당 된 값 보다 크면는 <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> 속성입니다. 이 예제에서는 사용 하 여 텍스트를 더 큰 없으면는 <xref:System.Windows.Forms.RichTextBox.SelectedText%2A> 속성을 컨트롤에 텍스트를 할당 합니다. 이 예제에서는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다 및 예제에서 메서드는 컨트롤에 붙여넣을 수 있는 매개 변수에 제공 된 텍스트를 포함 합니다. 이 예제에서는 필요는 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 속성이 텍스트 항목으로 제한 하려면 값으로 설정 된는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">속성에 할당된 값이 0보다 작은 경우</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤이 여러 줄을 입력할 수 있는 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          여러 줄을 입력할 수 있는 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.ContentsResizedEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.RichTextBox.HScroll" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.RichTextBox.ImeChange" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.LinkClickedEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.RichTextBox.Protected" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.RichTextBox.VScroll" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">클립보드에서 가져오는 데이터의 클립보드 형식입니다.</param>
        <summary>클립보드의 내용을 지정된 클립보드 형식으로 붙여넣습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에 클립보드의 데이터를 붙여이 메서드를 사용할 수 있습니다. 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 메서드 간에 차이가 있는 <xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType> 그대로 메서드를 사용 하면 지정된 클립보드 형식에만 텍스트를 붙여 넣습니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> 메서드는 클립보드 내의 데이터 지정된 클립보드 형식에 있는지 확인 합니다. 이 버전의를 호출할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 메서드 붙여넣기 작업은 적절 한 데이터 형식을 수 있도록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 에 비트맵을 붙여 메서드는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 파일에서 비트맵을 연 다음 예제에서는 <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> 메서드 비트맵 Windows 클립보드에 복사 합니다. 이 예제에서는 형식을 검색 하는 마지막으로 <xref:System.Drawing.Bitmap> 개체, 형식에 붙여 넣을 수 있는지 확인 하 고는 <xref:System.Windows.Forms.RichTextBox> 제어 및 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 메서드 데이터를 붙여 합니다.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">클립보드에서 계속 하십시오. 연관 된 열거형:는 <see langword="AllClipboard" /> 값 <see cref="T:System.Security.Permissions.UIPermissionClipboard" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="m">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <param name="keyData">처리할 키를 나타내는 <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>명령 키를 처리합니다.</summary>
        <returns>
          컨트롤이 문자를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 보호된 텍스트를 수정하려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 컨트롤에서 보호 된 상태로 표시 된 텍스트를 수정 하려고 하는 시기를 결정 하는 응용 프로그램에서이 이벤트에 대 한 이벤트 처리기를 만들 수 있습니다. 텍스트에 대 한 적절 한 변경할 수 있도록 해 주는 대화 상자를 표시 하거나 텍스트 사용자 수정 하려고 하는 사용자가 보호에 알리기 위해 이벤트 처리기를 사용할 수 있습니다. 예를 들어 보호 된 영역에 날짜 이면 사용자가 다음 컨트롤의 텍스트에 적용할 수 있는 날짜를 선택할 수 있도록 대화 상자를 표시할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 이벤트는 이 클래스와 관련이 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤에서 실행 취소한 마지막 작업을 다시 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 그런 다음 사용할 수는 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 컨트롤에 마지막 실행 취소 작업을 다시 적용 하는 메서드. <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 메서드를 사용 하면 컨트롤에는 사용자가 실행 취소 마지막 작업을 다시 적용할 수 있는지 여부를 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 및 <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> 속성, 및 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 방법에서 텍스트의 삭제를 제외 하 고 모든 작업을 다시 실행 작업을 제한 합니다. 이 예제에서는 포함 된 폼이 있어야는 <xref:System.Windows.Forms.RichTextBox> 컨트롤과 내에서 작업의 <xref:System.Windows.Forms.RichTextBox> 수행 되 고이 예제의 코드를 호출 하기 전에 실행을 취소 합니다.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 메서드를 호출할 때 컨트롤에 다시 적용할 수 있는 동작의 이름을 가져옵니다.</summary>
        <value>
          <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 메서드를 호출할 때 수행되는 동작의 이름을 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 빈 문자열을 반환 하는 경우 (""), 작업이 없는 컨트롤에 다시 적용할 수 있는 합니다. 실행 취소 하 고 마지막 작업을 확인 하려면이 메서드를 사용할 수는 <xref:System.Windows.Forms.RichTextBox> 에 대 한 호출 될 때 컨트롤에 다시 적용할 수 있는 컨트롤의 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 메서드 구성 됩니다. 모든 작업을 사용 하 여 컨트롤에 다시 적용할 수 있는지 여부를 확인할 수는 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 및 <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> 속성, 및 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 방법에서 텍스트의 삭제를 제외 하 고 모든 작업을 다시 실행 작업을 제한 합니다. 이 예제에서는 포함 된 폼이 있어야는 <xref:System.Windows.Forms.RichTextBox> 컨트롤과 내에서 작업의 <xref:System.Windows.Forms.RichTextBox> 수행 되 고이 예제의 코드를 호출 하기 전에 실행을 취소 합니다.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>
          바로 가기 키를 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤 내에서 한 줄의 텍스트 크기를 가져오거나 설정합니다.</summary>
        <value>컨트롤 내에 있는 한 줄의 텍스트 크기(픽셀)입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 0 보다 큰 값을 컨트롤에 입력 한 경우 표시 되지 않는 여백은 지정된 된 컨트롤의 왼쪽에서 픽셀 수에 있는 컨트롤에 배치 됩니다. 이 여백을 벗어나는 입력 된 모든 텍스트 컨트롤의에서 텍스트의 다음 줄에 배치 됩니다. 이 속성에는 현재 속성이 설정 된 후에 컨트롤에 입력 추가 텍스트 컨트롤에 입력 된 모든 텍스트에 적용 합니다. 에 입력 된 모든 텍스트에 대 한 최대 선 두께 지정 하려면이 속성을 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만드는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.RichTextBox> 텍스트를 확대 하는, 단어를 두 번와 컨트롤의 클라이언트 영역 오른쪽에 여백이 때 컨트롤의 텍스트에서 단어를 자동으로 선택 합니다. 경우는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 작은 폭이이 코드를 사용 하 여 만들어집니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트의 각 문자를 별도 줄에 표시 되는 위치입니다. 이 세로 표시 위치에서 작업 하는 동안 단어의 모든 부분을 클릭 하는 텍스트가 세로로 표시 됩니다 팩트에 관계 없이 단어의 모든 문자 선택 됩니다. 이 예제에서는 포함 된 폼이 있어야는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 값이 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 RTF(서식 있는 텍스트 형식) 코드를 포함하여, <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트를 가져오거나 설정합니다.</summary>
        <value>RTF 형식으로 된 컨트롤의 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표시 하거나 컨트롤의 텍스트에 정의 된 지정한 RTF 서식을 사용 하 여 컨트롤의 텍스트를 추출 하는 컨트롤에 RTF 형식의 텍스트를이 속성을 사용할 수 있습니다. 이 속성은 컨트롤에 RTF 텍스트가 Microsoft Word 또는 Windows 워드 패드 같은 다른 RTF 원본의 할당 하려는 경우 일반적으로 사용 됩니다.  
  
 변경 하는 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 만 원시 텍스트 서식 없이 런타임 시 속성은 유지 합니다.  
  
 RTF 코드에 대 한 참조의 MSDN library에서 "서식 있는 텍스트 형식 사양 (RTF), 버전 1.6" http://msdn.microsoft.com/library합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" />의 내용을 파일로 저장합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">저장할 파일의 이름 및 위치입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" />의 내용을 RTF(서식 있는 텍스트 형식) 파일로 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드를 사용 하면 컨트롤의 전체 내용을 Microsoft Word 및 Windows 워드 패드 같은 다른 프로그램에서 사용할 수 있는 RTF 파일을 저장할 수 있습니다. 파일 이름을 지정 하는 경우에 전달 되는 `path` 매개 변수가 지정된 된 디렉터리에 이미 있습니다., 예 고 없이 파일을 덮어쓰게 됩니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 에 파일의 내용을 로드 하는 메서드는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
> [!NOTE]
>  컨트롤의 콘텐츠를 각기 다른 유형의 ASCII 텍스트 등의 파일 형식에 저장 하려면의 값을 허용 하는이 방법의 다른 버전을 사용 하 여는 <xref:System.Windows.Forms.RichTextBoxStreamType> 열거형을 매개 변수로 합니다.  
  
   
  
## Examples  
 콘텐츠를 저장 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> RTF 파일을 제어 합니다. 이 예제에서는 사용 된 <xref:System.Windows.Forms.SaveFileDialog> 클래스를 저장 하는 사용자, 경로 및 파일의 파일 이름에서 요청 대화 상자를 표시 합니다. 코드 서식 있는 텍스트 형식에서 콘텐츠를 가정 하는 파일을 저장 합니다. 파일이 이미 있으면 자동으로 덮어씁니다. 이 예제에서는 코드에 배치 됩니다는 <xref:System.Windows.Forms.Form> 가 있는 클래스는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤의 내용을 파일에 저장하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">저장할 파일이 들어 있는 데이터 스트림입니다.</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 내용을 열려 있는 데이터 스트림으로 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드를 사용 하면 이미 열려 있는 데이터 스트림에 컨트롤의 전체 내용을 저장할 수 있습니다. 데이터 스트림을 파일에 다음 정보를 저장할 수 있습니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 에 파일의 내용을 로드 하는 메서드는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드 또한에 전송 되는 정보의 데이터 형식을 지정할 수 있습니다는 <xref:System.IO.Stream> 개체입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 및 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 스트림 사용 하 여 메서드. 사용 하는 방법도 보여 줍니다는 <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, 및 <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> 멤버입니다.  
  
 프로젝트에 복사할 때 실행할 준비가 되는 전체 예제입니다.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileType" /> 매개 변수에 지정된 파일 형식이 잘못된 경우</exception>
        <exception cref="T:System.IO.IOException">컨트롤의 내용을 파일에 저장하는 동안 오류가 발생한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 만들거나 파일을 수정 합니다. 연관 된 열거형:는 <see langword="Write" /> 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">저장할 파일의 이름 및 위치입니다.</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 내용을 특정 형식의 파일로 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드를 사용 하면 컨트롤의 전체 내용을 Microsoft Word 및 Windows 워드 패드 같은 다른 프로그램에서 사용할 수 있는 RTF 파일을 저장할 수 있습니다. 파일 이름을 지정 하는 경우에 전달 되는 `path` 매개 변수가 지정된 된 디렉터리에 이미 있습니다., 예 고 없이 파일을 덮어쓰게 됩니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 에 파일의 내용을 로드 하는 메서드는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 방법을 사용 하면 컨트롤의 내용을 저장 하는 파일 형식을 지정할 수 있습니다. 컨트롤의 내용에 따라 적절 한 형식으로 파일 저장 되도록 하려면이 기능을 사용할 수 있습니다. 예를 들어 경우 문서에 글꼴 스타일 또는 색 차이가 없습니다, 있습니다 수 파일을 저장으로 ASCII 텍스트 파일을 설정 하 여는 `fileType` 매개 변수를 `RichTextBoxStreamType.PlainText`합니다.  
  
   
  
## Examples  
 콘텐츠를 저장 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> ASCII 텍스트 파일에 있습니다. 이 예제에서는 사용은 <xref:System.Windows.Forms.SaveFileDialog> 클래스 경로 파일 이름을 사용자를에서 요청 하는 대화 상자를 표시 합니다. 다음 코드는 해당 파일에 컨트롤의 콘텐츠를 저장합니다. 이 예제에서는이 버전의 사용은 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 파일 표준 서식 있는 텍스트 형식 대신 ASCII 텍스트 파일로 저장할 수를 지정 하는 메서드. 이 예제에서는 코드에 배치 됩니다는 <xref:System.Windows.Forms.Form> 가 있는 클래스는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileType" /> 매개 변수에 지정된 파일 형식이 잘못된 경우</exception>
        <exception cref="T:System.IO.IOException">컨트롤의 내용을 파일에 저장하는 동안 오류가 발생한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 만들거나 파일을 수정 합니다. 연관 된 열거형:는 <see langword="Write" /> 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에 표시할 스크롤 막대의 형식을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 값 중 하나입니다. 기본값은 <see langword="RichTextBoxScrollBars.Both" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 가로 및 세로 스크롤 막대의 사용자에 게 제공 하는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 컨트롤의 실제 크기 범위 밖에 있는 컨트롤 내의 텍스트를 스크롤할 수 있도록 합니다. 또한 컨트롤의 콘텐츠를 스크롤을 제한할 컨트롤에서 스크롤 막대를 제거 하려면이 속성을 사용할 수 있습니다.  
  
> [!NOTE]
>  가로 스크롤 막대가 표시 되지 않을 경우는 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 은 `true`의 값에 관계 없이 <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">지정된 값이 <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 열거형에 정의되지 않은 경우</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 현재 선택된 RTF(서식 있는 텍스트 형식)의 텍스트를 가져오거나 설정합니다.</summary>
        <value>컨트롤에서 선택된 RTF 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 RTF 형식 코드를 포함 하는 컨트롤에서 선택한 텍스트를 가져올 수 있습니다. 서식 및 붙여넣기를 갖춘 RTF 허용 하는 다른 응용 프로그램의 텍스트 Microsoft Word, Windows 워드 패드 등의 텍스트를 지정 하거나, 컨트롤에서 텍스트를 복사 하려면이 속성을 사용할 수 있습니다. 선택한 텍스트를 RTF 형식 코드 없이 가져오려면는 <xref:System.Windows.Forms.TextBoxBase.SelectedText%2A> 속성입니다.  
  
 현재 선택한 텍스트가 없는 경우이 속성에 지정 된 텍스트 삽입 지점에 삽입 됩니다. 텍스트를 선택 하는 경우이 속성에 할당 된 모든 텍스트를 선택한 텍스트를 바꿉니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 내에서 선택된 텍스트를 가져오거나 설정합니다.</summary>
        <value>컨트롤에서 선택된 텍스트를 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을는 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 속성에 글머리 기호 목록을 만드는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 폼에 만들어집니다.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역 또는 삽입 지점에 적용할 맞춤 방식을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에서 선택 된 단락이 없는 경우이 속성을 설정할 맞춤 설정을 삽입 지점이 표시 되도 단락 맞춤 속성 설정을 포함 하는 단락 이후에 생성에 대 한 단락에 적용 됩니다. 예를 들어, 경우에 두 단락은 <xref:System.Windows.Forms.RichTextBox> 제어 및 커서는 두 번째 단락 내에 있습니다. 설정 하는 경우는 <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 속성을 `HorizontalAlignment.Center`, 삽입 지점에 단락 컨트롤 내에서 가운데에 표시 됩니다. 세 번째 단락 두 번째 단락 뒤 만들어지면도 정렬 컨트롤의 중심입니다.  
  
 선택 영역 이루어지면 컨트롤 내에서 속성을 설정 하는 경우 선택한 모든 단락이 속성 설정에 따라 정렬 됩니다. 이 속성을 사용 하 여에서 만들어지는 문서에서 단락 정렬는 <xref:System.Windows.Forms.RichTextBox>합니다. 예를 들어 가운데 맞춤 될 문서에서 모든 단락을 하려는 경우 컨트롤의 단락을 모두 선택 고 설정할 수는 <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 속성을 `HorizontalAlignment.Center`합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 반환 `SelectionAlignment.Left` 텍스트 선택 혼합 된 여러 단락을 포함 하는 경우.  
  
   
  
## Examples  
 다음 코드 예제 내에서 텍스트를 정렬 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">지정된 값이 <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 클래스에 정의된 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에서 텍스트를 선택할 때 표시되는 텍스트 색을 가져오거나 설정합니다.</summary>
        <value>텍스트를 선택했을 때의 텍스트 색을 나타내는 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 속성 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> 가져오거나에서 선택한 텍스트의 색을 설정 하는 <xref:System.Windows.Forms.RichTextBox>합니다. 현재 선택한 텍스트가 없는 경우는 <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> 캐럿의 현재 위치에 속성이 적용 됩니다. 해당 위치에서 입력 된 문자에 지정 된 <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역 또는 삽입 지점에 글머리 기호 스타일이 적용되어 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          현재 선택 영역 또는 삽입 지점에 적용된 글머리 기호 스타일이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 선택한 텍스트가 없는 경우 현재 삽입 지점 삽입 지점 다음에 사용자가 입력 모든 단락의 글머리 기호 스타일 적용 됩니다. 글머리 기호 스타일 삽입 지점이 이동 될 때까지 또는 빈 글머리 항목에 사용자가 Enter 키를 누를 때 컨트롤의 텍스트에 적용 됩니다.  
  
 이 속성을 설정 하는 경우 텍스트가 컨트롤 내에서 선택 하는 경우 선택한 텍스트 내 모든 단락의 글머리 기호 목록에서 항목으로 변환 됩니다. 이 속성을 사용 하 여 글머리 기호 목록에서 만드는 문서 내에서 만들 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다.  
  
 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> 속성을 사용 하면 글머리 기호 및 글머리 기호 항목의 텍스트 사이 적용할 들여쓰기 크기를 지정할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을는 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 속성에 글머리 기호 목록을 만드는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 폼에 만들어집니다.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 내의 텍스트 선택 영역이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 컨트롤 내에서 텍스트 선택 영역을 변경 하는 시기를 결정 하는이 이벤트에 대 한 이벤트 처리기를 만들 수 있습니다. 이 이벤트에 대 한 이벤트 처리기는 사용자가 응용 프로그램 내에서 작업을 완료 될 때까지 선택 된 텍스트를 유지 데 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.RichTextBox.SelectionChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.RichTextBox.SelectionChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 텍스트가 기준선 위에 위 첨자로 표시되거나 기준선 아래에 아래 첨자로 표시되는지 여부를 가져오거나 설정합니다.</summary>
        <value>문자 오프셋을 지정하는 숫자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값은-2000 및 2000 사이 여야 합니다.  
  
 이 속성을 0으로 설정 하는 경우 텍스트가 기준선에 나타납니다. 양수 이면 숫자의 기준선 위에 텍스트 선택 올릴 픽셀 수를 지정 합니다. 음수 이면이 숫자는 아래 첨자로 텍스트 선택의 픽셀 수 기준인 지정 합니다. 위 첨자 또는 아래도 텍스트를 지정 하려면이 속성을 사용할 수 있습니다.  
  
 선택한 텍스트가 없는 경우 현재 삽입 지점 하 고 모든 텍스트를 사용자가 입력 한 삽입 지점 다음에 오프셋을 적용 합니다. 문자 오프셋 속성 컨트롤 내의 다른 부분으로 삽입 지점을 이동 될 때까지 또는 다른 값으로 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트와 텍스트 텍스트 선택 항목에 적용 된이 속성의 값을 갖게 됩니다 후 입력 합니다. 이 속성은 위 첨자 및 아래 첨자 텍스트 수학 식으로 이러한 응용 프로그램을 만드는 데 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 위 첨자 및 아래 첨자 텍스트 내에서 지정 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여 <xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A> 속성. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 값이 -2000보다 작거나 2000보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 텍스트 선택 영역 또는 삽입 지점의 텍스트 색을 가져오거나 설정합니다.</summary>
        <value>현재의 텍스트 선택 영역이나 삽입 지점 다음에 입력된 텍스트에 적용할 색을 나타내는 <see cref="T:System.Drawing.Color" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택 된 텍스트에 둘 이상의 색 지정 된 경우이 속성은 반환 `Color.Empty`합니다. 현재 선택한 텍스트가 없는 경우이 속성에 지정 된 텍스트 색 현재 삽입 지점 하 고 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트에 적용 됩니다. 텍스트 색 설정이 다른 색으로 되거나 삽입점 컨트롤 내의 다른 섹션으로 이동할 때 해당 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트와 텍스트 텍스트 선택 항목에 적용 된이 속성의 값을 갖게 됩니다 후 입력 합니다. 텍스트의 색을 변경 하려면이 속성을 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 컨트롤의 글꼴과를 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> 속성을 지정 하는 굵은 글꼴 스타일을 가진 새 글꼴을 할당 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.ColorDialog> 지정 현재 텍스트 선택 영역이 나 현재 삽입 후 입력 한 텍스트에 대 한 색을 지정 하려면 사용자에 게는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제는 예제에 정의 된 메서드를 추가 하려면 한 <xref:System.Windows.Forms.Form> 클래스를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 텍스트 선택 영역 또는 삽입 지점의 글꼴을 가져오거나 설정합니다.</summary>
        <value>현재의 텍스트 선택 영역이나 삽입 지점 다음에 입력된 텍스트에 적용할 글꼴을 나타내는 <see cref="T:System.Drawing.Font" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 현재 텍스트 선택 영역에 지정 된 둘 이상의 글꼴, `null`합니다. 현재 선택한 텍스트가 없는 경우 현재 삽입 지점 삽입 지점 다음 컨트롤에 입력 하는 모든 텍스트가이 속성에 지정 된 글꼴 적용 됩니다. 글꼴 설정을 다른 글꼴 또는 삽입 지점이 컨트롤 내의 다른 섹션으로 이동할 때 해당 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트와 텍스트 텍스트 선택 항목에 적용 된이 속성의 값을 갖게 됩니다 후 입력 합니다. 텍스트의 글꼴 스타일을 변경 하려면이 속성을 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 굵게, 기울임꼴 및 밑줄이 그어진 텍스트 컨트롤에서 만들 수 있습니다. 텍스트 및 텍스트에 적용 된 글꼴의 크기를 변경할 수 있습니다.  
  
 컨트롤에 있는 텍스트의 색을 변경 하려면 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 속성입니다.  
  
   
  
## Examples  
 텍스트 선택 이나 내에서 삽입 지점 뒤에 입력 한 텍스트에 대 한 설정 현재 글꼴 굵게 스타일을 변경 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 코드에서 메서드 내에 포함 되어 있음을 <xref:System.Windows.Forms.Form>합니다. 이 예제에서는 필요는 <xref:System.Windows.Forms.RichTextBox>명명 된 `richTextBox1`에 추가 된는 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택된 단락에 있는 텍스트 첫 줄의 왼쪽 가장자리와 다음 줄의 왼쪽 가장자리 사이의 거리를 가져오거나 설정합니다.</summary>
        <value>현재 텍스트 선택 영역 또는 삽입 지점에 적용된 첫 줄 들여쓰기의 거리(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택한 텍스트가 없는 경우 삽입 지점을 있는 단락과 삽입 지점 다음 컨트롤에 입력 하는 모든 텍스트가 내어쓰기 적용 됩니다. 첫 줄 들여쓰기 설정이 서로 다른 값 또는 컨트롤 내에서 다른 단락으로 삽입 지점이 이동 될 때까지 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트와 텍스트 텍스트 선택 항목에 적용 된이 속성의 값을 갖게 됩니다 후 입력 합니다. 이 속성을 사용 하 여 첫 줄 들여쓰기 단락에 적용할 수 있습니다.  
  
 단락 선택의 첫 번째 줄의 들여쓰기를 설정 하려면는 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제 내에서 첫 줄 들여쓰기를 지정 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택 영역이 시작되는 줄의 들여쓰기 길이(픽셀)를 가져오거나 설정합니다.</summary>
        <value>현재 텍스트 선택 영역 또는 삽입 지점의 왼쪽에 적용된 들여쓰기 거리(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택한 텍스트가 없는 경우 삽입 지점을 있는 단락과 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트 들여쓰기 설정이 적용 됩니다. 들여쓰기 설정에 다른 값 또는 컨트롤 내에서 다른 단락으로 삽입 지점이 이동 될 때까지 해당 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트와 텍스트 텍스트 선택 항목에 적용 된이 속성의 값을 갖게 됩니다 후 입력 합니다. 이 속성을 사용 하 여의 문서에 포함 된 단락 들여쓰기는 <xref:System.Windows.Forms.RichTextBox>합니다. 와 함께에서이 속성을 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> 단락에서 단락 표시를 만들려고 합니다.  
  
 단락의 첫 줄 들여쓰기 컨트롤에서을 만들려면 사용은 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제 내에서 들여쓰기 형식의 텍스트로 지정 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> 속성. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 선택된 문자의 수를 가져오거나 설정합니다.</summary>
        <value>텍스트 상자에서 선택한 문자 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 모든 문자에서에서 현재 선택 된 텍스트 상자 컨트롤에는 선택한 텍스트에 대 한 작업을 수행 하기 전에 확인 하려면이 속성을 사용할 수 있습니다. 작업을 단일 문자를 수행 하면 선택 되는 문자 (공백 포함)의 총 수를 확인 하려면이 속성을 사용할 수도 있습니다는 `for` 루프입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.RichTextBox.SelectionLength%2A> 속성 내에서 텍스트를 선택 하는 경우를 확인 하는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다. 이 예제에서는 필요 `richTextBox1` 컨트롤에서 선택 된 텍스트를 포함 합니다.  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 텍스트 선택 영역이 보호되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          현재 선택 영역의 내용을 변경할 수 없으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택한 텍스트가 없는 경우 삽입 지점을 있는 단락과 삽입 지점 다음 컨트롤에 입력 하는 모든 텍스트가 보호 설정이 적용 됩니다. 보호 설정에 다른 값 또는 컨트롤 내에서 다른 단락으로 삽입 지점이 이동 될 때까지 해당 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트와 텍스트 텍스트 선택 항목에 적용 된이 속성의 값을 갖게 됩니다 후 입력 합니다. 컨트롤 내의 텍스트 부분을 수정할 수 없도록 사용자를 방지 하기 위해이 속성을 사용할 수 있습니다.  
  
 이 속성은로 설정 하는 경우 `true`, <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트는 사용자가 현재 선택 된 텍스트를 변경 하려고 할 때 발생 합니다.  
  
> [!NOTE]
>  이 속성은 반환 `true` 전체 선택 컨트롤 내에서 보호 된 콘텐츠를 포함 하는 경우에 합니다.  
  
   
  
## Examples  
 다음 코드 예제 내에서 보호 된 텍스트를 지정 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여 <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> 속성. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 "RichTextBox." 라는 단어를 포함 하는 여기에 추가 하는 텍스트  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 오른쪽 가장자리와 현재 삽입 지점에서 선택되거나 추가된 텍스트의 오른쪽 가장자리 사이의 거리(픽셀)입니다.</summary>
        <value>현재 선택 영역 또는 삽입 지점의 오른쪽에 있는 들여쓰기 공간의 크기(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택한 텍스트가 없는 경우 삽입 지점을 있는 단락과 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트 들여쓰기 설정이 적용 됩니다. 들여쓰기 설정에 다른 값 또는 컨트롤 내에서 다른 단락으로 삽입 지점이 이동 될 때까지 해당 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트와 텍스트 텍스트 선택 항목에 적용 된이 속성의 값을 갖게 됩니다 후 입력 합니다. 이 속성을 사용 하 여의 문서에 포함 된 단락 들여쓰기는 <xref:System.Windows.Forms.RichTextBox>합니다. 와 함께에서이 속성을 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> 단락에서 단락 표시를 만들려고 합니다.  
  
 단락의 첫 줄 들여쓰기 컨트롤에서을 만들려면 사용은 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에 오른쪽 여백에를 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여 <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> 속성입니다. 이 예제에서는 포함 된 폼을 해야는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 예제 코드는 폼의 클래스에서 이벤트에서 호출 되 고 있습니다.  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 절대 탭 정지 위치를 가져오거나 설정합니다.</summary>
        <value>각 멤버가 탭 오프셋(픽셀)을 지정하는 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 각 탭에서 현재 선택한 텍스트에 대 한 간격을 포함 하는 배열을 가져올 수는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 그런 다음 각 탭 내의 텍스트 선택 항목의 크기를 조정 하려면이 속성을 사용할 수 있습니다. 예를 들어 문서 내에서 탭 간격을 조정 하려는 경우 문서 전체 선택 고 얻을 수 있습니다를 사용 하 여 탭 공간 목록은 <xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A> 속성입니다. 다음에 새 값을 조정할 수 있으며이 속성에 다시 할당.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">배열의 요소 수가 최대값인 32개보다 많은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 내에서 선택 유형을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택 영역에서 컨트롤 내에서 작업을 수행할 때 선택 항목을 제대로 처리 하기 위해 컨트롤에서 현재 선택 되어 있는 데이터의 형식을 확인 하려면이 속성을 사용할 수 있습니다. 속성에서 값의 조합을 나타낼 수는 <xref:System.Windows.Forms.RichTextBoxSelectionTypes> 다양 한 유형의 현재 선택 영역에 있는 개체를 나타내는 열거형입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택 영역 여백이 <see cref="T:System.Windows.Forms.RichTextBox" />에 표시되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          선택 영역 여백이 컨트롤에서 활성화되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하 여 사용자의 텍스트 줄을 쉽게 선택할 수 있도록는 <xref:System.Windows.Forms.RichTextBox>합니다. 선택 영역 여백을의 왼쪽에 추가 되는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 여백 쉽게에 대 한 사용자가 컨트롤의 왼쪽에서 시작 하는 텍스트를 선택할 수 있습니다. 사용자는 한 줄 텍스트를 선택 하려면 선택 영역 여백을 클릭 하거나 해당 줄에 포함 된 전체 단락을 선택 하려면 두 번 클릭 수 있습니다.  
  
> [!NOTE]
>  경우는 <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> 속성이 `true`설정는 <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> 속성을 `RichTextBoxScrollBars.Horizontal`, `RichTextBoxScrollBars.Vertical`, 또는 `RichTextBoxScrollBars.Both` 스크롤 막대가 표시 되지 것입니다. 상태에서 스크롤 막대를 표시 하기 위해는 <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> 속성이로 설정 되어 `true`로 설정 된 <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> 속성을 `RichTextBoxScrollBars.ForcedHorizontal`, `RichTextBoxScrollBars.ForcedVertical`, 또는 `RichTextBoxScrollBars.ForcedBoth`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>RichTextBox의 현재 텍스트를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 표시된 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 줄의 텍스트를 표시 하는 <xref:System.Windows.Forms.RichTextBox>로 설정 된 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성을 `true`합니다. 읽거나 설정 텍스트 여러 줄 텍스트 상자를 사용 하 여는 <xref:System.Windows.Forms.TextBoxBase.Lines%2A> 속성입니다. <xref:System.Windows.Forms.RichTextBox.Text%2A> 속성의 내용에 적용 되는 방법에 대 한 정보를 반환 하지 않는 <xref:System.Windows.Forms.RichTextBox>합니다. (RTF) 코드는 서식 있는 텍스트를 가져오려면는 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성입니다. 에 입력할 수 있는 텍스트의 크기는 <xref:System.Windows.Forms.RichTextBox> 컨트롤 사용 가능한 시스템 메모리에 의해서만 제한 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 텍스트 길이를 가져옵니다.</summary>
        <value>컨트롤의 텍스트에 포함된 문자의 수입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.TextBoxBase.Undo" /> 메서드를 호출할 때 컨트롤에서 실행 취소할 수 있는 동작의 이름을 가져옵니다.</summary>
        <value>실행 취소할 수 있는 동작의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 실행 취소할 수 있는 컨트롤 내에서 수행 된 마지막 동작을 확인할 수 있습니다. 이 속성을 사용 하 여 컨트롤의 사용자가 실행 취소할 수 있는 작업을 제한할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 세로 스크롤 막대를 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.RichTextBox.VScroll> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.RichTextBox.VScroll> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Windows 메시지 개체입니다.</param>
        <summary>Windows 메시지를 처리합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" />의 현재 확대/축소 수준을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 내용이 확대/축소되는 비율입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값은 1/64 (0.015625)에서 포함 하지 64.0 사이일 수 있습니다. 1.0 값을 지정 하지 확대/축소 컨트롤에 적용 됩니다. 확대/축소 기능이 문서 트루타입 글꼴이 포함 하는 경우 최적으로 수행 합니다. 트루타입 글꼴이 컨트롤을 문서에 사용 하면는 <xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A> 속성은 가장 가까운 정수 값을 사용 합니다. 사용자를 사용 하도록 설정 하려면이 속성을 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 컨트롤을 확인 하거나 더 많은 문서를 화면에 볼 수 있도록 뷰 축소을 너무 작은 설명서의 섹션으로 확대/축소 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만드는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.RichTextBox> 텍스트를 확대 하는, 단어를 두 번와 컨트롤의 클라이언트 영역 오른쪽에 여백이 때 컨트롤의 텍스트에서 단어를 자동으로 선택 합니다. 경우는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 작은 폭이이 코드를 사용 하 여 만들어집니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트의 각 문자를 별도 줄에 표시 되는 위치입니다. 이 세로 표시 위치에서 작업 하는 동안 단어의 모든 부분을 클릭 하는 텍스트가 세로로 표시 됩니다 팩트에 관계 없이 단어의 모든 문자 선택 됩니다. 이 예제에서는 포함 된 폼이 있어야는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 확대/축소 비율이 허용 범위에 속하지 않는 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>