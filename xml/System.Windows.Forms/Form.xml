<Type Name="Form" FullName="System.Windows.Forms.Form">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="95d840228da10b998cd2a6f059f0b9fa19adc332" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36522929" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <TypeSignature Language="VB.NET" Value="Public Class Form&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Form : System::Windows::Forms::ContainerControl" />
  <TypeSignature Language="F#" Value="type Form = class&#xA;    inherit ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a window or dialog box that makes up an application's user interface.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Forms.Form> 응용 프로그램에 표시 하는 모든 창의 표현입니다. <xref:System.Windows.Forms.Form> 클래스 standard, 여백, 도구 및 부동 창을 만드는 데 사용할 수 있습니다. 사용할 수도 있습니다는 <xref:System.Windows.Forms.Form> 클래스 대화 상자와 같은 모달 창을 만들 수 있습니다. 특별 한 종류 (MDI) 다중 문서 인터페이스 폼을 폼의 MDI 자식 폼을 호출 하는 다른 폼을 포함할 수 있습니다. 설정 하 여 MDI 폼 만들어집니다는 <xref:System.Windows.Forms.Form.IsMdiContainer%2A> 속성을 `true`합니다. MDI 자식 폼을 설정 하 여 만든는 <xref:System.Windows.Forms.Form.MdiParent%2A> 속성 자식 폼을 포함 하는 MDI 부모 폼을 합니다.  
  
 사용할 수 있는 속성을 사용 하 여 <xref:System.Windows.Forms.Form> 클래스를 만들면 창 또는 대화 상자의 모양, 크기, 색 및 창 관리 기능을 확인할 수 있습니다. <xref:System.Windows.Forms.Control.Text%2A> 속성 창의 캡션을 제목 표시줄에 지정할 수 있습니다. <xref:System.Windows.Forms.Form.Size%2A> 및 <xref:System.Windows.Forms.Form.DesktopLocation%2A> 속성을 사용 하면 표시 되는 크기와 창의 위치를 정의할 수 있습니다. 사용할 수는 <xref:System.Windows.Forms.Control.ForeColor%2A> 모든 컨트롤의 기본 전경색을 변경 하려면 색 속성 폼에 배치 합니다. <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, 및 <xref:System.Windows.Forms.Form.MaximizeBox%2A> 속성을 사용 하면 컨트롤을 폼 최소화, 최대화 하거나 실행 시 크기를 조정할 수 있는지 여부를 합니다.  
  
 속성 외에 폼을 조작 하는 클래스의 메서드를 사용할 수 있습니다. 예를 들어, 사용할 수는 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼을 모달 대화 상자로 표시 합니다. 사용할 수는 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> 메서드를 폼의 바탕 화면에서 위치를 지정 합니다.  
  
 이벤트는 <xref:System.Windows.Forms.Form> 클래스를 허용 하면 폼에서 수행 하는 작업에 응답할 수 있습니다. 사용할 수는 <xref:System.Windows.Forms.Form.Activated> 폼 활성화 될 때 폼의 컨트롤에 표시 된 데이터를 업데이트 하는 등 작업을 수행 하는 이벤트입니다.  
  
 라는 메서드를 배치 하 여 응용 프로그램에서 폼 시작 클래스로 사용할 수 있습니다 `Main` 클래스에 있습니다. 에 `Main` 메서드를 만들고 폼을 표시 하는 코드를 추가 합니다. 추가 해야 합니다는 `STAThread` 특성을 `Main` 폼을 실행 하려면 메서드. 시작 폼을 닫을 때 응용 프로그램이 닫힙니다.  
  
 설정 하는 경우는 <xref:System.Windows.Forms.Control.Enabled%2A> 속성을 `false` 하기 전에 <xref:System.Windows.Forms.Form> 표시 됩니다 (예를 들어 설정 <xref:System.Windows.Forms.Control.Enabled%2A> 를 false로 [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)] 디자이너), 최소화, 최대화, 닫기 및 시스템 단추를 사용 하도록 유지 합니다. 설정한 경우 <xref:System.Windows.Forms.Control.Enabled%2A> 를 `false` 후의 <xref:System.Windows.Forms.Form> 됩니다 (예: Load 이벤트가 발생할 때), 단추가 비활성화 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Form();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Forms.Form" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 폼의 크기가 높이 및 너비가 300 픽셀이 고 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한 사용 하 여 설정 된 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 폼의 메서드 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ AcceptButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptButton : System.Windows.Forms.IButtonControl with get, set" Usage="System.Windows.Forms.Form.AcceptButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the button on the form that is clicked when the user presses the ENTER key.</summary>
        <value>폼의 적용 단추로 사용할 단추를 나타내는 <see cref="T:System.Windows.Forms.IButtonControl" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 사용자가 응용 프로그램에서 ENTER 키를 누를 때 발생 하는 기본 동작을 지정할 수 있습니다. 이 속성에 할당 된 단추 이어야 합니다는 <xref:System.Windows.Forms.IButtonControl> 또는 현재 폼에 있는 컨테이너 내에 있는 현재 양식에 인 합니다.  
  
 사용자가 수동으로 마우스로 accept 단추를 클릭 하지 않고 완료 되 면 ENTER 키를 누르면 수 있으므로 간단한 양식을 빠르게 탐색할 수 있도록이 속성을 사용할 수 있습니다.  
  
 폼에서 현재 선택 된 컨트롤 ENTER 키를 차단 하 고 처리 하는 경우 적용 단추가 활성화 될 수 있습니다. 예를 들어 여러 줄 텍스트 상자 컨트롤에 ENTER 키를를 누른 상태로 선택 컨트롤에서 줄 바꿈 문자를 삽입할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.CancelButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Activate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; unit" Usage="form.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activates the form and gives it focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼 활성화 상태가 앞으로 활성 응용 프로그램 이거나 없으면이 활성 응용 프로그램 창 캡션의 깜박입니다. 폼이이 메서드를 사용 하려면에 대 한 표시 되어야 합니다. 응용 프로그램에서 활성 폼을 확인 하려면 사용 하 여는 <xref:System.Windows.Forms.Form.ActiveForm%2A> 속성 또는 <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> 양식은 다중 문서 MDI (인터페이스) 응용 프로그램의 경우 속성을 사용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> 및 <xref:System.Windows.Forms.Form.Activate%2A> 멤버입니다. 예제를 실행 하려면 이라는 폼에 다음 코드를 붙여 `Form1` 호출할 단추가 포함 된 `Button1` 와 두 개의 `Label` 이라는 컨트롤 `Label1` 및 `Label2`합니다.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">포커스를 변경 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the form is activated in code or by the user.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  응용 프로그램이 활성화 되어 폼이 여러 개 때 현재 형식은 입력된 포커스가 있는 폼이입니다. 양식에 표시 되지 않는 활성 폼 일 수 없습니다. 표시 폼을 활성화 하는 가장 간단한 방법은를 클릭 하거나 적절 한 키보드 조합을 사용 됩니다.  
  
 호출 코드를 사용 하 여 런타임에 폼을 활성화 하는 <xref:System.Windows.Forms.Form.Activate%2A> 메서드. 폼이 활성화 되지 않은 경우 폼의 데이터에 대 한 변경 내용에 따라 폼의 내용을 업데이트 하는 등 작업에 대 한이 이벤트를 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, 및 <xref:System.Windows.Forms.Form.Activate%2A> 멤버입니다. 예제를 실행 하려면 이라는 Form1 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.Button> 호출 `Button1` 와 두 개의 <xref:System.Windows.Forms.Label> 이라는 컨트롤 `Label1` 및 `Label2`합니다.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ActivateMdiChild(System::Windows::Forms::Form ^ form);" />
      <MemberSignature Language="F#" Value="member this.ActivateMdiChild : System.Windows.Forms.Form -&gt; unit" Usage="form.ActivateMdiChild form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">The child form to activate.</param>
        <summary>Activates the MDI child of a form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `form` 매개 변수는 이미 활성 MDI 자식 폼은 다음 <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> 메서드를 반환 합니다. 경우 `form` 않습니다 `null`, 활성 MDI 자식 폼 되도록 설정 됩니다.  
  
 여부는 `form` 매개 변수는 `null` 여부 <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> 를 발생 시킵니다는 <xref:System.Windows.Forms.Form.MdiChildActivate> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ActiveForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Form ^ ActiveForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveForm : System.Windows.Forms.Form" Usage="System.Windows.Forms.Form.ActiveForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the currently active form for this application.</summary>
        <value>현재 활성 폼을 나타내는 <see cref="T:System.Windows.Forms.Form" />이고 활성 폼이 없는 경우 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 폼 이나 컨트롤에서 동작을 수행 하려면 현재 활성 폼에 대 한 참조를 사용할 수 있습니다.  
  
 응용 프로그램은 (mdi 다중) 다중 문서 인터페이스 응용 프로그램을 사용 하 여는 <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> 속성을 현재 활성 MDI 자식 폼을 가져옵니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 활성 폼을 가져오고 폼에 있는 모든 컨트롤을 사용 하지 않도록 설정 합니다. 이 예제에서는 사용은 <xref:System.Windows.Forms.Control.Controls%2A> 양식이 폼에 있는 각 컨트롤을 반복 하는 컨트롤을 사용 하지 않도록 설정의 컬렉션입니다.  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">폼을 요청 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveMdiChild As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ActiveMdiChild { System::Windows::Forms::Form ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveMdiChild : System.Windows.Forms.Form" Usage="System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the currently active multiple-document interface (MDI) child window.</summary>
        <value>현재 활성 상태인 MDI 자식 창을 나타내는 <see cref="T:System.Windows.Forms.Form" />을(를) 반환하고 현재 자식 창이 없는 경우 <see langword="null" />을(를) 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 MDI 응용 프로그램에서 열려 있는 MDI 자식 폼을 확인 하려면이 메서드를 사용할 수 있습니다. 또한 응용 프로그램에 표시 되는 또 다른 형태 또는 MDI 부모 폼에서 MDI 자식 창에 대 한 작업을 수행 하려면이 메서드를 사용할 수 있습니다.  
  
 현재 활성 폼 MDI 자식 폼을 없는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.Form.ActiveForm%2A> 속성에 대 한 참조를 얻으려고 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 활성 MDI 자식 폼 및 모든 반복에 대 한 참조를 가져옵니다 <xref:System.Windows.Forms.TextBox> 폼에 컨트롤 다시 설정 하면 해당 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성입니다. 이 예제에서는 MDI 부모 폼을 만들었는지와 MDI 부모 폼에서이 메서드 호출은 만들어지는 되 고 필요 합니다.  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberSignature Language="F#" Value="member this.AddOwnedForm : System.Windows.Forms.Form -&gt; unit" Usage="form.AddOwnedForm ownedForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">The <see cref="T:System.Windows.Forms.Form" /> that this form will own.</param>
        <summary>Adds an owned form to this form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소유자 폼에 할당 된 상태를 유지 될 때까지 소유는 <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> 메서드를 호출 합니다. 설정 하 여 다른가 소유 하는 폼을 만들 수도 있습니다는 <xref:System.Windows.Forms.Form.Owner%2A> 소유자 폼에 대 한 참조를 사용 하 여 속성입니다.  
  
 폼을 다른 폼에서 소유 하는 경우 종료 되었거나 소유자 양식으로 숨겨집니다. 예를 들어 라는 폼 `Form2` 이라는 폼에서 소유 하는 `Form1`합니다. 경우 `Form1` 닫히거나을 최소화 하 고 `Form2` 도 닫히거나 숨겨집니다. 소유 된 폼의 소유자 폼 뒤 표시 되지 됩니다. 찾기 등의 windows에 대 한 소유 된 폼을 사용할 수 있으며 소유자 폼을 선택한 경우 소유자 폼 뒤 표시 되지 않아야 하는 창과 바꿀 수 있습니다.  
  
> [!NOTE]
>  폼이 (mdi 다중) 다중 문서 인터페이스 부모 폼이이 속성 열려 있는 MDI 자식 폼 현재 제외 하 고 표시 되는 모든 폼을 반환 합니다. MDI 부모 폼에서 열려 있는 MDI 자식 폼을 가져오려면는 <xref:System.Windows.Forms.Form.MdiChildren%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.AddOwnedForm%2A> 메서드를 다른 폼의 소유 된 폼으로 둔 양식을 표시 합니다. 소유 된 폼 표시 되 면, 소유자 폼을 최소화할 수 있습니다 및 함께 소유 된 폼이 최소화 됩니다. 이 예제에서는 다른 이벤트 또는 메서드는 폼의 코드 예제에서 호출 되도록 합니다.  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberSignature Language="F#" Value="override this.AdjustFormScrollbars : bool -&gt; unit" Usage="form.AdjustFormScrollbars displayScrollbars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          <see langword="true" /> to show the scroll bars; otherwise, <see langword="false" />.</param>
        <summary>Adjusts the scroll bars on the container based on the current control positions and the control currently selected.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowTransparency : bool with get, set" Usage="System.Windows.Forms.Form.AllowTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the opacity of the form can be adjusted.</summary>
        <value>폼의 불투명도를 변경할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은으로 자동 설정 `true` 경우는 `Opacity` 변경 됩니다. 폼의 불투명도 사용 하 여 설정 된 경우는 `Opacity` 속성 폼에 폼에서 개체 계층화 됩니다. 설정 하는 경우는 <xref:System.Windows.Forms.Form.AllowTransparency%2A> 속성을 `false` 폼 폼의 표시 성능을 향상 하는 계층화 된 모드에 있지 않게 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ApplyAutoScaling ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ApplyAutoScaling();" />
      <MemberSignature Language="F#" Value="member this.ApplyAutoScaling : unit -&gt; unit" Usage="form.ApplyAutoScaling " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resizes the form according to the current value of the <see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" /> property and the size of the current font.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 사용 하 여 폼 크기를 결정 하는이 메서드는 <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> 속성 및 <xref:System.Windows.Forms.Form.Size%2A> 에서 반환 된 값은 <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScale As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoScale { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScale : bool with get, set" Usage="System.Windows.Forms.Form.AutoScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the form adjusts its size to fit the height of the font used on the form and scales its controls.</summary>
        <value>폼에 사용된 현재 글꼴에 따라 해당 폼의 크기 및 컨트롤이 자동으로 조정되는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.AutoScale%2A> 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다. 사용되는 대체 항목은 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType>입니다. 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 이 속성을 사용 하 여 폼 및 글꼴 변경 내용에 따라 자동으로 조정 하도록 컨트롤입니다. 이 글꼴의 크기가 달라질 응용 프로그램 또는 Windows에서 사용 하기 위해 지정 된 언어에 따라 유용할 수 있습니다.  
  
 크기를 가져오는 폼이 자동 크기 조정 사용 하 여 <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> 속성입니다. 크기를 결정 하려면 폼 자동으로 조정 기반으로 사용 하 여 특정 글꼴는 <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScaleBaseSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size AutoScaleBaseSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleBaseSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the base size used for autoscaling of the form.</summary>
        <value>이 폼에서 자동 크기 조정을 위해 사용하는 기본 크기를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  이 멤버의 이전 버전과 호환성을 위해 유지 합니다. 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 값은 <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> 속성은 폼에 대 한 배율 인수를 계산 하려면 양식 표시 시간에 사용 합니다. 자동 크기 조정 기본 크기는 폼에서 사용를 기반으로 비교 하는 시스템의 글꼴 크기에 대 한 자동 크기 조정을 사용 되는 경우 폼의 크기 조정을를 결정 하기. 크기를 결정 하려면 폼 자동으로 조정 기반으로 사용 하 여 특정 글꼴는 <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> 메서드.  
  
> [!NOTE]
>  이 속성의 값은 폼을 처음으로 만들어질 때 사용 됩니다. 속성이 설정 되어 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScroll : bool with get, set" Usage="System.Windows.Forms.Form.AutoScroll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the form enables autoscrolling.</summary>
        <value>폼에서 자동 스크롤 기능을 사용하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 `true`, 컨트롤이 폼의 클라이언트 영역 외부에 있는 경우 스크롤 막대가 폼에 표시 됩니다. 또한 자동 스크롤에 있으면 폼의 클라이언트 영역 자동으로 스크롤됩니다 입력된 포커스가 있는 컨트롤을 표시 되도록 합니다.  
  
 사용자가 자신의 비디오 해상도 설정을 낮은 해상도로 설정 된 경우 컨트롤을 볼 수 있는 기능을 손실 하지 못하도록 하려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.AutoScroll%2A> 속성 폼의 클라이언트 영역 보다 큰 컨트롤을 표시할 수 있도록 합니다. 이 예제에서는 새 폼을 만들고 추가 <xref:System.Windows.Forms.Button> 컨트롤을 폼입니다. <xref:System.Windows.Forms.Button> 컨트롤은 초과 하 여 배치 새 폼의 클라이언트 영역입니다. <xref:System.Windows.Forms.Form.AutoScroll%2A> 속성이 스크롤 막대 컨트롤을 스크롤할 수 있도록 폼에 표시 하려면 true로 설정 되어 있습니다. 이 예제에서는 이벤트 처리기 또는 다른 방법의 다른 폼에서이 예제에 정의 된 메서드가 호출 되도록 합니다.  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Form.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Resize the form according to the setting of <see cref="P:System.Windows.Forms.Form.AutoSizeMode" />.</summary>
        <value>폼의 크기가 자동으로 조정되면 <see langword="true" />이고, 폼의 크기를 수동으로 조정해야 하면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Windows.Forms.Form.AutoSize%2A> 폼 크기를 내용에 맞게 조정 되도록 합니다.  
  
 폼의 값에 관계 없이 Visual Studio 폼 디자이너에서 자동으로 크기가 조정 되지 않습니다는 <xref:System.Windows.Forms.Form.AutoSize%2A> 및 <xref:System.Windows.Forms.Form.AutoSizeMode%2A> 속성입니다. 폼 올바르게 크기 조정에서 이러한 두 속성의 값에 따라 런타임에 합니다. 반대로, 사용자 지정 <xref:System.Windows.Forms.UserControl> 자동으로 디자인 타임 및 런타임 시 크기 조정 합니다.  
  
 사용 하는 경우 <xref:System.Windows.Forms.Form.AutoSize%2A>, <xref:System.Windows.Forms.Control.MinimumSize%2A> 및 <xref:System.Windows.Forms.Control.MaximumSize%2A> 의 현재 값을 제외한 속성은 적용 된 <xref:System.Windows.Forms.Control.Size%2A> 속성은 무시 됩니다. 사용 하 여 <xref:System.Windows.Forms.Form.AutoSize%2A> 및 <xref:System.Windows.Forms.Form.AutoSizeMode%2A> 렌더링는 <xref:System.Windows.Forms.Form.AutoScroll%2A> 속성 폼 보기에서 포함된 된 컨트롤 숨기기을 축소할 수 없으므로 없기 때문에 불필요 합니다.  
  
 참조는 <xref:System.Windows.Forms.AutoSizeMode> 때 폼 동작에 대 한 내용은 열거형 <xref:System.Windows.Forms.Form.AutoSize%2A> 은 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 내용에 맞게 자동으로 크기가 조정 되는 코드를 사용 하 여 만든 폼을 보여 줍니다. 실행 되는 경우 폼에 표시 되는 <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.TextBox> URL을 입력에 대 한 및 <xref:System.Windows.Forms.Button> 사용자의 기본 웹 브라우저 내 해당 URL을 표시 합니다. 사용 하 여 코드 예제는 <xref:System.Windows.Forms.FlowLayoutPanel> 포함 된 레이아웃에 하나씩를 제어 합니다. 또한 설정는 <xref:System.Windows.Forms.Control.AutoSize%2A> 및 <xref:System.Windows.Forms.AutoSizeMode> 성장 시키고 해당 폼의 내용에 맞게 축소 합니다.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="P:System.Windows.Forms.Form.AutoSize" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSizeMode As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoSizeMode AutoSizeMode { System::Windows::Forms::AutoSizeMode get(); void set(System::Windows::Forms::AutoSizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSizeMode : System.Windows.Forms.AutoSizeMode with get, set" Usage="System.Windows.Forms.Form.AutoSizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the mode by which the form automatically resizes itself.</summary>
        <value>
          <see cref="T:System.Windows.Forms.AutoSizeMode" /> 열거형 값입니다. 기본값은 <see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정의 <xref:System.Windows.Forms.Form.AutoSizeMode%2A> 속성을 새 값을 하면 다시 레이아웃 폼입니다.  
  
 폼의 값에 관계 없이 Visual Studio 폼 디자이너에서 자동으로 크기가 조정 되지 않습니다는 <xref:System.Windows.Forms.Form.AutoSize%2A> 및 <xref:System.Windows.Forms.Form.AutoSizeMode%2A> 속성입니다. 폼 올바르게 크기 조정에서 이러한 두 속성의 값에 따라 런타임에 합니다. 반대로, 사용자 지정 <xref:System.Windows.Forms.UserControl> 자동으로 디자인 타임 및 런타임 시 크기 조정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 내용에 맞게 자동으로 크기가 조정 되는 코드를 사용 하 여 만든 폼을 보여 줍니다. 실행할 때 코드는 <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.TextBox> URL을 입력에 대 한 및 <xref:System.Windows.Forms.Button> 사용자의 기본 웹 브라우저 내 해당 URL을 표시 합니다. 사용 하 여 코드 예제는 <xref:System.Windows.Forms.FlowLayoutPanel> 포함 된 레이아웃에 하나씩를 제어 합니다. 또한 설정는 <xref:System.Windows.Forms.Control.AutoSize%2A> 및 <xref:System.Windows.Forms.AutoSizeMode> 성장 시키고 해당 폼의 내용에 맞게 축소 합니다.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value is not a valid <see cref="T:System.Windows.Forms.AutoSizeMode" /> value.</exception>
        <altmember cref="T:System.Windows.Forms.AutoSizeMode" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberSignature Language="F#" Value="member this.AutoValidate : System.Windows.Forms.AutoValidate with get, set" Usage="System.Windows.Forms.Form.AutoValidate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether controls in this container will be automatically validated when the focus changes.</summary>
        <value>포커스가 변경될 때 암시적으로 포함된 컨트롤의 유효성을 검사할지 여부를 나타내는 <see cref="T:System.Windows.Forms.AutoValidate" /> 열거형 값입니다. 기본값은 Inherit입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoValidateChanged : EventHandler " Usage="member this.AutoValidateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="P:System.Windows.Forms.Form.AutoValidate" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Form.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the background color for the control.</summary>
        <value>컨트롤의 배경색을 나타내는 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberSignature Language="VB.NET" Value="Public Property CancelButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ CancelButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CancelButton : System.Windows.Forms.IButtonControl with get, set" Usage="System.Windows.Forms.Form.CancelButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the button control that is clicked when the user presses the ESC key.</summary>
        <value>폼의 취소 단추를 나타내는 <see cref="T:System.Windows.Forms.IButtonControl" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼에 대 한 취소 단추에는 ESC 키를 누를 때마다 클릭 되 단추 컨트롤입니다. 이 속성에 할당 된 단추 이어야 합니다는 <xref:System.Windows.Forms.IButtonControl> 또는 현재 폼에 있는 컨테이너 내에 있는 현재 양식에 인 합니다.  
  
 이 속성을 사용 하면 사용자가 응용 프로그램에서 ESC 키를 누를 때 발생 하는 기본 동작을 지정할 수 있습니다. 수동으로 마우스로 취소 단추를 클릭 하지 않고 변경 내용을 커밋하지 않고 창을 닫으려면 ESC 키를 누르기만 허용 하 여 간단한 양식을 빠르게 탐색할 수 있도록 하려면이 속성을 사용할 수 있습니다.  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A> 폼에서 다른 컨트롤 ESC 키를 가로채 면 작동 하지 않을 수 있습니다. 예를 들어 한 <xref:System.Windows.Forms.ComboBox> 폼에 열려 ESC 닫힙니다는 <xref:System.Windows.Forms.ComboBox> 폼을 종료 하는 대신 합니다.  
  
 <xref:System.Windows.Forms.IButtonControl> 개체에 할당 된 <xref:System.Windows.Forms.Form.CancelButton%2A> 폼에 표시 되어야 합니다. 그렇지 않으면는 esc 키 아무런 효과가 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToParent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToParent();" />
      <MemberSignature Language="F#" Value="member this.CenterToParent : unit -&gt; unit" Usage="form.CenterToParent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Centers the position of the form within the bounds of the parent form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하지 마십시오는 <xref:System.Windows.Forms.Form.CenterToParent%2A> 사용자 코드에서 직접 메서드. 대신, 설정 된 <xref:System.Windows.Forms.Form.StartPosition%2A> 속성을 <xref:System.Windows.Forms.FormStartPosition.CenterParent>합니다.  
  
 양식 또는 대화는 최상위 수준, 다음 경우 <xref:System.Windows.Forms.Form.CenterToParent%2A> 화면이 나 바탕 화면에 대해 폼 가운데에 맞춥니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterParent" />
        <altmember cref="M:System.Windows.Forms.Form.CenterToScreen" />
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToScreen();" />
      <MemberSignature Language="F#" Value="member this.CenterToScreen : unit -&gt; unit" Usage="form.CenterToScreen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Centers the form on the current screen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 사용자 코드에서 직접 호출 하지 마십시오. 대신, 설정 된 <xref:System.Windows.Forms.Form.StartPosition%2A> 속성을 <xref:System.Windows.Forms.FormStartPosition.CenterScreen>합니다.  
  
 <xref:System.Windows.Forms.Form.CenterToScreen%2A> 메서드 다음과 같은 우선 순위를 사용 하 여 폼 가운데 하는 데 사용 하 여 화면을 결정 합니다.  
  
1.  <xref:System.Windows.Forms.Form.Owner%2A> 폼의 속성입니다.  
  
2.  폼의 HWND 소유자입니다.  
  
3.  현재 마우스 커서에 있는 화면입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterScreen" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the size of the client area of the form.</summary>
        <value>폼의 클라이언트 영역 크기를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼의 클라이언트 영역 크기에는 테두리 및 제목 표시줄을 제외한 폼의 크기가입니다. 폼의 클라이언트 영역에는 컨트롤을 배치할 수 있는 폼 내에서 영역이입니다. 이 속성을 사용 하 여 폼의 컨트롤을 배치 하 고 크기를 조정할 또는 그래픽 작업을 수행할 때 적절 한 크기를 가져올 수 있습니다. 전체 폼의 크기를 가져오려면는 <xref:System.Windows.Forms.Form.Size%2A> 속성 하거나 개별 속성을 사용 하 여 <xref:System.Windows.Forms.Control.Height%2A> 및 <xref:System.Windows.Forms.Control.Width%2A>합니다.  
  
> [!NOTE]
>  현재 응용 프로그램 설정을 사용 하 여이 속성에 바인딩할 수 없습니다. 응용 프로그램 설정에 대 한 자세한 내용은 참조 하십시오. [응용 프로그램 설정 개요](~/docs/framework/winforms/advanced/application-settings-overview.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 이벤트 처리기를 만듭니다.는 <xref:System.Windows.Forms.Control.Resize> 폼의 이벤트입니다. 이벤트 처리기에서 사용는 <xref:System.Windows.Forms.Form.ClientSize%2A> 있도록 폼의 속성을 <xref:System.Windows.Forms.Button> 라는 컨트롤 `button1` 폼의 전체 클라이언트 영역을 채웁니다.  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="form.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼이 닫힐 때 개체 내에서 생성 된 모든 리소스 닫혀 있고 폼이 삭제 됩니다. 처리 하 여 런타임에 폼의 닫는 방지할 수 있습니다는 <xref:System.Windows.Forms.Form.Closing> 이벤트와 설정 된 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성의는 <xref:System.ComponentModel.CancelEventArgs> 이벤트 처리기에 매개 변수로 전달 합니다. 닫으려는 폼은 응용 프로그램의 시작 폼을 응용 프로그램 종료 됩니다.  
  
 폼에서 삭제 되지 않은 두 가지 경우 `Close` 는 경우는 (mdi 다중) 다중 문서 인터페이스 응용 프로그램의 일부인 (1) 및 폼은 보이지 않습니다. (2)을 표시 한 양식 사용 하 여 및 <xref:System.Windows.Forms.Form.ShowDialog%2A>합니다. 이러한 경우에 호출 해야 합니다 <xref:System.Windows.Forms.Form.Dispose%2A> 가비지 수집에 대 한 폼의 컨트롤을 모두 표시 하도록 수동으로 합니다.  
  
> [!NOTE]
>  때는 <xref:System.Windows.Forms.Form.Close%2A> 메서드가 호출 되는 <xref:System.Windows.Forms.Form> 모덜리스 창으로 표시를 호출할 수 없습니다는 <xref:System.Windows.Forms.Control.Show%2A> 메서드 폼의 리소스가 이미 해제 되었으므로 때문에 폼을 표시 합니다. 폼을 숨기고 표시를 사용 하 여 확인 된 <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> 메서드.  
  
> [!CAUTION]
>  이전에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 2.0는 <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> 이벤트는 실행 될 때 발생 하는 <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> 메서드를 호출 응용 프로그램을 종료 하 합니다. 유효성 검사 코드를 실행 해야 하는 이러한 이벤트 중 하나에 있으면 호출 해야는 <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> 호출 하기 전에 개별적으로 열려 있는 각 폼에 대 한 메서드는 <xref:System.Windows.Forms.Application.Exit%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The form was closed while a handle was being created.</exception>
        <exception cref="T:System.ObjectDisposedException">You cannot call this method from the <see cref="E:System.Windows.Forms.Form.Activated" /> event when <see cref="P:System.Windows.Forms.Form.WindowState" /> is set to <see cref="F:System.Windows.Forms.FormWindowState.Maximized" />.</exception>
        <altmember cref="P:System.ComponentModel.CancelEventArgs.Cancel" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the form is closed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed> 이벤트는.NET Framework 버전 2.0에서에서 사용 되지 않습니다; 사용 된 <xref:System.Windows.Forms.Form.FormClosed> 이벤트 대신 합니다.  
  
 이 이벤트는 사용자 또는 폼이 닫힌 후 발생는 <xref:System.Windows.Forms.Form.Close%2A> 폼의 메서드. 폼을 닫는 하지 않도록 하려면 처리는 <xref:System.Windows.Forms.Form.Closing> 이벤트 집합과 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성은 <xref:System.ComponentModel.CancelEventArgs> 이벤트 처리기에 전달 된 `true`합니다.  
  
 폼에서 사용 하는 리소스를 확보 하는 등의 작업을 수행 하 고 폼에 입력 한 정보를 저장 하 또는 부모 폼을 업데이트 하려면이 이벤트를 사용할 수 있습니다.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> 이벤트는 실행 될 때 발생 하는 <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> 메서드는 응용 프로그램을 종료 합니다. 유효성 검사 코드를 실행 해야 하는 이러한 이벤트 중 하나에 있으면 호출 해야는 <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> 호출 하기 전에 개별적으로 열려 있는 각 폼에 대 한 메서드는 <xref:System.Windows.Forms.Application.Exit%2A> 메서드.  
  
 폼이 MDI 부모 폼의 <xref:System.Windows.Forms.Form.Closing> 모든 MDI 자식 폼의 MDI 부모 폼의 하기 전에 발생 <xref:System.Windows.Forms.Form.Closing> 이벤트가 발생 합니다. 또한는 <xref:System.Windows.Forms.Form.Closed> 모든 MDI 자식 폼의 발생 하기 전에 <xref:System.Windows.Forms.Form.Closed> MDI 부모 폼의 이벤트가 발생 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, 및 <xref:System.Windows.Forms.Form.Activate%2A> 멤버입니다. 예제를 실행 하려면 이라는 폼에 다음 코드를 붙여 `Form1` 포함 하는 <xref:System.Windows.Forms.Button> 호출 `Button1` 와 두 개의 <xref:System.Windows.Forms.Label> 이라는 컨트롤 `Label1` 및 `Label2`합니다.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the form is closing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closing> 이벤트는.NET Framework 버전 2.0에서에서 사용 되지 않습니다; 사용 된 <xref:System.Windows.Forms.Form.FormClosing> 이벤트 대신 합니다.  
  
 <xref:System.Windows.Forms.Form.Closing> 이 이벤트는 폼을 닫을 때 발생 합니다. 폼이 닫힐 때 개체 내에서 만들어진 모든 리소스가 해제 되 고 폼이 삭제 됩니다. 이 이벤트를 취소 하면 폼 열린 상태로 유지 됩니다. 폼의 클로저를 취소 하려면는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 의 속성은 <xref:System.ComponentModel.CancelEventArgs> 이벤트 처리기에 전달 된 `true`합니다.  
  
 폼을 모달 대화 상자로 표시 되 면 클릭 하 고 **닫기** 단추 (x 폼의 오른쪽 위 모서리에 있는 단추)를 사용 하면 양식을 숨길 및 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성으로 설정 됩니다 `DialogResult.Cancel`합니다. 에 할당 된 값을 재정의할 수 있습니다는 <xref:System.Windows.Forms.Form.DialogResult%2A> 클릭할 때 속성의 **닫기** 설정 하 여 단추는 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성에 대 한 이벤트 처리기에는 <xref:System.Windows.Forms.Form.Closing> 폼의 이벤트입니다.  
  
> [!NOTE]
>  때는 <xref:System.Windows.Forms.Form.Close%2A> 메서드가 호출 되는 <xref:System.Windows.Forms.Form> 모덜리스 창으로 표시를 호출할 수 없습니다는 <xref:System.Windows.Forms.Control.Show%2A> 메서드 폼의 리소스가 이미 해제 되었으므로 때문에 폼을 표시 합니다. 폼을 숨기고 표시를 사용 하 여 확인 된 <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> 메서드.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> 이벤트는 실행 될 때 발생 하는 <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> 메서드는 응용 프로그램을 종료 합니다. 유효성 검사 코드를 실행 해야 하는 이러한 이벤트 중 하나에 있으면 호출 해야는 <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> 호출 하기 전에 개별적으로 열려 있는 각 폼에 대 한 메서드는 <xref:System.Windows.Forms.Application.Exit%2A> 메서드.  
  
 폼이 MDI 부모 폼의 <xref:System.Windows.Forms.Form.Closing> 모든 MDI 자식 폼의 MDI 부모 폼의 하기 전에 발생 <xref:System.Windows.Forms.Form.Closing> 이벤트가 발생 합니다. 또한는 <xref:System.Windows.Forms.Form.Closed> 모든 MDI 자식 폼의 발생 하기 전에 <xref:System.Windows.Forms.Form.Closed> MDI 부모 폼의 이벤트가 발생 합니다. 취소는 <xref:System.Windows.Forms.Form.Closing> 때도 MDI 자식 폼의 이벤트는 <xref:System.Windows.Forms.Form.Closing> MDI 부모 폼에서 발생 하는 이벤트입니다. 그러나로 설정 됩니다 이벤트를 취소 `true` 는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 의 속성은 <xref:System.ComponentModel.CancelEventArgs> 부모 폼에 매개 변수로 전달 되는 합니다. 모든 MDI 부모 및 자식 폼을 강제로 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성을 `false` 는 mdi 부모 폼입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Form.Closing> 여부를 테스트 하에 있는 텍스트는 <xref:System.Windows.Forms.TextBox> 변경 되었습니다. 있는 경우, 사용자가 것인지 묻는 메시지가 나타나면 파일에 변경 내용을 저장 합니다.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberSignature Language="VB.NET" Value="Public Property ControlBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ControlBox { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ControlBox : bool with get, set" Usage="System.Windows.Forms.Form.ControlBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether a control box is displayed in the caption bar of the form.</summary>
        <value>
          <see langword="true" /> 폼의 오른쪽 위 모퉁이에 컨트롤 상자가 표시 되는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Form.ControlBox%2A> 속성이 `true`, 캡션 표시줄의 오른쪽 위 모퉁이에 컨트롤 상자가 표시 됩니다. 컨트롤 상자 포함 될 수 있습니다 최소화, 최대화 및 닫기 단추를 단추는 또한 데 도움이 됩니다. 에 대 한는 `ControlBox` 매개 변수가 적용 속성 폼을 설정 해야 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 속성을 <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, 또는 <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>합니다.  
  
 설정 하는 경우 <xref:System.Windows.Forms.Form.ControlBox%2A> 를 `false` 설정는 <xref:System.Windows.Forms.Form.Location%2A> 속성에는 <xref:System.Windows.Forms.Form.Size%2A> 폼의 속성이 양식의 비클라이언트 영역 숨겨진 반영 하도록 업데이트 되지 않습니다. 이 문제를 해결 하려면 변경 하는 코드를 삽입는 <xref:System.Windows.Forms.Form.Location%2A> 속성에는 <xref:System.Windows.Forms.Control.HandleCreated> 이벤트 처리기입니다.  
  
> [!NOTE]
>  로 설정 하면 `false`, <xref:System.Windows.Forms.Form.ControlBox%2A> 속성이 생성 시 최대화 표시 되는 다중 문서 MDI (인터페이스) 자식 폼에 적용 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 어떤 테두리 또는 캡션 상자를 하지 않은 폼을 만들 속성입니다. 이 예제에서 만든 양식 응용 프로그램에 대 한 시작 화면을 만드는 데 사용할 수 없습니다. 예제에서는 예에 나오는 메서드는 폼 클래스에 정의 되 고 폼이 초기화 될 때 호출.  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="form.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new instance of the control collection for the control.</summary>
        <returns>A new instance of <see cref="T:System.Windows.Forms.Control.ControlCollection" /> assigned to the control.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberSignature Language="F#" Value="override this.CreateHandle : unit -&gt; unit" Usage="form.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates the handle for the form. If a derived class overrides this function, it must call the base implementation.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">A handle for this <see cref="T:System.Windows.Forms.Form" /> has already been created.</exception>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Form.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the required creation parameters when the control handle is created.</summary>
        <value>컨트롤 핸들을 만들 때 필요한 작성 매개 변수가 포함된 <see cref="T:System.Windows.Forms.CreateParams" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivate;" />
      <MemberSignature Language="F#" Value="member this.Deactivate : EventHandler " Usage="member this.Deactivate : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the form loses focus and is no longer the active form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비활성화 된 폼의 데이터로 업데이트 하는 응용 프로그램의 다른 창 등의 작업을 수행 하려면이 이벤트를 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.Deactivate> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.Deactivate> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
        <altmember cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Form.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default Input Method Editor (IME) mode supported by the control.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ImeMode" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 입력된 (입력기)는 사용자가 표준 키보드를 사용 하 여 복잡 한 한글 등의 기호를 입력할 수 있는 프로그램입니다.  
  
 구현 되는 <xref:System.Windows.Forms.Form> 클래스,이 속성은 항상 반환는 <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> 값입니다. 이 속성의 값에 할당 되는 <xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Form.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default size of the control.</summary>
        <value>컨트롤의 기본 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.DefWndProc :  -&gt; unit" Usage="form.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">The Windows <see cref="T:System.Windows.Forms.Message" /> to process.</param>
        <summary>Sends the specified message to the default window procedure.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle DesktopBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.DesktopBounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Form.DesktopBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the size and location of the form on the Windows desktop.</summary>
        <value>데스크톱 좌표를 사용하여 Windows 데스크톱에서 폼의 경계를 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데스크톱 좌표로 작업 표시줄을 제외 하는 화면에서의 작업 영역을 기반으로 합니다. 바탕 화면 좌표계는 픽셀 시작 합니다. 응용 프로그램이 다중 모니터 시스템에서 실행 되는 경우 폼의 좌표는 조합 된 데스크톱 좌표입니다.  
  
 이 속성은 크기와 다른 양식 또는 응용 프로그램을 기준으로 폼의 Windows 바탕 화면에서 위치를 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에서 바탕 화면 맨 위에서부터 데스크톱 및 50 픽셀의 왼쪽된 테두리 50 픽셀을 위치 지정된이 있도록 크기와 폼의 위치를 설정 합니다. 이 예제에서는 메서드가 양식 클래스 내에서 정의 되어 있어야 합니다.  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopLocation" />
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopLocation As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point DesktopLocation { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.DesktopLocation : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Form.DesktopLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the location of the form on the Windows desktop.</summary>
        <value>데스크톱에서 폼의 위치를 나타내는 <see cref="T:System.Drawing.Point" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데스크톱 좌표로 작업 표시줄을 제외 하는 화면에서의 작업 영역을 기반으로 합니다. 바탕 화면 좌표계는 픽셀 기반으로 합니다. 응용 프로그램이 다중 모니터 시스템에서 실행 되는 경우 폼의 좌표는 조합 된 데스크톱 좌표입니다.  
  
 Windows 바탕 화면에서 다른 폼과 응용 프로그램을 기준으로 폼 배치 하려면이 속성을 사용할 수 있습니다.  
  
 호출 하는 경우는 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> 메서드 호출 하기 전에 <xref:System.Windows.Forms.Form.Show%2A> 메서드를 폼으로 운영 체제에 의해 결정 된 기본 위치에 배치 됩니다. 창 위치를 지정 하는 방법에 대 한 자세한 내용은 MSDN library에서 "창 기능" 문서 "창 크기 및 위치" 섹션을 참조 하십시오. http://msdn.microsoft.com/library합니다.  
  
 호출 하는 경우 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> 호출한 후 <xref:System.Windows.Forms.Form.Show%2A>, 폼을 사용자가 지정한 위치에 배치 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에서 바탕 화면 맨 위에서부터 데스크톱 및 100 픽셀의 왼쪽된 테두리 100 픽셀을 위치 지정된이 있도록 폼의 위치를 설정 합니다. 이 예제에서는 폼 클래스 내에 메서드가 정의 되어 있는지 필요 합니다.  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DialogResult DialogResult { System::Windows::Forms::DialogResult get(); void set(System::Windows::Forms::DialogResult value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : System.Windows.Forms.DialogResult with get, set" Usage="System.Windows.Forms.Form.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the dialog result for the form.</summary>
        <value>폼이 대화 상자로 사용되는 경우 해당 폼의 결과를 나타내는 <see cref="T:System.Windows.Forms.DialogResult" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼의 대화 상자 결과는 모달 대화 상자로 표시 되 면 폼에서 반환 되는 값입니다. 폼이 대화 상자로 표시를 하는 경우이 속성의 값으로 설정 된 <xref:System.Windows.Forms.DialogResult> 열거형 형식에 대 한 대화 상자 결과의 값을 설정, 모달 대화 상자를 숨깁니다 및 컨트롤을 반환 합니다. 일반적으로이 속성은에서 설정 되는 <xref:System.Windows.Forms.Button.DialogResult%2A> 속성의는 <xref:System.Windows.Forms.Button> 폼에서 컨트롤입니다. 클릭 하면는 <xref:System.Windows.Forms.Button> 에 할당 된 값을 제어는 <xref:System.Windows.Forms.Button.DialogResult%2A> 속성의는 <xref:System.Windows.Forms.Button> 에 할당 되는 <xref:System.Windows.Forms.Form.DialogResult%2A> 폼의 속성입니다.  
  
 폼을 모달 대화 상자로 표시 되 면 클릭 하 고 **닫기** 단추 (X가 폼의 오른쪽 위 모서리에 있는 단추)를 사용 하면 양식을 숨길 및 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성으로 설정 됩니다 `DialogResult.Cancel`합니다. <xref:System.Windows.Forms.Form.Close%2A> 메서드가 클릭할 때 자동으로 호출 되지 않습니다는 **닫기** 대화 상자의 단추의 값을 설정 하거나는 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성입니다. 대신, 폼 숨겨져 있고 대화 상자의 새 인스턴스를 만들지 않고 다시 표시할 수 있습니다. 이러한 동작으로 인해를 호출 해야 합니다는 <xref:System.Windows.Forms.Control.Dispose%2A> 폼은 더 이상 필요 없는 응용 프로그램에서 폼의 메서드.  
  
 대화 상자에서 수행 되는 동작을 제대로 처리할 수 있도록 대화 상자를 닫을 하는 방법을 확인 하려면이 속성을 사용할 수 있습니다.  
  
> [!NOTE]
>  에 할당 된 값을 재정의할 수 있습니다는 <xref:System.Windows.Forms.Form.DialogResult%2A> 클릭할 때 속성의 **닫기** 설정 하 여 단추는 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성에 대 한 이벤트 처리기에는 <xref:System.Windows.Forms.Form.Closing> 폼의 이벤트입니다.  
  
> [!NOTE]
>  경우는 <xref:System.Windows.Forms.Form> 모덜리스 창에서 반환 된 값으로 표시 되는 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성 폼을 닫을 때 폼의 리소스가 자동으로 해제 하기 때문에 폼에 사용 된 값을 반환 하지 수도 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 대화 상자로 있는 폼을 표시 하 고 참조 하 여 폼의 확인 또는 취소 단추가 클릭 되었다는 있는지 여부를 나타내는 메시지 상자를 표시 된 <xref:System.Windows.Forms.Form.DialogResult%2A> 폼의 속성입니다.  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value specified is outside the range of valid values.</exception>
        <altmember cref="T:System.Windows.Forms.DialogResult" />
        <altmember cref="P:System.Windows.Forms.Button.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="form.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Disposes of the resources (other than memory) used by the <see cref="T:System.Windows.Forms.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 public `Dispose` 메서드 및 <xref:System.Object.Finalize%2A> 메서드. `Dispose` 보호 된 호출 `Dispose(Boolean)` 메서드는 `disposing` 매개 변수 설정 `true`합니다. <xref:System.Object.Finalize%2A> 호출 `Dispose` 와 `disposing` 로 설정 `false`합니다.  
  
 `disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.Windows.Forms.Form>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다. 이 메서드는 참조되는 각 개체의 `Dispose` 메서드를 호출합니다.  
  
 <xref:System.Windows.Forms.Form.Dispose%2A> 사용 하 여 폼이 표시 하는 경우 자동으로 호출 됩니다는 <xref:System.Windows.Forms.Form.Show%2A> 메서드. 하는 경우와 같은 다른 방법을 <xref:System.Windows.Forms.Form.ShowDialog%2A> 사용 하는 경우 또는 폼이 전혀 표시 되지 않는 호출 해야 합니다 <xref:System.Windows.Forms.Form.Dispose%2A> 응용 프로그램 내에서 직접 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 다른 개체에서 여러 번 호출할 수 있습니다. <see langword="Dispose(Boolean)" />를 재정의할 때 이전 <see langword="Dispose" /> 호출에서 삭제된 개체를 참조하지 않도록 주의하십시오. 구현 하는 방법에 대 한 자세한 내용은 <see langword="Dispose(Boolean)" />, 참조 [Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md) 구현 합니다.  에 대 한 자세한 내용은 <see langword="Dispose" /> 및 <see cref="M:System.Object.Finalize" />, 참조 [관리 되지 않는 Resources](~/docs/standard/garbage-collection/unmanaged.md) 정리 하 고 [Finalize 메서드를 재정의] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.Forms.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.Forms.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the DPI setting changes on the display device where the form is currently displayed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FormBorderStyle As FormBorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormBorderStyle FormBorderStyle { System::Windows::Forms::FormBorderStyle get(); void set(System::Windows::Forms::FormBorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.FormBorderStyle : System.Windows.Forms.FormBorderStyle with get, set" Usage="System.Windows.Forms.Form.FormBorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the border style of the form.</summary>
        <value>폼에 표시되는 테두리의 스타일을 나타내는 <see cref="T:System.Windows.Forms.FormBorderStyle" />입니다. 기본값은 <see langword="FormBorderStyle.Sizable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼의 테두리 스타일 폼의 바깥쪽 가장자리 표시 되는 방식을 결정 합니다. 폼의 테두리 표시를 변경 하는 것 외에도 특정 테두리 스타일의 크기도 조정할 폼을 방지 합니다. 예를 들어는 `FormBorderStyle.FixedDialog` 테두리 스타일의 대화 상자 폼의 테두리 변경 하 고 폼 크기를 조정 하지 못하도록 합니다. 테두리 스타일 크기 또는 폼의 캡션 표시줄 섹션의 가용성에 영향을 줄 수 있습니다.  
  
> [!NOTE]
>  와 <xref:System.Windows.Forms.FormBorderStyle.Sizable> 스타일 수 없으면 특정 한 최소 값 이하로 창 크기를 조정 하면 설정한 경우에 <xref:System.Windows.Forms.Form.ControlBox%2A> 를 `false` 길이가 0 인 문자열을 할당 하 고 <xref:System.Windows.Forms.Form.Text%2A>합니다. 사용 하 여이 문제를 해결할 것이 좋습니다는 <xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow> 대신 스타일입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value specified is outside the range of valid values.</exception>
        <altmember cref="T:System.Windows.Forms.FormBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosed As FormClosedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosedEventHandler ^ FormClosed;" />
      <MemberSignature Language="F#" Value="member this.FormClosed : System.Windows.Forms.FormClosedEventHandler " Usage="member this.FormClosed : System.Windows.Forms.FormClosedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the form is closed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosed> 이 이벤트는 사용자 또는 폼이 닫힌 후 발생는 <xref:System.Windows.Forms.Form.Close%2A> 메서드 또는 <xref:System.Windows.Forms.Application.Exit%2A> 의 메서드는 <xref:System.Windows.Forms.Application> 클래스입니다. 폼을 닫는 하지 않도록 하려면 처리는 <xref:System.Windows.Forms.Form.FormClosing> 이벤트 집합과 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성은 <xref:System.ComponentModel.CancelEventArgs> 이벤트 처리기에 전달 된 `true`합니다.  
  
 폼에서 사용 하는 리소스를 확보 하는 등의 작업을 수행 하 고 폼에 입력 한 정보를 저장 하 또는 부모 폼을 업데이트 하려면이 이벤트를 사용할 수 있습니다.  
  
 폼이 (mdi 다중) 다중 문서 인터페이스 부모 폼의 <xref:System.Windows.Forms.Form.FormClosing> 모든 MDI 자식 폼의 MDI 부모 폼의 하기 전에 발생 <xref:System.Windows.Forms.Form.FormClosing> 이벤트가 발생 합니다. 마찬가지로,는 <xref:System.Windows.Forms.Form.FormClosed> 모든 MDI 자식 폼의 발생 하기 전에 <xref:System.Windows.Forms.Form.FormClosed> MDI 부모 폼의 이벤트가 발생 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.FormClosed> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.FormClosed> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosing As FormClosingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosingEventHandler ^ FormClosing;" />
      <MemberSignature Language="F#" Value="member this.FormClosing : System.Windows.Forms.FormClosingEventHandler " Usage="member this.FormClosing : System.Windows.Forms.FormClosingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs before the form is closed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosing> 이 이벤트는 폼을 닫을 때 발생 합니다. 폼을 닫을 때 삭제 되 고 폼과 관련 된 모든 리소스를 해제 합니다. 이 이벤트를 취소 하면 폼 열린 상태로 유지 됩니다. 폼의 클로저를 취소 하려면는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 의 속성은 <xref:System.Windows.Forms.FormClosingEventArgs> 이벤트 처리기에 전달 된 `true`합니다.  
  
 폼을 모달 대화 상자로 표시 되 면 클릭 하 고 **닫기** 단추 (x 폼의 오른쪽 위 모서리에 있는 단추)를 사용 하면 양식을 숨길 및 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성으로 설정 됩니다 `DialogResult.Cancel`합니다. 에 할당 된 값을 재정의할 수 있습니다는 <xref:System.Windows.Forms.Form.DialogResult%2A> 클릭할 때 속성의 **닫기** 설정 하 여 단추는 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성에 대 한 이벤트 처리기에는 <xref:System.Windows.Forms.Form.FormClosing> 폼의 이벤트입니다.  
  
> [!NOTE]
>  때는 <xref:System.Windows.Forms.Form.Close%2A> 메서드가 호출 되는 <xref:System.Windows.Forms.Form> 모덜리스 창으로 표시를 호출할 수 없습니다는 <xref:System.Windows.Forms.Control.Show%2A> 메서드 폼의 리소스가 이미 해제 되었으므로 때문에 폼을 표시 합니다. 폼을 숨기고 표시를 사용 하 여 확인 된 <xref:System.Windows.Forms.Control.Hide%2A> 메서드.  
  
 폼이 (mdi 다중) 다중 문서 인터페이스 부모 폼의 <xref:System.Windows.Forms.Form.FormClosing> 모든 MDI 자식 폼의 MDI 부모 폼의 하기 전에 발생 <xref:System.Windows.Forms.Form.FormClosing> 이벤트가 발생 합니다. 마찬가지로,는 <xref:System.Windows.Forms.Form.FormClosed> 모든 MDI 자식 폼의 발생 하기 전에 <xref:System.Windows.Forms.Form.FormClosed> MDI 부모 폼의 이벤트가 발생 합니다. 취소는 <xref:System.Windows.Forms.Form.FormClosing> 때도 MDI 자식 폼의 이벤트는 <xref:System.Windows.Forms.Form.FormClosing> MDI 부모 폼에서 발생 하는 이벤트입니다. 그러나로 설정 됩니다 이벤트를 취소 `true` 는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 의 속성은 <xref:System.Windows.Forms.FormClosingEventArgs> 부모 폼에 매개 변수로 전달 되는 클래스입니다. 모든 MDI 부모 및 자식 폼을 강제로 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성을 `false` 는 mdi 부모 폼입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.FormClosing> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.FormClosing> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::SizeF GetAutoScaleSize(System::Drawing::Font ^ font);" />
      <MemberSignature Language="F#" Value="static member GetAutoScaleSize : System.Drawing.Font -&gt; System.Drawing.SizeF" Usage="System.Windows.Forms.Form.GetAutoScaleSize font" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font">A <see cref="T:System.Drawing.Font" /> representing the font to determine the autoscaled base size of the form.</param>
        <summary>Gets the size when autoscaling the form based on a specified font.</summary>
        <returns>A <see cref="T:System.Drawing.SizeF" /> representing the autoscaled size of the form.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> 메서드는 사용 되지 않는 in.NET Framework 버전 2.0. 이 멤버의 이전 버전과 호환성을 위해 유지 합니다. 자동 크기 조정 하는 방법에 대 한 자세한 내용은 참조 [Windows Forms의 자동 크기 조정을](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)합니다.  
  
 폼을 폼에 글꼴을 적용 하기 전에 자동 크기 조정을 특정 글꼴에 대 한는 크기를 확인 하려면이 메서드를 사용할 수 있습니다. 크기를 확인 하려는 경우는 특정 폼이를 폼에 사용 된 현재 글꼴에 따라, 사용 된 <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="form.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">A <see cref="T:System.Drawing.Rectangle" /> that specifies the area for which to retrieve the display bounds.</param>
        <param name="factor">The height and width of the control's bounds.</param>
        <param name="specified">One of the values of <see cref="T:System.Windows.Forms.BoundsSpecified" /> that specifies the bounds of the control to use when defining its size and position.</param>
        <summary>Retrieves the bounds within which the control is scaled.</summary>
        <returns>A <see cref="T:System.Drawing.Rectangle" /> representing the bounds within which the control is scaled.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberSignature Language="VB.NET" Value="Public Property HelpButton As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HelpButton { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HelpButton : bool with get, set" Usage="System.Windows.Forms.Form.HelpButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether a Help button should be displayed in the caption box of the form.</summary>
        <value>폼의 캡션 표시줄에 도움말 단추를 표시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이로 설정 된 경우 `true`, 왼쪽의 캡션 표시줄에 물음표 있는 작은 단추가 표시 되는 **닫기** 단추입니다. 응용 프로그램에 대 한 도움말을 표시 하려면이 단추를 사용할 수 있습니다. 에 대 한 이벤트 처리기를 만들 수는 <xref:System.Windows.Forms.Control.HelpRequested> 폼의 도움말 단추를 클릭할 때 사용자에 게 도움말 정보를 표시 하는 이벤트입니다.  

도움말 단추를 폼의 값을 표시 하려면 <xref:System.Windows.Forms.Form.ControlBox> 속성 이어야 합니다 `true`, 해당 기본값입니다. <xref:System.Windows.Forms.Form.ControlBox> 속성 캡션 표시줄의 오른쪽 위 모퉁이 최대화 단추, 최소화 단추, 도움말 단추 및 닫기 단추와 같은 컨트롤 포함 되는지 여부를 결정 합니다. 또한 양식의 설정 해야 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 속성을 <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, 또는 <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>합니다.  


> [!IMPORTANT]
>  값은 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성은 무시 됩니다는 **최대화** 또는 **최소화** 단추가 표시 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpButtonClicked As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ HelpButtonClicked;" />
      <MemberSignature Language="F#" Value="member this.HelpButtonClicked : System.ComponentModel.CancelEventHandler " Usage="member this.HelpButtonClicked : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the **Help** button is clicked.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.HelpButtonClicked> 이벤트가 발생할 때의 **도움말** 폼의 캡션 표시줄에 단추를 클릭 합니다. **도움말** 단추가 표시 되는지를 때는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성이 `true`합니다. <xref:System.Windows.Forms.Form.HelpButtonClicked> 취소할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.HelpButtonClicked> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.HelpButtonClicked> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.HelpButton" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As Icon" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Icon ^ Icon { System::Drawing::Icon ^ get(); void set(System::Drawing::Icon ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Drawing.Icon with get, set" Usage="System.Windows.Forms.Form.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the icon for the form.</summary>
        <value>폼의 아이콘을 나타내는 <see cref="T:System.Drawing.Icon" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼의 아이콘을 폼의 컨트롤 상자에 표시 되는 아이콘을 비롯 하 여 작업 표시줄에 폼을 나타내는 그림을 지정 합니다.  
  
 이 속성이 아무런 효과가 경우 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 로 설정 된 <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>합니다. 이 경우 폼 아이콘이 표시 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanged As InputLanguageChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangedEventHandler ^ InputLanguageChanged;" />
      <MemberSignature Language="F#" Value="member this.InputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventHandler " Usage="member this.InputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the input language of the form has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼의 모양 및 폼의 입력된 언어에 대 한 변경 내용을 기반으로 하는 텍스트를 변경 하려면이 이벤트를 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.InputLanguageChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.InputLanguageChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanging As InputLanguageChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangingEventHandler ^ InputLanguageChanging;" />
      <MemberSignature Language="F#" Value="member this.InputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventHandler " Usage="member this.InputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the user attempts to change the input language for the form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 폼에 대 한 입력된 언어를 변경 하 여 만들어지기 전에 발생 합니다. 언어 변경 설정 하 여 취소할 수 있습니다는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 의 속성은 <xref:System.Windows.Forms.InputLanguageChangingEventArgs> 이벤트 처리기에 전달 된 `false`합니다. 이벤트가 취소 되는 입력된 언어 변경 되지 않습니다. 응용 프로그램에 대 한 적절 한 요청한 입력된 언어 변경 되는지 확인 하려면이 이벤트를 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.InputLanguageChanging> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.InputLanguageChanging> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMdiChild As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiChild { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMdiChild : bool" Usage="System.Windows.Forms.Form.IsMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the form is a multiple-document interface (MDI) child form.</summary>
        <value>폼이 MDI 자식 폼인 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 런타임 시 MDI 자식 폼은 MDI 부모 폼의 클라이언트 영역 안에 표시 됩니다. MDI 자식 폼 최대화을 최소화 하며 MDI 부모 폼 내에서 이동 될 수 있습니다. MDI 자식 폼을 만들려면 할당는 <xref:System.Windows.Forms.Form> MDI 부모 폼에 사용 됩니다는 <xref:System.Windows.Forms.Form.MdiParent%2A> 자식 폼의 속성입니다. 사용할 수는 <xref:System.Windows.Forms.Form.IsMdiContainer%2A> 속성을 폼이 MDI 부모 폼입니다.  
  
 사용할 수는 <xref:System.Windows.Forms.Form.IsMdiChild%2A> 속성을 메서드 또는 속성에 의해 반환 된 폼 MDI 자식 폼 또는 대화 상자와 같은 응용 프로그램에서 표준 형식 인지 확인 합니다.  
  
> [!NOTE]
>  모든 MDI 자식 폼에는 크기 조정 가능한 테두리, 컨트롤 메뉴 상자 및 최소화 및 **최대화** 의 설정에 관계 없이 단추는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, 및 <xref:System.Windows.Forms.Form.MaximizeBox%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property IsMdiContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiContainer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsMdiContainer : bool with get, set" Usage="System.Windows.Forms.Form.IsMdiContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the form is a container for multiple-document interface (MDI) child forms.</summary>
        <value>폼이 MDI 자식 폼의 컨테이너인 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 MDI 부모 폼을 표시 및 폼의 동작을 변경합니다. 이 속성이로 설정 된 경우 `true`, 폼에 볼록한 테두리가 오목한 클라이언트 영역을 표시 합니다. 부모 폼에 사용 된 모든 MDI 자식 폼의 클라이언트 영역 내에 표시 됩니다.  
  
 MDI 부모 폼이 닫히면는 <xref:System.Windows.Forms.Form.Closing> 모든 MDI 자식 폼의 MDI 부모 폼의 하기 전에 발생 <xref:System.Windows.Forms.Form.Closing> 이벤트가 발생 합니다. 또한는 <xref:System.Windows.Forms.Form.Closed> 모든 MDI 자식 폼의 발생 하기 전에 <xref:System.Windows.Forms.Form.Closed> MDI 부모 폼의 이벤트가 발생 합니다.  
  
> [!NOTE]
>  두 개 있는 경우 <xref:System.Windows.Forms.MenuStrip> 설정 된 MDI 자식 폼의 컨트롤 <xref:System.Windows.Forms.Form.IsMdiContainer%2A> 를 `true` 부모에 대 한 폼 중 하나만의 내용을 병합 하는 <xref:System.Windows.Forms.MenuStrip> 컨트롤입니다. 사용 하 여 <xref:System.Windows.Forms.ToolStripManager.Merge%2A> 내용을 병합 하 여 추가 자식 <xref:System.Windows.Forms.MenuStrip> MDI 부모 폼에서 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Form.IsMdiContainer%2A> 변경할 뿐 아니라 속성은 `BackColor` MDI 폼의 속성입니다. 이 예제를 실행 하려면 새 폼에 다음 코드를 붙여 넣습니다.  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRestrictedWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRestrictedWindow { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRestrictedWindow : bool" Usage="System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the form can use all windows and user input events without restriction.</summary>
        <value>폼에 제한이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A> 속성 결정 여부는 <xref:System.Security.Permissions.UIPermissionWindow.AllWindows> 권한이 부여 됩니다. 이 속성은 런타임에 폼의 생성자에서 설정 되며 폼의 수명 동안 캐시 됩니다. 공용 언어 런타임 부모 생성자가 부분 신뢰 환경에서 항상 호출을 보장 부분 신뢰에서 실행 되는 Windows Forms 응용 프로그램에서이 검사를 피할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPreview As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeyPreview { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeyPreview : bool with get, set" Usage="System.Windows.Forms.Form.KeyPreview" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the form will receive key events before the event is passed to the control that has focus.</summary>
        <value>폼이 모든 키 이벤트를 받는 경우 <see langword="true" />이고, 폼에서 현재 선택되어 있는 컨트롤이 키 이벤트를 받는 경우 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이로 설정 된 경우 `true`, 폼을 모두를 받게 됩니다 <xref:System.Windows.Forms.Control.KeyPress>, <xref:System.Windows.Forms.Control.KeyDown>, 및 <xref:System.Windows.Forms.Control.KeyUp> 이벤트입니다. 폼의 이벤트 처리기는 키 입력 처리를 완료 하면 키 입력 포커스가 있는 컨트롤에 할당 됩니다. 예를 들어 경우는 <xref:System.Windows.Forms.Form.KeyPreview%2A> 속성이로 설정 되어 `true` 현재 선택 된 컨트롤은 한 <xref:System.Windows.Forms.TextBox>키 입력은 폼의 이벤트 처리기에서 처리 한 후는 <xref:System.Windows.Forms.TextBox> 컨트롤 누른 키를 받게 됩니다. 폼 수준 에서만 키보드 이벤트를 처리 하 고 키보드 이벤트를 수신 하도록 컨트롤을 허용 하지 설정는 <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> 속성 폼의 <xref:System.Windows.Forms.Control.KeyPress> 이벤트 처리기를 `true`합니다.  
  
 이 속성을 사용 하 여 처리 하거나 응용 프로그램의 대부분의 키 입력을 처리 하거나 키 입력을 처리 하는 적절 한 컨트롤을 호출할 수 있습니다. 예를 들어 응용 프로그램에서 기능 키를 사용할 때 키 입력 이벤트를 받을 수 있는 각 컨트롤에 대 한 코드를 작성 하는 대신 폼 수준에서 키 입력을 처리 하는 것이 좋습니다.  
  
> [!NOTE]
>  폼에 표시 되거나 설정 된 컨트롤이 키보드 이벤트를 모두 자동으로 받습니다.  
  
> [!NOTE]
>  폼의 컨트롤 받은 키 입력을 취소를 프로그래밍할 수 있습니다. 컨트롤을 폼에 이러한 키 입력 보내지 않습니다, 이후 폼을 볼 수 없습니다 하의 설정에 관계 없이 <xref:System.Windows.Forms.Form.KeyPreview%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제는 폼을 설정 하는 방법을 보여 줍니다 <xref:System.Windows.Forms.Form.KeyPreview%2A> 속성을 true로 폼 수준에서 키 이벤트를 처리 합니다. 이 예제를 실행 하려면 빈 폼에 다음 코드를 붙여 넣습니다.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LayoutMdi (value As MdiLayout)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LayoutMdi(System::Windows::Forms::MdiLayout value);" />
      <MemberSignature Language="F#" Value="member this.LayoutMdi : System.Windows.Forms.MdiLayout -&gt; unit" Usage="form.LayoutMdi value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value">One of the <see cref="T:System.Windows.Forms.MdiLayout" /> values that defines the layout of MDI child forms.</param>
        <summary>Arranges the multiple-document interface (MDI) child forms within the MDI parent form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 허용 하기 위해 더 쉽게 탐색 및 조작 MDI 자식 폼의 MDI 부모 폼의 MDI 자식 폼을 정렬 하려면이 메서드를 사용할 수 있습니다. MDI 자식 폼 종속 연결 된, 또는 MDI 부모 폼 내에서 아이콘으로 가로 또는 세로로 바둑판식 수 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 MDI 응용 프로그램의 부모 폼에서 창 메뉴의 메뉴 항목에 대 한 이벤트 처리기를 보여 줍니다. 각 이벤트 처리기를 호출 하 여 <xref:System.Windows.Forms.Form.LayoutMdi%2A> 자식 폼을 정렬 하는 메서드는 응용 프로그램에서 현재 열려 있습니다.  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MdiLayout" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs before a form is displayed for the first time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼에서 사용 하는 리소스를 할당 하는 등의 작업을 수행 하려면이 이벤트를 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, 및 <xref:System.Windows.Forms.Form.Activate%2A> 멤버입니다. 예제를 실행 하려면 이라는 폼에 다음 코드를 붙여 `Form1` 포함 하는 <xref:System.Windows.Forms.Button> 호출 `Button1` 와 두 개의 <xref:System.Windows.Forms.Label> 이라는 컨트롤 `Label1` 및 `Label2`합니다.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Form.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Drawing.Point" /> that represents the upper-left corner of the <see cref="T:System.Windows.Forms.Form" /> in screen coordinates.</summary>
        <value>화면 좌표에서 <see cref="T:System.Windows.Forms.Form" />의 왼쪽 위 모퉁이를 나타내는 <see cref="T:System.Drawing.Point" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point> 즉, 값 형식 구조가입니다. 속성에 액세스 하는 경우 <xref:System.Drawing.Point>, 속성의 복사본이 반환 됩니다. 따라서 변경는 <xref:System.Drawing.Point.X%2A> 또는 <xref:System.Drawing.Point.Y%2A> 속성의는 <xref:System.Drawing.Point> 에서 반환 된는 <xref:System.Windows.Forms.Control.Location%2A> 속성에 영향을 주지 것입니다는 <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, 또는 <xref:System.Windows.Forms.Control.Bottom%2A> 의 속성 값은 <xref:System.Windows.Forms.Form>. 이러한 속성을 조정 하려면 각 속성 값을 개별적으로 설정 하거나 설정는 <xref:System.Windows.Forms.Form.Location%2A> 를 새 속성 <xref:System.Drawing.Point>합니다.  
  
 <xref:System.Windows.Forms.Form.Location%2A> 속성 가져오거나는 <xref:System.Windows.Forms.Control.Location%2A> 의 속성은 <xref:System.Windows.Forms.Control> 기본 클래스 및 집합은 <xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A> 속성을 `true`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Property MainMenuStrip As MenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuStrip ^ MainMenuStrip { System::Windows::Forms::MenuStrip ^ get(); void set(System::Windows::Forms::MenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainMenuStrip : System.Windows.Forms.MenuStrip with get, set" Usage="System.Windows.Forms.Form.MainMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the primary menu container for the form.</summary>
        <value>폼의 메뉴 구조에 대한 컨테이너를 나타내는 <see cref="T:System.Windows.Forms.MenuStrip" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 뿐만 아니라는 <xref:System.Windows.Forms.Form.MainMenuStrip%2A> 해야 속성 <xref:System.Windows.Forms.Control.ControlCollection.Add%2A> 는 <xref:System.Windows.Forms.MenuStrip> 컨트롤을 <xref:System.Windows.Forms.Control.Controls%2A> 폼의 컬렉션입니다.  
  
 <xref:System.Windows.Forms.MenuStrip> 클래스를 대체는 <xref:System.Windows.Forms.MainMenu> 이전 버전의.NET Framework 클래스입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuStrip" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Form.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the space between controls.</summary>
        <value>컨트롤 사이의 공백을 나타내는 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="P:System.Windows.Forms.Form.Margin" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaximizeBox { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MaximizeBox : bool with get, set" Usage="System.Windows.Forms.Form.MaximizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the **Maximize** button is displayed in the caption bar of the form.</summary>
        <value>
          <see langword="true" /> 표시 하는 * * 최대화 * * 폼에 대 한 단추 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 A **최대화** 단추를 사용 하면 사용자가 창을 전체 화면 크기로 확대 합니다. 표시 하는 **최대화** 단추를 폼의 값 <xref:System.Windows.Forms.Form.ControlBox> 속성 이어야 `true`, 값이 기본값으로 합니다.  <xref:System.Windows.Forms.Form.ControlBox> 속성 캡션 표시줄의 오른쪽 위 모퉁이 최대화 단추, 최소화 단추, 도움말 단추 및 닫기 단추와 같은 컨트롤 포함 되는지 여부를 결정 합니다. 또한 양식의 설정 해야 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 속성을 <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, 또는 <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>합니다.  
  
 A **최대화** 창이 최대화 되 면 자동으로 단추 복원 단추 됩니다. 최소화 하거나 창을 자동으로 복원 하면 복원 단추 변경 다시는 **최대화** 단추입니다.  
  
> [!NOTE]
>  런타임에 폼을 최대화를 생성 한 <xref:System.Windows.Forms.Control.Resize> 이벤트입니다. <xref:System.Windows.Forms.Form.WindowState%2A> 속성 창의 현재 상태를 반영 합니다. 설정 하는 경우는 <xref:System.Windows.Forms.Form.WindowState%2A> 속성을 `FormWindowState.Maximized`, 설정값 관계 없이 적용에 대 한 폼이 최대화는 <xref:System.Windows.Forms.Form.MaximizeBox%2A> 및 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Property MaximizedBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::Rectangle MaximizedBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.MaximizedBounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Form.MaximizedBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets and sets the size of the form when it is maximized.</summary>
        <value>폼이 최대화될 때 폼의 경계를 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of the <see cref="P:System.Drawing.Rectangle.Top" /> property is greater than the height of the form.  -or-  The value of the <see cref="P:System.Drawing.Rectangle.Left" /> property is greater than the width of the form.</exception>
        <block subset="none" type="overrides">
          <para>상속 된 클래스 <see cref="T:System.Windows.Forms.Form" /> 최대화 되어 폼에 대 한 새 경계를 제공 하려면이 메서드를 재정의할 수 있습니다. 클래스는이 속성을 설정 내부적으로 때 폼의 * * 최대화 * * 단추를 클릭 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximizedBoundsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximizedBoundsChanged;" />
      <MemberSignature Language="F#" Value="member this.MaximizedBoundsChanged : EventHandler " Usage="member this.MaximizedBoundsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.Form.MaximizedBounds" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum size the form can be resized to.</summary>
        <value>폼의 최대 크기를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 지정된 된 최대 크기를 폼의 크기를 제한할 수 있습니다. 단일 창 숨겨져야 다른 창을 이어지지 되도록이 기능을 동시에 여러 창을 표시할 때 사용할 수 있습니다. 이 속성은로 설정 하는 경우는 <xref:System.Drawing.Size> 높이 및 폭, 폼 0 개체 Windows 설정도 넘어 없는 최대 크기를 갖게 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 설정 된 <xref:System.Windows.Forms.Form.MaximumSize%2A> 속성입니다.  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The values of the height or width within the <see cref="T:System.Drawing.Size" /> object are less than zero.</exception>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MaxWindowTrackSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximumSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.MaximumSizeChanged : EventHandler " Usage="member this.MaximumSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.Form.MaximumSize" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.MaximumSizeChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.MaximumSizeChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MdiChildActivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MdiChildActivate;" />
      <MemberSignature Language="F#" Value="member this.MdiChildActivate : EventHandler " Usage="member this.MdiChildActivate : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a multiple-document interface (MDI) child form is activated or closed within an MDI application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트를 사용 하 여 MDI 자식 폼의 콘텐츠를 업데이트 하는 등 작업을 수행 하 고 활성화 된 MDI 자식 폼의 상태에 따라 MDI 부모 폼에서 사용할 수 있는 메뉴 옵션을 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.MdiChildActivate> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.MdiChildActivate> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiChildren As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ MdiChildren { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MdiChildren : System.Windows.Forms.Form[]" Usage="System.Windows.Forms.Form.MdiChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an array of forms that represent the multiple-document interface (MDI) child forms that are parented to this form.</summary>
        <value>각각 이 폼의 MDI 자식 폼 중 하나를 나타내는 <see cref="T:System.Windows.Forms.Form" /> 개체의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 MDI 부모 폼에서 현재 열려 있는 모든 MDI 자식 폼에 대 한 참조를 가져올 수 있습니다. MDI 자식 폼을 만들려면 할당는 <xref:System.Windows.Forms.Form> MDI 부모 폼에 사용 됩니다는 <xref:System.Windows.Forms.Form.MdiParent%2A> 자식 폼의 속성입니다.  
  
 이 속성을 모든 MDI 자식 폼 MDI 부모 폼을 닫을 때 데이터베이스에 데이터를 저장 하는 등 작업을 수행 하거나 응용 프로그램에서 수행 된 작업에 따라 자식 폼의 필드를 업데이트할 루핑하려면 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Form.MdiChildren%2A> 속성을 추가 하 고 MDI 자식 폼 목록을 반복는 <xref:System.Windows.Forms.Button> 각각 제어 합니다.  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiParent As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ MdiParent { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MdiParent : System.Windows.Forms.Form with get, set" Usage="System.Windows.Forms.Form.MdiParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current multiple-document interface (MDI) parent form of this form.</summary>
        <value>MDI 부모 폼을 나타내는 <see cref="T:System.Windows.Forms.Form" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 MDI 자식 폼을 만들려면 할당는 <xref:System.Windows.Forms.Form> MDI 부모 폼에 사용 됩니다는 <xref:System.Windows.Forms.Form.MdiParent%2A> 자식 폼의 속성입니다. 모든 자식 폼을 동작을 수행 하는 메서드를 호출 하거나 모든 자식 폼을 필요로 하는 전역 정보를 가져오는 MDI 자식 폼에서이 속성을 사용할 수 있습니다.  
  
> [!NOTE]
>  두 개 있는 경우 <xref:System.Windows.Forms.MenuStrip> 설정 된 MDI 자식 폼의 컨트롤 <xref:System.Windows.Forms.Form.IsMdiContainer%2A> 를 `true` 부모에 대 한 폼 중 하나만의 내용을 병합 하는 <xref:System.Windows.Forms.MenuStrip> 컨트롤입니다. 사용 하 여 <xref:System.Windows.Forms.ToolStripManager.Merge%2A> 내용을 병합 하 여 추가 자식 <xref:System.Windows.Forms.MenuStrip> MDI 부모 폼에서 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 MDI 응용 프로그램에서 자식 폼을 만드는 방법을 보여 줍니다. 예제 코드와 자식 폼을 식별 하는 고유한 텍스트 양식을 만듭니다. 이 예제에서는 사용은 <xref:System.Windows.Forms.Form.MdiParent%2A> 속성을 통해 폼이 자식 폼을 지정 합니다. 이 예제는 예제에서 코드는 양식에서 호출 되도록 하려면 해당 <xref:System.Windows.Forms.Form.IsMdiContainer%2A> 속성이로 설정 `true` 그리고 폼에 라는 전용 클래스 수준 정수 변수에 `childCount`합니다.  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">The <see cref="T:System.Windows.Forms.Form" /> assigned to this property is not marked as an MDI container.  -or-  The <see cref="T:System.Windows.Forms.Form" /> assigned to this property is both a child and an MDI container form.  -or-  The <see cref="T:System.Windows.Forms.Form" /> assigned to this property is located on a different thread.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">폼을 요청 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberSignature Language="VB.NET" Value="Public Property Menu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ Menu { System::Windows::Forms::MainMenu ^ get(); void set(System::Windows::Forms::MainMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Menu : System.Windows.Forms.MainMenu with get, set" Usage="System.Windows.Forms.Form.Menu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Forms.MainMenu" /> that is displayed in the form.</summary>
        <value>폼에 표시할 메뉴를 나타내는 <see cref="T:System.Windows.Forms.MainMenu" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 런타임 시 완전 한 메뉴 집합 사이 전환 하려면이 속성을 사용할 수 있습니다. 예를 들어 하나 정의할 수 있습니다 <xref:System.Windows.Forms.MainMenu> 활성 MDI 자식 폼 및 다른 (mdi 다중) 다중 문서 인터페이스 폼에 표시할 <xref:System.Windows.Forms.MainMenu> 자식 창이 표시 될 때 표시할 수 있습니다. 사용할 수도 있습니다를 다른 <xref:System.Windows.Forms.MainMenu> 특정 조건을 서로 다른 메뉴 집합을 표시 해야 하는 응용 프로그램에 존재 하는 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.MainMenu>, 두 개의 할당 <xref:System.Windows.Forms.MenuItem> 개체는 <xref:System.Windows.Forms.MainMenu> 폼에 바인딩합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 라는 만든 `Form1`합니다.  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuComplete;" />
      <MemberSignature Language="F#" Value="member this.MenuComplete : EventHandler " Usage="member this.MenuComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the menu of a form loses focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 수행 중인 명령에서 발생 하 고 메뉴가 포커스를 잃으면 메뉴 항목에에서 대 한 메뉴를 클릭할 때 발생 합니다. 이 이벤트를 사용 하 여 텍스트를 업데이트 하는 등 작업을 수행 하는 <xref:System.Windows.Forms.StatusBar> 컨트롤 또는 설정 및 해제 단추에는 <xref:System.Windows.Forms.ToolBar>합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.MenuComplete> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.MenuComplete> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuStart As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuStart;" />
      <MemberSignature Language="F#" Value="member this.MenuStart : EventHandler " Usage="member this.MenuStart : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the menu of a form receives focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 사용자가 메뉴에서 모든 메뉴 항목을 클릭할 때 발생 합니다. 설정 및 해제 메뉴에 액세스 하는 경우 사용자가 액세스 해서는 안 되는 양식에서 컨트롤 등의 작업을 수행 하려면이 이벤트를 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.MenuStart> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.MenuStart> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedMenu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ MergedMenu { System::Windows::Forms::MainMenu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergedMenu : System.Windows.Forms.MainMenu" Usage="System.Windows.Forms.Form.MergedMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the merged menu for the form.</summary>
        <value>폼의 병합된 메뉴를 나타내는 <see cref="T:System.Windows.Forms.MainMenu" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 폼이 (mdi 다중) 다중 문서 인터페이스 자식 폼은 부모 폼의 메뉴가 해당 메뉴를 병합 하는 경우에 주로 사용 됩니다. 이 속성을 사용 하 여를 변경 하거나 메뉴 구조에 대 한 추가 MDI 응용 프로그램에서 현재 메뉴 구조를 가져올 수 있습니다. 된 병합 되지 않은 <xref:System.Windows.Forms.MainMenu> 사용 하 여 폼에 할당 된 <xref:System.Windows.Forms.Form.Menu%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.Form.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MinimizeBox { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MinimizeBox : bool with get, set" Usage="System.Windows.Forms.Form.MinimizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the **Minimize** button is displayed in the caption bar of the form.</summary>
        <value>
          <see langword="true" /> 표시 하는 * * 최소화 * * 폼에 대 한 단추 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A **최소화** 창을 아이콘으로 최소화 하기 위해 사용자가 단추를 사용 합니다. 표시 하는 **최소화** 단추를 폼의 값 <xref:System.Windows.Forms.Form.ControlBox> 속성 이어야 `true`, 값이 기본값으로 합니다.  <xref:System.Windows.Forms.Form.ControlBox> 속성 캡션 표시줄의 오른쪽 위 모퉁이 최대화 단추, 최소화 단추, 도움말 단추 및 닫기 단추와 같은 컨트롤 포함 되는지 여부를 결정 합니다. 또한 양식의 설정 해야 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 속성을 <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, 또는 <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  런타임에 폼을 최소화에서는 오류가 발생 하는 <xref:System.Windows.Forms.Control.Resize> 이벤트입니다. <xref:System.Windows.Forms.Form.WindowState%2A> 속성 창의 현재 상태를 반영 합니다. 설정 하는 경우는 <xref:System.Windows.Forms.Form.WindowState%2A> 속성을 `FormWindowState.Minimized`, 설정값 관계 없이 적용에 대 한 폼이 최소화는 <xref:System.Windows.Forms.Form.MinimizeBox%2A> 및 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum size the form can be resized to.</summary>
        <value>폼의 최소 크기를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 지정 된 최소 크기로 폼의 크기를 제한할 수 있습니다. 사용자가 원하지 않는 크기로 창 크기를 조정 하지 않도록 하려면이 기능을 사용할 수 있습니다. 이 속성은로 설정 하는 경우는 <xref:System.Drawing.Size> 높이 및 너비를 폼 0 개체 Windows 설정도 넘어 없는 최소 크기를 가집니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The values of the height or width within the <see cref="T:System.Drawing.Size" /> object are less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MinimumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MinimumSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.MinimumSizeChanged : EventHandler " Usage="member this.MinimumSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.Form.MinimumSize" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.MinimumSizeChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.MinimumSizeChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Modal : bool" Usage="System.Windows.Forms.Form.Modal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this form is displayed modally.</summary>
        <value>폼이 모달 형식으로 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼이 모달 형식으로 표시 합니다 (키보드 또는 마우스 클릭)을 입력 하지 않고 모달 폼에 있는 개체를 제외 하 고 발생할 수 있습니다. 프로그램 숨기 거 나 닫기를 모달 폼 (일반적으로 사용자의 일부 동작에 대 한 응답) 다른 폼에 입력 하기 전에 발생할 수 있습니다. 모달 형식으로 표시 되는 폼은 일반적으로 응용 프로그램에서 대화 상자로 사용 됩니다.  
  
 메서드 또는 속성에서 가져온 양식 모달 형식으로 표시 되어 있는지 여부를 확인 하려면이 속성을 사용할 수 있습니다.  
  
 표시 하려면 폼 모달 형식으로 사용 된 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Form.Modal%2A> 속성 폼을 모달 폼으로 표시 되는지 확인 합니다. 없는 경우는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 및 <xref:System.Windows.Forms.Form.TopLevel%2A> 속성 폼을 도구 창 테두리를 포함 하는 하위 수준의 폼 변경 됩니다.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.ShowDialog" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="form.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.Activated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnActivated%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 파생된 클래스에서 이벤트를 처리 하는 기본 방법에는이 메서드를 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="form.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="form.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="form.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.Closed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A> 메서드는.NET Framework 버전 2.0에서에서 사용 되지 않는, 사용 된 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 메서드 대신 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 파생된 클래스에서 이벤트를 처리 하는 기본 방법에는이 메서드를 재정의 합니다.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A> 및 <xref:System.Windows.Forms.Form.OnClosing%2A> 메서드 호출 되지 않습니다는 <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> 메서드는 응용 프로그램을 종료 합니다. 유효성 검사 코드를 실행 해야 하는 이러한 방법 중 하나에 있으면 호출 해야는 <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> 호출 하기 전에 개별적으로 열려 있는 각 폼에 대 한 메서드는 <xref:System.Windows.Forms.Application.Exit%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.OnClosed%2A> 에서 파생 된 클래스에서 메서드가 <xref:System.Windows.Forms.Form> 합니다.  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="form.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.Closing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosing%2A> 메서드는.NET Framework 버전 2.0에서에서 사용 되지 않는, 사용 된 <xref:System.Windows.Forms.Form.OnFormClosing%2A> 메서드 대신 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnClosing%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 파생된 클래스에서 이벤트를 처리 하는 기본 방법에는이 메서드를 재정의 합니다.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A> 및 <xref:System.Windows.Forms.Form.OnClosing%2A> 메서드 호출 되지 않습니다는 <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> 메서드는 응용 프로그램을 종료 합니다. 유효성 검사 코드를 실행 해야 하는 이러한 방법 중 하나에 있으면 호출 해야는 <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> 호출 하기 전에 개별적으로 열려 있는 각 폼에 대 한 메서드는 <xref:System.Windows.Forms.Application.Exit%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Form.Closing> 여부를 테스트 하에 있는 텍스트는 <xref:System.Windows.Forms.TextBox> 변경 되었습니다. 있는 경우, 사용자가 것인지 묻는 메시지가 나타나면 파일에 변경 내용을 저장 합니다.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.ComponentModel.CancelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberSignature Language="F#" Value="override this.OnCreateControl : unit -&gt; unit" Usage="form.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see langword="CreateControl" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivate : EventArgs -&gt; unit&#xA;override this.OnDeactivate : EventArgs -&gt; unit" Usage="form.OnDeactivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.Deactivate" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnDeactivate%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As DpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::Forms::DpiChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.Forms.DpiChangedEventArgs -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.Forms.DpiChangedEventArgs -&gt; unit" Usage="form.OnDpiChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.DpiChanged" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="form.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnEnter : EventArgs -&gt; unit" Usage="form.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.Enter" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnEnter%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="form.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.FontChanged" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosed (e As FormClosedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosed(System::Windows::Forms::FormClosedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFormClosed : System.Windows.Forms.FormClosedEventArgs -&gt; unit&#xA;override this.OnFormClosed : System.Windows.Forms.FormClosedEventArgs -&gt; unit" Usage="form.OnFormClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.FormClosedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.FormClosed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A> 에서 현재 폼을 제거 하는 메서드는 <xref:System.Windows.Forms.Application.OpenForms%2A> 연결 되어 있는 컬렉션 <xref:System.Windows.Forms.Application>합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 파생된 클래스에서 이벤트를 처리 하는 기본 방법에는이 메서드를 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosing (e As FormClosingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosing(System::Windows::Forms::FormClosingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFormClosing : System.Windows.Forms.FormClosingEventArgs -&gt; unit&#xA;override this.OnFormClosing : System.Windows.Forms.FormClosingEventArgs -&gt; unit" Usage="form.OnFormClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.FormClosingEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.FormClosing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnFormClosing%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGetDpiScaledSize (deviceDpiOld As Integer, deviceDpiNew As Integer, ByRef desiredSize As Size) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnGetDpiScaledSize(int deviceDpiOld, int deviceDpiNew, System::Drawing::Size % desiredSize);" />
      <MemberSignature Language="F#" Value="abstract member OnGetDpiScaledSize : int * int *  -&gt; bool&#xA;override this.OnGetDpiScaledSize : int * int *  -&gt; bool" Usage="form.OnGetDpiScaledSize (deviceDpiOld, deviceDpiNew, desiredSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">The DPI value for the display device where the form was previously displayed.</param>
        <param name="deviceDpiNew">The DPI value for the display device where the form will be displayed.</param>
        <param name="desiredSize">A <see cref="T:System.Drawing.Size" /> representing the new size of the form based on the new DPI value.</param>
        <summary>Raises the GetDpiScaledSize event.</summary>
        <returns>
          <see langword="true" /> if successful; otherwise <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="form.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.HandleCreated" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="form.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpButtonClicked (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpButtonClicked(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpButtonClicked : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnHelpButtonClicked : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="form.OnHelpButtonClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.HelpButtonClicked" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
        <altmember cref="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanged (e As InputLanguageChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanged(System::Windows::Forms::InputLanguageChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventArgs -&gt; unit&#xA;override this.OnInputLanguageChanged : System.Windows.Forms.InputLanguageChangedEventArgs -&gt; unit" Usage="form.OnInputLanguageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.InputLanguageChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanging (e As InputLanguageChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanging(System::Windows::Forms::InputLanguageChangingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventArgs -&gt; unit&#xA;override this.OnInputLanguageChanging : System.Windows.Forms.InputLanguageChangingEventArgs -&gt; unit" Usage="form.OnInputLanguageChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.InputLanguageChanging" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="form.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">The event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.Layout" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="form.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.Load" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnLoad%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximizedBoundsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximizedBoundsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMaximizedBoundsChanged : EventArgs -&gt; unit&#xA;override this.OnMaximizedBoundsChanged : EventArgs -&gt; unit" Usage="form.OnMaximizedBoundsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximumSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMaximumSizeChanged : EventArgs -&gt; unit&#xA;override this.OnMaximumSizeChanged : EventArgs -&gt; unit" Usage="form.OnMaximumSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMdiChildActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMdiChildActivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMdiChildActivate : EventArgs -&gt; unit&#xA;override this.OnMdiChildActivate : EventArgs -&gt; unit" Usage="form.OnMdiChildActivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.MdiChildActivate" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMenuComplete : EventArgs -&gt; unit&#xA;override this.OnMenuComplete : EventArgs -&gt; unit" Usage="form.OnMenuComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.MenuComplete" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnMenuComplete%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuComplete" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuStart (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuStart(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMenuStart : EventArgs -&gt; unit&#xA;override this.OnMenuStart : EventArgs -&gt; unit" Usage="form.OnMenuStart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.MenuStart" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnMenuStart%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuStart" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMinimumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMinimumSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMinimumSizeChanged : EventArgs -&gt; unit&#xA;override this.OnMinimumSizeChanged : EventArgs -&gt; unit" Usage="form.OnMinimumSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="form.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.Paint" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnResize : EventArgs -&gt; unit" Usage="form.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.Resize" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeBegin (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeBegin(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResizeBegin : EventArgs -&gt; unit&#xA;override this.OnResizeBegin : EventArgs -&gt; unit" Usage="form.OnResizeBegin e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.ResizeBegin" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin> 경우에 이벤트를 발생 됩니다 폼의 <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> 속성이 `true`합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnResizeBegin%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeEnd (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeEnd(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResizeEnd : EventArgs -&gt; unit&#xA;override this.OnResizeEnd : EventArgs -&gt; unit" Usage="form.OnResizeEnd e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.ResizeEnd" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd> 경우에 이벤트를 발생 됩니다 폼의 <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> 속성이 `true`합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnResizeEnd%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftLayoutChanged : EventArgs -&gt; unit" Usage="form.OnRightToLeftLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 폼 이나 불가 리소스를 삭제 하는 경우는 <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> 메서드는 작업을 수행 하지 않고 반환 됩니다. 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 폼의 속성 값이 <xref:System.Windows.Forms.RightToLeft.Yes>, 호출을 통해 폼과 해당 자식 컨트롤의 핸들은 다시 다음는 <xref:System.Windows.Forms.Control.RecreateHandle%2A> 메서드.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Form.Dispose" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShown (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShown(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnShown : EventArgs -&gt; unit&#xA;override this.OnShown : EventArgs -&gt; unit" Usage="form.OnShown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Form.Shown" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown> 이벤트는 폼이 처음 표시 될 때마다 발생 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnShown%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnStyleChanged : EventArgs -&gt; unit" Usage="form.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.StyleChanged" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="form.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.TextChanged" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="form.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Form.OnVisibleChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.Forms.Form.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the opacity level of the form.</summary>
        <value>폼의 불투명도입니다. 기본값은 1.00입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Opacity%2A> 속성 폼과 해당 컨트롤에 대 한 투명도 수준을 지정할 수 있습니다. 이 속성을 100% (1.00) 보다 작은 값으로 설정, 테두리를 비롯 한 전체 양식은 더욱 투명해 집니다. 이 속성 값이 0% (0.00)을 설정 하면 폼 완전히 표시 되지 않습니다. 서로 다른 수준의 투명도 제공 하거나 나타나거나 폼을 단계적으로 변경 하는 등의 효과 제공 하려면이 속성을 사용할 수 있습니다. 폼 보기에 / 단계 수를 설정 하 여는 예를 들어는 <xref:System.Windows.Forms.Form.Opacity%2A> 속성 값 (0.00) 0% 및 100% (1.00)에 도달할 때까지 값을 점차적으로 증가 합니다.  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> 제공 하는 투명도에서 다른는 <xref:System.Windows.Forms.Form.TransparencyKey%2A>, 폼 수만 있게 해줍니다 며, 해당 컨트롤 완전히 투명 한 경우 같은 색에 지정 된 값으로는 <xref:System.Windows.Forms.Form.TransparencyKey%2A> 속성입니다.  
  
 이 속성은 실행할 수 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 은 `true`합니다.  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> 계층화 Windows API에 도입 된 Windows 2000 속성에 따라 달라 집니다. 자세한 내용은 "계층화 된 Windows:: A 새로운 방식으로를 사용 하 여 투명도 및 투명도 효과에 Windows" 응용 프로그램 참조의 Platform SDK 설명서에 [ http://msdn.microsoft.com ](http://msdn.microsoft.com/)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 75%의 불투명도로 표시 되는 양식을 만드는 방법을 보여 줍니다. 코드 예제와 함께 화면의 가운데에 배치 하는 새 양식을 만듭니다는 <xref:System.Windows.Forms.Form.Opacity%2A> 속성 폼의 불투명도 수준을 변경 하려면 설정 합니다. 코드 예제에서는 또한 설정는 <xref:System.Windows.Forms.Form.Size%2A> 속성을 더 큰 폼의 기본 크기 보다 폼 크기가 조정 합니다. 이 코드 예제는이 예에서 정의 된 메서드는 이벤트 처리기 또는 다른 방법의 다른 폼에서 가정 작성 되었습니다.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TransparencyKey" />
        <altmember cref="F:System.Windows.Forms.OSFeature.LayeredWindows" />
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedForms As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ OwnedForms { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedForms : System.Windows.Forms.Form[]" Usage="System.Windows.Forms.Form.OwnedForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an array of <see cref="T:System.Windows.Forms.Form" /> objects that represent all forms that are owned by this form.</summary>
        <value>이 폼에 대해 소유된 폼을 나타내는 <see cref="T:System.Windows.Forms.Form" /> 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을이 폼에서 소유 하 고 있는 모든 폼을 포함 하는 배열을 반환 합니다. 다른 폼에 소유 하는 폼을 하려면 호출 된 <xref:System.Windows.Forms.Form.AddOwnedForm%2A> 메서드. 될 때까지 소유 소유자 폼에 할당 된 상태로 유지 됩니다는 <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> 메서드를 호출 합니다. 설정 하 여 다른가 소유 하는 폼을 만들 수도 있습니다는 <xref:System.Windows.Forms.Form.Owner%2A> 소유자 폼에 대 한 참조를 사용 하 여 속성입니다.  
  
 폼을 다른 폼에서 소유 하는 경우 종료 되었거나 소유자 양식으로 숨겨집니다. 예를 들어 라는 폼 `Form2` 이라는 폼에서 소유 하는 `Form1`합니다. 경우 `Form1` 닫히거나을 최소화 하 고 `Form2` 도 닫히거나 숨겨집니다. 소유 된 폼의 소유자 폼 뒤 표시 되지 됩니다. 찾기 등의 windows에 대 한 소유 된 폼을 사용할 수 있으며 소유자 폼을 선택한 경우 소유자 폼 뒤 표시 되지 않아야 하는 창과 바꿀 수 있습니다.  
  
> [!NOTE]
>  폼이 (mdi 다중) 다중 문서 인터페이스 부모 폼이이 속성은 열려 있는 MDI 자식 폼 현재 제외 하 고 표시 되는 모든 폼을 반환 합니다. MDI 부모 폼에서 열려 있는 MDI 자식 폼을 가져오려면는 <xref:System.Windows.Forms.Form.MdiChildren%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.OwnedForms%2A> 소유자 폼에서 소유 하는 모든 폼을 수정 하는 속성입니다. 예제에서 첫 번째 방법은 소유 된 폼와 관련 된 소유 된 폼의 배열에 폼을 추가 합니다. 두 번째 방법은 모든 소유 된 폼과 캡션을 변경 하는입니다. 이 예제를 실행 하려면 두 메서드가 모두 이벤트 또는 폼의 다른 메서드에서 호출 됩니다.  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ Owner { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Forms.Form with get, set" Usage="System.Windows.Forms.Form.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the form that owns this form.</summary>
        <value>이 폼의 소유자 폼을 나타내는 <see cref="T:System.Windows.Forms.Form" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 폼에 소유 하는 폼을 하려면 할당 해당 <xref:System.Windows.Forms.Form.Owner%2A> 속성 소유자 수 있는 형식에 대 한 참조입니다.  
  
 폼을 다른 폼에서 소유 하는 경우 종료 되었거나 소유자 양식으로 숨겨집니다. 예를 들어 라는 폼 `Form2` 이라는 폼에서 소유 하는 `Form1`합니다. 경우 `Form1` 닫히거나을 최소화 하 고 `Form2` 도 닫히거나 숨겨집니다. 소유 된 폼의 소유자 폼 뒤 표시 되지 됩니다. 찾기 등의 windows에 대 한 소유 된 폼을 사용할 수 있으며 기존 소유자 폼을 선택한 경우 표시 되어야 하는 windows 수 있습니다. 부모 폼에서 소유 하는 폼을 확인 하려면 사용 하 여는 <xref:System.Windows.Forms.Form.OwnedForms%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">A top-level window cannot have an owner.</exception>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="form.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">A <see cref="T:System.Windows.Forms.Message" />, passed by reference, that represents the Win32 message to process.</param>
        <param name="keyData">One of the <see cref="T:System.Windows.Forms.Keys" /> values that represents the key to process.</param>
        <summary>Processes a command key.</summary>
        <returns>
          <see langword="true" /> if the keystroke was processed and consumed by the control; otherwise, <see langword="false" /> to allow further processing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessCmdKey%2A> 메서드 재정의 기본  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType> 주 메뉴 명령 키 및 MDI 액셀러레이터의 추가 처리 작업을 제공 구현입니다.  
  
 트래핑 키 입력에 대 한 내용은 "Visual C#을 사용 하 여 컨트롤에서 키 입력을 트래핑 하는 방법"을 참조 하 고 ".NET에서 키 입력을 트래핑 하는 방법을 제어 Visual Basic.NET을 사용 하 여"에서 Microsoft 기술 자료에서 http://support.microsoft.com합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogChar : char -&gt; bool" Usage="form.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">The character to process.</param>
        <summary>Processes a dialog character.</summary>
        <returns>
          <see langword="true" /> if the character was processed by the control; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="form.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">One of the <see cref="T:System.Windows.Forms.Keys" /> values that represents the key to process.</param>
        <summary>Processes a dialog box key.</summary>
        <returns>
          <see langword="true" /> if the keystroke was processed and consumed by the control; otherwise, <see langword="false" /> to allow further processing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessDialogKey%2A> 메서드 재정의 기본 <xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType> 구현 리턴 및 이스케이프 키 대화 상자에서 추가 처리 작업을 제공 합니다. Alt 키 또는 제어 한정자를 포함 하는 키 입력 없음 처리를 수행 하는 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.ProcessKeyPreview :  -&gt; bool" Usage="form.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">A <see cref="T:System.Windows.Forms.Message" />, passed by reference, that represents the window message to process.</param>
        <summary>Previews a keyboard message.</summary>
        <returns>
          <see langword="true" /> if the message was processed by the control; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessMnemonic : char -&gt; bool" Usage="form.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">The character to process.</param>
        <summary>Processes a mnemonic character.</summary>
        <returns>
          <see langword="true" /> if the character was processed as a mnemonic by the control; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessTabKey(bool forward);" />
      <MemberSignature Language="F#" Value="override this.ProcessTabKey : bool -&gt; bool" Usage="form.ProcessTabKey forward" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          <see langword="true" /> to cycle forward through the controls in the ContainerControl; otherwise, <see langword="false" />.</param>
        <summary>Selects the next available control and makes it the active control.</summary>
        <returns>
          <see langword="true" /> if a control is selected; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberSignature Language="F#" Value="member this.RemoveOwnedForm : System.Windows.Forms.Form -&gt; unit" Usage="form.RemoveOwnedForm ownedForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">A <see cref="T:System.Windows.Forms.Form" /> representing the form to remove from the list of owned forms for this form.</param>
        <summary>Removes an owned form from this form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소유자 폼에 할당 된 상태를 유지 될 때까지 소유는 <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> 메서드를 호출 합니다. 소유 된 폼 소유 된 폼 목록에서이 메서드 제거도 설정 소유자 폼 `null`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeBegin As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeBegin;" />
      <MemberSignature Language="F#" Value="member this.ResizeBegin : EventHandler " Usage="member this.ResizeBegin : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a form enters resizing mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin> 는 사용자가 일반적으로 클릭 하 고 끌어서 테두리 또는 폼의 오른쪽 아래 모서리에 있는 크기 조정 그립 중 하나는 폼 크기를 조정 하기 시작할 때 이벤트가 발생 합니다. 이 작업 크기 조정 작업이 완료 될 때까지 크기 조정 모달 루프에 폼을 넣습니다. 일반적으로 다음과 같은 이벤트 집합이 크기 조정 작업 중에 발생 합니다.  
  
1.  단일 <xref:System.Windows.Forms.Form.ResizeBegin> 폼 크기 조정 모드로 들어가면 이벤트가 발생 합니다.  
  
2.  0 개 이상의 쌍 <xref:System.Windows.Forms.Control.Resize> 및 <xref:System.Windows.Forms.Control.SizeChanged> 폼의 이벤트가 발생할 <xref:System.Windows.Forms.Form.Size%2A> 수정 됩니다.  
  
3.  단일 <xref:System.Windows.Forms.Form.ResizeEnd> 폼 크기 조정 모드를 종료 이벤트가 발생 합니다.  
  
> [!NOTE]
>  테두리 또는 크기 조정 그립 없이 클릭 만으로 생성 됩니다는 <xref:System.Windows.Forms.Form.ResizeBegin> 및 <xref:System.Windows.Forms.Form.ResizeEnd> 이벤트 중간 단계의 없이 <xref:System.Windows.Forms.Control.Resize> 및 <xref:System.Windows.Forms.Control.SizeChanged> 이벤트 쌍입니다.  
  
 <xref:System.Windows.Forms.Form.ResizeBegin> 및 <xref:System.Windows.Forms.Form.ResizeEnd> 이벤트 쌍은 사용자가 클릭 하 고 끌어서 캡션 표시줄에 폼을 이동 하는 경우에 발생 합니다. 이러한 이벤트에서 생성 되지 않은 폼의 프로그래밍 방식으로 조작 예를 들어 변경 하 여는 <xref:System.Windows.Forms.Form.Size%2A> 또는 <xref:System.Windows.Forms.Control.Location%2A> 속성입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.ResizeBegin> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.ResizeBegin> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeEnd As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeEnd;" />
      <MemberSignature Language="F#" Value="member this.ResizeEnd : EventHandler " Usage="member this.ResizeEnd : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a form exits resizing mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd> 테두리 또는 폼의 오른쪽 아래 모서리에 있는 크기 조정 그립 중 하나를 끌어서 놓는 하 여 일반적으로 폼의 크기 조정을 마쳤을 때 이벤트가 발생 합니다. 크기 조정 작업에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.Form.ResizeBegin> 이벤트입니다.  
  
 <xref:System.Windows.Forms.Form.ResizeEnd> 이벤트는 사용자가 클릭 하 고 캡션 표시줄을 끌어 양식을 이동한 후에 생성 됩니다. 이 이벤트가 생성 되지 않습니다는 폼의 프로그래밍 방식으로 조작 하 여 예를 들어 변경 하 여는 <xref:System.Windows.Forms.Form.Size%2A> 또는 <xref:System.Windows.Forms.Control.Location%2A> 속성입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.ResizeEnd> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.ResizeEnd> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle RestoreBounds { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Drawing.Rectangle" Usage="System.Windows.Forms.Form.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the location and size of the form in its normal window state.</summary>
        <value>표준 창 상태의 폼 위치 및 크기를 포함하는 <see cref="T:System.Drawing.Rectangle" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 사용 된 <xref:System.Windows.Forms.Form.RestoreBounds%2A> 속성을 사용자의 창 크기를 추적 하 고 표준 창 상태의 폼에 대 한 기본 위치를 지정 합니다. 값을 추적 해야는 <xref:System.Windows.Forms.Form.WindowState%2A> 및 <xref:System.Windows.Forms.Form.RestoreBounds%2A> 속성을 사용자의 창 기본 추적 합니다.  
  
> [!NOTE]
>  값은 <xref:System.Windows.Forms.Form.RestoreBounds%2A> 속성은 경우에만 유효는 <xref:System.Windows.Forms.Form.WindowState%2A> 속성의는 <xref:System.Windows.Forms.Form> 클래스 같지 않습니다. <xref:System.Windows.Forms.FormWindowState.Normal>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeftLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool RightToLeftLayout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeftLayout : bool with get, set" Usage="System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether right-to-left mirror placement is turned on.</summary>
        <value>오른쪽에서 왼쪽 방향의 미러 배치가 설정되어 있으면 <see langword="true" />이고, 표준 자식 컨트롤 배치에 대해서는 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 속성은 전세계 사용자를 위한 지역화 대비 폼을 개발 하는 데 매우 유용 합니다. 여러 폼은 왼쪽에서 오른쪽으로 폼에 컨트롤 표시 되는 있도록 설계 되었습니다. 이러한 폼이 쓰기 방향 언어와 호환 됩니다. 그러나 오른쪽에서 왼쪽 방향 언어의 사용자에 게 동일한 폼을 표시할 때 것이 좋습니다 폼에서 컨트롤의 순서를 반대로 하 합니다. 모두는 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 및 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성은 `true`, 미러링 켜 집니다 양식 및 컨트롤 배치 및 텍스트 방향에는 오른쪽에서 왼쪽 됩니다.  
  
 와 달리 <xref:System.Windows.Forms.Control.RightToLeft%2A>, <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 상속 되지 않습니다. 자식 컨트롤에 적용 하려는 경우 원하는 미러된 각 자식 컨트롤에 설정 해야 합니다.  
  
 소유자 그리기 없는 경우 지원 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 로 설정 된 `Yes`합니다. 소유자 그리기 이벤트가 계속 발생 하지만 이러한 이벤트에서 작성 한 코드의 동작은 정의 되지 않았습니다. 또한 <xref:System.Windows.Forms.Control.BackgroundImage%2A>, <xref:System.Windows.Forms.Form.Opacity%2A>, <xref:System.Windows.Forms.Form.TransparencyKey%2A>, 그리기 이벤트 지원 되지 않습니다.  
  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 및 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 인해 다음과 같은 Win32 API 창 스타일을 설정 합니다.  
  
-   때 <xref:System.Windows.Forms.Control.RightToLeft%2A> 로 설정 되어 `Yes` 및 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 로 설정 된 `true`를 설정 하는 Windows Forms는 `WS_EX_LAYOUTRTL` 창 스타일을 설정 하 고 제거는 `WS_EX_RIGHT` 및 `WS_EX_RTLREADING` 스타일입니다.  
  
-   때 <xref:System.Windows.Forms.Control.RightToLeft%2A> 로 설정 된 `Yes` 하지만 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 로 설정 되어 `No`를 설정 하는 Windows Forms는 `WS_EX_RIGHT` 및 `WS_EX_RTLREADING` 창 스타일입니다.  
  
 이 속성의 값을 변경 발생는 <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> 이벤트입니다.  
  
 전역화 문제에 대 한 자세한 내용은 참조 [지역화 대비 응용 프로그램 개발에 대 한 유용한](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftLayoutChanged : EventHandler " Usage="member this.RightToLeftLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the value of the <see cref="P:System.Windows.Forms.Form.RightToLeftLayout" /> property changes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A> 및 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 속성 지역화 대비 응용 프로그램 개발에 일반적으로 사용 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="form.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">The factor by which the height and width of the control are scaled.</param>
        <param name="specified">A <see cref="T:System.Windows.Forms.BoundsSpecified" /> value that specifies the bounds of the control to use when defining its size and position.</param>
        <summary>Scales the location, size, padding, and margin of a control.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleCore (x As Single, y As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleCore(float x, float y);" />
      <MemberSignature Language="F#" Value="override this.ScaleCore : single * single -&gt; unit" Usage="form.ScaleCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Percentage to scale the form horizontally</param>
        <param name="y">Percentage to scale the form vertically</param>
        <summary>Performs scaling of the form.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="override this.Select : bool * bool -&gt; unit" Usage="form.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">If set to true that the active control is changed</param>
        <param name="forward">If directed is true, then this controls the direction in which focus is moved. If this is <see langword="true" />, then the next control is selected; otherwise, the previous control is selected.</param>
        <summary>Selects this form, and optionally selects the next or previous control.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">포커스를 변경 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="form.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">The new <see cref="P:System.Windows.Forms.Control.Left" /> property value of the control.</param>
        <param name="y">The new <see cref="P:System.Windows.Forms.Control.Top" /> property value of the control.</param>
        <param name="width">The new <see cref="P:System.Windows.Forms.Control.Width" /> property value of the control.</param>
        <param name="height">The new <see cref="P:System.Windows.Forms.Control.Height" /> property value of the control.</param>
        <param name="specified">A bitwise combination of the <see cref="T:System.Windows.Forms.BoundsSpecified" /> values.</param>
        <summary>Performs the work of setting the specified bounds of this control.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="override this.SetClientSizeCore : int * int -&gt; unit" Usage="form.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Requested width of the client region.</param>
        <param name="y">Requested height of the client region.</param>
        <summary>Sets the client size of the form. This will adjust the bounds of the form to make the client size the requested size.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetDesktopBounds : int * int * int * int -&gt; unit" Usage="form.SetDesktopBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">The x-coordinate of the form's location.</param>
        <param name="y">The y-coordinate of the form's location.</param>
        <param name="width">The width of the form.</param>
        <param name="height">The height of the form.</param>
        <summary>Sets the bounds of the form in desktop coordinates.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데스크톱 좌표로 작업 표시줄을 제외 하는 화면에서의 작업 영역을 기반으로 합니다. 데스크톱에서 폼의 크기와 위치를 설정 하려면이 메서드를 사용할 수 있습니다. 데스크톱 좌표로 폼의 작업 영역을 기반으로 하므로 양식에 바탕 화면에서 완전히 표시 되는지 확인 하려면이 메서드를 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Form.SetDesktopBounds%2A> 메서드. 이 예제를 실행 하려면 이라는 단추가 포함 된 폼에 다음 코드를 붙여 `Button2`합니다. 모든 이벤트가 해당 이벤트 처리기와 연결 되어 있는지 확인 합니다.  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopLocation (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopLocation(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.SetDesktopLocation : int * int -&gt; unit" Usage="form.SetDesktopLocation (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">The x-coordinate of the form's location.</param>
        <param name="y">The y-coordinate of the form's location.</param>
        <summary>Sets the location of the form in desktop coordinates.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데스크톱 좌표로 작업 표시줄을 제외 하는 화면에서의 작업 영역을 기반으로 합니다. 폼을 배치할 바탕 화면에서이 메서드를 사용할 수 있습니다. 데스크톱 좌표로 폼의 작업 영역을 기반으로 하므로 양식에 바탕 화면에서 완전히 표시 되는지 확인 하려면이 메서드를 사용할 수 있습니다. 이 메서드는 최상위 폼;에 주로 사용 하도록 사용 하 여는 <xref:System.Windows.Forms.Form.LayoutMdi%2A> 다중 문서 MDI (인터페이스) 자식 폼을 배치 하는 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> 및 <xref:System.Windows.Forms.Form.Activate%2A> 멤버입니다. 예제를 실행 하려면 이라는 폼에 다음 코드를 붙여 `Form1` 호출할 단추가 포함 된 `Button1` 와 두 개의 `Label` 이라는 컨트롤 `Label1` 및 `Label2`합니다.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="override this.SetVisibleCore : bool -&gt; unit" Usage="form.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" /> to make the control visible; otherwise, <see langword="false" />.</param>
        <summary>Sets the control to the specified visible state.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show (owner As IWin32Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberSignature Language="F#" Value="override this.Show : System.Windows.Forms.IWin32Window -&gt; unit" Usage="form.Show owner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Any object that implements <see cref="T:System.Windows.Forms.IWin32Window" /> and represents the top-level window that will own this form.</param>
        <summary>Shows the form with the specified owner to the user.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비 모달 폼을 표시 하려면이 메서드를 사용할 수 있습니다. 이 메서드를 사용 하는 경우는 <xref:System.Windows.Forms.Form.Owner%2A> 폼의 속성이로 설정 되어 `owner`합니다. 비 모달 폼 צ ְ ײ는 <xref:System.Windows.Forms.Form.Owner%2A> 소유 양식에 대 한 정보를 가져올 속성입니다.  이 메서드를 호출 하는 것은 동일한 설정으로는 <xref:System.Windows.Forms.Form.Owner%2A> 비 모달의 속성과 다음 호출는 <xref:System.Windows.Forms.Control.Show> 메서드.  
  
 폼을 표시 설정에 해당 하는 <xref:System.Windows.Forms.Control.Visible%2A> 속성을 `true`합니다. 후의 <xref:System.Windows.Forms.Form.Show%2A> 메서드가 호출 되는 <xref:System.Windows.Forms.Control.Visible%2A> 속성의 값을 반환 `true` 될 때까지 <xref:System.Windows.Forms.Control.Hide%2A> 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The form being shown is already visible.  -or-  The form specified in the <paramref name="owner" /> parameter is the same as the form being shown.  -or-  The form being shown is disabled.  -or-  The form being shown is not a top-level window.  -or-  The form being shown as a dialog box is already a modal form.  -or-  The current process is not running in user interactive mode (for more information, see <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="Overload:System.Windows.Forms.Form.ShowDialog" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ShowDialog">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Shows the form as a modal dialog box.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; System.Windows.Forms.DialogResult" Usage="form.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Shows the form as a modal dialog box.</summary>
        <returns>One of the <see cref="T:System.Windows.Forms.DialogResult" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램에 모달 대화 상자를 표시 하려면이 메서드를 사용할 수 있습니다. 이 메서드가 호출 되 면 대화 상자를 닫은 후 뒤에 나오는 코드 될 때까지 실행 되지 않습니다. 대화 상자 할당할 수의 값 중 하나는 <xref:System.Windows.Forms.DialogResult> 열거형에 할당는 <xref:System.Windows.Forms.Button.DialogResult%2A> 속성의는 <xref:System.Windows.Forms.Button> 는 폼 또는 설정 하 여는 <xref:System.Windows.Forms.Form.DialogResult%2A> 코드에서 폼의 속성입니다. 이 값은 다음이 메서드에 의해 반환 됩니다. 대화 상자에서 발생 한 동작을 처리할 방법을 결정 하기 위해이 반환 값을 사용할 수 있습니다. 예를 들어 대화 상자가 닫히고 반환 되는 `DialogResult.Cancel` 값이이 메서드를 통해 코드를 호출 하면 못하게 <xref:System.Windows.Forms.Form.ShowDialog%2A> 에서 실행 합니다.  
  
 폼을 모달 대화 상자로 표시 되 면 클릭 하 고 **닫기** 단추 (x 폼의 오른쪽 위 모서리에 있는 단추)를 사용 하면 양식을 숨길 및 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성으로 설정 됩니다 `DialogResult.Cancel`합니다. 비 모달 폼 달리는 <xref:System.Windows.Forms.Form.Close%2A> 대화 상자 닫기 폼 단추를 클릭 하거나의 값을 설정 하는 경우.NET Framework에서 메서드가 호출 되지 않습니다는 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성입니다. 대신 폼 숨겨져 있고 대화 상자의 새 인스턴스를 만들지 않고 다시 표시할 수 있습니다. 호출 해야 대신 종료 하는 대화 상자가 모음이 숨겨진 표시 된 폼을 하기 때문에 <xref:System.Windows.Forms.Control.Dispose%2A> 폼은 더 이상 필요 없는 응용 프로그램에서 폼의 메서드.  
  
 이 버전의는 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드로 지정 하지 않습니다는 폼 이나 컨트롤의 소유자입니다. 이 버전 호출 될 때 현재 활성 창의 대화 상자의 소유자를 이루어집니다. 특정 소유자를 지정 하려는 경우이 방법의 다른 버전을 사용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼을 모달 대화 상자로 표시 하 고 값을 읽을 것인지 결정 하기 전에 대화 상자의 반환 값을 평가 <xref:System.Windows.Forms.TextBox> 대화 상자 폼에서 컨트롤입니다. 이 예제에서는 한 <xref:System.Windows.Forms.Form> 라는 `testDialog` 만들어집니다 및 포함 하는 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `TextBox1`합니다. 이 예제에서는 하기 위해서는 또한이 예제 코드에서는 다른 호출에 포함 된를 <xref:System.Windows.Forms.Form> 표시 하기 위해 `testDialog` 모달 대화 상자로 합니다. 이 예제에서는 버전을 사용 하 여 <xref:System.Windows.Forms.Form.ShowDialog%2A> 대화 상자에 대 한 소유자를 지정 하는 합니다.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The form being shown is already visible.  -or-  The form being shown is disabled.  -or-  The form being shown is not a top-level window.  -or-  The form being shown as a dialog box is already a modal form.  -or-  The current process is not running in user interactive mode (for more information, see <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog (owner As IWin32Window) As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : System.Windows.Forms.IWin32Window -&gt; System.Windows.Forms.DialogResult" Usage="form.ShowDialog owner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Any object that implements <see cref="T:System.Windows.Forms.IWin32Window" /> that represents the top-level window that will own the modal dialog box.</param>
        <summary>Shows the form as a modal dialog box with the specified owner.</summary>
        <returns>One of the <see cref="T:System.Windows.Forms.DialogResult" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램에 모달 대화 상자를 표시 하려면이 메서드를 사용할 수 있습니다. 이 메서드가 호출 되 면 대화 상자를 닫은 후 뒤에 나오는 코드 될 때까지 실행 되지 않습니다. 값 중 하나는 대화 상자를 할당할 수 있습니다 <xref:System.Windows.Forms.DialogResult> 에 할당 하 여는 <xref:System.Windows.Forms.Button.DialogResult%2A> 속성은 <xref:System.Windows.Forms.Button> 는 폼 또는 설정 하 여는 <xref:System.Windows.Forms.Form.DialogResult%2A> 코드에서 폼의 속성입니다. 이 값은 다음이 메서드에 의해 반환 됩니다. 대화 상자에서 발생 한 동작을 처리할 방법을 결정 하기 위해이 반환 값을 사용할 수 있습니다. 예를 들어 대화 상자가 닫히고 반환 되는 `DialogResult.Cancel` 값이이 메서드를 통해 코드를 호출 하면 못하게 <xref:System.Windows.Forms.Form.ShowDialog%2A> 에서 실행 합니다.  
  
 폼을 모달 대화 상자로 표시 되 면 클릭 하 고 **닫기** 단추 (x 폼의 오른쪽 위 모서리에 있는 단추)를 사용 하면 양식을 숨길 및 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성으로 설정 됩니다 `DialogResult.Cancel`합니다. 모덜리스 폼과 달리는 <xref:System.Windows.Forms.Form.Close%2A> 대화 상자 닫기 폼 단추를 클릭 하거나의 값을 설정 하는 경우.NET Framework에서 메서드가 호출 되지 않습니다는 <xref:System.Windows.Forms.Form.DialogResult%2A> 속성입니다. 대신 폼 숨겨져 있고 대화 상자의 새 인스턴스를 만들지 않고 다시 표시할 수 있습니다. 호출 해야 대신 종료 하는 대화 상자가 모음이 숨겨진 표시 된 폼을 하기 때문에 <xref:System.Windows.Forms.Control.Dispose%2A> 폼은 더 이상 필요 없는 응용 프로그램에서 폼의 메서드.  
  
 이 버전의는 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 사용 하는 표시 되는 대화 상자를 소유 하는 특정 모양을 지정할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼을 모달 대화 상자로 표시 하 고 값을 읽을 것인지 결정 하기 전에 대화 상자의 반환 값을 평가 <xref:System.Windows.Forms.TextBox> 대화 상자 폼에서 컨트롤입니다. 이 예제에서는 한 <xref:System.Windows.Forms.Form> 라는 `Form2` 만들어집니다 및 포함 하는 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `TextBox1`합니다. 이 예제에서는 버전을 사용 하 여 <xref:System.Windows.Forms.Form.ShowDialog%2A> 대화 상자에 대 한 소유자를 지정 하는 합니다.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The form specified in the <paramref name="owner" /> parameter is the same as the form being shown.</exception>
        <exception cref="T:System.InvalidOperationException">The form being shown is already visible.  -or-  The form being shown is disabled.  -or-  The form being shown is not a top-level window.  -or-  The form being shown as a dialog box is already a modal form.  -or-  The current process is not running in user interactive mode (for more information, see <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowIcon As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowIcon { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowIcon : bool with get, set" Usage="System.Windows.Forms.Form.ShowIcon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether an icon is displayed in the caption bar of the form.</summary>
        <value>폼의 캡션 표시줄에 아이콘이 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ShowIcon%2A> 속성 포함 한 <xref:System.Boolean> 나타내는 값 여부를 폼의 <xref:System.Windows.Forms.Form.Icon%2A> 폼의 캡션 표시줄에 표시 됩니다. 경우는 <xref:System.Windows.Forms.Form.ControlBox%2A> 속성은 `false`, 아이콘과 컨트롤 상자는 표시 되지 않습니다.  
  
 경우 <xref:System.Windows.Forms.Form.ShowIcon%2A> 은 `false` 일반 아이콘 기본 폼이 표시 되 면 응용 프로그램에 대 한 작업 표시줄 단추에 표시 됩니다.  
  
 경우에이 속성이 적용 되지 않습니다 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 로 설정 된 <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>합니다. 이 경우 폼 아이콘이 표시 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Icon" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the form is displayed in the Windows taskbar.</summary>
        <value>런타임에 폼을 Windows 작업 표시줄에 표시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 폼 내에서 폼 부모가 부모로 지정된 된 폼을 Windows 작업 표시줄에 표시 되지 않습니다.  
  
 사용자가 해당 폼 Windows 작업 표시줄을 선택 하지 못하도록 하려면이 속성을 사용할 수 있습니다. 예를 들어 응용 프로그램에서 찾기 및 바꾸기 도구 창을 표시는 경우 해당 창 응용 프로그램의 주 창 및 찾기 및 바꾸기 도구 창 모두에 필요 하기 때문에 Windows 작업 표시줄 선택 하지 않도록 설정 하려면 검색 하려면 적절 하 게 표시 합니다.  
  
 폼을 만들 때이 속성을 사용 하려면 자주는 <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> 스타일입니다. 설정의 <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> 스타일 것 만으로 창을 작업 표시줄에 표시 되지 것입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.ShowInTaskbar%2A> 속성 대화 상자을 Windows 작업 표시줄에 표시 되지 않습니다.  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Shown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Shown;" />
      <MemberSignature Language="F#" Value="member this.Shown : EventHandler " Usage="member this.Shown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs whenever the form is first displayed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown> 이후에 최소화, 최대화, 복원, 숨기기, 표시 또는 무효화 및 다시 그리기는이 이벤트가 발생 하지 않으면 이벤트는 처음으로 양식을 표시 하는 발생 합니다. 폼의 이벤트 순서에 대 한 자세한 내용은 참조 [Windows Forms에서 이벤트의 순서](~/docs/framework/winforms/order-of-events-in-windows-forms.md)합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Form.Shown> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.Form.Shown> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowWithoutActivation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowWithoutActivation { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowWithoutActivation : bool" Usage="System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the window will be activated when it is shown.</summary>
        <value>창이 표시될 때 활성화되지 않으면 <see langword="True" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 최상위 창을 표시 하려고 하지만 현재 창에서 입력된 포커스를 수행 하 여 사용자의 작업을 중단 하지 않으려는 경우이 속성을 사용 합니다. 이 정보 팝업 창이 또는 도구 팔레트 그리기 응용 프로그램에서 같은 부동 창 수 있습니다.  
  
 이 속성이 읽기 전용 이므로 변경할 수 있습니다만 해당 값 재정의 하 여 <xref:System.Windows.Forms.Form.ShowWithoutActivation%2A> 사용자 지정 폼 및에 `true`합니다.  
  
 사용을 고려해 야 하면 활성화 되지 않은 창 UI 컨트롤을 사용 하는 경우는 <xref:System.Windows.Forms.ToolStrip> 와 같은 컨트롤 <xref:System.Windows.Forms.ToolStripDropDown>합니다. 이러한 컨트롤은 창 없는, 되며 창이 선택할 때 활성화 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Form.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the size of the form.</summary>
        <value>폼의 크기를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 설정 하는 대신 동시에 높이 너비 (픽셀 단위)는 폼의 설정할 수 있습니다는 <xref:System.Windows.Forms.Control.Height%2A> 및 <xref:System.Windows.Forms.Control.Width%2A> 속성 개별적으로 합니다. 폼의 위치와 크기를 설정 하려는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.Form.DesktopBounds%2A> 데스크톱 좌표 또는 사용을 기반으로 하 고 양식을 찾습니다 크기 속성은 <xref:System.Windows.Forms.Control.Bounds%2A> 속성의는 <xref:System.Windows.Forms.Control> 화면 좌표계에 따라 폼의 위치와 크기를 설정 하는 클래스 inates 합니다.  
  
> [!NOTE]
>  이 속성의 최대값은 폼 실행 되는 화면 해상도로 제한 됩니다. 값 (예: 가로 + 12, 세로 + 12) 각 화면 크기 보다 12 픽셀 보다 클 수 없습니다.  
  
> [!NOTE]
>  Pocket PC 장치에서 설정 하 여 크기 조정 가능한 창을 만들 수 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 를 `None` 모두 제거 하 고 <xref:System.Windows.Forms.MainMenu> 제어 합니다. SmartPhone 장치에서 되지 크기를 조정할 수는 <xref:System.Windows.Forms.Form> -전체 화면을 항상 채웁니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 75%의 불투명도로 표시 되는 양식을 만드는 방법을 보여 줍니다. 예제 코드와 함께 화면의 가운데에 배치 하는 새 양식을 만듭니다는 <xref:System.Windows.Forms.Form.Opacity%2A> 속성 폼의 불투명도 수준을 변경 하려면 설정 합니다. 예제 코드는 또한 설정는 <xref:System.Windows.Forms.Form.Size%2A> 속성을 더 큰 폼의 기본 크기 보다 폼 크기가 조정 합니다. 이 예제에서는 이벤트 처리기 또는 다른 방법의 다른 폼에서이 예제에 정의 된 메서드가 호출 되도록 합니다.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeGripStyle As SizeGripStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::SizeGripStyle SizeGripStyle { System::Windows::Forms::SizeGripStyle get(); void set(System::Windows::Forms::SizeGripStyle value); };" />
      <MemberSignature Language="F#" Value="member this.SizeGripStyle : System.Windows.Forms.SizeGripStyle with get, set" Usage="System.Windows.Forms.Form.SizeGripStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the style of the size grip to display in the lower-right corner of the form.</summary>
        <value>표시할 크기 조정 그립의 스타일을 나타내는 <see cref="T:System.Windows.Forms.SizeGripStyle" />입니다. 기본값은 <see cref="F:System.Windows.Forms.SizeGripStyle.Auto" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 크기 조정 그립 폼에 표시 되는 시기를 확인할 수 있습니다. 크기 조정 그립을 표시 하거나의 설정에 따라이 자동으로 표시 한이 속성을 설정할 수 있습니다는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 크기 조정 그립을 숨기는 방법에는 <xref:System.Windows.Forms.Form> 때는 <xref:System.Windows.Forms.Form> 는 조정할 수 없습니다.  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value specified is outside the range of valid values.</exception>
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="T:System.Windows.Forms.SizeGripStyle" />
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property StartPosition As FormStartPosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormStartPosition StartPosition { System::Windows::Forms::FormStartPosition get(); void set(System::Windows::Forms::FormStartPosition value); };" />
      <MemberSignature Language="F#" Value="member this.StartPosition : System.Windows.Forms.FormStartPosition with get, set" Usage="System.Windows.Forms.Form.StartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the starting position of the form at run time.</summary>
        <value>폼의 시작 위치를 나타내는 <see cref="T:System.Windows.Forms.FormStartPosition" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 런타임 시 표시 될 때 폼의 시작 위치를 설정할 수 있습니다. 폼의 위치를 설정 하 여 수동으로 지정할 수 있습니다는 <xref:System.Windows.Forms.Form.Location%2A> 속성 또는 Windows가 지정한 기본 위치를 사용 합니다. 다중 문서 MDI (인터페이스) 자식 폼과 같은 폼은 부모 폼의 중심 또는 화면 중앙에 표시 하려면 폼을 배치할 수 있습니다.  
  
 폼이 표시 되기 전에이 속성을 설정 해야 합니다.  호출 하기 전에이 속성을 설정할 수는 <xref:System.Windows.Forms.Form.Show%2A> 또는 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드 또는 폼의 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 새 인스턴스를 만듭니다.는 <xref:System.Windows.Forms.Form> 호출과 <xref:System.Windows.Forms.Form.ShowDialog%2A> 메서드를 폼으로 대화 상자 표시 합니다. 예제에서는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, 및 <xref:System.Windows.Forms.Form.StartPosition%2A> 대화 상자에 표시 되는 모양 및 폼의 기능을 변경 하려면 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> 메서드가 폼의 <xref:System.Windows.Forms.Control.Controls%2A> 두 개를 추가할 컬렉션 <xref:System.Windows.Forms.Button> 컨트롤입니다. 이 예제에서는 사용는 <xref:System.Windows.Forms.Form.HelpButton%2A> 속성을 대화 상자의 캡션 표시줄에 도움말 단추를 표시 합니다.  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value specified is outside the range of valid values.</exception>
        <altmember cref="T:System.Windows.Forms.FormStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Form.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the tab order of the control within its container.</summary>
        <value>컨트롤 컨테이너 내의 컨트롤 집합(탭 순서로 포함)에 있는 컨트롤 인덱스를 포함하는 <see cref="T:System.Int32" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Forms 탭 순서에 포함 되지 않습니다. 설정의 <xref:System.Windows.Forms.Form.TabIndex%2A> 속성은 아무 작업도 수행 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.Form.TabIndex" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Form.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the user can give the focus to this control using the TAB key.</summary>
        <value>Tab 키를 사용하여 컨트롤의 포커스를 이동할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="P:System.Windows.Forms.Form.TabStop" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Form.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the text associated with this control.</summary>
        <value>이 컨트롤과 관련된 텍스트입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TopLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopLevel { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TopLevel : bool with get, set" Usage="System.Windows.Forms.Form.TopLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to display the form as a top-level window.</summary>
        <value>폼을 최상위 창으로 표시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 최상위 폼에는 창 있는 부모 폼이 없는, 또는 해당 부모 폼은 데스크톱 창입니다. 최상위 창에서 응용 프로그램 기본 폼으로 일반적으로 사용 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서 사용 된 <xref:System.Windows.Forms.Form.Modal%2A> 속성 폼을 모달 폼으로 표시 되는지 확인을 합니다. 없는 경우는 <xref:System.Windows.Forms.Form.FormBorderStyle%2A> 및 <xref:System.Windows.Forms.Form.TopLevel%2A> 속성 폼 하위 수준의 폼 도구 창 테두리도 변경 됩니다.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">A Multiple-document interface (MDI) parent form must be a top-level window.</exception>
        <altmember cref="P:System.Windows.Forms.Form.TopMost" />
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberSignature Language="VB.NET" Value="Public Property TopMost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopMost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TopMost : bool with get, set" Usage="System.Windows.Forms.Form.TopMost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the form should be displayed as a topmost form.</summary>
        <value>폼을 맨 위 폼으로 표시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 맨 위 폼은 활성 또는 전경 폼 폼이 아닌 경우에 다른 (맨 위) 폼을 합니다. 맨 위 폼의 windows 바탕 화면에 z-순서에서 가장 높은 지점에 항상 표시 됩니다. 찾기 및 바꾸기 도구 창과 같은 응용 프로그램에 항상 표시 되는 폼을 만들려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼을 맨 위를 만드는 방법을 보여 줍니다. 이 예제에서는 두 가지 형태, 최대화 하 고 다른 하나는 맨 위 폼으로 표시 됩니다 만듭니다. 명명 된 첫 번째 형태에서 `bottomForm`, 최대화, 사용 하 여 표시 되는 <xref:System.Windows.Forms.Form.WindowState%2A> 맨 위 폼의 기능을 더 잘 보여 주기 위해 속성. 라는 두 번째 형태 `topMostForm`, 설정는 <xref:System.Windows.Forms.Form.TopMost%2A> 속성을 `true` 맨 위 폼으로 표시를 합니다. 이 코드가 실행 되 면에서 최대화 된 폼을 클릭 하 발생 하지 않습니다 맨 위 폼 최대화 된 폼 아래 표시 됩니다. 이 예제에서는 다른 폼에서이 예제에 정의 된 메서드가 호출 되도록 합니다.  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TopLevel" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="form.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a string representing the current instance of the form.</summary>
        <returns>A string consisting of the fully qualified name of the form object's class, with the <see cref="P:System.Windows.Forms.Form.Text" /> property of the form appended to the end. For example, if the form is derived from the class <c>MyForm</c> in the <c>MyNamespace</c> namespace, and the <see cref="P:System.Windows.Forms.Form.Text" /> property is set to <c>Hello, World</c>, this method will return <c>MyNamespace.MyForm, Text: Hello, World</c>.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberSignature Language="VB.NET" Value="Public Property TransparencyKey As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color TransparencyKey { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.TransparencyKey : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Form.TransparencyKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the color that will represent transparent areas of the form.</summary>
        <value>폼에 투명하게 표시할 색을 나타내는 <see cref="T:System.Drawing.Color" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Form.TransparencyKey%2A> 속성에 할당 되는 <xref:System.Drawing.Color>, 동일한 폼의 영역 <xref:System.Windows.Forms.Control.BackColor%2A> 투명 하 게 표시 됩니다. 모든 마우스 작업을 마우스 클릭과 같은 폼의 투명 영역에서 수행 되는 투명 한 영역 아래의 창으로 전송 됩니다. 예를 들어 폼의 클라이언트 영역와 투명 하 게 수행 해당 영역에서 마우스를 클릭 하는 보내기 클릭에 대 한 이벤트 알림을 창 아래에 있습니다. 색에 할당 된 경우는 <xref:System.Windows.Forms.Form.TransparencyKey%2A> 속성 폼에 있는 모든 컨트롤와 같은지도 표시 될 투명 하 게 합니다. 예를 들어는 <xref:System.Windows.Forms.Button> 양식에 있는 컨트롤의 <xref:System.Windows.Forms.Form.TransparencyKey%2A> 속성이로 설정 `SystemColors.Control`, 컨트롤은 투명 하 게 않은 경우 표시는 <xref:System.Windows.Forms.Control.BackColor%2A> 속성의는 <xref:System.Windows.Forms.Button> 컨트롤을 다른 색으로 변경 됩니다.  
  
 이 속성은 실행할 수 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 은 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 폼의 배경색에 관계 없이 투명 한 클라이언트 영역을 포함 하는 창을 만듭니다. 이 예제에서는 메서드 예제 양식 클래스 내에서 정의 되어 있어야 합니다.  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateDefaultButton();" />
      <MemberSignature Language="F#" Value="override this.UpdateDefaultButton : unit -&gt; unit" Usage="form.UpdateDefaultButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Updates which button is the default button.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A> 메서드 확인 폼에 단추를 다음 우선 순위에 따라 사용자가 ENTER를 누를 때 Click 이벤트를 발생 시킵니다.  
  
1.  경우는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> 속성이 구현 하는 <xref:System.Windows.Forms.IButtonControl> 인터페이스, 제어 기본 단추 인지 합니다.  
  
2.  <xref:System.Windows.Forms.Form.AcceptButton%2A> 속성 기본 단추입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Validates all selectable child controls in the form.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren();" />
      <MemberSignature Language="F#" Value="override this.ValidateChildren : unit -&gt; bool" Usage="form.ValidateChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes all of the child controls within a control that support validation to validate their data.</summary>
        <returns>
          <see langword="true" /> if all of the children validated successfully; otherwise, <see langword="false" />. If called from the <see cref="E:System.Windows.Forms.Control.Validating" /> or <see cref="E:System.Windows.Forms.Control.Validated" /> event handlers, this method will always return <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberSignature Language="F#" Value="override this.ValidateChildren : System.Windows.Forms.ValidationConstraints -&gt; bool" Usage="form.ValidateChildren validationConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">Places restrictions on which controls have their <see cref="E:System.Windows.Forms.Control.Validating" /> event raised.</param>
        <summary>Causes all of the child controls within a control that support validation to validate their data.</summary>
        <returns>
          <see langword="true" /> if all of the children validated successfully; otherwise, <see langword="false" />. If called from the <see cref="E:System.Windows.Forms.Control.Validating" /> or <see cref="E:System.Windows.Forms.Control.Validated" /> event handlers, this method will always return <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As FormWindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormWindowState WindowState { System::Windows::Forms::FormWindowState get(); void set(System::Windows::Forms::FormWindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.Forms.FormWindowState with get, set" Usage="System.Windows.Forms.Form.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether form is minimized, maximized, or normal.</summary>
        <value>폼이 최소화, 최대화 또는 표준인지를 나타내는 <see cref="T:System.Windows.Forms.FormWindowState" />입니다. 기본값은 <see langword="FormWindowState.Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼이 표시 되기 전에 <xref:System.Windows.Forms.Form.WindowState%2A> 항상 속성이 `FormWindowState.Normal`초기 설정에 관계 없이 합니다. 이 <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Top%2A>, 및 <xref:System.Windows.Forms.Control.Width%2A> 속성 설정 합니다. 표시 된 후 폼이 나타나지 않으면 이러한 속성을 변경 해도 다시 폼이 표시 될 때까지 이전 상태로 반영 하는 <xref:System.Windows.Forms.Form.WindowState%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 설정 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Form.WindowState%2A> 를 최대화 합니다. 코드에서 호출 되는 <xref:System.Windows.Forms.Form.Shown> 폼이 만들어진 후 이벤트 처리기입니다.  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value specified is outside the range of valid values.</exception>
        <altmember cref="T:System.Windows.Forms.FormWindowState" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="form.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">The Windows <see cref="T:System.Windows.Forms.Message" /> to process.</param>
        <summary>Processes Windows messages.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>