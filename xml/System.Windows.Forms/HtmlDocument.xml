<Type Name="HtmlDocument" FullName="System.Windows.Forms.HtmlDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d6ea42599f937798371ada9988169189c5fb02d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30641137" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlDocument extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlDocument sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Windows.Forms.WebBrowser" /> 컨트롤에 호스트된 HTML 문서를 최상위 수준의 프로그래밍 방식으로 액세스할 수 있도록 합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> Internet Explorer의 문서 개체 라고도 HTML 문서 개체 모델 (DOM)에 관리 되는 래퍼를 제공 합니다. 인스턴스를 가져올 <xref:System.Windows.Forms.HtmlDocument> 통해는 <xref:System.Windows.Forms.WebBrowser.Document%2A> 의 속성은 <xref:System.Windows.Forms.WebBrowser> 컨트롤입니다.  
  
 HTML 문서 내의 태그 서로 중첩 될 수 있습니다. <xref:System.Windows.Forms.HtmlDocument> 따라서 인스턴스를 해당 자식으로, 문서 트리를 나타내는의 <xref:System.Windows.Forms.HtmlElement> 클래스입니다. 다음 코드 예제에서는 간단한 HTML 파일을 보여 줍니다.  
  
```  
<HTML>  
    <BODY>  
        <DIV name="Span1">Simple HTML Form</DIV>  
        <FORM>  
            <SPAN name="TextLabel">Enter Your Name:</SPAN>  
            <INPUT type="text" size="20" name="Text1">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 이 예제에서는 <xref:System.Windows.Forms.HtmlDocument> 내 전체 문서를 나타내는 `HTML` 태그입니다. `BODY`, `DIV`, `FORM` 및 `SPAN` 태그는 개별적으로 표시 됩니다 <xref:System.Windows.Forms.HtmlElement> 개체입니다.  
  
 여러 가지 방법으로이 트리에 있는 요소에 액세스할 수 있습니다. 사용 하 여는 <xref:System.Windows.Forms.HtmlDocument.Body%2A> 속성에 액세스는 `BODY` 태그와 모든 자식입니다. <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> 속성을 사용 하는 <xref:System.Windows.Forms.HtmlElement> 사용자 입력 포커스가 있는 HTML 페이지의 요소에 대 한 합니다. HTML 페이지 내에서 모든 요소 이름이; 있을 수합니다 있습니다. <xref:System.Windows.Forms.HtmlDocument.All%2A> 각각에 대 한 액세스를 제공 하는 컬렉션 <xref:System.Windows.Forms.HtmlElement> 인덱스 이름을 사용 하 합니다. <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A> 반환는 <xref:System.Windows.Forms.HtmlElementCollection> 모든 <xref:System.Windows.Forms.HtmlElement> 와 같은 개체는 지정 된 HTML 태그 이름을 갖는 `DIV` 또는 `TABLE`합니다. <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> 단일 반환 <xref:System.Windows.Forms.HtmlElement> 제공 하는 고유 ID에 해당 합니다. <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> 반환 된 <xref:System.Windows.Forms.HtmlElement> 제공 된 마우스 포인터 좌표에서 화면에 표시 될 수 있는 합니다.  
  
 사용할 수도 있습니다는 <xref:System.Windows.Forms.HtmlDocument.Forms%2A> 및 <xref:System.Windows.Forms.HtmlDocument.Images%2A> 각각 나타내는 사용자 요소를 통해 반복 하는 컬렉션 입력 폼과 그래픽을 합니다.  
  
 <xref:System.Windows.Forms.HtmlDocument> 관리 되지 않는 Internet Explorer의 DHTML DOM에서 구현한 인터페이스 기반: `IHTMLDocument`, `IHTMLDocument2`, `IHTMLDocument3`, 및 `IHTMLDocument4`합니다. 가장 자주 사용 되는 속성에 의해 관리 되지 않는 이러한 인터페이스에 메서드 노출 되 고 <xref:System.Windows.Forms.HtmlDocument>합니다. 다른 모든 속성 및 메서드를 사용 하 여 직접 액세스할 수는 <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> 속성을 원하는 관리 되지 않는 인터페이스 포인터를 캐스팅할 수 있습니다.  
  
 HTML 문서 프레임 되는 여러 창이 포함 될 수 있습니다 내부에 <xref:System.Windows.Forms.WebBrowser> 제어 합니다. 각 프레임은 자신의 HTML 페이지를 표시합니다. <xref:System.Windows.Forms.HtmlWindow.Frames%2A> 컬렉션을 통해 사용할 수는 <xref:System.Windows.Forms.HtmlDocument.Window%2A> 속성입니다. 사용할 수 있습니다는 <xref:System.Windows.Forms.HtmlDocument.Window%2A> 속성을 표시 된 페이지 크기를 조정 하는 문서를 스크롤하거나 표시 하는 사용자에 게 묻는 메시지를 표시 합니다.  
  
 <xref:System.Windows.Forms.HtmlDocument> HTML 페이지를 호스트 하는 경우를 처리 해야 하는 가장 일반적인 이벤트를 노출 합니다. 인터페이스에 의해 직접 노출 되지 않는 이벤트를 사용 하 여 이벤트에 대 한 처리기를 추가할 수 있습니다 <xref:System.Windows.Forms.HtmlDocument.AttachEventHandler%2A>합니다.  
  
 HTML 파일 포함 될 수 `SCRIPT` 액티브 스크립팅 언어 JScript 또는 VBScript 같은 중 하나로 작성 된 코드를 캡슐화 하는 태그입니다. <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> 속성의 실행에 대 한 메서드를 제공 및에 정의 된 메서드는 `SCRIPT` 태그입니다.  
  
> [!NOTE]
>  대부분의 속성, 메서드 및 이벤트에 동안 <xref:System.Windows.Forms.HtmlDocument> 가 관리 되지 않는 DOM에서와 동일한 이름을 유지 일부 된 변경의 일관성을 위해는 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Northwind 데이터베이스에서에서 데이터를 사용 하 여 만들려는 `HTML TABLE` 동적으로 사용 하 여 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>합니다. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 메서드는 또한을 먼저 셀을 추가 (`TD` 요소) 행에 (`TR` 요소), 다음 테이블에 행을 추가 하려면 마지막으로 테이블 현재 문서의 끝에 추가할 합니다. 이 코드 예제 응용 프로그램에 <xref:System.Windows.Forms.WebBrowser> 라는 컨트롤 `WebBrowser1`합니다. 문서를 로드 한 후 코드를 호출 해야 합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActiveElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement ActiveElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement ActiveElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ ActiveElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 입력 포커스가 있는 <see cref="T:System.Windows.Forms.HtmlElement" />를 제공합니다.</summary>
        <value>현재 입력 포커스가 있는 <see cref="T:System.Windows.Forms.HtmlElement" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문서에 포커스가 있지만 문서 요소가 없는 포커스를 지정 하는 경우 <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> 반환에 해당 하는 요소는 `<BODY>` 태그입니다.  
  
 문서에 포커스가 없으면 <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> 반환 `null`합니다.  
  
 입력된 포커스가 있는 경우 현재 요소가 셀 (`TD`) html에서 `TABLE` 태그 <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> 포함 하는 요소를 반환 합니다는 `TABLE` 요소입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ActiveLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ActiveLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ActiveLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 클릭할 때 하이퍼링크의 <see cref="T:System.Drawing.Color" />를 가져오거나 설정합니다.</summary>
        <value>활성 링크의 <see cref="T:System.Drawing.Color" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 클릭할 때 한 링크가 활성화 됨입니다. 탐색 전에 링크의 색을 변경 하려면이 속성을 변경 합니다.  
  
 <xref:System.Drawing.Color> 에 입력 된 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 지원는 `Alpha` 값과 동일 하지만 HTML DOM는 그렇지 않습니다. 따라서 `Alpha` 이 속성에 할당 하는 경우 영향을 미치지 것입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문서의 모든 <see cref="T:System.Windows.Forms.HtmlElementCollection" /> 개체를 저장하는 <see cref="T:System.Windows.Forms.HtmlElement" /> 인스턴스를 가져옵니다.</summary>
        <value>문서에 있는 모든 요소의 <see cref="T:System.Windows.Forms.HtmlElementCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.All%2A> 컬렉션 문서 트리에서 위치에 관계 없이 HTML 문서에서 모든 요소에 대 한 임의 액세스를 제공 합니다. 인덱스 또는 HTML 문서에 있는 모든 요소 이름, ID, 액세스를 사용 합니다. 모든 문서 내의 요소를 통해 반복 수도 있습니다.  
  
 일부 요소와 같은 `HEAD` 및 `TITLE`, 연결 된 이름이 있을 수 없습니다. 다른 모든 요소는 HTML 파일의 작성자에 게 할당 하는 경우에 이름을 갖게 됩니다. ID 또는 인덱스 이름이 없는 요소에 액세스할 수 있습니다.  
  
 요소에 직접 추가할 수 없습니다는 <xref:System.Windows.Forms.HtmlDocument.All%2A> 컬렉션 외부의 모든 요소는 html에서 파일은 `HTML` 태그는 부모 요소가 있어야 합니다. 사용 하 여는 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 메서드 또는 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 속성 <xref:System.Windows.Forms.HtmlElement> 트리에 새 요소를 추가할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 모든 문서 및 집합의 요소 반복 `Enabled=True`, 문서를 로드 하는 동안 사용자 입력을 방지 하기 위해 기본적으로 사용 하지 않는 요소를 활성화 합니다. 이 코드 예제 응용 프로그램에 <xref:System.Windows.Forms.WebBrowser> 라는 컨트롤 `WebBrowser1`합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">처리할 이벤트의 이름입니다.</param>
        <param name="eventHandler">이벤트를 처리하는 관리 코드입니다.</param>
        <summary>명명된 HTML DOM 이벤트에 대한 이벤트 처리기를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문서 로드가 완료 될 때까지 문서 또는 해당 개체 중 하나에 이벤트를 연결 해야 합니다. 이 메서드를 호출 해야 가장 빠른는 <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> 의 이벤트는 <xref:System.Windows.Forms.WebBrowser> 제어 합니다.  
  
 이 메서드를 사용 하 여 노출 되지 않는 관리 되지 않는 DOM 이벤트에 처리기를 연결 있습니다 <xref:System.Windows.Forms.HtmlDocument>합니다. 사용 가능한 관리 되지 않는 DOM 이벤트에 대 한 자세한 내용은 참조 [관리 되는 HTML 문서 개체 모델에서 노출 되지 않은 멤버에 액세스](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) 및 IHTMLDocument 인터페이스: [IHTMLDocument](http://go.microsoft.com/fwlink/?LinkId=104882), [IHTMLDocument2](http://go.microsoft.com/fwlink/?LinkId=104884), [IHTMLDocument3](http://go.microsoft.com/fwlink/?LinkId=104886), [IHTMLDocument4](http://go.microsoft.com/fwlink/?LinkId=104887), [IHTMLDocument5](http://go.microsoft.com/fwlink/?LinkId=104888)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTML 문서의 배경색을 가져오거나 설정합니다.</summary>
        <value>문서 배경의 <see cref="T:System.Drawing.Color" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.BackColor%2A> 화면의 해당 영역을 차지 하는 다른 요소가 없는 경우 표시 됩니다.  
  
 <xref:System.Drawing.Color> 에 입력 된 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 지원는 `Alpha` 값과 동일 하지만 HTML DOM는 그렇지 않습니다. 따라서 `Alpha` 이 속성에 할당 하는 경우 영향을 미치지 것입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Body { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Body" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Body" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Body As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Body { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <c>BODY</c> 태그에 대한 <see cref="T:System.Windows.Forms.HtmlElement" />를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> 개체에 대 한는 <c>본문</c> 태그입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 문서는 두 개의 주요 섹션으로 분할 됩니다.  
  
-   `HEAD`는 문서의 제목, 문서 메타 데이터를 포함 하 고 `SCRIPT` 요소입니다.  
  
-   `BODY`에 관련 된 요소를 모두 포함 하는 화면에 나타나는 문서 모양이 합니다.  
  
 동등한 옵션이 없습니다 `Head` 속성 <xref:System.Windows.Forms.HtmlDocument>합니다. 가져올 수는 `HEAD` 요소를 사용 하 여 <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 새 `DIV` 요소를 사용 하 여 문서 아래쪽에 추가 된 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 메서드.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 문서의 아무 위치나 클릭하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 문서에 대 한 클릭 검색 요소를 발견 하 고 사용 <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> 웹 페이지의 맨 위에 해당 요소입니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuShowing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.ContextMenuShowing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuShowing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ ContextMenuShowing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 문서의 상황에 맞는 메뉴를 표시하도록 요청할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 문서 또는 문서에서 요소를 마우스 오른쪽 단추로 클릭 하는 경우 표시 됩니다는 기본 상황에 맞는 메뉴 특정 요소에 있습니다. 이 이벤트를 사용 하 여 상황에 맞는 메뉴의 표시를 취소 하 고 자신의 중 하나를 표시 합니다.  
  
   
  
## Examples  
 다음 코드 예에서는 캡처는 <xref:System.Windows.Forms.HtmlDocument.ContextMenuShowing> 이벤트 사용 하 여 표시 하 고는 <xref:System.Windows.Forms.ContextMenuStrip>합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookie">
      <MemberSignature Language="C#" Value="public string Cookie { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Cookie" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberSignature Language="VB.NET" Value="Public Property Cookie As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Cookie { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서와 연결된 HTTP 쿠키를 가져오거나 설정합니다.</summary>
        <value>각 쿠키가 세미콜론으로 분리되어 있는 쿠키 목록이 포함된 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> 속성 <xref:System.Windows.Forms.HtmlDocument> 웹 페이지에 대해 설정 하는 모든 쿠키를 노출 합니다.  
  
 A *쿠키* 는 지정된 된 웹 페이지와 관련 된 임의의 이름/값 쌍입니다. 웹 개발자는 사용자가 방문 하거나 웹 사이트에 반환 하는 시기를 추적에 쿠키를 사용 합니다. 쿠키는 다음을 결정 하는 쿠키 조각을 호출 하는 여러 부분으로 구성 됩니다.  
  
-   쿠키가 적용 되는 문서를 설정 합니다. 도메인 및 경로입니다.  
  
-   이름과 쿠키의 값입니다.  
  
-   쿠키의 만료 날짜입니다.  
  
-   여부 쿠키 수만 전송 보안 연결을 사용 하 여.  
  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> 속성에는 여러 개의 쿠키 포함 될 수 있습니다.  
  
 만 사용할 수 있습니다는 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> 속성을 한 번에 하나의 쿠키를 설정 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement CreateElement (string elementTag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement CreateElement(string elementTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (elementTag As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ CreateElement(System::String ^ elementTag);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTag" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementTag">만들 HTML 요소의 이름입니다.</param>
        <summary>지정한 HTML 태그 형식의 새 <see langword="HtmlElement" />를 만듭니다.</summary>
        <returns>지정한 태그 형식의 새 요소입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `elementTag` 제외 하 고 Internet Explorer에서 지원 되는 HTML 태그 중 하나일 수 있습니다 `FRAME` 또는 `IFRAME`합니다.  
  
 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 현재 문서 트리에 연결 되지 않은 요소를 반환합니다. 문서에 요소를 추가 하려면 하나를 사용는 <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> 또는 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 메서드.  
  
 이 메서드는에 영향을 주지 상태 기존 문서의 소스 코드를 사용 하는 경우는 <xref:System.Windows.Forms.WebBrowser> 컨트롤의 **소스 보기** 상황에 맞는 메뉴 명령 또는 <xref:System.Windows.Forms.WebBrowser.DocumentText%2A> 및 <xref:System.Windows.Forms.WebBrowser.DocumentStream%2A> 의 속성은 <xref:System.Windows.Forms.WebBrowser> 컨트롤입니다.  
  
 새 요소를 만들 때 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>와 같은 특정 속성을 설정할 수 없습니다 `Name`합니다. Html로 할당 Name 특성을 설정 해야 하는 경우에는 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 문서에서 다른 개체의 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제는 HTML을 만들기 위해 Northwind 데이터베이스에서에서 데이터를 사용 하 여 테이블을 사용 하 여 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>합니다. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 메서드는 또한을 먼저 셀을 추가 (`TD` 요소) 행에 (`TR` 요소), 다음 테이블에 행을 추가 하려면 마지막으로 테이블 현재 문서의 끝에 추가할 합니다. 이 코드 예제 응용 프로그램에 <xref:System.Windows.Forms.WebBrowser> 이라는 컨트롤 `WebBrowser1`합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultEncoding">
      <MemberSignature Language="C#" Value="public string DefaultEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultEncoding { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 문서에 기본적으로 사용되는 인코딩을 가져옵니다.</summary>
        <value>페이지가 처음 표시될 때 브라우저에서 사용하는 인코딩을 나타내는 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 인코딩은 인코딩을 페이지가 처음 로드 될 때 사용 하는 관리 되는 HTML 문서 개체 모델 (DOM)는 시도입니다. 이 인코딩은 파생 된 Internet Explorer에서 **인코딩** 설정 또는 `META` 페이지 내에서 태그를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">처리를 중지할 이벤트의 이름입니다.</param>
        <param name="eventHandler">이벤트를 처리하는 관리 코드입니다.</param>
        <summary>HTML DOM의 명명된 이벤트에서 이벤트 처리기를 제거합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보안상의 이유로 이 문서의 도메인을 설명하는 문자열을 가져오거나 설정합니다.</summary>
        <value>유효한 도메인입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 다른 프레임의 두 가지 웹 페이지는에서 스크립트를 사용 하 여 다른 사용자의 콘텐츠를 액세스할 수 없습니다. 짝수 www.microsoft.com 및 msdn.microsoft.com 인이 인스턴스에서 간주 서로 다른 도메인. 최상위 도메인의 동일한 페이지에 대 한 프레임 간 스크립팅을 사용 하려면 새 값을 할당할 수 있습니다는 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 속성입니다. 설정 이전 URL 예제에서는 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> microsoft.com을 모두 페이지가 허용 서로 통신할 수 있습니다.  
  
 에 할당 된 문자열은 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 속성에 유효한 최상위 도메인 이어야 합니다. 이전 URL 예제에서 설정할 수 있습니다 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 속해에 속하지만.com에는 사용 하면 모든 페이지에서 인터넷을 통해 스크립트 페이지의 콘텐츠입니다.  
  
 사용할 수 없습니다는 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 속성을 사용 하 여 두 개의 서로 다른 프로토콜을 사용 하 여 액세스 되는 페이지에 대 한 프레임 간 스크립팅 합니다. 페이지의 한 프레임은 웹 서버 (http:// 프로토콜)에서 제공 하는 경우 파일 시스템 (file://) 프로토콜에서 제공 하는 다른 됩니다의 값에 관계 없이 다른 노드와 통신할 수는 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <c>Domain</c> 속성의 인수가 DNS(Domain Name System) 규칙을 사용하는 유효한 도메인 이름이어야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomDocument">
      <MemberSignature Language="C#" Value="public object DomDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomDocument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomDocument As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomDocument { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Windows.Forms.HtmlDocument" />에 대한 관리되지 않는 인터페이스 포인터를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Object" /> 나타내는 <c>IDispatch</c> 관리 되지 않는 문서에 대 한 포인터입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> 래퍼에 대 한는 Internet Explorer DOM 문서 개체 모델 (), COM.로 작성 된은 와 같은 내부 COM 인터페이스에서 노출 되지 않은 속성이 나 메서드에 액세스 해야 할 경우 `IHTMLDocument2`를 쿼리 하기 위해이 개체에 사용할 수 있습니다.  
  
 관리 되지 않는 인터페이스를 사용 하려면 응용 프로그램에 MSHTML 라이브러리를 (mshtml.dll)를 가져옵니다. 그러나 실행할 수도 있습니다 노출 되지 않은 속성 및 메서드를 사용 하 여 `IDispatch::Invoke` 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 캐스트는 <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> 에 `IHTMLDocument2` 포인터의 값을 표시 하 고는 `lastModified` 때 문서의 소유자 내용을 마지막으로 업데이트를 알려 주는 속성입니다. 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.Button> 폼 `Button6`합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 권한. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public string Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Encoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 대한 문자 인코딩을 가져오거나 설정합니다.</summary>
        <value>현재 문자 인코딩을 나타내는 <see cref="T:System.String" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">테스트할 개체입니다.</param>
        <summary>현재 개체와 해당 개체가 같은지를 테스트합니다.</summary>
        <returns>
          개체가 동일하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecCommand">
      <MemberSignature Language="C#" Value="public void ExecCommand (string command, bool showUI, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecCommand(string command, bool showUI, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.ExecCommand(System.String,System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecCommand (command As String, showUI As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecCommand(System::String ^ command, bool showUI, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="showUI" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">실행할 명령의 이름입니다.</param>
        <param name="showUI">사용자에게 명령별 대화 상자나 메시지 상자를 표시할지 여부입니다.</param>
        <param name="value">명령을 사용하여 할당할 값입니다. 일부 명령에는 적용되지 않습니다.</param>
        <summary>문서에 대해 지정한 명령을 실행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> 큰 배열을 명령은에 노출 된 메서드가 노출 <xref:System.Windows.Forms.HtmlDocument>합니다. 사용 하 여 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> 새 HTML 요소를 삽입, 선택 하 고 텍스트, 서식을 지정 하 고 수 선택을 취소 하 인증 자격 증명을 캐시 합니다. 전체 명령 목록을 참조 하십시오. [명령 식별자](http://go.microsoft.com/fwlink/?LinkId=198814)합니다.  
  
> [!NOTE]
>  복사와 같은 특정 명령에 반환 값을 갖습니다. 현재 구현에서 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A>, 호출에서 반환 값을 가져올 수 없습니다. 반환 값을 검색 하려면에 해당 하는 관리 되지 않는 메서드를 사용는 <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> 대신 참조 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 문서에 사용자 입력 포커스를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Windows.Forms.HtmlDocument.Focus%2A> 에 포커스가 설정 됩니다는 <xref:System.Windows.Forms.WebBrowser> 컨트롤이 컨트롤 현재 포커스가 없는 경우. 문서 내에 호스팅되는 경우는 `FRAME`,이 메서드는 그에 포커스를 둔 `FRAME` 내에서 `FRAMESET`합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">에 대 한 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> 폼에 포커스를 설정할 수 있는 권한이 있습니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.UIPermissionWindow" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Focused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문서에 사용자 입력 포커스가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          문서에 포커스가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.Focus" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.Focusing" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문서에 포커스가 지정되기 전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.HtmlDocument.Focusing> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.HtmlDocument> 라는 `HtmlDocument1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.HtmlDocument.Focusing> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#424](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#424)]
 [!code-vb[System.Windows.Forms.EventExamples#424](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#424)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문서의 텍스트 색을 가져오거나 설정합니다.</summary>
        <value>문서의 텍스트 색입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> <xref:System.Drawing.Color> 에 입력 된 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 지원는 `Alpha` 값과 동일 하지만 HTML DOM는 그렇지 않습니다. 따라서 `Alpha` 이 속성에 할당 하는 경우 영향을 미치지 것입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Forms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Forms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Forms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Forms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Forms As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Forms { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문서에 있는 모든 <c>&lt;FORM&gt;</c> 요소의 컬렉션을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> 의 <c> &lt;양식&gt; </c> 문서 내의 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 문서 하나 이상 있을 수 있습니다 `FORM` 데이터 전송에 대 한 입력된 필드를 사용 하 여 요소를 서버에 다시 합니다.  
  
 프로그래밍 방식으로 제출할 수 있습니다는 `FORM` 를 가져와서 해당 <xref:System.Windows.Forms.HtmlElement> 호출 하 고 해당 `Submit` 메서드를 사용 하 여는 <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> 메서드.  
  
 새 `FORM` 문서를 만들 수 있습니다 새 `FORM` 문자열로 태그에 할당 하는 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> HTML DOM;에 있는 요소의 속성 이전에 추가 하거나 사용할 수 있습니다는 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 를사용하여해당속성을설정하는메서드를<xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>를 사용 하 여 기존 요소 자식으로 추가 하 고 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 모든 반복의 `Form` 요소 웹 페이지 및 폼을 기본값으로 다시 설정 모든 사용자 입력을 지웁니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementById (id As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">검색할 요소의 ID 특성입니다.</param>
        <summary>요소의 <c>ID</c> 특성을 검색 키로 사용하여 단일 <see cref="T:System.Windows.Forms.HtmlElement" />를 검색합니다.</summary>
        <returns>지정된 값과 동일한 <c>ID</c> 특성을 갖는 첫 번째 개체를 반환하거나, <paramref name="id" />를 찾을 수 없는 경우 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 있는 경우 여러 개의 요소가 동일한 ID 값을 사용 하 여 문서의 <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> 찾은 첫 번째 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 검색 `TABLE` 문서에서 행의 수를 계산 하 고 웹 페이지에 결과 표시 합니다. 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.WebBrowser> 라는 프로젝트에서 컨트롤 `WebBrowser1`, 웹 페이지를 로드 하 고는 `TABLE` 인 `ID` 특성은 `Table1`합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementFromPoint (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementFromPoint(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementFromPoint(System::Drawing::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">화면에서 요소의 x, y 위치입니다. 이 위치는 문서의 왼쪽 위 모퉁이를 기준으로 합니다.</param>
        <summary>지정한 클라이언트 좌표에 있는 HTML 요소를 검색합니다.</summary>
        <returns>문서에서 지정한 화면 위치에 있는 <see cref="T:System.Windows.Forms.HtmlElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> 문서의 왼쪽 위 모서리는 (0, 0) 값을 할당 하는 데는 클라이언트 좌표를 사용 합니다. 커서의 현재 위치에 대 한 클라이언트 좌표를 사용 하 여 가져올 수 있습니다는 <xref:System.Windows.Forms.HtmlWindow.Position%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 문서에 대 한 클릭 검색 요소를 발견 하 고 사용 <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> 웹 페이지의 맨 위에 해당 요소입니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">검색할 <see cref="T:System.Windows.Forms.HtmlElement" /> 개체의 HTML 태그 이름입니다.</param>
        <summary>지정한 HTML 태그가 있는 요소의 컬렉션을 검색합니다.</summary>
        <returns>태그 이름이 <paramref name="tagName" /> 인수와 동일한 요소의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 HTML 페이지는 종종 사용 된 `META` 태그를 문서에 대 한 임의의 정보를 포함 합니다. 다음 HTML 코드 예제에서는 모든 검색는 `META` HTML 문서 내에서 태그를 찾습니다는 `META` 태그 이름의 `Description`, 사용자에 게 표시 합니다. 이 코드 예제 응용 프로그램에 <xref:System.Windows.Forms.WebBrowser> 라는 컨트롤 `WebBrowser1`합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 개체의 해시 코드를 검색합니다.</summary>
        <returns>이 개체의 메모리 내 해시를 나타내는 <see cref="T:System.Int32" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Images">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Images { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Images" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Images" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Images As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Images { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문서에 있는 모든 이미지 태그의 컬렉션을 가져옵니다.</summary>
        <value>문서의 IMG 태그당 하나씩 있는 <see cref="T:System.Windows.Forms.HtmlElement" /> 개체의 컬렉션입니다. 요소는 컬렉션에서 소스 순서대로 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Images%2A> 컬렉션을 반환 <xref:System.Windows.Forms.HtmlElement> 개체입니다. 같은 특성에 액세스 하려면 `ALT` 및 `SRC`에서 직접 노출 되지 않는 <xref:System.Windows.Forms.HtmlElement>를 사용 하 여는 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> 메서드.  
  
 문서에 새 이미지를 추가 하려면 새 만들거나 `IMG` 문자열로 태그에 할당 하는 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> HTML DOM;에 이전에 추가 하는 요소의 속성 사용 또는 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 메서드를 사용 하 여 해당 속성을 설정 <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>로 추가 하 고는 사용 하 여 기존 요소 자식의 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 검사 하는 `ALT` 문서에서 이미지의 모든 특성 기본값을 설정 하 고 `ALT` 특성 값을 아직 설정 되지 않은 경우.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTML 페이지에 정의된 액티브 스크립트 함수를 실행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 웹 페이지에는 스크립트의 콘텐츠를 실행합니다. 코드 예제에서는 다음 웹 페이지를 로드 한 필요 합니다.  
  
```  
<HTML>  
<SCRIPT>  
function test(name, address) {  
window.alert("Name is " + name + "; address is " + address);  
}  
</SCRIPT>  
  
<BODY>  
</BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">호출할 스크립트 메서드의 이름입니다.</param>
        <summary>HTML 페이지에 정의된 액티브 스크립트 함수를 실행합니다.</summary>
        <returns>액티브 스크립트 호출이 반환하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 되는 개체의 내부 형식 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> 달라 집니다. 호출된 된 액티브 스크립트 함수는 문자열 또는 정수 등의 스칼라 데이터를 반환 하는 경우를 문자열로 반환 됩니다. JScript 또는 VBScript를 사용 하 여 생성 된 개체와 같은 스크립트 기반 개체를 반환 하는 경우 `new` 연산자 됩니다 형식의 `Object`합니다. (호출 하 여 이러한 개체에서 호출을 수행할 수 있습니다 <xref:System.Object.GetType%2A> 를 사용 하 여 및 <xref:System.Type.InvokeMember%2A>.) 와 같은 HTML DOM 요소를 반환 하는 경우는 `DIV` 또는 `TABLE`, 유형 중 하나가 됩니다 `Object`MSHTML에 대 한 프로젝트 참조를 추가한 경우;. 하지만 DLL을 해당 특정 관리 되지 않는 DOM 유형으로 캐스팅할 수 됩니다.  
  
 JScript 및 VBScript를 포함 하는 사용자의 컴퓨터에 설치 된 모든 액티브 스크립팅 언어로 작성 된 함수를 호출할 수 있습니다.  
  
 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> 웹 페이지에 대 한 현재 보안 구성에서 허용 하지 않는 경우 또는 사용자가 명시적으로 Internet Explorer에서 스크립트 실행을 해제 하는 경우에 수행 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 웹 페이지에는 스크립트의 콘텐츠를 실행합니다. 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.WebBrowser> 이라는 응용 프로그램에서는 `WebBrowser1`, 웹 페이지를 로드 했 고 합니다.  
  
```  
<HTML>  
  
    <HEAD>  
        <TITLE>Invoke Script Sample</TITLE>  
  
        <SCRIPT>  
            function MyObject() {  
                this.Data = "Data for my private object.";  
            }  
            // Return a string.  
            function test() {  
                return("This is a test.");  
            }  
            // Return a JScript object.  
            function testJScriptObject() {  
                return(new(MyObject));  
            }  
            // Return a DOM element.  
            function testElement() {  
                return(div1);  
            }  
        </SCRIPT>  
    </HEAD>  
  
    <BODY>  
  
        <DIV id="div1">  
        </DIV>  
  
    </BODY>  
  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="scriptName">호출할 스크립트 메서드의 이름입니다.</param>
        <param name="args">스크립트 메서드에 전달할 인수입니다.</param>
        <summary>HTML 페이지에 정의된 액티브 스크립트 함수를 실행합니다.</summary>
        <returns>액티브 스크립트 호출이 반환하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 되는 개체의 내부 형식 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> 달라 집니다. 호출된 된 액티브 스크립트 함수는 문자열 또는 정수 등의 스칼라 데이터를 반환 하는 경우를 문자열로 반환 됩니다. JScript 또는 VBScript를 사용 하 여 생성 된 개체와 같은 스크립트 기반 개체를 반환 하는 경우 `new` 연산자 됩니다 형식의 `Object`합니다. (호출 하 여 이러한 개체에서 호출을 수행할 수 있습니다 <xref:System.Object.GetType%2A> 를 사용 하 여 및 <xref:System.Type.InvokeMember%2A>.) 와 같은 HTML DOM 요소를 반환 하는 경우는 `DIV` 또는 `TABLE`, 유형 중 하나가 됩니다 `Object`MSHTML에 대 한 프로젝트 참조를 추가한 경우;. 하지만 DLL을 해당 특정 관리 되지 않는 DOM 유형으로 캐스팅할 수 됩니다.  
  
 JScript 및 VBScript를 포함 하 여 사용자의 컴퓨터에 설치 된 모든 액티브 스크립팅 언어로 작성 된 함수를 호출할 수 있습니다.  
  
 사용자가 명시적으로 Internet Explorer에서 스크립트 실행을 해제 하는 경우에 아무것도 표시 되지 않음 또는 웹 페이지에 대 한 현재 보안 구성에서 허용 하지 않는 경우이 메서드는 아무 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 웹 페이지에는 스크립트의 콘텐츠를 실행합니다. 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.WebBrowser> 이라는 응용 프로그램에서는 `WebBrowser1`, 웹 페이지를 로드 했 고 합니다.  
  
```  
<HTML>  
    <SCRIPT>  
        function test(name, address) {  
            window.alert("Name is " + name + "; address is " + address);  
        }  
    </SCRIPT>  
  
    <BODY>  
    </BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>하이퍼링크의 색을 가져오거나 설정합니다.</summary>
        <value>현재 문서의 하이퍼링크 색입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> 에 입력 된 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 지원는 `Alpha` 값과 동일 하지만 HTML DOM는 그렇지 않습니다. 따라서 `Alpha` 이 속성에 할당 하는 경우 영향을 미치지 것입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Links">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Links { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Links" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Links" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Links As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Links { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 HTML 문서 내의 모든 하이퍼링크 목록을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> 개체의 <see cref="T:System.Windows.Forms.HtmlElement" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 컬렉션에서 사용 하 여 만든 모든 링크를 포함 됩니다는 `A`, `LINK`, 및 `AREA` html에서 태그입니다.  
  
 <xref:System.Windows.Forms.HtmlElement> 이 컬렉션에 포함 된 개체는 관리 되지 않는 캡슐화 `IHTMLLinkElement` 인터페이스입니다. 기본 인터페이스의 속성을 안전 하 게 액세스 하려면 사용 된 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>포커스가 컨트롤을 벗어나는 동안 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.HtmlDocument.LosingFocus> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.HtmlDocument> 라는 `HtmlDocument1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.HtmlDocument.LosingFocus> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#425](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#425)]
 [!code-vb[System.Windows.Forms.EventExamples#425](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#425)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 왼쪽 마우스 단추를 클릭하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.MouseDown> 이벤트가 발생 하기 전에 <xref:System.Windows.Forms.HtmlDocument.Click> 이벤트입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.HtmlDocument.MouseDown> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.HtmlDocument> 라는 `HtmlDocument1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.HtmlDocument.MouseDown> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#426](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#426)]
 [!code-vb[System.Windows.Forms.EventExamples#426](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#426)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스가 문서를 더 이상 가리키지 않을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.HtmlDocument.MouseLeave> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.HtmlDocument> 라는 `HtmlDocument1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.HtmlDocument.MouseLeave> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#427](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#427)]
 [!code-vb[System.Windows.Forms.EventExamples#427](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#427)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스를 문서 위로 이동하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.HtmlDocument.MouseMove> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.HtmlDocument> 라는 `HtmlDocument1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.HtmlDocument.MouseMove> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#428](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#428)]
 [!code-vb[System.Windows.Forms.EventExamples#428](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#428)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스를 문서 위로 이동하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.HtmlDocument.MouseOver> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.HtmlDocument> 라는 `HtmlDocument1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.HtmlDocument.MouseOver> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#429](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#429)]
 [!code-vb[System.Windows.Forms.EventExamples#429](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#429)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 왼쪽 마우스 단추를 놓으면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.HtmlDocument.MouseUp> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.HtmlDocument> 라는 `HtmlDocument1`합니다. 그런 다음 이벤트 처리기가 연결을 확인는 <xref:System.Windows.Forms.HtmlDocument.MouseUp> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#430](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#430)]
 [!code-vb[System.Windows.Forms.EventExamples#430](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#430)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Equality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 인스턴스입니다.</param>
        <param name="right">비교할 두 번째 인스턴스입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.Forms.HtmlDocument" /> 인스턴스가 같은 값을 표시하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          지정된 인스턴스가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[이 연산자는 해당 하는 방법은 <xref:System.Windows.Forms.HtmlDocument.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Inequality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 인스턴스입니다.</param>
        <param name="right">비교할 두 번째 인스턴스입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.Forms.HtmlDocument" /> 인스턴스가 같은 값을 표시하지 않는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          지정된 인스턴스가 같지 않으면 <see langword="true" />이고, 같으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument OpenNew (bool replaceInHistory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlDocument OpenNew(bool replaceInHistory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (replaceInHistory As Boolean) As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlDocument ^ OpenNew(bool replaceInHistory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replaceInHistory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="replaceInHistory">새 창을 탐색하면 DOM 탐색 기록의 이전 요소가 바뀌는지 여부입니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.HtmlDocument" /> 메서드와 함께 사용할 새 <see cref="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />를 가져옵니다.</summary>
        <returns>작성할 새 문서입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> 변수와 같은 연결 된 모든 상태를 포함 하 여 로드 된 이전 문서를 지웁니다. 탐색 이벤트를 발생 하지 것입니다 <xref:System.Windows.Forms.WebBrowser> 발생 합니다.  
  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> 항상 현재 창에 새 문서를 만듭니다. 사용 하 여 새 창에서 문서를 열려고는 <xref:System.Windows.Forms.HtmlWindow.Open%2A> 에서 메서드는 <xref:System.Windows.Forms.HtmlWindow> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 DOM 작성을 준비 하 고 사용 하 여 새 문서를 씁니다는 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 메서드.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 문서의 텍스트 방향을 가져오거나 설정합니다.</summary>
        <value>
          텍스트가 오른쪽에서 왼쪽으로 렌더링되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> HTML 또는 코드에서 명시적으로 설정 하지 않은 경우 모든 값을 됩니다.  
  
 와 달리는 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> Windows Forms 컨트롤에서 속성 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> 관리 되는 HTML DOM에서 영향을 주지 것입니다 영어 텍스트의 방향입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Stop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Stop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Stop As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Stop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>다른 웹 페이지에 대한 탐색이 중단되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 페이지를 로드 하는 프로그램 코드를 호출 하는 경우 중지 됩니다는 <xref:System.Windows.Forms.WebBrowser.Stop%2A> 의 메서드는 <xref:System.Windows.Forms.WebBrowser> 제어 합니다. 네트워크 중단 또는 웹 사이트 오작동으로 인해 발생 한 탐색 오류를 일으키지 것입니다 <xref:System.Windows.Forms.HtmlDocument.Stop> 발생 하도록 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Windows Forms 응용 프로그램에서 상태 표시줄을 다시 설정 때는 `Stop` 이벤트가 발생 합니다. 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.StatusBar> 라는 컨트롤 `StatusBar1` 응용 프로그램에서 합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTML 문서의 <c>&lt;TITLE&gt;</c> 태그의 텍스트 값을 가져오거나 설정합니다.</summary>
        <value>현재 문서의 제목입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Forms.HtmlDocument.Title%2A> 속성을 이해 하기 쉬운 이름으로 문서를 식별 합니다.  
  
 이 속성에 대 한 변경에도 반영 됩니다는 <xref:System.Windows.Forms.WebBrowser.DocumentTitle%2A> 의 속성은 <xref:System.Windows.Forms.WebBrowser> 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 문서의 URL 링크 위치 하 고 사용 하는 문서의 제목 링크 텍스트로 현재 문서에 대 한 HTML 하이퍼링크를 만듭니다. 이 코드 예제 응용 프로그램에 <xref:System.Windows.Forms.WebBrowser> 라는 컨트롤 `WebBrowser1`합니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#14)]
 [!code-vb[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.WebBrowser.DocumentTitle" />
        <altmember cref="T:System.Windows.Forms.WebBrowser" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서의 위치를 설명하는 URL을 가져옵니다.</summary>
        <value>이 문서의 URL을 나타내는 <see cref="T:System.Uri" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 읽기 전용입니다. 사용 하 여 새 문서를 탐색 하려면는 <xref:System.Windows.Forms.WebBrowser.Url%2A> 속성에는 <xref:System.Windows.Forms.WebBrowser> 제어 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitedLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color VisitedLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color VisitedLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property VisitedLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color VisitedLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 이미 방문한 HTML 페이지의 링크 색을 가져오거나 설정합니다.</summary>
        <value>방문한 링크의 색입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Color` 에 입력 된 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 지원는 `Alpha` 값과 동일 하지만 HTML DOM는 그렇지 않습니다. 따라서 `Alpha` 이 속성에 할당 하는 경우 영향을 미치지 것입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Window" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Window" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Window As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Window { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서와 연결된 <see cref="T:System.Windows.Forms.HtmlWindow" />를 가져옵니다.</summary>
        <value>이 문서의 창입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 HTML 문서와 같은 다른 중요 한 개체에 액세스할 뿐만 아니라 문서의 화면 크기를 조작 하 고 새 창을 열에 사용할 수, 하는 창에 호출 하는 HTML DOM 개체를 포함할는 <xref:System.Windows.Forms.HtmlHistory>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">문서에 쓸 HTML 텍스트입니다.</param>
        <summary>새 HTML 페이지를 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 모든 호출 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 를 호출 하 여 붙여야 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A>, 현재 문서와 모든 변수는 지워집니다. 에 대 한 호출 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 그 자리에 새 HTML 문서를 만듭니다. 특정 문서 일부만 변경 하려면 적절 한 가져올 <xref:System.Windows.Forms.HtmlElement> 설정 하 고 해당 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 속성.  
  
 전체 유효한 HTML 문서를 사용 하 여 작성 하는 것이 좋습니다.는 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 메서드를 포함 하 여 `HTML` 및 `BODY` 태그입니다. 그러나 간단히 HTML 요소를 작성 하는 경우 (DOM (문서 개체 모델)는 사용자에 대 한 이러한 요소를 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 새 엽니다 <xref:System.Windows.Forms.HtmlDocument> 새 HTML 파일에 씁니다.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>