<Type Name="Control" FullName="System.Windows.Forms.Control">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f165afa77e5133f21dc1457c8775b30a3be3018" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061835" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>시각적으로 표시되는 구성 요소인 컨트롤의 기본 클래스를 정의합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 정의 컨트롤 클래스를 만들려면에서 상속 된 <xref:System.Windows.Forms.UserControl>, <xref:System.Windows.Forms.Control> 클래스 또는 다른 Windows Forms에서 컨트롤을 제공 합니다. 사용자 지정 컨트롤 제작 하는 방법에 대 한 자세한 내용은 참조 [.NET Framework와 함께 사용자 지정 Windows Forms 컨트롤 개발](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md)합니다.  
  
 <xref:System.Windows.Forms.Control> 사용자에 게 정보를 표시 하는 클래스에서 필요한 매우 기본적인 기능을 구현 하는 클래스입니다. 키보드 및 포인팅 장치를 통해 사용자 입력을 처리합니다. 메시지 라우팅 및 보안을 처리합니다. 그리기를 구현 하지는 않지만 (해당 위치 및 크기), 컨트롤의 범위를 정의 합니다. 창 핸들을 제공 (`hWnd`).  
  
 Windows Forms 컨트롤 주변 환경 처럼 자식 컨트롤이 표시 되어 있으므로 앰비언트 속성을 사용 합니다. *앰비언트 속성* 은 그렇지 않은 경우, 즉 컨트롤 속성 설정, 부모 컨트롤에서 검색 됩니다. 컨트롤에 없는 경우는 <xref:System.Windows.Forms.Control.Parent%2A>, 및에서 속성이 설정 되지 않은 경우 해당 컨트롤 통해 앰비언트 속성의 값을 확인 하는 <xref:System.Windows.Forms.Control.Site%2A> 속성입니다. 컨트롤은 사이트에 없거나, 사이트 앰비언트 속성을 지원 하지 않는 경우 또는 속성에 설정 되어 있지 않으면는 <xref:System.Windows.Forms.AmbientProperties>, 컨트롤 자체 기본값을 사용 합니다. 일반적으로 앰비언트 속성은 컨트롤의와 같은 <xref:System.Windows.Forms.Control.BackColor%2A>, 즉 자식 컨트롤에 전달 합니다. 예를 들어 한 <xref:System.Windows.Forms.Button> 같은 가질 수 <xref:System.Windows.Forms.Control.BackColor%2A> 부모로 <xref:System.Windows.Forms.Form> 기본적으로 합니다. 앰비언트 속성에서 제공 되는 <xref:System.Windows.Forms.Control> 클래스에 포함: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.ForeColor%2A>, 및 <xref:System.Windows.Forms.Control.RightToLeft%2A>합니다.  
  
> [!NOTE]
>  비주얼 스타일을 지원 하 여 Windows Forms 응용 프로그램을 하려면 설정 해야는 <xref:System.Windows.Forms.FlatStyle> 속성을 `System` 실행 파일을 사용 하 여 매니페스트를 포함 합니다. 매니페스트는 응용 프로그램 실행 파일 내에서 리소스 사용 또는 실행 파일과 동일한 디렉터리에 있는 별도 파일로 포함 되어 있는 XML 파일입니다. 예로 매니페스트의 예 섹션을 참조 하십시오.는 <xref:System.Windows.Forms.FlatStyle> 열거형입니다. 비주얼 스타일을 사용 하는 방법에 대 한 자세한 내용은 참조 [비주얼 스타일](http://msdn.microsoft.com/library/windows/desktop/bb773187.aspx)합니다.  
  
 Windows Forms 내게 필요한 옵션 지원 기본 제공 되 고 있으며 화면 확대기 및 검토자 유틸리티와 같은 접근성 클라이언트 응용 프로그램 작업, 음성 입력된 유틸리티 화상 키보드를 사용 하면 응용 프로그램에 대 한 정보를 제공 합니다. 대체 입력된 장치 및 키보드 향상 유틸리티입니다. 추가 정보를 접근성 클라이언트 응용 프로그램을 제공할 수도 있습니다. 이 추가 정보를 제공 하는 방법은 두 가지가 있습니다. 설정할 수 있습니다는 <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>, 및 <xref:System.Windows.Forms.Control.AccessibleRole%2A> 접근성 클라이언트 응용 프로그램에 보고 되는 속성 값입니다. 이 메서드는 기존 컨트롤에 대 한 제한 된 내게 필요한 옵션 정보를 제공 하려면 일반적으로 사용 됩니다. 또는에서 파생 되는 고유한 클래스를 작성할 수는 <xref:System.Windows.Forms.AccessibleObject> 또는 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 클래스, 필요에 따라 많은 내게 필요한 옵션 정보를 제공 합니다.  
  
> [!NOTE]
>  더 나은 성능을 유지 하기 위해 해당 생성자에는 컨트롤의 크기를 설정 하지 마십시오. 재정의 하는 메서드가 좋습니다는 <xref:System.Windows.Forms.Control.DefaultSize%2A> 속성입니다.  
  
> [!NOTE]
>  에 대 한 데이터 바인딩을 추가 하지 마십시오는 <xref:System.Windows.Forms.Control> 생성자에서입니다. 이렇게 하면 코드 생성에서 오류가 발생 하 고 원하지 않는 동작이 발생할 수 있습니다.  
  
 대부분의 컨트롤의는 <xref:System.Windows.Forms> 네임 스페이스를 구축 하는 기반으로 기본 Windows 공용 컨트롤을 사용 합니다. Windows 공용 컨트롤에 대 한 자세한 내용은 참조 [일반 컨트롤 참조](http://msdn.microsoft.com/library/windows/desktop/bb775497.aspx)합니다.  
  
 별도 프로세스에서 Windows Forms 컨트롤을 식별 하려면 사용 하는 표준 `SendMessage` WM_GETCONTROLNAME 메시지를 전달 하도록 호출 합니다. WM_GETCONTROLNAME는 별개의 언어와 Windows 계층 구조입니다. 자세한 내용은 "Windows Forms에 대 한 권장 솔루션" 항목을 참조[Windows Forms 자동화](http://msdn.microsoft.com/library/ms996405.aspx)합니다.  
  
 사용 하 여 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 여러 스레드에서 컨트롤에 대 한 액세스를 동기화 하는 속성입니다. 다중 스레드 Windows Forms 컨트롤에 대 한 자세한 내용은 참조 하십시오. [하는 방법: Windows Forms 컨트롤에 스레드로부터 안전한 호출 수행](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>다음 멤버는 스레드로부터 안전 하 게 보호에: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />, <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />, <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" />, 및 <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다.</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.Control" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.Control" /> 클래스의 새 인스턴스를 기본 설정으로 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> 클래스는 Windows Forms 응용 프로그램에서 사용 되는 모든 컨트롤에 대 한 기본 클래스입니다. 이 클래스는 클래스의 인스턴스를 만들려면 일반적으로 사용 되지 않으므로이 생성자는 일반적으로 직접 호출 되지 하지만 않고 파생된 클래스에 의해 호출 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">컨트롤에 의해 표시된 텍스트입니다.</param>
        <summary>지정된 텍스트를 사용하여 <see cref="T:System.Windows.Forms.Control" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> 클래스는 Windows Forms 응용 프로그램에서 사용 되는 모든 컨트롤에 대 한 기본 클래스입니다. 이 클래스는 클래스의 인스턴스를 만들려면 일반적으로 사용 되지 않으므로이 생성자는 일반적으로 직접 호출 되지 하지만 않고 파생된 클래스에 의해 호출 됩니다.  
  
 이 버전의는 <xref:System.Windows.Forms.Control.%23ctor%2A> 생성자 초기 설정 <xref:System.Windows.Forms.Control.Text%2A> 속성 값을는 `text` 매개 변수 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">컨트롤의 부모가 될 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <param name="text">컨트롤에 의해 표시된 텍스트입니다.</param>
        <summary>지정된 텍스트를 사용하여 <see cref="T:System.Windows.Forms.Control" /> 클래스의 새 인스턴스를 자식 컨트롤로 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> 클래스는 Windows Forms 응용 프로그램에서 사용 되는 모든 컨트롤에 대 한 기본 클래스입니다. 이 클래스는 클래스의 인스턴스를 만들려면 일반적으로 사용 되지 않으므로이 생성자는 일반적으로 직접 호출 되지 하지만 않고 파생된 클래스에 의해 호출 됩니다.  
  
 이 버전의는 <xref:System.Windows.Forms.Control.%23ctor%2A> 생성자 초기 설정 <xref:System.Windows.Forms.Control.Text%2A> 속성 값을는 `text` 매개 변수 값입니다. 또한 생성자는 부모 컨트롤에 컨트롤을 추가 <xref:System.Windows.Forms.Control.ControlCollection>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">컨트롤에 의해 표시된 텍스트입니다.</param>
        <param name="left">컨트롤 컨테이너의 왼쪽 가장자리로부터 시작하여 픽셀 단위로 나타낸 컨트롤의 <see cref="P:System.Drawing.Point.X" /> 위치입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Left" /> 속성에 할당됩니다.</param>
        <param name="top">컨트롤 컨테이너의 위쪽 가장자리로부터 시작하여 픽셀 단위로 나타낸 컨트롤의 <see cref="P:System.Drawing.Point.Y" /> 위치입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Top" /> 속성에 할당됩니다.</param>
        <param name="width">컨트롤의 너비(픽셀)입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Width" /> 속성에 할당됩니다.</param>
        <param name="height">컨트롤의 높이(픽셀)입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Height" /> 속성에 할당됩니다.</param>
        <summary>지정된 텍스트, 크기 및 위치를 사용하여 <see cref="T:System.Windows.Forms.Control" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> 클래스는 Windows Forms 응용 프로그램에서 사용 되는 모든 컨트롤에 대 한 기본 클래스입니다. 이 클래스는 클래스의 인스턴스를 만들려면 일반적으로 사용 되지 않으므로이 생성자는 일반적으로 직접 호출 되지 하지만 않고 파생된 클래스에 의해 호출 됩니다.  
  
 이 버전의는 <xref:System.Windows.Forms.Control.%23ctor%2A> 생성자 초기 설정 <xref:System.Windows.Forms.Control.Text%2A> 속성 값을는 `text` 매개 변수 값입니다. 초기 <xref:System.Windows.Forms.Control.Size%2A> 및 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤에 따라 결정 되는 `left`, `top`, `width` 및 `height` 매개 변수 값입니다.  
  
> [!NOTE]
>  더 나은 성능을 유지 하기 위해 해당 생성자에는 컨트롤의 크기를 설정 하지 마십시오. 재정의 하는 메서드가 좋습니다는 <xref:System.Windows.Forms.Control.DefaultSize%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">컨트롤의 부모가 될 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <param name="text">컨트롤에 의해 표시된 텍스트입니다.</param>
        <param name="left">컨트롤 컨테이너의 왼쪽 가장자리로부터 시작하여 픽셀 단위로 나타낸 컨트롤의 <see cref="P:System.Drawing.Point.X" /> 위치입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Left" /> 속성에 할당됩니다.</param>
        <param name="top">컨트롤 컨테이너의 위쪽 가장자리로부터 시작하여 픽셀 단위로 나타낸 컨트롤의 <see cref="P:System.Drawing.Point.Y" /> 위치입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Top" /> 속성에 할당됩니다.</param>
        <param name="width">컨트롤의 너비(픽셀)입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Width" /> 속성에 할당됩니다.</param>
        <param name="height">컨트롤의 높이(픽셀)입니다. 이 값은 <see cref="P:System.Windows.Forms.Control.Height" /> 속성에 할당됩니다.</param>
        <summary>지정된 텍스트, 크기 및 위치를 사용하여 <see cref="T:System.Windows.Forms.Control" /> 클래스의 새 인스턴스를 자식 컨트롤로 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> 클래스는 Windows Forms 응용 프로그램에서 사용 되는 모든 컨트롤에 대 한 기본 클래스입니다. 이 클래스는 클래스의 인스턴스를 만들려면 일반적으로 사용 되지 않으므로이 생성자는 일반적으로 직접 호출 되지 하지만 않고 파생된 클래스에 의해 호출 됩니다.  
  
 이 버전의는 <xref:System.Windows.Forms.Control.%23ctor%2A> 생성자 초기 설정 <xref:System.Windows.Forms.Control.Text%2A> 속성 값을는 `text` 매개 변수 값입니다. 또한 생성자는 부모 컨트롤에 컨트롤을 추가 <xref:System.Windows.Forms.Control.ControlCollection>합니다. 초기 <xref:System.Windows.Forms.Control.Size%2A> 및 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤에 따라 결정 되는 `left`, `top`, `width` 및 `height` 매개 변수 값입니다.  
  
> [!NOTE]
>  더 나은 성능을 유지 하기 위해 해당 생성자에는 컨트롤의 크기를 설정 하지 마십시오. 재정의 하는 메서드가 좋습니다는 <xref:System.Windows.Forms.Control.DefaultSize%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>내게 필요한 옵션 지원 클라이언트 응용 프로그램에 <see cref="T:System.Windows.Forms.AccessibleEvents" />를 알립니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">내게 필요한 옵션 지원 클라이언트 응용 프로그램에 알릴 <see cref="T:System.Windows.Forms.AccessibleEvents" />입니다.</param>
        <param name="childID">액세스할 수 있는 이벤트를 알릴 자식 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <summary>지정된 자식 컨트롤에 대해 지정된 <see cref="T:System.Windows.Forms.AccessibleEvents" />를 내게 필요한 옵션 지원 클라이언트 응용 프로그램에 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 해야 합니다는 <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType> 메서드 각각에 대해 <xref:System.Windows.Forms.AccessibleEvents> 접근성 클라이언트 응용 프로그램의 알림을 받을 수는 있습니다. <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> 일반적으로 메서드는 속성을 설정 하거나 내에서 이벤트 처리기입니다. 예를 들어, 호출할 수 있습니다는 <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> 메서드와 전달은 <xref:System.Windows.Forms.AccessibleEvents> 값 `Hide` 에서 대 한 이벤트 처리기 내에서 <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 내게 필요한 옵션 인식 차트를 만드는 방법을 보여 줍니다. 컨트롤을 사용 하는 <xref:System.Windows.Forms.AccessibleObject> 및 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 클래스 액세스할 수 있는 정보를 표시 합니다. 컨트롤은 범례를 따라 두 곡선을 그립니다. `ChartControlAccessibleObject` 클래스에서 파생 되 `ControlAccessibleObject`에 사용 되는 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 메서드는 차트 컨트롤에 대 한 사용자 지정 액세스할 수 있는 정보를 제공 합니다. 차트 범례는 실제 <xref:System.Windows.Forms.Control> -컨트롤을 따르지만 그려지며 차트 컨트롤에서 액세스할 수 있는 기본 제공 정보를 포함 하지 않습니다. 이 인해는 `ChartControlAccessibleObject` 재정의 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 반환 하는 메서드는 `CurveLegendAccessibleObject` 범례의 각 부분에 액세스할 수 있는 정보를 나타내는입니다. 액세스할 수 있는 인식 응용 프로그램이이 제어를 사용 하는 경우 컨트롤은 필요한 액세스 가능 정보를 제공할 수 있습니다.  
  
 코드 발췌 한이 호출을 보여 줍니다.는 <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A> 메서드. 참조는 <xref:System.Windows.Forms.AccessibleObject> 전체 코드 예제에 대 한 클래스 개요입니다.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="objectID" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">내게 필요한 옵션 지원 클라이언트 응용 프로그램에 알릴 <see cref="T:System.Windows.Forms.AccessibleEvents" />입니다.</param>
        <param name="objectID">
          <see cref="T:System.Windows.Forms.AccessibleObject" />의 식별자입니다.</param>
        <param name="childID">액세스할 수 있는 이벤트를 알릴 자식 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <summary>지정된 자식 컨트롤에 대해 지정된 <see cref="T:System.Windows.Forms.AccessibleEvents" />를 내게 필요한 옵션 지원 클라이언트 응용 프로그램에 알립니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 할당된 <see cref="T:System.Windows.Forms.AccessibleObject" />를 가져옵니다.</summary>
        <value>컨트롤에 할당된 <see cref="T:System.Windows.Forms.AccessibleObject" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 되는 인스턴스를 제어 하려면 재정의 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 메서드.  
  
 현재 컨트롤에 할당된 <xref:System.Windows.Forms.AccessibleObject> 클래스가 없으면 이 클래스의 새 인스턴스가 만들어집니다.  
  
> [!NOTE]
>  가져오거나 설정할는 <xref:System.Windows.Forms.Control.AccessibilityObject%2A> 속성에 대 한 참조를 추가 해야는 `Accessibility` 어셈블리와 함께 설치는[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]합니다.  
  
 액세스 가능한 개체에 대 한 자세한 내용은 참조 [Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592.aspx)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>내게 필요한 옵션 지원 클라이언트 응용 프로그램에서 사용되는 컨트롤의 기본 작업 설명을 가져오거나 설정합니다.</summary>
        <value>내게 필요한 옵션 지원 클라이언트 응용 프로그램에서 사용할 컨트롤의 기본 동작 설명입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개체의 <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> 속성 개체의 기본 사용자의 관점에서 조작 방법에 설명 합니다. 이 속성에 동사 또는 짧은 동사 구 이어야 합니다.  
  
> [!NOTE]
>  일부 개체는 기본 동작 및 일부 개체에 관련 된 기본 작업이 있는 것은 <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType> 다음 예제와 같이 속성:  
  
-   선택 된 확인란 "취소"의 기본 동작에는 "선택 됩니다."의 값  
  
-   선택 취소 된 확인란에 "확인"의 기본 동작 및 값이 "옵션"을 해제 합니다.  
  
-   "인쇄" 레이블이 붙은 단추 기본 동작이 "Press"의 값이 없는 합니다.  
  
-   레이블 또는 "Printer"를 표시 하는 텍스트 상자 컨트롤에 기본 작업이 없는 "Printer"의 값  
  
 액세스 가능한 개체의 속성에 대 한 자세한 내용은 참조 [설명이 포함 된 속성의 콘텐츠](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>내게 필요한 옵션 지원 클라이언트 응용 프로그램에서 사용하는 컨트롤의 설명을 가져오거나 설정합니다.</summary>
        <value>내게 필요한 옵션 지원 클라이언트 응용 프로그램에서 사용하는 컨트롤의 설명입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개체의 <xref:System.Windows.Forms.Control.AccessibleDescription%2A> 속성은 개체의 시각적 모양에 대 한 텍스트 설명을 제공 합니다. 설명은 이해를 돕기 위해 시각 장애인을 위해 주로 사용 하지만 컨텍스트 검색 이나 다른 응용 프로그램에 사용할 수도 있습니다.  
  
 <xref:System.Windows.Forms.Control.AccessibleDescription%2A> 속성 설명이 드러나지 않습니다. 경우에 필요 하거나 중복 되는 경우 개체의 기반 <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleRole%2A>, <xref:System.Windows.Forms.AccessibleObject.State%2A>, 및 <xref:System.Windows.Forms.AccessibleObject.Value%2A> 속성입니다. 예를 들어, "확인" 단추에는 추가 정보를 사용 해야 합니다. 하지만 선인장 그림이 표시 된 단추입니다. <xref:System.Windows.Forms.Control.AccessibleName%2A>, 및 <xref:System.Windows.Forms.Control.AccessibleRole%2A> (용도나 <xref:System.Windows.Forms.AccessibleObject.Help%2A>) 선인장 단추에 대 한 속성의 용도 설명 하지만 <xref:System.Windows.Forms.Control.AccessibleDescription%2A> 속성 "선인장 그림이 표시 된 단추입니다."와 같은 명백 하지 않은 정보를 전달 합니다  
  
 액세스 가능한 개체의 속성에 대 한 자세한 내용은 참조 [설명이 포함 된 속성의 콘텐츠](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 인스턴스를 만듭니다는 <xref:System.Windows.Forms.CheckBox> 파생 클래스를 `MyCheckBox`, 할당 한 <xref:System.Drawing.Image> 를 해당 <xref:System.Windows.Forms.ButtonBase.Image%2A> 속성을 설정은 <xref:System.Windows.Forms.Control.AccessibleName%2A> 및 <xref:System.Windows.Forms.Control.AccessibleDescription%2A> 속성 때문에 <xref:System.Windows.Forms.Control.Text%2A> 속성은 `null`합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 라는 `MyForm`합니다.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>내게 필요한 옵션 지원 클라이언트 응용 프로그램에서 사용하는 컨트롤의 이름을 가져오거나 설정합니다.</summary>
        <value>내게 필요한 옵션 지원 클라이언트 응용 프로그램에서 사용하는 컨트롤의 이름입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleName%2A> 속성은 간략하게 설명 하 고 텍스트와 같은 해당 컨테이너 내에서 개체를 식별 하는 레이블을 <xref:System.Windows.Forms.Button>, 이름는 <xref:System.Windows.Forms.MenuItem>, 또는 옆에 표시 되는 레이블을 <xref:System.Windows.Forms.TextBox> 제어 합니다.  
  
 액세스 가능한 개체의 속성에 대 한 자세한 내용은 참조는 "[설명이 포함 된 속성의 콘텐츠](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 인스턴스를 만듭니다는 <xref:System.Windows.Forms.CheckBox> 파생 클래스를 `MyCheckBox`, 할당 된 <xref:System.Drawing.Image> 를 해당 <xref:System.Windows.Forms.ButtonBase.Image%2A> 속성을 설정은 <xref:System.Windows.Forms.Control.AccessibleName%2A> 및 <xref:System.Windows.Forms.Control.AccessibleDescription%2A> 이후 속성은 <xref:System.Windows.Forms.Control.Text%2A> 속성 `null`합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 라는 `MyForm`합니다.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 액세스 가능 역할을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.AccessibleRole" />의 다음 값 중 하나입니다. 기본값은 <see langword="Default" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleRole%2A> 속성은 개체가 어떤 사용자 인터페이스 요소 종류인지 설명합니다. 컨트롤의 역할을 확인할 수 없으면 <xref:System.Windows.Forms.Control.AccessibleRole%2A> 속성은 `Default`로 설정됩니다.  
  
 액세스 가능한 개체의 속성에 대 한 자세한 내용은 참조 [설명이 포함 된 속성의 콘텐츠](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">할당된 값이 <see cref="T:System.Windows.Forms.AccessibleRole" /> 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 컨트롤로 끌어 온 데이터가 해당 컨트롤에서 허용되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤에서 끌어서 놓기 작업을 수행할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 사용자 이미지 또는 이미지 파일을 폼으로 끌어 지점에 표시 되도록가를 놓이고는 다음 코드 예제에서는 합니다. <xref:System.Windows.Forms.Control.OnPaint%2A> 메서드는 폼을 그릴 될 때마다 이미지를 다시 그리기 위해 재정의 됩니다; 그렇지 않은 경우 이미지는 다음에 다시 그릴 때까지 유지만 합니다. <xref:System.Windows.Forms.Control.DragEnter> 이벤트 처리 메서드는 형식으로 끌고 있는 데이터의 형식을 결정 하 고 적절 한 피드백을 제공 합니다. <xref:System.Windows.Forms.Control.DragDrop> 경우 이벤트 처리 메서드는 폼에 이미지를 표시 한 <xref:System.Drawing.Image> 데이터에서 만들 수 있습니다. 때문에 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> 값은 화면 좌표를 사용 하 여는 <xref:System.Windows.Forms.Control.PointToClient%2A> 메서드를 클라이언트 좌표로 변환 합니다.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정에 대 한 무제한 클립보드 액세스에 대 한 <see langword="true" />합니다. 연관 된 열거형:는 <see langword="AllClipboard" /> 의 값 <see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.AllowDrop" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.AllowDrop" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.AllowDrop" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 바인딩되는 컨테이너의 가장자리를 가져오거나 설정하고 해당 부모를 기초로 컨트롤 크기를 조정하는 방법을 결정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.AnchorStyles" /> 값의 비트 조합입니다. 기본값은 <see langword="Top" /> 및 <see langword="Left" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Windows.Forms.Control.Anchor%2A> 컨트롤은 자동으로 조정 방법을 부모 컨트롤 크기 조정 되는지를 정의 하는 속성입니다. 부모 컨트롤에 컨트롤을 고정 부모 컨트롤 크기를 조정할 때 부모 컨트롤의 가장자리를 기준으로 같은 위치에 고정된 된 가장자리 남아 있는지 확인 합니다.  
  
 해당 컨테이너의 가장자리를 하나 이상의 컨트롤을 고정할 수 있습니다. 예를 들어 한 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.Button> 인 <xref:System.Windows.Forms.Control.Anchor%2A> 속성 값으로 설정 됩니다 `Top` 및 `Bottom`, <xref:System.Windows.Forms.Button> 는 의위쪽및아래쪽가장자리에고정된거리를유지하기위해<xref:System.Windows.Forms.Form>로 <xref:System.Windows.Forms.Control.Height%2A> 의 <xref:System.Windows.Forms.Form> 증가 합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A> 및 <xref:System.Windows.Forms.Control.Dock%2A> 속성은 함께 사용할 수 없습니다. 한 번에 하나만 설정할 수 있습니다 및 우선적으로 마지막으로 설정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추가 <xref:System.Windows.Forms.Button> 폼에 일반적인 속성 중 일부를 설정 합니다. 이 예제에서는 폼 크기가 조정 될 때의 상대 위치를 유지할 수 있도록 폼의 오른쪽 아래 모서리에 있는 단추를 고정 합니다. 그런 다음 설정의 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 단추와 같은 크기를 조정 하 고는 <xref:System.Drawing.Image>합니다. 설정한 후의 <xref:System.Windows.Forms.Control.TabStop%2A> 를 `true` 설정 하 고는 <xref:System.Windows.Forms.Control.TabIndex%2A> 속성입니다. 마지막으로 처리 하는 이벤트 처리기 추가 <xref:System.Windows.Forms.Control.Click> 단추의 이벤트가 있습니다. 이 예제를 실행 하려면 프로그램 <xref:System.Windows.Forms.ImageList> 라는 `imageList1`합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.Anchor" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.Anchor" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.Anchor" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" />에서 이 컨트롤이 스크롤되는 위치를 가져오거나 설정합니다.</summary>
        <value>스크롤 위치를 지정하는 <see cref="T:System.Drawing.Point" />입니다. 기본값은 컨트롤의 왼쪽 위 모퉁이입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>
          사용하도록 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 이벤트는 이 클래스와 관련이 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 배경색을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 배경색을 나타내는 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 속성 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.BackColor%2A> 속성 하지 않는 한 투명 한 색을 지원 하지 않습니다는 `SupportsTransparentBackColor` 값 <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> 로 설정 된 `true`합니다.  
  
 <xref:System.Windows.Forms.Control.BackColor%2A> 속성이 앰비언트 속성입니다. 그렇지 않은 경우, 즉 앰비언트 속성은 컨트롤 속성 설정, 부모 컨트롤에서 검색 됩니다. 예를 들어 한 <xref:System.Windows.Forms.Button> 같은 가질 수 <xref:System.Windows.Forms.Control.BackColor%2A> 부모로 <xref:System.Windows.Forms.Form> 기본적으로 합니다. 앰비언트 속성에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.AmbientProperties> 클래스 또는 <xref:System.Windows.Forms.Control> 클래스 개요입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.BackColor%2A> 및 <xref:System.Windows.Forms.Control.ForeColor%2A> 컨트롤을 기본 시스템 색상입니다. 코드 재귀적으로 컨트롤에 자식 컨트롤이 경우 자신을 호출 합니다. 이 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하나 이상의 자식 컨트롤과; 그러나 자식 컨테이너 컨트롤, like는 <xref:System.Windows.Forms.Panel> 또는 <xref:System.Windows.Forms.GroupBox>, 자체 자식 컨트롤은 보다 잘 보여 주는 재귀 합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.BackColor" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.BackColor" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.BackColor" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.BackColor" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.BackColor%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트 처리기 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 *PropertyName* `Changed` 있는 될 때 발생 하는 해당 *PropertyName* 값이 변경 (* PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 표시할 배경 이미지를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 배경에 표시할 이미지를 나타내는 <see cref="T:System.Drawing.Image" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   사용 하 여는 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 속성을 컨트롤에 그래픽 이미지를 삽입 합니다.  
  
> [!NOTE]
>  반투명, 투명 한 색을 사용 하 여 이미지 배경 이미지와 Windows Forms 컨트롤에서 지원 되지 않습니다.  
>   
>  이 속성이 지원 되지 않는 자식 컨트롤 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> 속성은 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추가 <xref:System.Windows.Forms.Button> 폼에 일반적인 속성 중 일부를 설정 합니다. 이 예제에서는 폼 크기가 조정 될 때의 상대 위치를 유지할 수 있도록 폼의 오른쪽 아래 모서리에 있는 단추를 고정 합니다. 그런 다음 설정의 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 단추와 같은 크기를 조정 하 고는 <xref:System.Drawing.Image>합니다. 설정한 후의 <xref:System.Windows.Forms.Control.TabStop%2A> 를 `true` 설정 하 고는 <xref:System.Windows.Forms.Control.TabIndex%2A> 속성입니다. 마지막으로 처리 하는 이벤트 처리기 추가 <xref:System.Windows.Forms.Control.Click> 단추의 이벤트가 있습니다. 이 예제를 실행 하려면 프로그램 <xref:System.Windows.Forms.ImageList> 라는 `imageList1`합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트 처리기 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 *PropertyName* `Changed` 있는 될 때 발생 하는 해당 *PropertyName* 값이 변경 (* PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.ImageLayout" /> 열거형에서 정의된 대로 배경 이미지 레이아웃을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ImageLayout" />의 값(<see cref="F:System.Windows.Forms.ImageLayout.Center" />, <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> 또는 <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />) 중 하나입니다. 기본값은 <see cref="F:System.Windows.Forms.ImageLayout.Tile" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> 속성을 통해 위치 및 컨트롤에 배치 했으면 이미지의 동작을 지정 합니다. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> 경우에 적용 됩니다는 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 속성을 설정 합니다.  
  
 설정 하는 경우에 큰 이미지에 대 한 성능을 향상 시킬 수 <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> 이외의 다른 값으로 <xref:System.Windows.Forms.ImageLayout.Tile>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">지정된 열거형 값이 없는 경우</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" /> 속성이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> 속성을 프로그래밍 방식으로 또는 사용자 인터페이스에 의해 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤의 내부 핸들이 작성된 스레드에서 대리자를 비동기식으로 실행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">매개 변수를 사용하지 않는 메서드의 대리자입니다.</param>
        <summary>컨트롤의 내부 핸들이 작성된 스레드에서 지정된 대리자를 비동기식으로 실행합니다.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 작업의 결과를 나타내는 <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대리자가 비동기적으로 호출 하 고이 메서드가 즉시 반환 합니다. 컨트롤의 핸들이 있는 스레드에서 모든 스레드에서이 메서드를 호출할 수 있습니다. 컨트롤의 핸들이 아직 존재 하지 않는 경우 창 핸들이 폼 또는 컨트롤을 찾을 때까지이 메서드는 컨트롤의 부모 체인을 검색 합니다. 적절 한 핸들을 찾을 수 있는 경우 <xref:System.Windows.Forms.Control.BeginInvoke%2A> 예외가 throw 됩니다. 대리자 메서드 내에서 예외 포착 되지 않는 것으로 간주 되어 응용 프로그램의 포착 되지 않은 예외 처리기로 전송 됩니다.  
  
 호출할 수 있습니다 <xref:System.Windows.Forms.Control.EndInvoke%2A> 경우도 있지만이 필요 하지 않은 경우는 대리자의 반환 값을 검색할 수 있습니다. <xref:System.Windows.Forms.Control.EndInvoke%2A> 반환 값을 검색할 수 있을 때까지 차단 됩니다.  
  
> [!NOTE]
>  대부분의 메서드는 컨트롤 에서만 호출 될 수 스레드에서 컨트롤이 만들어진 위치입니다. 외에 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 속성에는 스레드로부터 안전 컨트롤에서 네 가지 메서드가 있습니다: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, 및 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다. 다른 모든 메서드 호출에 대 한 사용할지 invoke 메서드 중 하나를 컨트롤의 스레드에 대 한 호출을 마샬링하 합니다. Invoke 메서드는 항상 컨트롤의 스레드에 해당 콜백을 호출합니다.  
  
> [!NOTE]
>  메시지를 처리 해야 하는 스레드가 더 이상 활성 상태 이면 예외가 throw 될 수 없습니다.  
  
   
  
## Examples  
 사용법을 설명 하는 다음 코드 예제는 <xref:System.Windows.Forms.Control.BeginInvoke%2A> 메서드.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">해당 창 핸들을 찾을 수 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 직접 실행 호출자입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">
          <c>args</c> 매개 변수에 있는 매개 변수의 수 및 형식과 동일한 매개 변수를 갖는 메서드의 대리자입니다.</param>
        <param name="args">주어진 메서드에 인수로 전달하는 개체의 배열입니다. 인수가 필요하지 않으면 <see langword="null" />일 수 있습니다.</param>
        <summary>컨트롤의 내부 핸들이 작성된 스레드에서 특정 인수를 사용하여 지정된 대리자를 비동기식으로 실행합니다.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 작업의 결과를 나타내는 <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대리자가 비동기적으로 호출 하 고이 메서드가 즉시 반환 합니다. 컨트롤의 핸들이 있는 스레드에서 모든 스레드에서이 메서드를 호출할 수 있습니다. 컨트롤의 핸들이 아직 존재 하지 않는 경우 창 핸들이 폼 또는 컨트롤을 찾을 때까지이 메서드는 컨트롤의 부모 체인을 검색 합니다. 적절 한 핸들을 찾을 수 있는 경우 <xref:System.Windows.Forms.Control.BeginInvoke%2A> 예외가 throw 됩니다. 대리자 메서드 내에서 예외 포착 되지 않는 것으로 간주 되어 응용 프로그램의 포착 되지 않은 예외 처리기로 전송 됩니다.  
  
 호출할 수 있습니다 <xref:System.Windows.Forms.Control.EndInvoke%2A> 경우도 있지만이 필요 하지 않은 경우는 대리자의 반환 값을 검색할 수 있습니다. <xref:System.Windows.Forms.Control.EndInvoke%2A> 반환 값을 검색할 수 있을 때까지 차단 됩니다.  
  
> [!NOTE]
>  대부분의 메서드는 컨트롤 에서만 호출 될 수 스레드에서 컨트롤이 만들어진 위치입니다. 외에 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 속성에는 스레드로부터 안전 컨트롤에서 네 가지 메서드가 있습니다: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, 및 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다. 다른 모든 메서드 호출에 대 한 사용할지 invoke 메서드 중 하나를 컨트롤의 스레드에 대 한 호출을 마샬링하 합니다. Invoke 메서드는 항상 컨트롤의 스레드에 해당 콜백을 호출합니다.  
  
> [!NOTE]
>  메시지를 처리 해야 하는 스레드가 더 이상 활성 상태 이면 예외가 throw 될 수 없습니다.  
  
   
  
## Examples  
 사용법을 설명 하는 다음 코드 예제는 <xref:System.Windows.Forms.Control.BeginInvoke%2A> 메서드.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">해당 창 핸들을 찾을 수 있습니다.</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 <see cref="T:System.Windows.Forms.BindingContext" />를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 <see cref="T:System.Windows.Forms.BindingContext" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingContext> 의 <xref:System.Windows.Forms.Control> 하나의 반환 하는 데 사용 되 <xref:System.Windows.Forms.BindingManagerBase> 에 포함 된 모든 데이터 바인딩된 컨트롤에 대 한는 <xref:System.Windows.Forms.Control>합니다. <xref:System.Windows.Forms.BindingManagerBase> 동기화 동일한 데이터 소스에 바인딩된 모든 컨트롤을 유지 합니다. 예를 들어 설정는 <xref:System.Windows.Forms.BindingManagerBase.Position%2A> 의 속성은 <xref:System.Windows.Forms.BindingManagerBase> 모든 데이터 바인딩된 컨트롤이 가리키는 내부 목록에서 항목을 지정 합니다.  
  
 새로 만드는 방법에 대 한 자세한 내용은 <xref:System.Windows.Forms.BindingContext> 할당 하는 <xref:System.Windows.Forms.Control.BindingContext%2A> 속성 참조는 <xref:System.Windows.Forms.BindingContext.%23ctor%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 네 개를 만듭니다 <xref:System.Windows.Forms.Binding> 다섯 개의 컨트롤을 바인딩하는 개체는 <xref:System.Windows.Forms.DateTimePicker> 4 <xref:System.Windows.Forms.TextBox> 을 여러 데이터 소스 컨트롤입니다. <xref:System.Windows.Forms.BindingContext> 다음 얻는 데 사용 되는 <xref:System.Windows.Forms.BindingManagerBase> 각 데이터 원본에 대 한 합니다.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.BindingContext" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.BindingContext" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.BindingContext" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.BindingContext" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 <xref:System.Windows.Forms.BindingContext> 에 <xref:System.Windows.Forms.Control> 통해는 <xref:System.Windows.Forms.Control.BindingContext%2A> 속성 참조는 <xref:System.Windows.Forms.BindingContext.%23ctor%2A> 생성자입니다.  
  
 이 이벤트는 <xref:System.Windows.Forms.Control.BindingContext%2A> 속성이 변경 될 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 변경 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추가 <xref:System.EventHandler> 위임는 <xref:System.Windows.Forms.Control.BindingContextChanged> 의 이벤트는 <xref:System.Windows.Forms.TextBox> 제어 합니다.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 아래쪽 가장자리와 해당 컨테이너 클라이언트 영역의 위쪽 가장자리 사이의 거리(픽셀)를 가져옵니다.</summary>
        <value>컨트롤의 아래쪽 가장자리와 해당 컨테이너 클라이언트 영역의 위쪽 가장자리 사이의 거리(픽셀)를 나타내는 <see cref="T:System.Int32" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값의 합계와 같은지는 <xref:System.Windows.Forms.Control.Top%2A> 속성 값 및 <xref:System.Windows.Forms.Control.Height%2A> 속성 값입니다.  
  
 <xref:System.Windows.Forms.Control.Bottom%2A> 속성은 읽기 전용 속성입니다. 값을 변경 하 여이 속성 값을 조작할 수 있습니다는 <xref:System.Windows.Forms.Control.Top%2A> 또는 <xref:System.Windows.Forms.Control.Height%2A> 속성 또는 호출의 <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, 또는 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Bottom%2A> 속성의 하 한을 정의할 수는 <xref:System.Windows.Forms.TextBox> 컨트롤 컨테이너의 클라이언트 영역을 기준으로 합니다.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 컨트롤을 기준으로 비클라이언트 요소를 포함하는 컨트롤의 크기와 위치(픽셀)를 가져오거나 설정합니다.</summary>
        <value>부모 컨트롤을 기준으로 비클라이언트 요소를 포함하여 컨트롤의 크기와 위치를 나타내는 <see cref="T:System.Drawing.Rectangle" />(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 범위는 스크롤 막대, 테두리, 제목 표시줄, 메뉴 등 비클라이언트 요소를 포함 합니다. <xref:System.Windows.Forms.Control.SetBoundsCore%2A> 메서드는 설정 하 여 <xref:System.Windows.Forms.Control.Bounds%2A> 속성입니다. <xref:System.Windows.Forms.Control.Bounds%2A> 속성이 통해 변경 되지 않습니다 해당 `set` 메서드를 재정의 해야 하는 <xref:System.Windows.Forms.Control.SetBoundsCore%2A> 메서드 코드가 실행 되도록 때는 <xref:System.Windows.Forms.Control.Bounds%2A> 속성을 설정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개를 만들며 <xref:System.Windows.Forms.Button> 폼에서 제어 하 고 다양 한 크기 및 위치 관련 속성을 사용 하 여 해당 크기와 위치를 설정 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하에 너비와 높이가 이상 300 픽셀입니다.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤을 Z 순서의 맨 앞으로 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤이 z 순서의 맨 앞으로 이동 합니다. 다른 컨트롤의 자식 컨트롤을 사용 하는 경우 자식 컨트롤이 z 순서의 맨 앞으로 이동 됩니다. <xref:System.Windows.Forms.Control.BringToFront%2A> 컨트롤을 최상위 컨트롤로 하며 발생 하지 않는 경우 만들지는 <xref:System.Windows.Forms.Control.Paint> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하면는 <xref:System.Windows.Forms.Label> 호출 하 여 표시 되는 <xref:System.Windows.Forms.Control.BringToFront%2A> 메서드. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.Panel> 라는 `panel1`, 및 <xref:System.Windows.Forms.Label> 라는 `label1`합니다.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IME 지원을 사용하도록 <see cref="P:System.Windows.Forms.Control.ImeMode" /> 속성을 활성 값으로 설정할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          모든 경우에 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스 반환 하도록이 속성을 재정의할 수 `false` IME 지원 되지 않는 경우.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 포커스를 받을 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤이 포커스를 받을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 입력된 포커스를 받을 컨트롤에 대 한 순서 대로 컨트롤에 할당 하는 핸들 있어야 및 <xref:System.Windows.Forms.Control.Visible%2A> 및 <xref:System.Windows.Forms.Control.Enabled%2A> 속성 둘 다로 설정 해야 `true` 컨트롤 모든 부모 컨트롤이 컨트롤이 폼에 대해 또는 컨트롤의 가장 바깥쪽 부모 폼 이어야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정 된 포커스를 설정 <xref:System.Windows.Forms.Control>포커스를 받을 수 있으면, 합니다.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 이벤트가 발생할 수 있는지를 확인합니다.</summary>
        <value>
          컨트롤이 이벤트가 고정되지 않은 ActiveX 컨트롤로 호스팅되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에이 컨트롤 ActiveX 컨트롤로 호스팅되는지,이 속성은 반환 `false` ActiveX 컨트롤에 있는 경우 이벤트입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 선택할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤을 선택할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 `true` 경우는 `Selectable` 값 <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> 로 설정 된 `true`표시 되 고 사용 가능한 컨트롤 자체는 다른 컨트롤에 포함 되며 부모 컨트롤이 표시 되 고 사용 하도록 설정 합니다.  
  
 다음 목록에 Windows Forms 컨트롤은 선택할 수 및의 값을 반환 합니다 `false` 에 대 한는 <xref:System.Windows.Forms.Control.CanSelect%2A> 속성입니다. 이러한 컨트롤에서 파생 된 컨트롤은도 선택할 수 없습니다.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (이 경우 컨트롤에 링크가)  
  
   
  
## Examples  
 다음 코드 예제에서는 지정 된 선택 <xref:System.Windows.Forms.Control>선택 가능한 경우, 합니다.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 마우스를 캡처했는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤이 마우스를 캡처했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤이 마우스를 캡처, 커서가 테두리 내 여부에 관계 없이 마우스 입력을 받습니다. 마우스는 일반적으로 끌기 작업 중에 캡처됩니다.  
  
 전경 창이 마우스를 캡처할 수 있습니다. 배경 창이 이렇게 하려고 하면 창 마우스 커서가 표시 된 창 영역 내에 있을 때 발생 하는 마우스 이벤트에 대 한 메시지를 받습니다. 또한 전경 창이 마우스를 캡처, 경우에 계속 클릭할 수 다른 창은 전경으로 전환 합니다.  
  
 마우스를 캡처한 바로 가기 키 작업 하면 안 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Control.Capture%2A> 속성입니다. 이 예제를 포함 하는 폼에서 다음 코드를 붙여넣습니다 실행 하려면 한 <xref:System.Windows.Forms.Label> 레이블 1과 2 라는 <xref:System.Windows.Forms.ListBox> listbox1 및 listbox2 컨트롤 이라는 합니다. 폼 및 컨트롤의 <xref:System.Windows.Forms.Control.MouseDown> 이벤트는이 예에서 메서드에 연결 되어 있습니다.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성 값을 설정 하려면 모든 창입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 포커스를 받을 때 유효성 검사가 필요한 모든 컨트롤에 대해 유효성 검사가 수행되도록 하는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤이 포커스를 받을 때 유효성 검사가 필요한 모든 컨트롤에 대해 유효성 검사가 수행되도록 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성 값은 대개로 설정 `false` 도움말 단추와 같은 컨트롤에 대 한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Windows.Forms.TextBox> 고 사용자가 입력 하는 전자 메일 주소 유효성을 검사 합니다. 표준 형식으로 전자 메일 주소가 없으면 (포함 된 "@" and "."), 유효성 검사에 실패는 <xref:System.Windows.Forms.ErrorProvider> 이벤트가 취소 되 고 아이콘이 표시 됩니다. 폼에 단추 중 하나에 해당 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이로 설정 `false`합니다. 클릭 하거나이 단추에 포커스 설정 유효성 검사를 트리거하지 않습니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox>, <xref:System.Windows.Forms.ErrorProvider> 컨트롤 및 <xref:System.Windows.Forms.Button> 폼에 만든 합니다.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.CausesValidation" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>포커스 또는 키보드 UI(사용자 인터페이스) 큐가 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.ChangeUICues> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.ChangeUICues> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 디버깅되는 동안 컨트롤의 <see cref="P:System.Windows.Forms.Control.Handle" /> 속성에 액세스하는 잘못된 스레드에 대한 호출을 catch할지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          잘못된 스레드에 대한 호출이 catch되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 만드는 스레드가 아닌 다른 스레드에서 제어 하는 메서드 또는 속성 중 하나에 액세스 하려고 하면 종종 예기치 않은 결과가 발생 합니다. 일반적인 잘못 된 스레드 활동은 컨트롤의에 액세스 하는 잘못 된 스레드에서 호출 <xref:System.Windows.Forms.Control.Handle%2A> 속성입니다. 설정 <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> 를 `true` 를 찾아서이 스레드 작업을 보다 쉽게 디버깅 하는 동안 진단 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 클릭하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Click> 이벤트 전달는 <xref:System.EventArgs> 해당 이벤트 처리기에 따라서 것만 한 번의 클릭이 발생 했음을 나타냅니다. 보다 구체적인 마우스 정보 (단추, 클릭, 휠 회전 또는 위치 수)가 필요한 경우 사용 된 <xref:System.Windows.Forms.Control.MouseClick> 이벤트입니다. 그러나는 <xref:System.Windows.Forms.Control.MouseClick> 클릭 하 고 ENTER 키를 누르는 것과 같은 마우스 이외의 작업에 의해 발생 하는 경우 이벤트를 발생 하지 것입니다.  
  
 두 번 클릭은 운영 체제의 마우스 설정에 따라 결정 됩니다. 천천히 두 번 클릭하는 것이 아닌 두 번 클릭(double-click)으로 간주될 수 있도록 마우스 단추 클릭 간격을 설정할 수 있습니다. <xref:System.Windows.Forms.Control.Click> 이벤트는 컨트롤을 두 번 클릭할 때마다 발생 합니다. 예를 들어에 대 한 이벤트 처리기가는 <xref:System.Windows.Forms.Control.Click> 및 <xref:System.Windows.Forms.Control.DoubleClick> 의 이벤트는 <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Click> 및 <xref:System.Windows.Forms.Control.DoubleClick> 발생 하는 폼을 두 번 클릭 하 고 두 방법 모두 호출 됩니다. 컨트롤을 두 번 클릭 하는 경우 및 컨트롤을 지원 하지 않습니다는 <xref:System.Windows.Forms.Control.DoubleClick> 이벤트는 <xref:System.Windows.Forms.Control.Click> 이벤트를 두 번 발생할 수 있습니다.  
  
 설정 해야 합니다는 `StandardClick` 값 <xref:System.Windows.Forms.ControlStyles> 를 `true` 이 이벤트를 발생 합니다.  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Control.Click> 이벤트 처리기에서 이벤트입니다.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>표준 Windows Forms 컨트롤에서 상속 하 고 변경 된 <see langword="StandardClick" /> 또는 <see langword="StandardDoubleClick" /> 값의 <see cref="T:System.Windows.Forms.ControlStyles" /> 를 <see langword="true" /> 효과가 없습니다. 모든 컨트롤을 지원 하지 않는 경우 하거나 예기치 않은 동작이 발생할 수 있습니다는 <see cref="E:System.Windows.Forms.Control.Click" /> 또는 <see cref="E:System.Windows.Forms.Control.DoubleClick" />이벤트입니다.  
  
 다음 표에서 Windows Forms 컨트롤 및 이벤트 (event) (<see cref="E:System.Windows.Forms.Control.Click" /> 또는 <see cref="E:System.Windows.Forms.Control.DoubleClick" />)는 지정 된 마우스 작업에 대 한 응답에서 발생 합니다.  
  
 <list type="table"><listheader><term> 컨트롤  
  
 </term><description> 마우스 왼쪽된 단추 클릭  
  
 </description><description> 왼쪽된 마우스 두 번 클릭  
  
 </description><description> 마우스 오른쪽 단추 클릭  
  
 </description><description> 마우스 오른쪽 단추 두 번 클릭  
  
 </description><description> 마우스 가운데 단추 클릭  
  
 </description><description> 마우스 가운데 단추를 두 번 클릭  
  
 </description><description> XButton1 마우스 클릭  
  
 </description><description> XButton1 마우스 두 번 클릭  
  
 </description><description> XButton2 마우스 클릭  
  
 </description><description> XButton2 마우스 두 번 클릭  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />,  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />,  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />,  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />,  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />,  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />,  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \* <see cref="T:System.Windows.Forms.ListView" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />,  
  
 <see cref="T:System.Windows.Forms.Label" />,  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />,  
  
 <see cref="T:System.Windows.Forms.Panel" />,  
  
 <see cref="T:System.Windows.Forms.GroupBox" />,  
  
 <see cref="T:System.Windows.Forms.PictureBox" />,  
  
 <see cref="T:System.Windows.Forms.Splitter" />,  
  
 <see cref="T:System.Windows.Forms.StatusBar" />,  
  
 <see cref="T:System.Windows.Forms.ToolBar" />,  
  
 <see cref="T:System.Windows.Forms.TabPage" />,  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description></item></list>  
  
 \* 마우스 포인터가 자식 개체에 대해 이어야 합니다 (<see cref="T:System.Windows.Forms.TreeNode" /> 또는 <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
 * *는 <see cref="T:System.Windows.Forms.TabControl" /> 하나 이상 있어야 <see cref="T:System.Windows.Forms.TabPage" /> 에 해당 <see cref="P:System.Windows.Forms.TabControl.TabPages" /> 컬렉션입니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 클라이언트 영역을 나타내는 사각형을 가져옵니다.</summary>
        <value>컨트롤의 클라이언트 영역을 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 클라이언트 영역은 스크롤 막대, 테두리, 제목 표시줄, 메뉴 등 비클라이언트 요소에서 뺀 컨트롤의 범위입니다.  
  
 클라이언트 좌표는 컨트롤 클라이언트 영역의 왼쪽 위 모퉁이 기준으로 이므로,이 속성에서 반환 되는 사각형의 왼쪽 위 모퉁이의 좌표는 (0, 0). 크기와 컨트롤의 화면에 그리기 등의 작업에 대 한 컨트롤 클라이언트 영역의 좌표를 가져오려면이 속성을 사용할 수 있습니다.  
  
 컨트롤에서 그리기에 대 한 자세한 내용은 참조 [Windows Forms 컨트롤 렌더링](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 대 한 자동 스크롤을 사용할 수, 폼의 크기를 조정 및 단추 계속 표시 되는 폼 크기가 조정 후 확인 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.Button> 라는 `button2` 에 있습니다.  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 클라이언트 영역의 높이와 너비를 가져오거나 설정합니다.</summary>
        <value>컨트롤 클라이언트 영역의 크기를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 클라이언트 영역은 스크롤 막대, 테두리, 제목 표시줄, 메뉴 등 비클라이언트 요소에서 뺀 컨트롤의 범위입니다. <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> 메서드는 설정 하 여 <xref:System.Windows.Forms.Control.ClientSize%2A> 속성입니다. <xref:System.Windows.Forms.Control.ClientSize%2A> 속성이 통해 변경 되지 않습니다 해당 `set` 메서드를 재정의 해야 하는 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> 메서드 코드가 실행 되도록 때는 <xref:System.Windows.Forms.Control.ClientSize%2A> 속성을 설정 합니다.  
  
 <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType> 및 <xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType> 속성 컨트롤의 클라이언트 영역 높이 너비를 나타냅니다. 컨트롤의 화면에 그리기 등의 작업에 대 한 컨트롤의 클라이언트 영역 크기를 구합니다이 속성을 사용할 수 있습니다.  
  
 컨트롤에서 그리기에 대 한 자세한 내용은 참조 [Windows Forms 컨트롤 렌더링](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)합니다.  
  
> [!NOTE]
>  응용 프로그램 설정을이 속성에 바인딩할 수 없습니다. 응용 프로그램 설정에 대 한 자세한 내용은 참조 하십시오. [응용 프로그램 설정 개요](~/docs/framework/winforms/advanced/application-settings-overview.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 컨트롤의 서식 있는 텍스트에 연결할 수 있도록 지정된 된 컨트롤을 조정 합니다. 서식 있는 텍스트는 <xref:System.Windows.Forms.Control.Text%2A> 컨트롤을 사용 하 여 속성의 할당 된 <xref:System.Windows.Forms.Control.Font%2A> 텍스트에 적용 합니다. `AutoSizeControl` 이 예제의 메서드 역시는 `textPadding` 컨트롤의 모든 가장자리에 적용할 안쪽을 나타내는 매개 변수입니다. 안쪽을 하려면 텍스트를 정렬 합니다는 <xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType> 값, 컨트롤이를 지원 합니다.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ClientSize" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.ClientSizeChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.ClientSizeChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 포함하고 있는 응용 프로그램의 회사 이름이나 작성자를 가져옵니다.</summary>
        <value>컨트롤을 포함하고 있는 응용 프로그램의 회사 이름이나 작성자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CompanyName%2A> 속성은 읽기 전용 속성입니다. 이 속성의 값을 변경 하려면는 <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A> 의 속성 값은 <xref:System.Reflection.AssemblyCompanyAttribute>합니다. C# 코드 집합의 다음 줄은 <xref:System.Windows.Forms.Control.CompanyName%2A> 속성입니다.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  앱에 대 한 회사 이름, 제품 이름 및 제품 버전을 제공할 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서 응용 프로그램에 대 한 정보를 표시 한 <xref:System.Windows.Forms.Label> 에 포함 된 한 <xref:System.Windows.Forms.Form>합니다. 이 예제에서는 <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> 및 <xref:System.Windows.Forms.Control.ProductVersion%2A> 설정 되었습니다.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">실행할 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <summary>지정된 컨트롤이 특정 컨트롤의 자식인지를 나타내는 값을 검색합니다.</summary>
        <returns>
          지정된 컨트롤이 특정 컨트롤의 자식이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 사용 하면는 <xref:System.Windows.Forms.Label> 호출 하 여 표시 되는 <xref:System.Windows.Forms.Control.BringToFront%2A> 메서드. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.Panel> 라는 `panel1`, 및 <xref:System.Windows.Forms.Label> 라는 `label1`합니다.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이나 해당 컨트롤의 자식 컨트롤이 현재 입력 포커스를 가지고 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤이나 해당 컨트롤의 자식 컨트롤이 현재 입력 포커스를 가지고 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤이 나 그 안에 포함 된 컨트롤에 입력된 포커스가 있는지 여부를 확인 하려면이 속성을 사용할 수 있습니다. 컨트롤에 포커스를 컨트롤은 자식 컨트롤의 모든 권한이 있는지 여부에 상관 없이 포커스 있는지 여부를 확인 하려면 사용 된 <xref:System.Windows.Forms.Control.Focused%2A> 속성입니다. 컨트롤이 입력된 포커스를 사용는 <xref:System.Windows.Forms.Control.Focus%2A> 또는 <xref:System.Windows.Forms.Control.Select%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤과 연결된 바로 가기 메뉴를 가져오거나 설정합니다.</summary>
        <value>해당 컨트롤과 연결된 바로 가기 메뉴를 나타내는 <see cref="T:System.Windows.Forms.ContextMenu" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 바로 가기 메뉴를 사용 하 여 컨트롤에서 마우스 오른쪽 단추로 될 때 사용자에 게 상황에 맞는 메뉴 옵션을 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.ContextMenu> 에 할당 한 <xref:System.Windows.Forms.TreeView> 마우스 오른쪽 단추를 클릭 한 후 해제 합니다. 이 코드를 실행 하려면는 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.TreeView> 에 있습니다. 또한 전체 동기화를 하는 <xref:System.Windows.Forms.TreeView> 에 <xref:System.Windows.Forms.ContextMenu> 에 할당 된 해당 <xref:System.Windows.Forms.Control.ContextMenu%2A> 속성 합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.ContextMenu" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.ContextMenu" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.ContextMenu" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ContextMenu" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.ContextMenu%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 바로 가기 메뉴에 변경이 발생할 때 메시지를 표시 합니다.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤과 연결된 <see cref="T:System.Windows.Forms.ContextMenuStrip" />을 가져오거나 설정합니다.</summary>
        <value>이 컨트롤의 <see cref="T:System.Windows.Forms.ContextMenuStrip" />이거나, <see langword="null" />이 없는 경우 <see cref="T:System.Windows.Forms.ContextMenuStrip" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.ContextMenu> 가 컨트롤에 할당 된는 <xref:System.Windows.Forms.ContextMenu> 우선는 <xref:System.Windows.Forms.ContextMenuStrip>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 3 개를 추가 하는 방법을 보여 줍니다. <xref:System.Windows.Forms.ToolStripMenuItem> 개체는 <xref:System.Windows.Forms.ContextMenuStrip>합니다. 또한 설정을 보여 줍니다는 <xref:System.Windows.Forms.Control.ContextMenuStrip%2A> 폼의 속성입니다.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.ContextMenuStripChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.ContextMenuStripChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.Control.ControlCollection" />에 새로운 컨트롤이 추가되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.ControlAdded> 폼에 컨트롤을 추가 하려면에 추가 된 컨트롤의 이름을 표시 한 <xref:System.Windows.Forms.MessageBox>합니다.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.Control.ControlCollection" />에서 컨트롤이 제거되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.ControlRemoved> 양식에서 컨트롤을 제거 하려면에 제거 된 컨트롤의 이름을 표시 한 <xref:System.Windows.Forms.MessageBox>합니다.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 포함된 컨트롤의 컬렉션을 가져옵니다.</summary>
        <value>컨트롤에 포함된 컨트롤의 컬렉션을 나타내는 <see cref="T:System.Windows.Forms.Control.ControlCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Forms.Control> 컨트롤의 컬렉션에 대 한 부모 작동할 수 있습니다. 여러 컨트롤에 추가 될 때에 예를 들어는 <xref:System.Windows.Forms.Form>, 각 컨트롤의 멤버인는 <xref:System.Windows.Forms.Control.ControlCollection> 에 할당 된는 <xref:System.Windows.Forms.Control.Controls%2A> 에서 파생 된 폼의 속성은 <xref:System.Windows.Forms.Control> 클래스입니다.  
  
 컨트롤을 조작할 수는 <xref:System.Windows.Forms.Control.ControlCollection> 에 할당 된는 <xref:System.Windows.Forms.Control.Controls%2A> 에서 사용할 수 있는 메서드를 사용 하 여 속성의 <xref:System.Windows.Forms.Control.ControlCollection> 클래스입니다.  
  
 여러 컨트롤에 부모 컨트롤을 추가할 때 것이 좋습니다를 호출 하는 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 추가할 컨트롤을 초기화 하기 전에 메서드. 부모 컨트롤에 컨트롤을 추가한 후 호출 된 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드. 이렇게 하면 많은 컨트롤이 응용 프로그램의 성능이 향상 됩니다.  
  
 사용 하 여 <xref:System.Windows.Forms.Control.Controls%2A> 중첩 된 컨트롤을 포함 하 여 양식의 모든 컨트롤을 반복 하는 속성입니다. 사용 하 여는 <xref:System.Windows.Forms.Control.GetNextControl%2A> 탭 순서의 이전 또는 다음 자식 컨트롤을 검색 하는 메서드입니다. 사용 하 여는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> 속성을 가져오거나 컨테이너 컨트롤의 활성 컨트롤을 설정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 제거 된 <xref:System.Windows.Forms.Control> 에서 <xref:System.Windows.Forms.Control.ControlCollection> 파생된 클래스의 <xref:System.Windows.Forms.Panel> 컬렉션의 멤버인 경우. 이 예제에서는 만든는 <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.Button>와 하나 이상의 <xref:System.Windows.Forms.RadioButton> 컨트롤에 <xref:System.Windows.Forms.Form>합니다. <xref:System.Windows.Forms.RadioButton> 컨트롤에 추가 되는 <xref:System.Windows.Forms.Panel> 컨트롤 및 <xref:System.Windows.Forms.Panel> 에 추가 된 컨트롤은 <xref:System.Windows.Forms.Form>합니다. 단추를 클릭할 때 라디오 단추 라는 `removeButton` 에서 제거 되는 <xref:System.Windows.Forms.Control.ControlCollection>합니다.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤의 액세스 가능성 개체를 새로 만듭니다.</summary>
        <returns>컨트롤의 새로운 <see cref="T:System.Windows.Forms.AccessibleObject" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 메서드를 명시적으로 호출하지 않으면 <xref:System.Windows.Forms.Control.AccessibilityObject%2A> 속성을 참조할 때 이 메서드가 호출됩니다.  
  
> [!NOTE]
>  가져오거나 설정할는 <xref:System.Windows.Forms.Control.AccessibilityObject%2A> 속성에 대 한 참조를 추가 해야는 `Accessibility` 어셈블리와 함께 설치는 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 내게 필요한 옵션 인식 차트를 만드는 방법을 보여 줍니다. 컨트롤을 사용 하는 <xref:System.Windows.Forms.AccessibleObject> 및 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 클래스 액세스할 수 있는 정보를 표시 합니다. 컨트롤은 범례를 따라 두 곡선을 그립니다. `ChartControlAccessibleObject` 클래스에서 파생 되 `ControlAccessibleObject`에 사용 되는 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 메서드는 차트 컨트롤에 대 한 사용자 지정 액세스할 수 있는 정보를 제공 합니다. 차트 범례는 실제 <xref:System.Windows.Forms.Control> -컨트롤을 따르지만 그려지며 차트 컨트롤에서 액세스할 수 있는 기본 제공 정보를 포함 하지 않습니다. 이 인해는 `ChartControlAccessibleObject` 재정의 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 반환 하는 메서드는 `CurveLegendAccessibleObject` 범례의 각 부분에 액세스할 수 있는 정보를 나타내는입니다. 액세스할 수 있는 인식 응용 프로그램이이 제어를 사용 하는 경우 컨트롤은 필요한 액세스 가능 정보를 제공할 수 있습니다.  
  
 이 코드 발췌 구문에서는 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 메서드. 참조는 <xref:System.Windows.Forms.AccessibleObject> 전체 코드 예제에 대 한 클래스 개요입니다.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> 파생된 클래스에서 기본 클래스의을 호출 하지 마십시오 <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> 메서드.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>핸들과 모든 표시되는 자식 컨트롤을 포함하여 표시 가능한 컨트롤을 강제로 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateControl%2A> 메서드를 사용 하면 컨트롤과 해당 자식 컨트롤에 대해 만들 수에 대 한 핸들입니다. 컨트롤이 나 해당 자식; 조작에 대 한 핸들을 즉시 필요할 때이 메서드는 사용 단순히 호출 컨트롤의 생성자를 만들지 않습니다는 <xref:System.Windows.Forms.Control.Handle%2A>합니다.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A> 경우 컨트롤 핸들을 만들지 않습니다 컨트롤의 <xref:System.Windows.Forms.Control.Visible%2A> 속성은 `false`합니다. 호출할 수 있습니다는 <xref:System.Windows.Forms.Control.CreateHandle%2A> 메서드 또는 액세스는 <xref:System.Windows.Forms.Control.Handle%2A> 만들 컨트롤의 속성 처리는 컨트롤의 표시 여부에 관계 없이 하지만 경우 컨트롤의 자식에 대 한 핸들이 만들어집니다 창이 없습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤에 대한 컨트롤 컬렉션의 새 인스턴스를 만듭니다.</summary>
        <returns>컨트롤에 할당된 <see cref="T:System.Windows.Forms.Control.ControlCollection" />의 새 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>이 메서드의 기본 클래스 버전을 파생된 클래스에서 호출 되어야 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 만들어졌는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤이 만들어졌으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Created%2A> 속성에서 반환 `true` 경우는 <xref:System.Windows.Forms.Control> 컨트롤의 핸들 수 되지 만들어졌거나 아직 다시 생성 하는 경우에 성공적으로 만들었습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 컨트롤에 대한 <see cref="T:System.Drawing.Graphics" />를 만듭니다.</summary>
        <returns>컨트롤에 대한 <see cref="T:System.Drawing.Graphics" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics> 통해 검색 하는 개체는 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 메서드 하지 일반적으로 보존 되는 현재 Windows 메시지가 처리 된 후 해당 개체와 함께 색칠 다음 WM_PAINT 메시지와 함께 지워집니다 때문에 있습니다. 캐시할 수 없으며 따라서는 <xref:System.Drawing.Graphics> 사용 같은 표시 되지 않는 메서드를 제외 하 고 다시 사용 하기 위해 개체 <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>합니다. 대신 호출 해야 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 사용할 때마다는 <xref:System.Drawing.Graphics> 개체를 호출 <xref:System.Drawing.Graphics.Dispose%2A> 사용 했으면 합니다. Windows 메시지에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.Forms.Control.WndProc%2A>합니다.  
  
 기본적으로 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 호출 스레드에 소유권을 설정 하 고 다른 스레드에서 호출 되 면 실패 합니다.  
  
> [!NOTE]
>  외에 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 속성에는 스레드로부터 안전 컨트롤에서 네 가지 메서드가 있습니다: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, 및 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다. 다른 모든 메서드 호출에 대 한 사용할지 invoke 메서드 중 하나를 컨트롤의 스레드에 대 한 호출을 마샬링하 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 컨트롤의 서식 있는 텍스트에 연결할 수 있도록 지정된 된 컨트롤을 조정 합니다. 서식 있는 텍스트는 <xref:System.Windows.Forms.Control.Text%2A> 컨트롤을 사용 하 여 속성의 할당 된 <xref:System.Windows.Forms.Control.Font%2A> 텍스트에 적용 합니다. `AutoSizeControl` 이 예제의 메서드 역시는 `textPadding` 컨트롤의 모든 가장자리에 적용할 안쪽을 나타내는 매개 변수입니다. 안쪽을 하려면 텍스트를 정렬 합니다는 `MiddleCenter` 값 <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> 컨트롤이를 지원 합니다.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출할 하위 창에서 안전 하 게 보호 합니다. 연관 된 열거형: <see langword="SafeSubWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤의 핸들을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 호출 하지 않아야는 <xref:System.Windows.Forms.Control.CreateHandle%2A> 메서드를 직접 합니다. 호출 하는 메서드가 좋습니다는 <xref:System.Windows.Forms.Control.CreateControl%2A> 강제로 컨트롤을 만들 때 컨트롤 및 해당 자식 컨트롤에 대해 만들 수에 대 한 핸들입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">개체가 삭제된 상태인 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.CreateHandle" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.CreateHandle" /> 메서드 핸들을 만들 수 있도록 합니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 핸들이 만들어지는 경우 필요한 작성 매개 변수를 가져옵니다.</summary>
        <value>컨트롤 핸들을 만들 때 필요한 작성 매개 변수가 포함된 <see cref="T:System.Windows.Forms.CreateParams" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateParams%2A> 속성 하지 재정의 되 고 파생 된 컨트롤의 속성을 조정 하는 데 사용 해야 합니다. 와 같은 <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>, 및 <xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType> 와 같은 컨트롤에서 해당 속성으로 설정 해야 <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>합니다. <xref:System.Windows.Forms.CreateParams> 표준 Windows 컨트롤 클래스를 래핑할 또는 Windows Forms 네임 스페이스에서 제공 하지 않는 스타일을 설정할 때만 확장 해야 합니다. 제어 매개 변수를 만드는 방법에 대 한 자세한 내용은 참조는 `CreateWindow` 및 `CreateWindowEx` 함수 및 [CREATESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632603.aspx)설명서를 구성 합니다.  
  
   
  
## Examples  
 다음 코드 예에서는 확장 된 <xref:System.Windows.Forms.Control.CreateParams%2A> 속성의는 <xref:System.Windows.Forms.Button> 파생 클래스입니다. <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType> 속성이 변경 되 고 단추를 한 <xref:System.Drawing.Icon> 아닌 <xref:System.Drawing.Image>합니다. 이 예제에서는 있어야에서 상속 되는 클래스는 <xref:System.Windows.Forms.Button> 클래스입니다.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">속성 값을 가져올 때 관리 되지 않는 코드를 호출 하는 직접 실행 호출자의 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.CreateParams" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.CreateParams" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 컨트롤 위에 있을 때 표시되는 커서를 가져오거나 설정합니다.</summary>
        <value>마우스 포인터가 컨트롤 위에 있을 때 표시되는 커서를 나타내는 <see cref="T:System.Windows.Forms.Cursor" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 할당 한 <xref:System.Windows.Forms.Cursor> 에 <xref:System.Windows.Forms.Control.Cursor%2A> 마우스 포인터가 컨트롤 위에 있을 때 표시 되는 커서를 변경 하려면 컨트롤의 속성입니다. 일시적으로 응용 프로그램 집합에 있는 모든 컨트롤에 대 한 마우스 커서를 변경 하는 <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> 속성입니다. 설정한 일반적으로 <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> 속성을 채울 때 대기 커서를 한 <xref:System.Windows.Forms.ComboBox> 또는 저장 하거나 파일을 로드 합니다.  
  
 <xref:System.Windows.Forms.Control.Cursor%2A> 속성이 앰비언트 속성입니다. 그렇지 않은 경우, 즉 앰비언트 속성은 컨트롤 속성 설정, 부모 컨트롤에서 검색 됩니다. 예를 들어 한 <xref:System.Windows.Forms.Button> 같은 가질 수 <xref:System.Windows.Forms.Control.BackColor%2A> 부모로 <xref:System.Windows.Forms.Form> 기본적으로 합니다. 앰비언트 속성에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.AmbientProperties> 클래스 또는 <xref:System.Windows.Forms.Control> 클래스 개요입니다.  
  
   
  
## Examples  
 다음 코드 예에서는 채우기는 <xref:System.Windows.Forms.ComboBox> 사용자의 사용 가능한 논리 드라이브로 사용 합니다. 콤보 상자의 또한 설정 <xref:System.Windows.Forms.Cursor> 속성 이므로 <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType> 커서 마우스 포인터를 드롭 다운 단추 위로 가져갈 때 표시 됩니다. 이 코드를 실행 하려면는 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.ComboBox> 에 있습니다.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성 값을 설정할 하위 창에서 안전 하 게 보호 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.Cursor" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.Cursor" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 메서드는 <see cref="P:System.Windows.Forms.Control.Cursor" /> 속성; 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Cursor" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Cursor%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 마우스 커서를 변경 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> 속성에는 <xref:System.Windows.Forms.Cursor> 클래스 및 <xref:System.Windows.Forms.Cursors> 클래스입니다. 이 예에서는 포함 된 폼을 만듭니다는 <xref:System.Windows.Forms.ComboBox> 컨트롤은 <xref:System.Windows.Forms.Panel> 컨트롤 및 <xref:System.Windows.Forms.ListView> 제어 합니다. <xref:System.Windows.Forms.ComboBox> 에서 제공 하는 모든 커서를 포함 된 <xref:System.Windows.Forms.Cursors> 클래스입니다. 사용자가 단위로 나타낸 마우스 포인터를 선택 하는 경우는 <xref:System.Windows.Forms.ComboBox>, <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> 속성이 선택 된 커서에 대 한 커서 업데이트를로 설정 되어는 <xref:System.Windows.Forms.Panel>합니다. <xref:System.Windows.Forms.ListView> 업데이트 될 때마다 업데이트 되는 <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType> 이벤트가 발생 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 대한 데이터 바인딩을 가져옵니다.</summary>
        <value>컨트롤의 <see cref="T:System.Windows.Forms.ControlBindingsCollection" /> 개체를 포함하는 <see cref="T:System.Windows.Forms.Binding" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Forms.Control.DataBindings%2A> 속성에 액세스는 <xref:System.Windows.Forms.ControlBindingsCollection>합니다. 추가 하 여 <xref:System.Windows.Forms.Binding> 개체를 컬렉션에는 개체의 속성에는 컨트롤의 모든 속성을 바인딩할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추가 <xref:System.Windows.Forms.Binding> 개체는 <xref:System.Windows.Forms.ControlBindingsCollection> 다섯 개의 컨트롤의: 4 개의 <xref:System.Windows.Forms.TextBox> 컨트롤 및 <xref:System.Windows.Forms.DateTimePicker> 컨트롤입니다. <xref:System.Windows.Forms.ControlBindingsCollection>는 <xref:System.Windows.Forms.Control.DataBindings%2A> 클래스의 <xref:System.Windows.Forms.Control> 속성을 통해 액세스됩니다.  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 배경색을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 기본 배경 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Drawing.SystemColors.Control" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이것이 기본 <xref:System.Windows.Forms.Control.BackColor%2A> 일반 최상위 컨트롤의 속성 값입니다. 파생된 클래스는 서로 다른 기본값을 가질 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, 및 <xref:System.Windows.Forms.Control.DefaultForeColor%2A> 멤버입니다. 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.ListBox> ListBox1를 호출 합니다. 호출 된 `Populate_ListBox` 폼의 생성자 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리 메서드.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 커서를 가져오거나 설정합니다.</summary>
        <value>현재 기본 커서를 나타내는 <see cref="T:System.Windows.Forms.Cursor" /> 형식의 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 재정의 <xref:System.Windows.Forms.Control.DefaultCursor%2A> 를 컨트롤에 대 한 기본 커서를 구성 합니다. 이 컨트롤의 생성자에 커서를 설정 하는 보다 더 효율적 이며 자동 지원 특정 커서와 관련 된 디자이너 기능에 대 한 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 글꼴을 가져옵니다.</summary>
        <value>컨트롤의 기본 <see cref="T:System.Drawing.Font" />입니다. 반환되는 값은 운영 체제와 시스템의 로컬 문화권 설정에 따라 다릅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서 설명에서 반환 된 값 <xref:System.Windows.Forms.Control.DefaultFont%2A> 운영 체제와 로컬 문화권에 따라 합니다.  
  
|시스템 / 또는 Culture|글꼴|  
|----------------------------|----------|  
|Windows NT 4 x, 일본어 버전|MS UI Gothic, 9 포인트입니다.|  
|아랍어 Windows|Tahoma, 8 포인트입니다.|  
|다른 운영 체제/culture|MS Shell Dlg 논리 글꼴, 일반적으로 Microsoft San Serif 8 지점입니다.|  
  
 MS Shell Dlg 글꼴 시스템 레지스트리에 설정에 매핑됩니다.  
  
 이전 글꼴이 설치 되어 있지 않으면 기본 글꼴이 Tahoma, 8 포인트 인 경우 Tahoma, 8 포인트 설치 되어 있지 않으면 <xref:System.Windows.Forms.Control.DefaultFont%2A> 의 값을 반환 된 <xref:System.Drawing.FontFamily.GenericSansSerif%2A> 속성  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, 및 <xref:System.Windows.Forms.Control.DefaultForeColor%2A> 멤버입니다. 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.ListBox> ListBox1를 호출 합니다. 호출 된 `Populate_ListBox` 폼의 생성자 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리 메서드.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">클라이언트 컴퓨터에 기본 글꼴이나 국가별 대체 글꼴이 설치되어 있지 않은 경우</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 전경색을 가져옵니다.</summary>
        <value>컨트롤의 기본 전경 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Drawing.SystemColors.ControlText" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이것이 기본 <xref:System.Windows.Forms.Control.ForeColor%2A> 부모로 지정 되지 않은 컨트롤의 속성 값입니다. 파생된 클래스는 서로 다른 기본값을 가질 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, 및 <xref:System.Windows.Forms.Control.DefaultForeColor%2A> 멤버입니다. 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.ListBox> ListBox1를 호출 합니다. 호출 된 `Populate_ListBox` 폼의 생성자 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리 메서드.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 지원하는 기본 IME(입력기) 모드를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ImeMode" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 (입력기)는 사용자가 표준 키보드를 사용 하 여 복잡 한 한글 등의 기호를 입력할 수 있는 프로그램입니다.  
  
 구현 되는 <xref:System.Windows.Forms.Control> 클래스,이 속성은 항상 반환는 <xref:System.Windows.Forms.ImeMode.Inherit?displayProperty=nameWithType> 값입니다. <xref:System.Windows.Forms.ImeMode.Inherit> 값 IME 모드는 부모 컨트롤에서 상속 되도록 지정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Windows.Forms.Control.DefaultImeMode%2A> 속성을 입력 방법 편집기 해제를 설정 합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 사이에 기본적으로 지정되는 공백(픽셀)을 가져옵니다.</summary>
        <value>컨트롤 사이의 기본 공백을 나타내는 <see cref="T:System.Windows.Forms.Padding" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 최대 크기로 지정되는 길이와 높이를 픽셀 단위로 가져옵니다.</summary>
        <value>컨트롤의 크기를 나타내는 <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 최소 크기로 지정되는 길이와 높이를 픽셀 단위로 가져옵니다.</summary>
        <value>컨트롤의 크기를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 내용의 내부 간격(픽셀)을 가져옵니다.</summary>
        <value>컨트롤 내용의 내부 간격을 나타내는 <see cref="T:System.Windows.Forms.Padding" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 크기를 가져옵니다.</summary>
        <value>컨트롤의 기본 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DefaultSize%2A> 속성이 나타내는 <xref:System.Drawing.Size> 처음 만들어질 때 컨트롤의 합니다. 설정 하 여 컨트롤의 크기를 조정할 수 있습니다는 <xref:System.Windows.Forms.Control.Size%2A> 속성 값입니다.  
  
> [!NOTE]
>  더 나은 성능을 유지 하기 위해 설정 하지 않으면는 <xref:System.Drawing.Size> 생성자에서 컨트롤의 합니다. 재정의 하는 메서드가 좋습니다는 <xref:System.Windows.Forms.Control.DefaultSize%2A> 속성입니다.  
  
> [!NOTE]
>  Windows Server 2003 시스템의 크기는 <xref:System.Windows.Forms.Form> 최대 픽셀 너비와 높이 모니터에 의해 제한 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Windows.Forms.Control.DefaultSize%2A> 속성 폼 500 픽셀로의 기본 크기를 만듭니다.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.DefaultSize" /> 는 반환할 것이 좋습니다 파생된 클래스에서 속성을 한 <see cref="T:System.Drawing.Size" /> 모든 구현을 재정의 하는 대신 원하는 크기와 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">처리할 Windows <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>지정된 메시지를 기본 창 프로시저로 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 메시지를 처리 하는 방법에 대 한 자세한 내용은 참조는 [WindowProc 함수](http://go.microsoft.com/fwlink/?LinkId=181565)합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 직접 실행 호출자입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤과 연결된 핸들을 제거합니다.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 직접 실행 호출자입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> 메서드는 핸들이 소멸 될 수 있도록 합니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 현재 표시 중인 디스플레이 장치의 DPI 값을 가져옵니다.</summary>
        <value>디스플레이 장치의 DPI 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 표시 영역을 나타내는 사각형을 가져옵니다.</summary>
        <value>컨트롤의 표시 영역을 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DisplayRectangle%2A> 속성의 표시 영역 컨트롤의 클라이언트 사각형을 반환 합니다. 기본 컨트롤 클래스에 대 한 클라이언트 사각형에는이 같습니다. 그러나 상속 하는 컨트롤의 클라이언트 영역 표시 영역과 다른 경우이 변경 해야 할 수 있습니다. 표시 사각형은 가장 작은 <xref:System.Drawing.Rectangle> 컨트롤을 포함 하 고 컨트롤을 배치 하는 데 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> 속성을 기본 구현을 확장 합니다. 또는 모든 구현을 제공 해야 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>
          <see cref="T:System.Windows.Forms.Control" />과 해당 자식 컨트롤에서 사용하는 관리되지 않는 리소스를 해제하고, 필요에 따라 관리되는 리소스를 해제할 수도 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 public `Dispose()` 메서드 및 <xref:System.Object.Finalize%2A> 메서드.`Dispose()` 보호 된 호출 `Dispose(Boolean)` 메서드는 `disposing` 매개 변수 설정 `true`합니다. <xref:System.Object.Finalize%2A> 호출 `Dispose` 와 `disposing` 로 설정 `false`합니다.  
  
 `disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.Windows.Forms.Control>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다. 이 메서드는 참조되는 각 개체의 `Dispose()` 메서드를 호출합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" />는 다른 개체에서 여러 번 호출할 수 있습니다. 재정의 하는 경우 <see langword="Dispose(Boolean)" /> 이전 호출에서 삭제 된 개체를 참조 하지 않도록 주의 <see langword="Dispose" />합니다. 구현 하는 방법에 대 한 자세한 내용은 <see langword="Dispose(Boolean)" />, 참조 [Dispose 메서드를 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
 에 대 한 자세한 내용은 <see langword="Dispose" /> 및 <see cref="M:System.Object.Finalize" />, 참조 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 및 [Finalize 메서드를 재정의](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>기본 <see cref="T:System.Windows.Forms.Control" /> 클래스에 대한 삭제 작업이 진행되고 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          기본 <see cref="T:System.Windows.Forms.Control" /> 클래스에 대한 삭제 작업이 진행되고 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이 반환 하는 경우 `true`, 기본 <xref:System.Windows.Forms.Control> 클래스 삭제 작업이 진행 됩니다. 삭제 된 컨트롤은 더 이상 유효한 Windows 컨트롤로 참조할 수 없습니다. 컨트롤의 인스턴스 삭제 하는 경우에 가비지 수집을 통해 메모리에서 제거 될 때까지 메모리에 유지 계속 됩니다. 호출할 수 없습니다의 삭제는 컨트롤을 해당 <xref:System.Windows.Forms.Control.RecreateHandle%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어느 컨트롤 테두리가 부모 컨트롤에 도킹되는지를 가져오거나 설정하고 해당 부모를 기초로 컨트롤 크기를 조정하는 방법을 결정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.DockStyle" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.Forms.DockStyle.None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Windows.Forms.Control.Dock%2A> 컨트롤은 자동으로 조정 방법을 부모 컨트롤 크기 조정 되는지를 정의 하는 속성입니다. 예를 들어 설정 <xref:System.Windows.Forms.Control.Dock%2A> 를 <xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType> 하면 컨트롤이 부모 컨트롤의 왼쪽된 가장자리에 맞춰지고 하 고 크기를 조정 부모 컨트롤의 크기를 조정 합니다. 컨트롤은 폼의 z 축 (깊이)와 함께 폼에 컨트롤의 시각적 계층은 Z 순서에 도킹 됩니다.  
  
 부모 컨테이너의 한쪽 가장자리에 도킹 될 수 있습니다 또는 모든 가장자리에 도킹 될 수 컨트롤과 부모 컨테이너를 입력 합니다.  
  
 설정의 <xref:System.Windows.Forms.Control.Margin%2A> 도킹된 된 컨트롤에 속성에는 해당 컨테이너의 가장자리에서 컨트롤의 거리에 대 한 영향을 주지 않습니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A> 및 <xref:System.Windows.Forms.Control.Dock%2A> 속성은 함께 사용할 수 없습니다. 한 번에 하나만 설정할 수 있습니다 및 우선적으로 마지막으로 설정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Windows.Forms.GroupBox> 공통 속성 중 일부를 설정 합니다. 이 예에서는 만듭니다는 <xref:System.Windows.Forms.TextBox> 설정 하 고 해당 <xref:System.Windows.Forms.Control.Location%2A> 그룹 상자 내에서. 그런 다음 설정의 <xref:System.Windows.Forms.Control.Text%2A> 그룹 상자 및 폼의 위쪽에 도킹 된 그룹 상자 속성입니다. 마지막으로, 그룹 상자 설정 하 여 비활성화는 <xref:System.Windows.Forms.Control.Enabled%2A> 속성을 `false`, 사용 하지 않도록 설정할 그룹 상자에 포함 된 모든 컨트롤에 이르게 됩니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">할당된 값이 <see cref="T:System.Windows.Forms.DockStyle" /> 값 중 하나가 아닌 경우</exception>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.Dock" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.Dock" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 메서드는 <see cref="P:System.Windows.Forms.Control.Dock" /> 속성; 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Dock" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Dock%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트 처리기 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 *PropertyName* `Changed` 있는 될 때 발생 하는 해당 *PropertyName* 값이 변경 (* PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">끌 데이터입니다.</param>
        <param name="allowedEffects">
          <see cref="T:System.Windows.Forms.DragDropEffects" /> 값 중 하나입니다.</param>
        <summary>끌어서 놓기 작업을 시작합니다.</summary>
        <returns>끌어서 놓기 작업 동안 수행된 마지막 효과를 나타내는 <see cref="T:System.Windows.Forms.DragDropEffects" /> 열거형의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `allowedEffects` 작업이 발생할 수 있는 끌기 매개 변수를 결정 합니다. 관리 되는 기본 클래스는 끌기 작업을 다른 프로세스에서 응용 프로그램과 상호 운용 하는 경우 데이터 해야 하거나 (<xref:System.String>, <xref:System.Drawing.Bitmap>, 또는 <xref:System.Drawing.Imaging.Metafile>)를 구현 하는 개체 또는 <xref:System.Runtime.Serialization.ISerializable> 또는 <xref:System.Windows.Forms.IDataObject>합니다.  
  
 다음에서는 끌어서 놓기 작업이 발생하는 방식 및 시기에 대해 설명합니다.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드는 현재 커서 위치에서 컨트롤을 확인 합니다. 그런 다음 컨트롤은 유효한 놓기 대상 인지 확인 합니다.  
  
 컨트롤이 유효한 놓기 대상일 경우는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 지정 된 끌어서 놓기 효과 함께 발생 합니다. 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
 마우스 커서 위치, 키보드 상태 및 마우스 단추 상태의 변경 내용을 추적합니다.  
  
-   사용자가 창의 외부로 이동하면 <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생합니다.  
  
-   마우스를 다른 컨트롤로 가져가면 해당 컨트롤에 대한 <xref:System.Windows.Forms.Control.DragEnter>가 발생합니다.  
  
-   마우스를 동일한 컨트롤 내에서 이동하면 <xref:System.Windows.Forms.Control.DragOver> 이벤트가 발생합니다.  
  
 키보드 또는 마우스 단추 상태가 변경 될 경우는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트가 발생 하 고 데이터를 끌기를 계속할지 여부를 결정 하거나의 값을 기준으로 작업을 취소 하는 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 이벤트의 속성 <xref:System.Windows.Forms.QueryContinueDragEventArgs>합니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Continue`, <xref:System.Windows.Forms.Control.DragOver> 이벤트 작업을 계속 하려면는 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 적절 한 시각적 피드백이 설정 될 수 있도록 새로운 효과 함께 발생 합니다. 유효한 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver> 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 쌍을 이루고 있어서 마우스가 놓기 대상을 통과할 사용자에 게 마우스 위치에 대 한 최신 피드백이 제공 됩니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Drop`, 놓기 효과 값이 원본에 반환, 되므로 소스 응용 프로그램이 소스 데이터에 대해 적절 한 작업을 수행할 수 예를 들어 데이터 잘라내기 작업이 이동 인 경우.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생 합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드는 모든 예외를 catch 하 고 다음과 같은 보안 또는 심각한 예외만 다시 throw 합니다.  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 다음 코드 예제에서는 두 끌어서 놓기 작업을 보여 줍니다. <xref:System.Windows.Forms.ListBox> 컨트롤입니다. 예제에서는 호출은 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 끌기 작업이 시작 될 때 메서드. 마우스를 이동 하는 경우 끌기 작업이 시작 이상 <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> 하는 동안 마우스 위치에서의 <xref:System.Windows.Forms.Control.MouseDown> 이벤트입니다. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 메서드 결정 하는 동안 끌어 항목의 인덱스를 사용 하는 `MouseDown` 이벤트입니다.  
  
 또한이 예제에서는 끌어서 놓기 작업에 대 한 사용자 지정 커서를 사용 하 여 보여 줍니다. 이 예제를 실행 하려면 커서 파일 `3dwarro.cur` 및 `3dwno.cur`, 사용자 지정 끌어서에 대 한 응용 프로그램 디렉터리에 있으면 놓기-커서, 각각. 사용자 지정 커서 사용 하는 경우는 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> 을 선택 합니다. 에 설정 된 사용자 지정 커서는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트 처리기입니다.  
  
 키보드 상태에서 평가 됩니다는 <xref:System.Windows.Forms.Control.DragOver> 오른쪽에 대 한 이벤트 처리기 `ListBox`항목 끌기 작업을 결정 하는, SHIFT, CTRL 및 ALT, CTRL + ALT 키의 상태를 기반 합니다. 위치는 `ListBox` 삭제가 발생 중도 결정 됩니다는 `DragOver` 이벤트입니다. 삭제할 데이터가 아닌 경우는 `String`, 하면 <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> 로 설정 된 `None` 에서 <xref:System.Windows.Forms.DragDropEffects>합니다. 드롭다운 상태에 표시 되는 마지막으로,는 `DropLocationLabel` <xref:System.Windows.Forms.Label>합니다.  
  
 데이터를 오른쪽에 대 한 drop `ListBox` 에 따라 결정 됩니다는 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 처리기 및 `String` 적절 한 위치에서 값이 추가 `ListBox`합니다. 끌기 작업, 폼의 경계를 벗어나면 경우에서 끌어서 놓기 작업이 취소 되 고 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트 처리기입니다.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 다음 코드 예제를 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.DragDropEffects> 끌어서 놓기 작업에 사용 되는 컨트롤 간의 데이터를 전송 하는 방법을 지정 하는 열거형입니다. 이 예제에서는 폼에 포함 되어 있는지는 <xref:System.Windows.Forms.RichTextBox> 제어 및 <xref:System.Windows.Forms.ListBox> 컨트롤과 하는 <xref:System.Windows.Forms.ListBox> 컨트롤이 올바른 파일 이름 목록으로 채워집니다. 사용자 파일 이름을 끌 때는 <xref:System.Windows.Forms.RichTextBox> 컨트롤, 컨트롤의 <xref:System.Windows.Forms.Control.DragEnter> 이벤트가 발생 합니다. 이벤트 처리기 내에서 <xref:System.Windows.Forms.DragEventArgs.Effect%2A> 속성의는 <xref:System.Windows.Forms.DragEventArgs> 로 초기화 <xref:System.Windows.Forms.DragDropEffects> 파일 경로에서 참조 하는 데이터에 복사 되어야 함을 나타내려면는 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤에서 깜빡임을 줄이거나 방지하기 위해 보조 버퍼를 사용하여 화면을 다시 그려야 하는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이중 버퍼링을 사용하여 컨트롤의 화면을 그려야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 버퍼링 된 그래픽 줄이거나 깜빡임을 점진적으로 다시 그리면은 표시 된 화면의 부분의 발생 하는 제거할 수 있습니다. 버퍼링 된 그래픽에서는 업데이트 된 데이터 버퍼에 먼저 기록 됩니다. 다음 그래픽 버퍼의 데이터를 표시 된 화면 메모리에 신속 하 게 기록 됩니다. 일반적으로 표시 된 그래픽 메모리의 상대적으로 더 빨리 스위치 깜빡임을 그 밖에 발생할 수를 줄입니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A> 바인딩 가능한 속성이 아닙니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 두 번 클릭하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 번 클릭은 운영 체제의 마우스 설정에 따라 결정 됩니다. 천천히 두 번 클릭하는 것이 아닌 두 번 클릭(double-click)으로 간주될 수 있도록 마우스 단추 클릭 간격을 설정할 수 있습니다. <xref:System.Windows.Forms.Control.Click> 이벤트는 컨트롤을 두 번 클릭할 때마다 발생 합니다. 예를 들어에 대 한 이벤트 처리기가는 <xref:System.Windows.Forms.Control.Click> 및 <xref:System.Windows.Forms.Control.DoubleClick> 의 이벤트는 <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Click> 및 <xref:System.Windows.Forms.Control.DoubleClick> 발생 하는 폼을 두 번 클릭 하 고 두 방법 모두 호출 됩니다. 컨트롤을 두 번 클릭 하는 경우 및 컨트롤을 지원 하지 않습니다는 <xref:System.Windows.Forms.Control.DoubleClick> 이벤트는 <xref:System.Windows.Forms.Control.Click> 이벤트를 두 번 발생할 수 있습니다.  
  
 설정 해야 합니다는 `StandardDoubleClick` 및 `StandardClick` 값 <xref:System.Windows.Forms.ControlStyles> 를 `true` 이 이벤트를 발생 합니다. 이러한 값으로 이미 설정 되었을 `true` 기존 계획에서 상속 하는 경우에 Windows Forms 컨트롤입니다.  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.DoubleClick> 의 이벤트는 <xref:System.Windows.Forms.ListBox> 에 나열 된 텍스트 파일을 로드 하는 <xref:System.Windows.Forms.ListBox> 에 <xref:System.Windows.Forms.TextBox> 제어 합니다.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>표준 Windows Forms 컨트롤에서 상속 하 고 변경 된 <see langword="StandardClick" /> 또는 <see langword="StandardDoubleClick" /> 값의 <see cref="T:System.Windows.Forms.ControlStyles" /> 를 <see langword="true" /> 효과가 없습니다. 모든 컨트롤을 지원 하지 않는 경우 하거나 예기치 않은 동작이 발생할 수 있습니다는 <see cref="E:System.Windows.Forms.Control.Click" /> 또는 <see cref="E:System.Windows.Forms.Control.DoubleClick" />이벤트입니다.  
  
 다음 표에서 Windows Forms 컨트롤 및 이벤트 (event) (<see cref="E:System.Windows.Forms.Control.Click" /> 또는 <see cref="E:System.Windows.Forms.Control.DoubleClick" />)는 지정 된 마우스 작업에 대 한 응답에서 발생 합니다.  
  
 <list type="table"><listheader><term> 컨트롤  
  
 </term><description> 마우스 왼쪽된 단추 클릭  
  
 </description><description> 왼쪽된 마우스 두 번 클릭  
  
 </description><description> 마우스 오른쪽 단추 클릭  
  
 </description><description> 마우스 오른쪽 단추 두 번 클릭  
  
 </description><description> 마우스 가운데 단추 클릭  
  
 </description><description> 마우스 가운데 단추를 두 번 클릭  
  
 </description><description> XButton1 마우스 클릭  
  
 </description><description> XButton1 마우스 두 번 클릭  
  
 </description><description> XButton2 마우스 클릭  
  
 </description><description> XButton2 마우스 두 번 클릭  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />,  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />,  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />,  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />,  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />,  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />,  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \* <see cref="T:System.Windows.Forms.ListView" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description><description> 없음  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description><description> 클릭  
  
 </description><description> Click, Click  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />,  
  
 <see cref="T:System.Windows.Forms.Label" />,  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />,  
  
 <see cref="T:System.Windows.Forms.Panel" />,  
  
 <see cref="T:System.Windows.Forms.GroupBox" />,  
  
 <see cref="T:System.Windows.Forms.PictureBox" />,  
  
 <see cref="T:System.Windows.Forms.Splitter" />,  
  
 <see cref="T:System.Windows.Forms.StatusBar" />,  
  
 <see cref="T:System.Windows.Forms.ToolBar" />,  
  
 <see cref="T:System.Windows.Forms.TabPage" />,  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description><description> 클릭  
  
 </description><description> Click, DoubleClick  
  
 </description></item></list>  
  
 \* 마우스 포인터가 자식 개체에 대해 이어야 합니다 (<see cref="T:System.Windows.Forms.TreeNode" /> 또는 <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
 * *는 <see cref="T:System.Windows.Forms.TabControl" /> 하나 이상 있어야 <see cref="T:System.Windows.Forms.TabPage" /> 에 해당 <see cref="P:System.Windows.Forms.TabControl.TabPages" /> 컬렉션입니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 컨트롤 또는 양식의 DPI가 변경된 후에 컨트롤의 DPI 설정이 프로그래밍 방식으로 변경되면 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 컨트롤 또는 양식에 대한 DPI 변경 이벤트가 발생하기 전에 컨트롤의 DPI 설정이 프로그래밍 방식으로 변경되면 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>끌어서 놓기 작업이 완료될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DragEventArgs.X%2A> 및 <xref:System.Windows.Forms.DragEventArgs.Y%2A> 속성의는 <xref:System.Windows.Forms.DragEventArgs> 에 화면 좌표를 클라이언트 좌표로 표시 되지 않습니다. Visual C# 코드의 다음 줄을 클라이언트로 속성 변환 <xref:System.Drawing.Point>합니다.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  버전에서 보다 이전 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]을 넣고는 <xref:System.Windows.Forms.UserControl> 와 <xref:System.Windows.Forms.Control.DragEnter> 및 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 Windows Form에 끌어다 놓습니다로 요소는 <xref:System.Windows.Forms.UserControl> 디자인 타임에는 `DropDrop` 및 `DropEnter` 이벤트는 발생합니다. 그러나 닫았다가 솔루션을 다시 열고는 <xref:System.Windows.Forms.Control.DragEnter> 및 <xref:System.Windows.Forms.Control.DragDrop> 이벤트가 다시 발생 하지 않습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 이 코드 발췌 한 구문을 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Control.DragDrop> 이벤트입니다. 참조는 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 전체 코드 예제에 대 한 메서드.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개체를 컨트롤의 범위 안으로 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragEnter> 처음으로 가져왔을 마우스 커서를 컨트롤 위로 끌어서 놓기 작업 중 때 이벤트가 발생 합니다.  
  
> [!NOTE]
>  버전에서 보다 이전 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]을 넣고는 <xref:System.Windows.Forms.UserControl> 와 <xref:System.Windows.Forms.Control.DragEnter> 및 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 Windows Form에 끌어다 놓습니다로 요소는 <xref:System.Windows.Forms.UserControl> 디자인 타임에는 `DropDrop` 및 `DropEnter` 이벤트는 발생합니다. 그러나 닫았다가 솔루션을 다시 열고는 <xref:System.Windows.Forms.Control.DragEnter> 및 <xref:System.Windows.Forms.Control.DragDrop> 이벤트가 다시 발생 하지 않습니다.  
  
 다음에서는 끌어서 놓기 작업이 발생하는 방식 및 시기에 대해 설명합니다.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드는 현재 커서 위치에서 컨트롤을 확인 합니다. 그런 다음 컨트롤은 유효한 놓기 대상 인지 확인 합니다.  
  
 컨트롤이 유효한 놓기 대상일 경우는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 지정 된 끌어서 놓기 효과 함께 발생 합니다. 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
 마우스 커서 위치, 키보드 상태 및 마우스 단추 상태의 변경 내용을 추적합니다.  
  
-   사용자가 창의 외부로 이동하면 <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생합니다.  
  
-   마우스를 다른 컨트롤로 가져가면 해당 컨트롤에 대한 <xref:System.Windows.Forms.Control.DragEnter>가 발생합니다.  
  
-   마우스를 동일한 컨트롤 내에서 이동하면 <xref:System.Windows.Forms.Control.DragOver> 이벤트가 발생합니다.  
  
 키보드 또는 마우스 단추 상태가 변경 될 경우는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트가 발생 하 고 데이터를 끌기를 계속할지 여부를 결정 하거나의 값을 기준으로 작업을 취소 하는 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 이벤트의 속성 <xref:System.Windows.Forms.QueryContinueDragEventArgs>합니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Continue`, <xref:System.Windows.Forms.Control.DragOver> 이벤트 작업을 계속 하려면는 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 적절 한 시각적 피드백이 설정 될 수 있도록 새로운 효과 함께 발생 합니다. 유효한 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver> 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 쌍을 이루고 있어서 마우스가 놓기 대상을 통과할 사용자에 게 마우스 위치에 대 한 최신 피드백이 제공 됩니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Drop`, 놓기 효과 값이 원본에 반환, 되므로 소스 응용 프로그램이 소스 데이터에 대해 적절 한 작업을 수행할 수 예를 들어 데이터 잘라내기 작업이 이동 인 경우.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생 합니다.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.DragEventArgs.X%2A> 및 <xref:System.Windows.Forms.DragEventArgs.Y%2A> 속성의는 <xref:System.Windows.Forms.DragEventArgs> 에 화면 좌표를 클라이언트 좌표로 표시 되지 않습니다. Visual C# 코드의 다음 줄을 클라이언트로 속성 변환 <xref:System.Drawing.Point>합니다.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 끌어서 놓기 작업을 보여 줍니다. <xref:System.Windows.Forms.ListBox> 컨트롤입니다. 예제에서는 호출은 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 끌기 작업이 시작 될 때 메서드. 마우스를 이동 하는 경우 끌기 작업이 시작 이상 <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> 하는 동안 마우스 위치에서의 <xref:System.Windows.Forms.Control.MouseDown> 이벤트입니다. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 메서드 결정 하는 동안 끌어 항목의 인덱스를 사용 하는 `MouseDown` 이벤트입니다.  
  
 또한이 예제에서는 끌어서 놓기 작업에 대 한 사용자 지정 커서를 사용 하 여 보여 줍니다. 이 예제를 실행 하려면 커서 파일 `3dwarro.cur` 및 `3dwno.cur`, 사용자 지정 끌어서에 대 한 응용 프로그램 디렉터리에 있으면 놓기-커서, 각각. 사용자 지정 커서 사용 하는 경우는 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> 을 선택 합니다. 에 설정 된 사용자 지정 커서는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트 처리기입니다.  
  
 키보드 상태에서 평가 됩니다는 <xref:System.Windows.Forms.Control.DragOver> 오른쪽에 대 한 이벤트 처리기 `ListBox`항목 끌기 작업을 결정 하는, SHIFT, CTRL 및 ALT, CTRL + ALT 키의 상태를 기반 합니다. 위치는 `ListBox` 삭제가 발생 중도 결정 됩니다는 `DragOver` 이벤트입니다. 삭제할 데이터가 아닌 경우는 `String`, 하면 <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> 로 설정 된 `None` 에서 <xref:System.Windows.Forms.DragDropEffects>합니다. 드롭다운 상태에 표시 되는 마지막으로,는 `DropLocationLabel` <xref:System.Windows.Forms.Label>합니다.  
  
 데이터를 오른쪽에 대 한 drop `ListBox` 에 따라 결정 됩니다는 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 처리기 및 `String` 적절 한 위치에서 값이 추가 `ListBox`합니다. 끌기 작업, 폼의 경계를 벗어나면 경우에서 끌어서 놓기 작업이 취소 되 고 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트 처리기입니다.  
  
 이 코드 발췌 한 구문을 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Control.DragEnter> 이벤트입니다. 참조는 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 전체 코드 예제에 대 한 메서드.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 범위 밖으로 개체를 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragLeave> 이벤트는 현재 끌어서 놓기 작업을 취소 하는 사용자 또는 사용자가 컨트롤에서 커서를 끌 때 발생 합니다.  
  
 다음에서는 끌어서 놓기 작업이 발생하는 방식 및 시기에 대해 설명합니다.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드는 현재 커서 위치에서 컨트롤을 확인 합니다. 그런 다음 컨트롤은 유효한 놓기 대상 인지 확인 합니다.  
  
 컨트롤이 유효한 놓기 대상일 경우는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 지정 된 끌어서 놓기 효과 함께 발생 합니다. 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
 마우스 커서 위치, 키보드 상태 및 마우스 단추 상태의 변경 내용을 추적합니다.  
  
-   사용자가 창의 외부로 이동하면 <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생합니다.  
  
-   마우스를 다른 컨트롤로 가져가면 해당 컨트롤에 대한 <xref:System.Windows.Forms.Control.DragEnter>가 발생합니다.  
  
-   마우스를 동일한 컨트롤 내에서 이동하면 <xref:System.Windows.Forms.Control.DragOver> 이벤트가 발생합니다.  
  
 키보드 또는 마우스 단추 상태가 변경 될 경우는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트가 발생 하 고 데이터를 끌기를 계속할지 여부를 결정 하거나의 값을 기준으로 작업을 취소 하는 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 이벤트의 속성 <xref:System.Windows.Forms.QueryContinueDragEventArgs>합니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Continue`, <xref:System.Windows.Forms.Control.DragOver> 이벤트 작업을 계속 하려면는 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 적절 한 시각적 피드백이 설정 될 수 있도록 새로운 효과 함께 발생 합니다. 유효한 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver> 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 쌍을 이루고 있어서 마우스가 놓기 대상을 통과할 사용자에 게 마우스 위치에 대 한 최신 피드백이 제공 됩니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Drop`, 놓기 효과 값이 원본에 반환, 되므로 소스 응용 프로그램이 소스 데이터에 대해 적절 한 작업을 수행할 수 예를 들어 데이터 잘라내기 작업이 이동 인 경우.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 끌어서 놓기 작업을 보여 줍니다. <xref:System.Windows.Forms.ListBox> 컨트롤입니다. 예제에서는 호출은 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 끌기 작업이 시작 될 때 메서드. 마우스를 이동 하는 경우 끌기 작업이 시작 이상 <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> 하는 동안 마우스 위치에서의 <xref:System.Windows.Forms.Control.MouseDown> 이벤트입니다. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 메서드 결정 하는 동안 끌어 항목의 인덱스를 사용 하는 `MouseDown` 이벤트입니다.  
  
 또한이 예제에서는 끌어서 놓기 작업에 대 한 사용자 지정 커서를 사용 하 여 보여 줍니다. 이 예제를 실행 하려면 커서 파일 `3dwarro.cur` 및 `3dwno.cur`, 사용자 지정 끌어서에 대 한 응용 프로그램 디렉터리에 있으면 놓기-커서, 각각. 사용자 지정 커서 사용 하는 경우는 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> 을 선택 합니다. 에 설정 된 사용자 지정 커서는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트 처리기입니다.  
  
 키보드 상태에서 평가 됩니다는 <xref:System.Windows.Forms.Control.DragOver> 오른쪽에 대 한 이벤트 처리기 `ListBox`항목 끌기 작업을 결정 하는, SHIFT, CTRL 및 ALT, CTRL + ALT 키의 상태를 기반 합니다. 위치는 `ListBox` 삭제가 발생 중도 결정 됩니다는 `DragOver` 이벤트입니다. 삭제할 데이터가 아닌 경우는 `String`, 하면 <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> 로 설정 된 `None` 에서 <xref:System.Windows.Forms.DragDropEffects>합니다. 드롭다운 상태에 표시 되는 마지막으로,는 `DropLocationLabel` <xref:System.Windows.Forms.Label>합니다.  
  
 데이터를 오른쪽에 대 한 drop `ListBox` 에 따라 결정 됩니다는 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 처리기 및 `String` 적절 한 위치에서 값이 추가 `ListBox`합니다. 끌기 작업, 폼의 경계를 벗어나면 경우에서 끌어서 놓기 작업이 취소 되 고 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트 처리기입니다.  
  
 이 코드 발췌 한 구문을 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Control.DragLeave> 이벤트입니다. 참조는 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 전체 코드 예제에 대 한 메서드.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개체를 컨트롤의 범위 위로 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragOver> 이벤트는 끌어서 놓기 작업 동안 컨트롤의 범위 내에서 마우스 커서를 이동 하면 발생 합니다.  
  
 다음에서는 끌어서 놓기 작업이 발생하는 방식 및 시기에 대해 설명합니다.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드는 현재 커서 위치에서 컨트롤을 확인 합니다. 그런 다음 컨트롤은 유효한 놓기 대상 인지 확인 합니다.  
  
 컨트롤이 유효한 놓기 대상일 경우는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 지정 된 끌어서 놓기 효과 함께 발생 합니다. 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
 마우스 커서 위치, 키보드 상태 및 마우스 단추 상태의 변경 내용을 추적합니다.  
  
-   사용자가 창의 외부로 이동하면 <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생합니다.  
  
-   마우스를 다른 컨트롤로 가져가면 해당 컨트롤에 대한 <xref:System.Windows.Forms.Control.DragEnter>가 발생합니다.  
  
-   마우스를 동일한 컨트롤 내에서 이동하면 <xref:System.Windows.Forms.Control.DragOver> 이벤트가 발생합니다.  
  
 키보드 또는 마우스 단추 상태가 변경 될 경우는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트가 발생 하 고 데이터를 끌기를 계속할지 여부를 결정 하거나의 값을 기준으로 작업을 취소 하는 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 이벤트의 속성 <xref:System.Windows.Forms.QueryContinueDragEventArgs>합니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 값은 `Continue`, <xref:System.Windows.Forms.Control.DragOver> 이벤트 작업을 계속 하려면는 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 적절 한 시각적 피드백이 설정 될 수 있도록 새로운 효과 함께 발생 합니다. 유효한 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver> 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 쌍을 이루고 있어서 마우스가 놓기 대상을 통과할 사용자에 게 마우스 위치에 대 한 최신 피드백이 제공 됩니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Drop`, 놓기 효과 값이 원본에 반환, 되므로 소스 응용 프로그램이 소스 데이터에 대해 적절 한 작업을 수행할 수 예를 들어 데이터 잘라내기 작업이 이동 인 경우.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생 합니다.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.DragEventArgs.X%2A> 및 <xref:System.Windows.Forms.DragEventArgs.Y%2A> 속성의는 <xref:System.Windows.Forms.DragEventArgs> 에 화면 좌표를 클라이언트 좌표로 표시 되지 않습니다. C# 코드의 다음 줄을 클라이언트로 속성 변환 <xref:System.Drawing.Point>:  
    >   
    >  Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 끌어서 놓기 작업을 보여 줍니다. <xref:System.Windows.Forms.ListBox> 컨트롤입니다. 예제에서는 호출은 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 끌기 작업이 시작 될 때 메서드. 마우스를 이동 하는 경우 끌기 작업이 시작 이상 <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> 하는 동안 마우스 위치에서의 <xref:System.Windows.Forms.Control.MouseDown> 이벤트입니다. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 메서드 결정 하는 동안 끌어 항목의 인덱스를 사용 하는 `MouseDown` 이벤트입니다.  
  
 또한이 예제에서는 끌어서 놓기 작업에 대 한 사용자 지정 커서를 사용 하 여 보여 줍니다. 이 예제를 실행 하려면 커서 파일 `3dwarro.cur` 및 `3dwno.cur`, 사용자 지정 끌어서에 대 한 응용 프로그램 디렉터리에 있으면 놓기-커서, 각각. 사용자 지정 커서 사용 하는 경우는 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> 을 선택 합니다. 에 설정 된 사용자 지정 커서는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트 처리기입니다.  
  
 키보드 상태에서 평가 됩니다는 <xref:System.Windows.Forms.Control.DragOver> 오른쪽에 대 한 이벤트 처리기 `ListBox`항목 끌기 작업을 결정 하는, SHIFT, CTRL 및 ALT, CTRL + ALT 키의 상태를 기반 합니다. 위치는 `ListBox` 삭제가 발생 중도 결정 됩니다는 `DragOver` 이벤트입니다. 삭제할 데이터가 아닌 경우는 `String`, 하면 <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> 로 설정 된 `None` 에서 <xref:System.Windows.Forms.DragDropEffects>합니다. 드롭다운 상태에 표시 되는 마지막으로,는 `DropLocationLabel` <xref:System.Windows.Forms.Label>합니다.  
  
 데이터를 오른쪽에 대 한 drop `ListBox` 에 따라 결정 됩니다는 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 처리기 및 `String` 적절 한 위치에서 값이 추가 `ListBox`합니다. 끌기 작업, 폼의 경계를 벗어나면 경우에서 끌어서 놓기 작업이 취소 되 고 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트 처리기입니다.  
  
 이 코드 발췌 한 구문을 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Control.DragOver> 이벤트입니다. 참조는 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 전체 코드 예제에 대 한 메서드.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">그릴 비트맵입니다.</param>
        <param name="targetBounds">컨트롤이 렌더링되는 범위입니다.</param>
        <summary>지정한 비트맵에서의 렌더링을 지원합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A> ActiveX 컨트롤에 대 한 메서드가 지원 되지 않습니다. 재정의할 수 있습니다는 <xref:System.Windows.Forms.Control.OnPrint%2A> 이벤트 하 고 필요한 경우 사용자 지정 인쇄 논리를 제공 합니다.  
  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A> 메서드에 다음과 같은 제한이 있습니다.  
  
-   <xref:System.ArgumentException> 큰 비트맵에 대해 throw 될 수 있습니다. 허용 되는 최대 크기는 컴퓨터에 따라 다릅니다.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> 지원 하지 않습니다는 `Ink` Windows XP Tablet PC Edition 2005 운영 체제에 대 한 제어 합니다.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> 자식 그리지 않습니다 <xref:System.Windows.Forms.TextBox> 경우는 <xref:System.Windows.Forms.Control.Visible%2A> 의 속성은 <xref:System.Windows.Forms.TextBox> 로 설정 된 `false`합니다.  
  
-   컨테이너 내에 있는 컨트롤 역순으로 렌더링 됩니다.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> 에 대 한 완전히 작동 하지 않습니다는 <xref:System.Windows.Forms.RichTextBox>에게만 비트맵의 테두리를 그립니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 사용자 상호 작용에 응답할 수 있는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤이 사용자 상호 작용에 응답할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 <xref:System.Windows.Forms.Control.Enabled%2A> 속성을 런타임에 컨트롤을 사용 하지 않도록 설정 하거나 설정할 수 있습니다. 예를 들어 응용 프로그램의 현재 상태에 적용 되지 않는 컨트롤을 비활성화할 수 있습니다. 또한 해당 사용을 제한 하는 컨트롤을 해제할 수 있습니다. 예를 들어 사용자가 클릭 하지 않도록 하려면 단추를 해제할 수 있습니다. 컨트롤이 비활성화 된 경우에 선택할 수 없습니다.  
  
> [!IMPORTANT]
>  설정의 <xref:System.Windows.Forms.Control.Enabled%2A> 속성을 `false` 응용 프로그램의 컨트롤 상자를 사용 하지 않도록 설정 하지 않거나 응용 프로그램 창에서 포커스를 받을 방지 합니다.  
  
 컨테이너 컨트롤의 enabled 속성을 설정 하는 경우 `false`, 포함 된 모든 컨트롤도 비활성화 됩니다. 예를 들어 사용자가 비활성화 된에 포함 된 컨트롤은 클릭할 경우 <xref:System.Windows.Forms.GroupBox> 컨트롤은 이벤트가 발생 하지 않습니다.  
  
> [!NOTE]
>  스크롤할 수 있는 컨트롤을 사용 하지 않도록 설정 하는 경우 스크롤 막대가 조건도 비활성화 됩니다. 예를 들어 사용할 수 없는 여러 줄 textbox가 텍스트의 모든 줄을 표시 하려면 스크롤할 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Windows.Forms.GroupBox> 공통 속성 중 일부를 설정 합니다. 이 예에서는 만듭니다는 <xref:System.Windows.Forms.TextBox> 설정 하 고 해당 <xref:System.Windows.Forms.Control.Location%2A> 그룹 상자 내에서. 그런 다음 설정의 <xref:System.Windows.Forms.Control.Text%2A> 그룹 상자 및 폼의 위쪽에 도킹 된 그룹 상자 속성입니다. 마지막으로, 그룹 상자 설정 하 여 비활성화는 <xref:System.Windows.Forms.Control.Enabled%2A> 속성을 `false`, 사용 하지 않도록 설정할 그룹 상자에 포함 된 모든 컨트롤에 이르게 됩니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Enabled" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Enabled%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 두 <xref:System.Windows.Forms.RadioButton> 보여 주기 위해 컨트롤의 <xref:System.Windows.Forms.Control.EnabledChanged> 이벤트입니다. 값을 변경 하 한 단추를 클릭 하는 <xref:System.Windows.Forms.Control.Enabled%2A> 하는 다른 단추의 속성 `false` 표시는 <xref:System.Windows.Forms.MessageBox>합니다.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />를 호출할 때 반환되는 특정 호출 비동기 작업을 나타내는 <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />입니다.</param>
        <summary>전달된 <see cref="T:System.IAsyncResult" />가 나타내는 비동기 작업의 반환 값을 검색합니다.</summary>
        <returns>비동기 작업을 통해 생성되는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 작업이 완료 되지 않은 경우이 함수는 결과가 나올 때까지 차단 됩니다.  
  
> [!NOTE]
>  외에 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 속성에는 스레드로부터 안전 컨트롤에서 네 가지 메서드가 있습니다: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, 및 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다. 다른 모든 메서드 호출에 대 한 사용할지 invoke 메서드 중 하나를 컨트롤의 스레드에 대 한 호출을 마샬링하 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 매개 변수 값이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">이전에 동일한 컨트롤에서 <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> 메서드를 호출하여 <paramref name="asyncResult" /> 개체를 만들지 않은 경우</exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 입력되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 키보드 (TAB, SHIFT + TAB 등)를 사용 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Select%2A> 또는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드를 설정 하거나는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> 속성을 현재 폼으로 포커스 이벤트가 다음 순서 대로 발생:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 마우스를 사용 하거나 호출 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드, 포커스 이벤트가 다음 순서 대로 발생 합니다.  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Enter> 및 <xref:System.Windows.Forms.Control.Leave> 이벤트에 의해 표시 되는 <xref:System.Windows.Forms.Form> 클래스입니다. 에 해당 하는 이벤트는 <xref:System.Windows.Forms.Form> 클래스는 <xref:System.Windows.Forms.Form.Activated> 및 <xref:System.Windows.Forms.Form.Deactivate> 이벤트입니다. <xref:System.Windows.Forms.Control.Enter> 및 <xref:System.Windows.Forms.Control.Leave> 이벤트는 계층적 및 적절 한 컨트롤에 도달할 때까지 부모 체인 위쪽 및 아래쪽 연계 됩니다. 예를 들어 있다고 가정는 <xref:System.Windows.Forms.Form> 두 개의 <xref:System.Windows.Forms.GroupBox> 컨트롤 및 각 <xref:System.Windows.Forms.GroupBox> 컨트롤에 하나 <xref:System.Windows.Forms.TextBox> 제어 합니다. 하나에서 캐럿을 이동할 때 <xref:System.Windows.Forms.TextBox> 다른는 <xref:System.Windows.Forms.Control.Leave> 에 대 한 이벤트는 <xref:System.Windows.Forms.TextBox> 및 <xref:System.Windows.Forms.GroupBox>, 및 <xref:System.Windows.Forms.Control.Enter> 이벤트가 발생 하면 다른 <xref:System.Windows.Forms.GroupBox> 및 <xref:System.Windows.Forms.TextBox>합니다.  
  
> [!CAUTION]
>  내에서 포커스를 설정 하지 마십시오는 <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, 또는 <xref:System.Windows.Forms.Control.Validated> 이벤트 처리기입니다. 이렇게 하면 응용 프로그램 또는 운영 체제 응답 하지 발생할 수 있습니다. 자세한 내용은 참조는 `WM_KILLFOCUS` "키보드 입력 참조" 섹션 및의 "메시지 교착 상태" 섹션에 있는 항목은[에 대 한 메시지와 메시지 큐](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)항목입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Enter> 의 전경색과 배경색 색을 변경 하는 이벤트는 <xref:System.Windows.Forms.TextBox> 특정 조건 하에서 합니다.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤이 포함된 폼을 검색합니다.</summary>
        <returns>컨트롤이 포함된 <see cref="T:System.Windows.Forms.Form" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 <xref:System.Windows.Forms.Control.Parent%2A> 속성 값 수와 같을 수 없습니다는 <xref:System.Windows.Forms.Form> 반환한 <xref:System.Windows.Forms.Control.FindForm%2A> 메서드. 예를 들어 경우는 <xref:System.Windows.Forms.RadioButton> 컨트롤 내에 포함 된 한 <xref:System.Windows.Forms.GroupBox> 컨트롤 및 <xref:System.Windows.Forms.GroupBox> 에 <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.RadioButton> 컨트롤의 <xref:System.Windows.Forms.Control.Parent%2A> 는 <xref:System.Windows.Forms.GroupBox> 및 <xref:System.Windows.Forms.GroupBox> 컨트롤의 <xref:System.Windows.Forms.Control.Parent%2A>는 <xref:System.Windows.Forms.Form>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정 된 단추를 포함 하는 폼을 찾습니다.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤에 대한 입력 포커스를 설정합니다.</summary>
        <returns>
          입력 포커스 요청이 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Focus%2A> 메서드 반환 `true` 컨트롤이 입력된 포커스를 성공적으로 수신 하는 경우. 컨트롤 표시 하지 않고도 모든 시각적 포커스의 입력된 포커스를 가질 수 있습니다. 아래에 나열 된 선택할 수 없는 컨트롤에서이 동작은 주로 볼 또는 모든 컨트롤에서 파생 된 해당 합니다.  
  
 컨트롤을 선택 하 고 다음에 해당할 경우 입력된 포커스를 받을:는 `Selectable` 의 값 <xref:System.Windows.Forms.ControlStyles> 로 설정 된 `true`, 다른 컨트롤에 포함 된 및 모든 부모 컨트롤이 표시 되 고 사용 하도록 설정 되어 있습니다.  
  
 다음 목록에 Windows Forms 컨트롤은 선택할 수 있습니다. 이러한 컨트롤에서 파생 된 컨트롤은도 선택할 수 없습니다.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (이 경우 컨트롤에 링크가)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A> 하위 수준 메서드는 사용자 지정 컨트롤 작성자 주로 위한 것입니다. 대신, 응용 프로그램 프로그래머를 사용 해야는 <xref:System.Windows.Forms.Control.Select%2A> 메서드 또는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> 자식 컨트롤에 대 한 속성 또는 <xref:System.Windows.Forms.Form.Activate%2A> 폼에 대 한 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정 된 포커스를 설정 <xref:System.Windows.Forms.Control>포커스를 받을 수 있으면, 합니다.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 입력 포커스가 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤에 포커스가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 사용 하지 않도록 설정 된 <xref:System.Windows.Forms.MenuItem> 경우는 <xref:System.Windows.Forms.TextBox> 포커스가 없는 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.TextBox> 라는 `textBox1` 와 두 개의 <xref:System.Windows.Forms.MenuItem> 개체의 명명 된 `menuItemEdit` 및 `menuItemEditInsertCustomerInfo`합니다.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.Focused" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.Focused" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 표시되는 텍스트의 글꼴을 가져오거나 설정합니다.</summary>
        <value>컨트롤에 표시되는 텍스트에 적용되는 <see cref="T:System.Drawing.Font" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultFont" /> 속성 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Font%2A> 속성이 앰비언트 속성입니다. 그렇지 않은 경우, 즉 앰비언트 속성은 컨트롤 속성 설정, 부모 컨트롤에서 검색 됩니다. 예를 들어 한 <xref:System.Windows.Forms.Button> 같은 가질 수 <xref:System.Windows.Forms.Control.BackColor%2A> 부모로 <xref:System.Windows.Forms.Form> 기본적으로 합니다. 앰비언트 속성에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.AmbientProperties> 클래스 또는 <xref:System.Windows.Forms.Control> 클래스 개요입니다.  
  
 때문에 <xref:System.Drawing.Font> 는 변경할 수 없습니다 (조정할 수 없는 속성을 의미)를 할당할 수 있습니다는 <xref:System.Windows.Forms.Control.Font%2A> 는 새 <xref:System.Drawing.Font>합니다. 그러나 기존 글꼴에 새 글꼴을 만들 수 있습니다.  
  
 [Visual Basic, C#]  
  
 다음은 기존 글꼴을 굵게를 조정 하는 방법의 예입니다.  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.FontDialog> 사용자 및 변경 내용에는 <xref:System.Drawing.Font> 의 <xref:System.Windows.Forms.DateTimePicker> 제어 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 와 <xref:System.Windows.Forms.Button> 및 <xref:System.Windows.Forms.DateTimePicker> 에 있습니다.  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.Font" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.Font" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.Font" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Font" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Font%2A> 속성이 상호 작용을 통해 또는 프로그래밍 방식으로 수정으로 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Control.FontChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 글꼴 높이를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 <see cref="T:System.Drawing.Font" /> 높이(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.FontHeight%2A> 속성은 컨트롤의 이외의 다른 값으로 설정 하지 <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType> 값 또는-1입니다. 설정 <xref:System.Windows.Forms.Control.FontHeight%2A> -1로는 캐시 된 높이 값을 지우면의 효과가 없으며 값 속성이 참조 되는 다음에 다시 계산 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 전경색을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 전경 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultForeColor" /> 속성 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ForeColor%2A> 속성이 앰비언트 속성입니다. 그렇지 않은 경우, 즉 앰비언트 속성은 컨트롤 속성 설정, 부모 컨트롤에서 검색 됩니다. 예를 들어 한 <xref:System.Windows.Forms.Button> 같은 가질 수 <xref:System.Windows.Forms.Control.BackColor%2A> 부모로 <xref:System.Windows.Forms.Form> 기본적으로 합니다. 앰비언트 속성에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.AmbientProperties> 클래스 또는 <xref:System.Windows.Forms.Control> 클래스 개요입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.BackColor%2A> 및 <xref:System.Windows.Forms.Control.ForeColor%2A> 컨트롤을 기본 시스템 색상입니다. 코드 재귀적으로 컨트롤에 자식 컨트롤이 경우 자신을 호출 합니다. 이 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하나 이상의 자식 컨트롤과; 그러나 자식 컨테이너 컨트롤, like는 <xref:System.Windows.Forms.Panel> 또는 <xref:System.Windows.Forms.GroupBox>, 자체 자식 컨트롤은 보다 잘 보여 주는 재귀 합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.ForeColor" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.ForeColor" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.ForeColor" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ForeColor" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.ForeColor%2A> 속성이 상호 작용을 통해 또는 프로그래밍 방식으로 수정으로 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트 처리기 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 *PropertyName* `Changed` 있는 될 때 발생 하는 해당 *PropertyName* 값이 변경 (* PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">검색할 창 핸들(<see langword="HWND" />)입니다.</param>
        <summary>지정된 핸들이 포함된 컨트롤을 검색합니다.</summary>
        <returns>지정된 핸들과 연결된 컨트롤을 나타내는 <see cref="T:System.Windows.Forms.Control" />입니다. 지정된 핸들이 있는 컨트롤이 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 컨트롤과 연결 된 하는 핸들을 찾을 때까지 창 핸들 부모 체인을 검색 합니다. 이 메서드는 보다 안정적는 <xref:System.Windows.Forms.Control.FromHandle%2A> 메서드를 여러 개 핸들을 소유 하는 컨트롤을 제대로 반환 하기 때문에 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">검색할 창 핸들(<see langword="HWND" />)입니다.</param>
        <summary>지정된 핸들과 연결된 컨트롤을 반환합니다.</summary>
        <returns>지정된 핸들과 연결된 컨트롤을 나타내는 <see cref="T:System.Windows.Forms.Control" />입니다. 지정된 핸들이 있는 컨트롤이 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Windows.Forms.Control.FromChildHandle%2A> 메서드 둘 이상의 핸들을 소유 하는 컨트롤을 반환 해야 하는 경우.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="objectId">검색할 <see langword="Int32" />를 식별하는 <see cref="T:System.Windows.Forms.AccessibleObject" />입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.Forms.AccessibleObject" />를 검색합니다.</summary>
        <returns>지정된 <see cref="T:System.Windows.Forms.AccessibleObject" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 <see cref="P:System.Windows.Forms.Control.AutoSize" /> 속성을 사용할 수 있을 때 컨트롤이 동작하는 방법을 나타내는 값을 검색합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.AutoSizeMode" /> 값 중 하나입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 위치에 있는 자식 컨트롤을 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">컨트롤을 찾을 좌표가 포함된 <see cref="T:System.Drawing.Point" />입니다. 좌표는 컨트롤 클라이언트 영역의 왼쪽 위 모퉁이를 기준으로 표시됩니다.</param>
        <summary>지정된 좌표에 위치한 자식 컨트롤을 검색합니다.</summary>
        <returns>지정된 지점에 위치한 컨트롤을 나타내는 <see cref="T:System.Windows.Forms.Control" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정된 된 지점에서 자식 컨트롤이 없는 경우는 <xref:System.Windows.Forms.Control.GetChildAtPoint%2A> 메서드 반환 `null`합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 windows 컨트롤을 반환 하는 경우이 메서드를 호출 하는 데 아닌 경우 컨트롤의 자식 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" />
      </Parameters>
      <Docs>
        <param name="pt">컨트롤을 찾을 좌표가 포함된 <see cref="T:System.Drawing.Point" />입니다. 좌표는 컨트롤 클라이언트 영역의 왼쪽 위 모퉁이를 기준으로 표시됩니다.</param>
        <param name="skipValue">특정 형식의 자식 컨트롤을 무시할지를 결정하는 <see cref="T:System.Windows.Forms.GetChildAtPointSkip" /> 값 중 하나입니다.</param>
        <summary>지정한 좌표에 있는 자식 컨트롤을 검색하여 특정 형식의 자식 컨트롤을 무시할지를 지정합니다.</summary>
        <returns>지정한 좌표의 자식 <see cref="T:System.Windows.Forms.Control" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 컨트롤의 부모 컨트롤 체인까지 다음 <see cref="T:System.Windows.Forms.ContainerControl" />을 반환합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.IContainerControl" />의 부모를 나타내는 <see cref="T:System.Windows.Forms.Control" />입니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">검색을 시작하는 데 사용할 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <param name="forward">
          탭 순서에서 앞으로 검색하면 <see langword="true" />이고, 뒤로 검색하면 <see langword="false" />입니다.</param>
        <summary>자식 컨트롤의 탭 순서에서 앞뒤에 있는 다음 컨트롤을 검색합니다.</summary>
        <returns>탭 순서에서 다음 <see cref="T:System.Windows.Forms.Control" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GetNextControl%2A> 메서드 탭 순서에 따라 달라 집니다. 사용 하 여 중첩 된 컨트롤을 포함 하는 양식의 모든 컨트롤을 반복 하는 <xref:System.Windows.Forms.Control.Controls%2A> 속성입니다. 가져오거나 설정할 컨테이너 컨트롤의 활성 컨트롤을 사용 하 여는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="proposedSize">컨트롤의 사용자 지정 크기 영역입니다.</param>
        <summary>컨트롤이 들어갈 수 있는 사각형 영역의 크기를 검색합니다.</summary>
        <returns>사각형의 너비와 높이를 나타내는 <see cref="T:System.Drawing.Size" /> 형식의 정렬된 쌍입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동작은 <xref:System.Windows.Forms.Control.GetPreferredSize%2A> 컨트롤에 따라 다릅니다. <xref:System.Windows.Forms.Control.LayoutEngine%2A> 컨트롤에 반환 되는 크기를 할당할 수 수 있습니다. 에 표시 된 제약 조건 보다 큰 크기를 반환할 수 있습니다는 `proposedSize` 매개 변수를 있지만 `proposedSize` 감소 하는 제약 조건으로 감소 해야 합니다. 예를 들어 `GetPreferredSize(new Size(100, 0))` 보다 넓은 되어서는 안 `GetPreferredSize(new Size(200, 0))`합니다. 예외는는 `proposedSize` 0 또는 `Size.Empty`, 제약 없이로 정의 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">디스플레이 범위를 검색할 영역을 지정하는 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <param name="factor">컨트롤 범위의 높이 및 너비입니다.</param>
        <param name="specified">크기 및 위치를 정의하는 데 사용할 컨트롤 범위를 지정하는 <see cref="T:System.Windows.Forms.BoundsSpecified" /> 값 중 하나입니다.</param>
        <summary>컨트롤의 배율이 조정되는 범위를 검색합니다.</summary>
        <returns>컨트롤의 크기가 조정되는 범위를 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 호출 하는 도우미 메서드입니다 <xref:System.Windows.Forms.Control.ScaleControl%2A> 를 컨트롤의 배율이 조정 되는 범위를 검색 합니다. 다시 사용 하려면이 메서드를 재정의할 수 있습니다는 <xref:System.Windows.Forms.Control.ScaleControl%2A> 범위를 직접 제공 해야 하지만 논리를 확장 합니다. 계정에 사용 하는 크기 조정 된 범위를 반환 하는 기본 구현에서 `specified` 범위, 컨트롤이 최상위 수준 인지 여부는 고정 되어 너비 또는 자동 크기 조정 및 컨트롤에 있을 수 있는 장식을 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">값을 반환할 <see cref="T:System.Windows.Forms.ControlStyles" /> 비트입니다.</param>
        <summary>컨트롤에 대해 지정된 컨트롤 스타일 비트의 값을 검색합니다.</summary>
        <returns>
          지정된 컨트롤 스타일 비트가 <see langword="true" />로 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤 스타일 비트 플래그는 지원 되는 동작을 분류 하는 데 사용 됩니다. 컨트롤을 호출 하 여 스타일을 사용 하도록 설정할 수는 <xref:System.Windows.Forms.Control.SetStyle%2A> 메서드와 적절 한 전달 <xref:System.Windows.Forms.ControlStyles> 비트 고 비트를 설정 하는 부울 값입니다. 에 지정 된 할당 된 값을 확인 하려면 <xref:System.Windows.Forms.ControlStyles> 를 사용 하 여는 <xref:System.Windows.Forms.Control.GetStyle%2A> 메서드와 전달은 <xref:System.Windows.Forms.ControlStyles> 평가 하는 멤버입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 반환 이중 버퍼링 관련된 스타일의 값에 대 한 비트는 <xref:System.Windows.Forms.Form>합니다. 이 예에서는 반환 `true` 모든 스타일 비트가 설정 된 경우에 `true`합니다.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤이 최상위 컨트롤인지를 확인합니다.</summary>
        <returns>
          해당 컨트롤이 최상위 컨트롤이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>끌기 작업을 수행하는 동안 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GiveFeedback> 는 끌어서 놓기 작업이 시작 될 때 이벤트가 발생 합니다. 와 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트, 끌기 이벤트의 소스를 끌어서 놓기 작업 중 사용자의 시각적 피드백을 제공 하기 위해 마우스 포인터의 모양을 수정할 수 있습니다.  
  
 다음에서는 끌어서 놓기 작업이 발생하는 방식 및 시기에 대해 설명합니다.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드는 현재 커서 위치에서 컨트롤을 확인 합니다. 그런 다음 컨트롤은 유효한 놓기 대상 인지 확인 합니다.  
  
 컨트롤이 유효한 놓기 대상일 경우는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 지정 된 끌어서 놓기 효과 함께 발생 합니다. 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
 마우스 커서 위치, 키보드 상태 및 마우스 단추 상태의 변경 내용을 추적합니다.  
  
-   사용자가 창의 외부로 이동하면 <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생합니다.  
  
-   마우스를 다른 컨트롤로 가져가면 해당 컨트롤에 대한 <xref:System.Windows.Forms.Control.DragEnter>가 발생합니다.  
  
-   마우스를 동일한 컨트롤 내에서 이동하면 <xref:System.Windows.Forms.Control.DragOver> 이벤트가 발생합니다.  
  
 키보드 또는 마우스 단추 상태가 변경 될 경우는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트가 발생 하 고 데이터를 끌기를 계속할지 여부를 결정 하거나의 값을 기준으로 작업을 취소 하는 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 이벤트의 속성 <xref:System.Windows.Forms.QueryContinueDragEventArgs>합니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Continue`, <xref:System.Windows.Forms.Control.DragOver> 이벤트 작업을 계속 하려면는 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 적절 한 시각적 피드백이 설정 될 수 있도록 새로운 효과 함께 발생 합니다. 유효한 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver> 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 쌍을 이루고 있어서 마우스가 놓기 대상을 통과할 사용자에 게 마우스 위치에 대 한 최신 피드백이 제공 됩니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Drop`, 놓기 효과 값이 원본에 반환, 되므로 소스 응용 프로그램이 소스 데이터에 대해 적절 한 작업을 수행할 수 예를 들어 데이터 잘라내기 작업이 이동 인 경우.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 끌어서 놓기 작업을 보여 줍니다. <xref:System.Windows.Forms.ListBox> 컨트롤입니다. 예제에서는 호출은 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 끌기 작업이 시작 될 때 메서드. 마우스를 이동 하는 경우 끌기 작업이 시작 이상 <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> 하는 동안 마우스 위치에서의 <xref:System.Windows.Forms.Control.MouseDown> 이벤트입니다. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 메서드 결정 하는 동안 끌어 항목의 인덱스를 사용 하는 `MouseDown` 이벤트입니다.  
  
 또한이 예제에서는 끌어서 놓기 작업에 대 한 사용자 지정 커서를 사용 하 여 보여 줍니다. 이 예제를 실행 하려면 커서 파일 `3dwarro.cur` 및 `3dwno.cur`, 사용자 지정 끌어서에 대 한 응용 프로그램 디렉터리에 있으면 놓기-커서, 각각. 사용자 지정 커서 사용 하는 경우는 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> 을 선택 합니다. 에 설정 된 사용자 지정 커서는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트 처리기입니다.  
  
 키보드 상태에서 평가 됩니다는 <xref:System.Windows.Forms.Control.DragOver> 오른쪽에 대 한 이벤트 처리기 `ListBox`항목 끌기 작업을 결정 하는, SHIFT, CTRL 및 ALT, CTRL + ALT 키의 상태를 기반 합니다. 위치는 `ListBox` 삭제가 발생 중도 결정 됩니다는 `DragOver` 이벤트입니다. 삭제할 데이터가 아닌 경우는 `String`, 하면 <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> 로 설정 된 `None` 에서 <xref:System.Windows.Forms.DragDropEffects>합니다. 드롭다운 상태에 표시 되는 마지막으로,는 `DropLocationLabel` <xref:System.Windows.Forms.Label>합니다.  
  
 데이터를 오른쪽에 대 한 drop `ListBox` 에 따라 결정 됩니다는 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 처리기 및 `String` 적절 한 위치에서 값이 추가 `ListBox`합니다. 끌기 작업, 폼의 경계를 벗어나면 경우에서 끌어서 놓기 작업이 취소 되 고 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트 처리기입니다.  
  
 이 코드 발췌 한 구문을 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트입니다. 참조는 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 전체 코드 예제에 대 한 메서드.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 포커스를 받으면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 키보드 (TAB, SHIFT + TAB 등)를 사용 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Select%2A> 또는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드를 설정 하거나는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> 속성을 현재 폼으로 포커스 이벤트가 다음 순서 대로 발생:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 마우스를 사용 하거나 호출 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드, 포커스 이벤트가 다음 순서 대로 발생 합니다.  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
 **참고** 는 <xref:System.Windows.Forms.Control.GotFocus> 및 <xref:System.Windows.Forms.Control.LostFocus> 이벤트는 WM_KILLFOCUS 및 WM_SETFOCUS Windows 메시지에 연결 된 하위 수준 포커스 이벤트입니다. 일반적으로 <xref:System.Windows.Forms.Control.GotFocus> 및 <xref:System.Windows.Forms.Control.LostFocus> 이벤트는 업데이트할 때에 사용 되 <xref:System.Windows.Forms.UICues> 때나 사용자 지정 컨트롤을 작성 합니다. 대신는 <xref:System.Windows.Forms.Control.Enter> 및 <xref:System.Windows.Forms.Control.Leave> 제외한 모든 컨트롤에 사용할 이벤트는 <xref:System.Windows.Forms.Form> 클래스를 사용 하는 <xref:System.Windows.Forms.Form.Activated> 및 <xref:System.Windows.Forms.Form.Deactivate> 이벤트입니다. 에 대 한 자세한 내용은 <xref:System.Windows.Forms.Control.GotFocus> 및 <xref:System.Windows.Forms.Control.LostFocus> 이벤트 참조는 [WM_SETFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx)및[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) 항목입니다.  
  
> [!CAUTION]
>  내에서 포커스를 설정 하지 마십시오는 <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, 또는 <xref:System.Windows.Forms.Control.Validated> 이벤트 처리기입니다. 이렇게 하면 응용 프로그램 또는 운영 체제 응답 하지 발생할 수 있습니다. 자세한 내용은 참조는 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) 항목입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.GotFocus> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.GotFocus> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 바인딩되는 창 핸들을 가져옵니다.</summary>
        <value>컨트롤의 창 핸들(<see cref="T:System.IntPtr" />)이 포함된 <see langword="HWND" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.Windows.Forms.Control.Handle%2A> 속성은 Windows `HWND`합니다. 핸들 아직 만들지 않은 경우이 속성을 참조 고쳐집니다 핸들을을 만들 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.Control.Handle%2A> 속성입니다. 실행 하려면 예제에서는 양식에서 다음 코드를 붙여넣습니다. 라는 두 개의 단추를 추가 `Button1` 및 `Button2` 폼에 해당 이벤트 처리기에 연결 된 모든 이벤트를 확인 합니다.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 핸들을 만들면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들이 생성 됩니다는 <xref:System.Windows.Forms.Control> 처음으로 표시 됩니다. 예를 들어 경우는 <xref:System.Windows.Forms.Control> 만들어집니다가 <xref:System.Windows.Forms.Control.Visible%2A> 로 설정 `false`, <xref:System.Windows.Forms.Control.HandleCreated> 될 때까지 이벤트를 발생 하지 것입니다 <xref:System.Windows.Forms.Control.Visible%2A> 로 설정 된 `true`합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.HandleCreated> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.HandleCreated> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 핸들이 소멸될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중에서 <xref:System.Windows.Forms.Control.HandleDestroyed> 컨트롤 이벤트는 여전히 유효한 Windows 컨트롤 및 <xref:System.Windows.Forms.Control.Handle%2A> 호출 하 여 다시 만들 수 있습니다는 <xref:System.Windows.Forms.Control.RecreateHandle%2A> 메서드.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.HandleDestroyed> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.HandleDestroyed> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 자식 컨트롤이 하나 이상 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤에 자식 컨트롤이 하나 이상 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.Controls%2A> 컬렉션에는 <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> 0 보다 큰는 <xref:System.Windows.Forms.Control.HasChildren%2A> 속성은 반환 `true`합니다. 에 액세스 하는 <xref:System.Windows.Forms.Control.HasChildren%2A> 속성 만들기 강제로 적용 하지 않습니다는 <xref:System.Windows.Forms.Control.ControlCollection> 컨트롤에 자식이 없는 경우이 속성을 참조 하므로 수 성능 이점을 제공 컨트롤의 트리를 탐색 하는 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.BackColor%2A> 및 <xref:System.Windows.Forms.Control.ForeColor%2A> 컨트롤을 기본 시스템 색상입니다. 코드 재귀적으로 컨트롤에 자식 컨트롤이 경우 자신을 호출 합니다. 이 코드 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하나 이상의 자식 컨트롤과; 그러나 자식 컨테이너 컨트롤, like는 <xref:System.Windows.Forms.Panel> 또는 <xref:System.Windows.Forms.GroupBox>, 자체 자식 컨트롤은 보다 잘 보여 주는 재귀 합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 높이를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 높이(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변경 내용을 <xref:System.Windows.Forms.Control.Height%2A> 및 <xref:System.Windows.Forms.Control.Top%2A> 속성 값은 <xref:System.Windows.Forms.Control.Bottom%2A> 변경 하려면 컨트롤의 속성 값입니다.  
  
> [!NOTE]
>  파생된 컨트롤에 대 한 최소 높이 <xref:System.Windows.Forms.Splitter> 은 1 픽셀입니다. 에 대 한 기본 높이 <xref:System.Windows.Forms.Splitter> 컨트롤은 세 가지 픽셀입니다. 설정의 높이 <xref:System.Windows.Forms.Splitter> 기본 높이에 속성 값으로 재설정 됩니다 하나 보다 작은 값으로 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개를 만들며 <xref:System.Windows.Forms.Button> 폼에서 제어 하 고 다양 한 크기 및 위치 관련 속성을 사용 하 여 해당 크기와 위치를 설정 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하에 너비와 높이가 이상 300 픽셀입니다.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 컨트롤에 대한 도움말을 요청하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.HelpRequested> 일반적으로 이벤트는 사용자가 F1 키 또는 관련된 상황에 맞는 도움말 단추를 클릭 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 처리는 <xref:System.Windows.Forms.Control.HelpRequested> 4 주소 필드가 포함 된 폼에서 사용자 지정 도움말 콘텐츠를 표시 하는 이벤트입니다. <xref:System.Windows.Forms.Control.HelpRequested> 포커스가 있는 주소 필드가에서 F1 키를 눌러 또는 상황에 맞는 도움말 단추를 사용 하 고 주소 필드에서 도움말 커서를 클릭 하 여 이벤트가 발생 합니다. <xref:System.Windows.Forms.HelpEventArgs.Handled%2A> 속성 임을 나타내는 true로 설정 되는 `HelpRequested` 이벤트를 처리 합니다. 또한 예제에 대 한 도움말 텍스트를 저장할는 <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType> 속성입니다.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>사용자에게 컨트롤을 숨깁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤을 숨기는 것이 설정에 해당 하는 <xref:System.Windows.Forms.Control.Visible%2A> 속성을 `false`합니다. 후의 <xref:System.Windows.Forms.Control.Hide%2A> 메서드가 호출 되는 <xref:System.Windows.Forms.Control.Visible%2A> 속성의 값을 반환 `false` 될 때까지 <xref:System.Windows.Forms.Control.Show%2A> 메서드를 호출 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 단추를 클릭할 때 CTRL 키를 누른 단추를 숨깁니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Button> 라는 `button1` 에 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 IME(입력기) 모드를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ImeMode" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.Forms.ImeMode.Inherit" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IME는 표준 키보드를 사용 하 여 복잡 한 한글 문자나 기호를 입력할 수 있게 하는 프로그램입니다. <xref:System.Windows.Forms.Control.ImeMode%2A> 일반적으로 속성 <xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType> 에 대 한 한 <xref:System.Windows.Forms.TextBox> 컨트롤입니다. 숫자 값만을 입력 합니다. <xref:System.Windows.Forms.Control.ImeMode%2A> 속성 값으로 설정 됩니다 <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> 에 대 한는 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 Input Method Editor 지원 직접적 또는에서 직접 입력을 허용 하지 않는 대부분의 클래스에이 속성의 값이 설정 됩니다 <xref:System.Windows.Forms.ImeMode.NoControl>합니다.  
  
> [!IMPORTANT]
>  사용자가 대화형으로 변경할 수는 <xref:System.Windows.Forms.Control.ImeMode%2A> 프로그래밍 방식으로 설정 하지 않은 경우 <xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType>합니다. 이 경우 사용자 입력기를 사용할 수 없습니다.  
>   
>  <xref:System.Windows.Forms.Control.ImeMode%2A> 전역 입력된 모드 적용 될 때 Windows 8에서 속성이 무시 됩니다. 자세한 내용은 참조 하십시오. [스위치 텍스트 입력에서에서 변경 Per-thread 사용자 단위로](http://go.microsoft.com/fwlink/?LinkID=256509)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">할당된 값이 <see cref="T:System.Windows.Forms.ImeMode" /> 열거형 값이 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 IME 모드를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 IME 모드입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ImeMode" /> 속성이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.ImeMode%2A> 속성이 상호 작용을 통해 또는 프로그래밍 방식으로 수정으로 변경 합니다.  
  
 입력기를 지원 하지 않는 컨트롤이이 이벤트를 발생 하지 않습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트 처리기 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 *PropertyName* `Changed` 있는 될 때 발생 하는 해당 *PropertyName* 값이 변경 (* PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤을 다른 컨테이너에 추가한 후 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.InitLayout%2A> 메서드 컨테이너에 컨트롤을 추가한 직후 호출 됩니다. <xref:System.Windows.Forms.Control.InitLayout%2A> 메서드를 사용 하면 해당 컨테이너에 따라 레이아웃 상태로 초기화 하는 컨트롤입니다. 예를 들어 일반적으로 적용 고정 및 도킹 컨트롤에 <xref:System.Windows.Forms.Control.InitLayout%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.InitLayout" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.InitLayout" /> 메서드 컨트롤을 올바르게 표시 되도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>특정 컨트롤 영역을 무효화하고 그리기 메시지를 컨트롤로 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤의 전체 화면을 무효화하고 컨트롤을 다시 그립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드 동기식 강제로 적용 하지 않습니다; 동기식을 강제로 표시 하려면 함수를 호출할는 <xref:System.Windows.Forms.Control.Update%2A> 메서드를 호출한 후의 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드. 이 메서드는 매개 변수 없이, 전체 클라이언트 영역 업데이트 영역에 추가 됩니다.  
  
   
  
## Examples  
 사용자 이미지 또는 이미지 파일을 폼으로 끌어 지점에 표시 되도록가를 놓이고는 다음 코드 예제에서는 합니다. <xref:System.Windows.Forms.Control.OnPaint%2A> 메서드는 폼을 그릴 될 때마다 이미지를 다시 그리기 위해 재정의 됩니다; 그렇지 않은 경우 이미지는 다음에 다시 그릴 때까지 유지만 합니다. <xref:System.Windows.Forms.Control.DragEnter> 이벤트 처리 메서드는 형식으로 끌고 있는 데이터의 형식을 결정 하 고 적절 한 피드백을 제공 합니다. <xref:System.Windows.Forms.Control.DragDrop> 경우 이벤트 처리 메서드는 폼에 이미지를 표시 한 <xref:System.Drawing.Image> 데이터에서 만들 수 있습니다. 때문에 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> 값은 화면 좌표를 사용 하 여는 <xref:System.Windows.Forms.Control.PointToClient%2A> 메서드를 클라이언트 좌표로 변환 합니다.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren">
          컨트롤의 자식 컨트롤을 무효화하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>특정 컨트롤 영역을 무효화하고 그리기 메시지를 컨트롤로 보냅니다. 또한 필요에 따라 컨트롤에 할당된 자식 컨트롤을 무효화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드 동기식 강제로 적용 하지 않습니다; 동기식을 강제로 표시 하려면 함수를 호출할는 <xref:System.Windows.Forms.Control.Update%2A> 메서드를 호출한 후의 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드. 이 메서드는 매개 변수 없이, 전체 클라이언트 영역 업데이트 영역에 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">무효화할 영역을 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <summary>지정된 컨트롤 영역을 무효화하고, 이 영역을 다음 그리기 작업에서 다시 그릴 컨트롤의 업데이트 영역에 추가하고, 그리기 메시지를 컨트롤로 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드 동기식 강제로 적용 하지 않습니다; 동기식을 강제로 표시 하려면 함수를 호출할는 <xref:System.Windows.Forms.Control.Update%2A> 메서드를 호출한 후의 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드. 이 메서드는 매개 변수 없이, 전체 클라이언트 영역 업데이트 영역에 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">무효화할 <see cref="T:System.Drawing.Region" />입니다.</param>
        <summary>지정된 컨트롤 영역을 무효화하고, 이 영역을 다음 그리기 작업에서 다시 그릴 컨트롤의 업데이트 영역에 추가하고, 그리기 메시지를 컨트롤로 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드 동기식 강제로 적용 하지 않습니다; 동기식을 강제로 표시 하려면 함수를 호출할는 <xref:System.Windows.Forms.Control.Update%2A> 메서드를 호출한 후의 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드. 이 메서드는 매개 변수 없이, 전체 클라이언트 영역 업데이트 영역에 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">무효화할 영역을 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <param name="invalidateChildren">
          컨트롤의 자식 컨트롤을 무효화하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 컨트롤 영역을 무효화하고, 이 영역을 다음 그리기 작업에서 다시 그릴 컨트롤의 업데이트 영역에 추가하고, 그리기 메시지를 컨트롤로 보냅니다. 또한 필요에 따라 컨트롤에 할당된 자식 컨트롤을 무효화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드 동기식 강제로 적용 하지 않습니다; 동기식을 강제로 표시 하려면 함수를 호출할는 <xref:System.Windows.Forms.Control.Update%2A> 메서드를 호출한 후의 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드. 이 메서드는 매개 변수 없이, 전체 클라이언트 영역 업데이트 영역에 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">무효화할 <see cref="T:System.Drawing.Region" />입니다.</param>
        <param name="invalidateChildren">
          컨트롤의 자식 컨트롤을 무효화하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 컨트롤 영역을 무효화하고, 이 영역을 다음 그리기 작업에서 다시 그릴 컨트롤의 업데이트 영역에 추가하고, 그리기 메시지를 컨트롤로 보냅니다. 또한 필요에 따라 컨트롤에 할당된 자식 컨트롤을 무효화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드 동기식 강제로 적용 하지 않습니다; 동기식을 강제로 표시 하려면 함수를 호출할는 <xref:System.Windows.Forms.Control.Update%2A> 메서드를 호출한 후의 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드. 이 메서드는 매개 변수 없이, 전체 클라이언트 영역 업데이트 영역에 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 다시 그려야 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.Invalidated> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.Invalidated> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤의 내부 창 핸들이 있는 스레드에서 대리자를 실행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">컨트롤의 스레드 컨텍스트에서 호출될 메서드가 있는 대리자입니다.</param>
        <summary>컨트롤의 내부 창 핸들이 있는 스레드에서 지정된 대리자를 실행합니다.</summary>
        <returns>호출되는 대리자의 반환 값이거나, 대리자에 반환 값이 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대리자는 C 또는 c + + 언어의 함수 포인터와 유사 합니다. 대리자는 대리자 개체를 내부 메서드에 대 한 참조를 캡슐화합니다. 대리자 개체 참조 된 메서드를 호출 하는 코드에 전달 될 수 하 고 컴파일 타임에는 메서드를 호출할 수 있습니다 알 수 없는 키를 누릅니다. C 또는 c + + 함수 포인터와는 달리 대리자는 개체 지향, 형식이 안전한 및 더 안전 합니다.  
  
 <xref:System.Windows.Forms.Control.Invoke%2A> 현재 컨트롤의 내부 창 핸들이 아직 존재 하지 않는 경우를 처리 하는 컨트롤의 부모 체인 컨트롤이 나 기간이 된 양식을 찾을 때까지 메서드를 검색 합니다. 적절 한 핸들을 찾을 수 있는 경우는 <xref:System.Windows.Forms.Control.Invoke%2A> 메서드 예외를 throw 합니다. 호출 하는 동안 발생 하는 예외를 다시 호출자에 게 전파 됩니다.  
  
> [!NOTE]
>  외에 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 속성에는 스레드로부터 안전 컨트롤에서 네 가지 메서드가 있습니다: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, 및 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다. 다른 모든 메서드 호출에 대 한 사용할지 invoke 메서드 중 하나를 컨트롤의 스레드에 대 한 호출을 마샬링하 합니다.  
  
 대리자의 인스턴스 수 <xref:System.EventHandler>,이 경우 보낸 사람 매개 변수가이 컨트롤 되 고 이벤트 매개 변수는 포함 <xref:System.EventArgs.Empty?displayProperty=nameWithType>합니다. 대리자의 인스턴스 수도 있습니다 <xref:System.Windows.Forms.MethodInvoker>, 또는 대리자는 void 매개 변수 목록입니다. 에 대 한 호출은 <xref:System.EventHandler> 또는 <xref:System.Windows.Forms.MethodInvoker> 대리자 보다 빨리 대리자의 다른 형식으로 호출 됩니다.  
  
> [!NOTE]
>  메시지를 처리 해야 하는 스레드가 더 이상 활성 상태 이면 예외가 throw 될 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 대리자를 포함 하는 컨트롤을 보여 줍니다. 대리자 목록 상자에 항목을 추가 하는 메서드를 캡슐화 하 고이 메서드는 폼의 기본 핸들을 소유 하는 스레드에서 실행 됩니다. 사용자가 단추를 클릭할 때 `Invoke` 대리자를 실행 합니다.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">
          <c>args</c> 매개 변수에 있는 매개 변수의 수 및 형식과 동일한 매개 변수를 갖는 메서드의 대리자입니다.</param>
        <param name="args">지정된 메서드에 인수로 전달하는 개체의 배열입니다. 메서드가 인수를 사용하지 않으면 이 매개 변수는 <see langword="null" />이 될 수 있습니다.</param>
        <summary>컨트롤의 내부 창 핸들이 있는 스레드에서 특정 인수 목록을 사용하여 지정된 대리자를 실행합니다.</summary>
        <returns>호출되는 대리자의 반환 값이 있는 <see cref="T:System.Object" />이거나, 대리자에 반환 값이 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대리자는 C 또는 c + + 언어의 함수 포인터와 유사 합니다. 대리자는 대리자 개체를 내부 메서드에 대 한 참조를 캡슐화합니다. 대리자 개체 참조 된 메서드를 호출 하는 코드에 전달 될 수 하 고 컴파일 타임에는 메서드를 호출할 수 있습니다 알 수 없는 키를 누릅니다. C 또는 c + + 함수 포인터와는 달리 대리자는 개체 지향, 형식이 안전한 및 더 안전 합니다.  
  
 컨트롤의 핸들이 아직 존재 하지 않는 경우 창 핸들이 폼 또는 컨트롤을 찾을 때까지이 메서드는 컨트롤의 부모 체인을 검색 합니다. 적절 한 핸들을 찾을 수 있는 경우이 메서드는 예외가 throw 됩니다. 호출 하는 동안 발생 하는 예외를 다시 호출자에 게 전파 됩니다.  
  
> [!NOTE]
>  외에 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 속성에는 스레드로부터 안전 컨트롤에서 네 가지 메서드가 있습니다: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, 및 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다. 다른 모든 메서드 호출에 대 한 사용할지 invoke 메서드 중 하나를 컨트롤의 스레드에 대 한 호출을 마샬링하 합니다.  
  
 대리자의 인스턴스 수 <xref:System.EventHandler>,이 경우 보낸 사람 매개 변수가이 컨트롤 되 고 이벤트 매개 변수는 포함 <xref:System.EventArgs.Empty?displayProperty=nameWithType>합니다. 대리자의 인스턴스 수도 있습니다 <xref:System.Windows.Forms.MethodInvoker>, 또는 대리자는 void 매개 변수 목록입니다. 에 대 한 호출은 <xref:System.EventHandler> 또는 <xref:System.Windows.Forms.MethodInvoker> 대리자 보다 빨리 대리자의 다른 형식으로 호출 됩니다.  
  
> [!NOTE]
>  메시지를 처리 해야 하는 스레드가 더 이상 활성 상태 이면 예외가 throw 될 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 대리자를 포함 하는 컨트롤을 보여 줍니다. 대리자 목록 상자에 항목을 추가 하는 메서드를 캡슐화 하 고이 메서드는 지정된 된 인수를 사용 하 여 폼의 기본 핸들을 소유 하는 스레드에서 실행 됩니다. 사용자가 단추를 클릭할 때 `Invoke` 대리자를 실행 합니다.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">해당 이벤트를 할당할 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>지정된 컨트롤에 대해 <see cref="E:System.Windows.Forms.Control.GotFocus" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">해당 이벤트를 할당할 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>지정된 컨트롤에 대해 <see cref="E:System.Windows.Forms.Control.LostFocus" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">
          <see cref="T:System.Windows.Forms.Control" /> 이벤트를 할당할 <see cref="E:System.Windows.Forms.Control.Click" />입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>지정된 컨트롤에 대해 <see cref="E:System.Windows.Forms.Control.Click" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Windows.Forms.Control" /> 이벤트를 할당할 <see cref="E:System.Windows.Forms.Control.Paint" />입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.PaintEventArgs" />입니다.</param>
        <summary>지정된 컨트롤에 대해 <see cref="E:System.Windows.Forms.Control.Paint" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Windows.Forms.Control" /> 이벤트를 할당할 <see cref="E:System.Windows.Forms.Control.Paint" />입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.PaintEventArgs" />입니다.</param>
        <summary>지정된 컨트롤에 대해 <see langword="PaintBackground" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호출자가 컨트롤이 만들어진 스레드와 다른 스레드에 있기 때문에 메서드를 통해 컨트롤을 호출하는 경우 해당 호출자가 호출 메서드를 호출해야 하는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤의 <see langword="true" />이 호출 스레드와 다른 스레드에서 만들어져 호출 메서드를 통해 해당 컨트롤을 호출해야 하는 경우 <see cref="P:System.Windows.Forms.Control.Handle" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Forms에서 컨트롤을 특정 스레드에 바인딩되며는 스레드로부터 안전 하지 않습니다. 따라서 다른 스레드에서 컨트롤의 메서드를 호출 하는 경우 하나를 사용 해야의 컨트롤의 호출을 적절 한 스레드에 마샬링해야 하는 메서드를 호출 합니다. 컨트롤 하는지 알 수 없는 경우에 유용할 수 있는 호출 메서드를 호출 해야 하는 경우를 확인 하려면이 속성을 사용할 수 있습니다.  
  
> [!NOTE]
>  이외에 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 속성, 컨트롤에는 스레드로부터 안전 하 게 호출할 네 가지 메서드가 있습니다: <xref:System.Windows.Forms.Control.Invoke%2A>,<xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> 및 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤에 대 한 핸들에서 이미 만든 경우. 호출 <xref:System.Windows.Forms.Control.CreateGraphics%2A> 컨트롤의 핸들이 백그라운드 스레드에서 생성 되기 전에 잘못 된 크로스 스레드 호출 될 수 있습니다. 다른 모든 메서드 호출에 대해 하나를 사용 해야 이러한 다른 스레드에서 호출 하는 경우 메서드를 호출 합니다.  
  
 컨트롤의 핸들이 아직 존재 하지 않는 경우 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 창 핸들이 폼 또는 컨트롤을 찾을 때까지 해당 컨트롤의 부모 체인을 위로 검색. 적절 한 핸들을 찾을 수 있는 경우는 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 메서드 반환 `false`합니다.  
  
 즉 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 반환할 수 `false` 경우 <xref:System.Windows.Forms.Control.Invoke%2A> 필요 하지 않습니다 (호출이 동일한 스레드에서 발생), 또는 다른 스레드에서 컨트롤 만들어졌지만 컨트롤의 핸들이 아직 만들어지지 않은 경우.  
  
 여기서 컨트롤의 핸들이 아직 만들어지지 않은 경우에 호출 하지 않아야 단순히 속성, 메서드 또는 이벤트 컨트롤에 있습니다. 메시지 펌프 하지 않고 스레드에서 컨트롤을 격리 하 고 고 응용 프로그램이 불안정 백그라운드 스레드에서 만들어질 컨트롤의 핸들이 발생할 수 있습니다.  
  
 값을 확인 하 여이 경우 으로부터 보호할 수 있습니다 <xref:System.Windows.Forms.Control.IsHandleCreated%2A> 때 <xref:System.Windows.Forms.Control.InvokeRequired%2A> 반환 `false` 백그라운드 스레드입니다. 컨트롤 핸들이 아직 만들지 않은 경우 호출 하기 전에 만든 될 때까지 대기 해야 <xref:System.Windows.Forms.Control.Invoke%2A> 또는 <xref:System.Windows.Forms.Control.BeginInvoke%2A>합니다. 일반적으로 이러한 경우 응용 프로그램에 대 한 기본 폼의 생성자에서 백그라운드 스레드가 생성 됩니다 (에서 같이 `Application.Run(new MainForm())`는 폼이 표시 되기 전에, 또는 `Application.Run` 가 호출 되었습니다.  
  
 한 가지 해결 방법은 백그라운드 스레드를 시작 하기 전에 폼의 핸들을 만든 될 때까지 기다려야 합니다. 호출 하 여 핸들 생성을 강제로 <xref:System.Windows.Forms.Control.Handle%2A> 속성 또는 때까지 기다려야는 <xref:System.Windows.Forms.Form.Load> 백그라운드 프로세스를 시작 하는 이벤트입니다.  
  
 사용 하는 것 보다 나은 해결책은 `SynchronizationContext` 반환한 <xref:System.Threading.SynchronizationContext> 스레드 간 위한 컨트롤 대신 합니다.  
  
> [!NOTE]
>  메시지를 처리 해야 하는 스레드가 더 이상 활성 상태 이면 예외가 throw 될 수 없습니다.  
  
 다중 스레드 Windows Forms 컨트롤에 대 한 자세한 내용은 참조 [하는 방법: 파일을 검색 하는 백그라운드 스레드를 사용 하 여](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md) 및 [하는 방법: Windows Forms 컨트롤에 스레드로부터 안전한 호출 수행](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 내게 필요한 옵션 지원 응용 프로그램에 표시되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤이 내게 필요한 옵션 지원 응용 프로그램에 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 삭제되었는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤이 삭제되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이 반환 하는 경우 `true`, 컨트롤의 삭제 되 고 올바른 Windows 컨트롤로 더 이상 참조할 수 없습니다. 컨트롤의 인스턴스 삭제 하는 경우에 가비지 수집을 통해 메모리에서 제거 될 때까지 메모리에 유지 계속 됩니다. 호출할 수 없습니다 컨트롤이 삭제 될 때 해당 <xref:System.Windows.Forms.Control.RecreateHandle%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 연결된 핸들이 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤에 핸들이 할당되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Forms.Control.IsHandleCreated%2A> 속성을 확인 하는지 여부를 <xref:System.Windows.Forms.Control.CreateHandle%2A> 가 호출 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">테스트할 문자입니다.</param>
        <summary>문자가 컨트롤이 인식하는 입력 문자인지를 확인합니다.</summary>
        <returns>
          문자가 컨트롤로 직접 보내지고 전처리되지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.IsInputChar%2A> 있는지 여부를 지정 된 문자를 확인 하는 `charCode` 매개 변수는 컨트롤이 하는 입력된 문자. 이 메서드는 지정된 된 입력된 문자를 전처리 되거나 컨트롤에 직접 전송 하는지 확인 하기 위해 창 메시지 전처리 하는 동안 호출 됩니다. 경우 <xref:System.Windows.Forms.Control.IsInputChar%2A> 반환 `true`, 지정된 된 문자는 컨트롤에 직접 전송 됩니다. 경우 <xref:System.Windows.Forms.Control.IsInputChar%2A> 반환 `false`, 지정된 된 문자를 전처리 되 고 전처리 단계에서 사용 하지 않은 경우에 컨트롤 전송 합니다. 전처리는 문자를 포함 다른 컨트롤의 니모닉 문자 인지 확인 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">
          <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>지정된 키가 일반 입력 키인지 또는 전처리가 필요한 특수 키인지를 확인합니다.</summary>
        <returns>
          지정된 키가 일반 입력 키이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.IsInputKey%2A> 키에서 지정 되었는지 여부를 확인 하는 `keyData` 매개 변수는 컨트롤이 입력된 키인지 합니다. 이 메서드는 지정 된 입력된 키인지 전처리 되거나 컨트롤에 직접 전송 하는지 확인 하기 위해 창 메시지 전처리 하는 동안 호출 됩니다. 경우 <xref:System.Windows.Forms.Control.IsInputKey%2A> 반환 `true`, 지정된 된 키 컨트롤에 직접 전송 됩니다. 경우 <xref:System.Windows.Forms.Control.IsInputKey%2A> 반환 `false`, 지정된 된 키가 전처리 하 고 전처리 단계에서 사용 하지 않은 경우에 컨트롤 전송 합니다. 전처리 하는 키의 탭, 리턴, esc를 누르고 및 위쪽 화살표, 아래쪽 화살표, 왼쪽 화살표 및 오른쪽 화살표 키를 포함 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.TextBox> 제어 합니다. 이 예제는 `TabTextBox` TAB 키를 처리 하는 클래스입니다. 경우는 `TabTextBox` 포커스가 있고 사용자 TAB 키를 눌러 텍스트 삽입 지점에 4 개의 공백이 추가 되어 선택한 텍스트를 대체 합니다. 기본적으로는 <xref:System.Windows.Forms.TextBox> 컨트롤이 입력된 포커스를 다음 컨트롤로 이동 하 여 TAB 키를 처리 합니다. 이 경우에 키 누름에 도달 하지 않습니다는 <xref:System.Windows.Forms.Control.OnKeyDown%2A> 메서드를 재정의 합니다. 이 기본 동작을 방지 하기 위해는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 메서드 재정의 반환 `true` TAB 키를 누를 때. 다른 모든 키 누르기는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 메서드 재정의 기본 클래스 버전의 메서드 호출의 결과 반환 합니다.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyVal">
          <see cref="T:System.Windows.Forms.Keys" /> 열거형의 Caps Lock, Num Lock 또는 Scroll Lock 멤버입니다.</param>
        <summary>Caps Lock, Num Lock 또는 Scroll Lock 키가 유효한지를 확인합니다.</summary>
        <returns>
          지정한 키가 유효하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Forms.Control.IsKeyLocked%2A> 여부를 개별적으로 또는 함께, CAPS LOCK, NUM LOCK 또는 SCROLL LOCK 키가 있는지 여부를 확인 하는 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정된 된 키 (이 경우 Caps Lock 키)가 유효한 지 여부를 나타내는 메시지 상자를 표시 합니다.  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="keyVal" /> 매개 변수는 Caps Lock, Num Lock 또는 Scroll Lock 키 이외의 키를 참조합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 미러링되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤이 미러링되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 미러링된 컨트롤 레이아웃 및 오른쪽에서 왼쪽으로 텍스트를 모두 표시합니다. 자세한 내용은 참조 [하는 방법: 미러링된 Windows Forms 만들기 및 컨트롤](http://msdn.microsoft.com/library/7c5c4ecc-9bfb-4508-8383-753e306719b1)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">테스트할 문자입니다.</param>
        <param name="text">검색할 문자열입니다.</param>
        <summary>지정된 문자가 특정 문자열의 컨트롤에 할당된 니모닉 문자인지를 확인합니다.</summary>
        <returns>
          <paramref name="charCode" /> 문자가 컨트롤에 할당된 니모닉 문자이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 니모닉 문자는 문자 바로 다음에 "&"의 첫 번째 인스턴스는 <xref:System.String>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 단추 클래스의 확장은 <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> 메서드를 사용자 지정 동작을 노출 합니다. 이 예제에서는 또한의 사용법을 보여줍니다는 <xref:System.Windows.Forms.Control.CanSelect%2A> 및 <xref:System.Windows.Forms.Control.IsMnemonic%2A> 속성입니다. 이 예에서는 실행 하려면 같은 파일에 폼 클래스 뒤 다음 코드를 붙여 넣습니다. 형식의 단추 추가 `MnemonicButton` 양식입니다.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 포커스가 있을 때 키를 누르면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 주요 이벤트는 다음 순서 대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 폼 수준 에서만 키보드 이벤트를 처리 하 고 키보드 이벤트를 수신할 다른 컨트롤에서는 설정는 <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> 속성 폼의 <xref:System.Windows.Forms.Control.KeyPress> 이벤트 처리 메서드를 `true`합니다. 탭, 리턴, ESC, 및 화살표 키 등의 특정 키 컨트롤에서 자동으로 처리 됩니다. 이러한 키에 <xref:System.Windows.Forms.Control.KeyDown> 재정의 해야 이벤트에는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 양식의 각 컨트롤의 메서드. 재정의 위한 코드는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 특수 키 중 하나를 누를 경우를 결정 하 고 값을 반환 해야 `true`합니다. 재정의 하는 대신는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 메서드를 처리할 수 있습니다는 <xref:System.Windows.Forms.Control.PreviewKeyDown> 이벤트 집합과 <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> 속성을 `true`합니다. 코드 예제를 참조 하십시오.는 <xref:System.Windows.Forms.Control.PreviewKeyDown> 이벤트입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.KeyDown> 컨트롤에 입력 한 문자 형식을 결정 하는 이벤트입니다.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 포커스가 있을 때 문자, 스페이스 또는 백스페이스 키를 누르면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 주요 이벤트는 다음 순서 대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 그러나 <xref:System.Windows.Forms.Control.KeyPress> 공간과 백스페이스 이외의 문자가 아닌 키에 의해 이벤트가 발생 하지 않습니다; 문자가 아닌 키 발생 마십시오.는 <xref:System.Windows.Forms.Control.KeyDown> 및 <xref:System.Windows.Forms.Control.KeyUp> 이벤트입니다.  
  
 사용 하 여는 <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> 샘플 키 입력을 런타임 시를 사용 하거나 공통 키 입력의 하위 집합을 수정 하는 속성입니다.  
  
 폼 수준 에서만 키보드 이벤트를 처리 하 고 키보드 이벤트를 수신할 다른 컨트롤에서는 설정는 <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> 속성 폼의 <xref:System.Windows.Forms.Control.KeyPress> 이벤트 처리 메서드를 `true`합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.KeyPress> 문자가 컨트롤에 진입 하지 못하도록 하는 이벤트입니다.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 포커스가 있을 때 키를 눌렀다 놓으면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 주요 이벤트는 다음 순서 대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 폼 수준 에서만 키보드 이벤트를 처리 하 고 키보드 이벤트를 수신할 다른 컨트롤에서는 설정는 <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> 속성 폼의 <xref:System.Windows.Forms.Control.KeyPress> 이벤트 처리 메서드를 `true`합니다. 탭, 리턴, ESC, 및 화살표 키 등의 특정 키 컨트롤에서 자동으로 처리 됩니다. 이러한 키에 <xref:System.Windows.Forms.Control.KeyUp> 재정의 해야 이벤트에는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 양식의 각 컨트롤의 메서드. 재정의 위한 코드 <xref:System.Windows.Forms.Control.IsInputKey%2A> 특수 키 중 하나를 누를 경우를 결정 하 고 값을 반환 해야 `true`합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.KeyUp> 인 이벤트는 <xref:System.Windows.Forms.Help> 사용자에 게 팝업 스타일 도움말을 표시 하는 클래스입니다.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 자식 컨트롤의 위치를 변경하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Layout> 이벤트 때 자식 컨트롤을 추가 하거나 제거할 범위 컨트롤 변경 되 고 있는 다른 변경 내용이 있을 수는 컨트롤의 레이아웃에 영향을 줄 때 발생 합니다. 레이아웃 이벤트를 사용 하 여 보류 될 수 있습니다는 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 및 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드. 레이아웃을 일시 중단을 사용 하면 각 변경에 대 한 레이아웃을 수행 하지 않고도 컨트롤에서 여러 동작을 수행할 수 있습니다. 예를 들어, 크기를 조정 하 고 컨트롤을 이동 하는 경우 각 작업 발생 한 <xref:System.Windows.Forms.Control.Layout> 이벤트입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 센터는 <xref:System.Windows.Forms.Form> 화면에서 <xref:System.Windows.Forms.Control.Layout> 이벤트입니다. 이렇게 하면 사용자가 크기 조정으로 가운데 맞춤 폼을 유지 됩니다. 이 예제에서는 만든는 <xref:System.Windows.Forms.Form> 제어 합니다.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 레이아웃 엔진의 캐시된 인스턴스를 가져옵니다.</summary>
        <value>컨트롤의 내용에 대한 <see cref="T:System.Windows.Forms.Layout.LayoutEngine" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.LayoutEngine%2A> 속성 컨트롤의 자식에 대 한 아닌 컨트롤 자체에 대 한 레이아웃 엔진을 가져옵니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>입력 포커스가 컨트롤을 벗어나면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 키보드 (TAB, SHIFT + TAB 등)를 사용 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Select%2A> 또는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드를 설정 하거나는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> 속성을 현재 폼으로 포커스 이벤트가 다음 순서 대로 발생:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 마우스를 사용 하거나 호출 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드, 포커스 이벤트가 다음 순서 대로 발생 합니다.  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Enter> 및 <xref:System.Windows.Forms.Control.Leave> 이벤트에 의해 표시 되는 <xref:System.Windows.Forms.Form> 클래스입니다. 에 해당 하는 이벤트는 <xref:System.Windows.Forms.Form> 클래스는 <xref:System.Windows.Forms.Form.Activated> 및 <xref:System.Windows.Forms.Form.Deactivate> 이벤트입니다. <xref:System.Windows.Forms.Control.Enter> 및 <xref:System.Windows.Forms.Control.Leave> 이벤트는 계층적 및 적절 한 컨트롤에 도달할 때까지 부모 체인 위쪽 및 아래쪽 연계 됩니다. 예를 들어 있다고 가정는 <xref:System.Windows.Forms.Form> 두 개의 <xref:System.Windows.Forms.GroupBox> 컨트롤 및 각 <xref:System.Windows.Forms.GroupBox> 컨트롤에 하나 <xref:System.Windows.Forms.TextBox> 제어 합니다. 하나에서 캐럿을 이동할 때 <xref:System.Windows.Forms.TextBox> 다른는 <xref:System.Windows.Forms.Control.Leave> 에 대 한 이벤트는 <xref:System.Windows.Forms.TextBox> 및 <xref:System.Windows.Forms.GroupBox>, 및 <xref:System.Windows.Forms.Control.Enter> 이벤트가 발생 하면 다른 <xref:System.Windows.Forms.GroupBox> 및 <xref:System.Windows.Forms.TextBox>합니다.  
  
> [!CAUTION]
>  내에서 포커스를 설정 하지 마십시오는 <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, 또는 <xref:System.Windows.Forms.Control.Validated> 이벤트 처리기입니다. 이렇게 하면 응용 프로그램 또는 운영 체제 응답 하지 발생할 수 있습니다. 자세한 내용은 참조는 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) 항목입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Leave> 컨트롤을 이전 상태로 다시 설정 하는 이벤트입니다.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 왼쪽 가장자리와 해당 컨테이너 클라이언트 영역의 왼쪽 가장자리 사이의 거리(픽셀)를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 왼쪽 가장자리와 해당 컨테이너 클라이언트 영역의 왼쪽 가장자리 사이의 거리(픽셀)를 나타내는 <see cref="T:System.Int32" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Left%2A> 속성 값은 해당 하는 <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> 의 속성은 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤의 속성 값입니다.  
  
 변경 내용을 <xref:System.Windows.Forms.Control.Width%2A> 및 <xref:System.Windows.Forms.Control.Left%2A> 속성 값은 <xref:System.Windows.Forms.Control.Right%2A> 변경 하려면 컨트롤의 속성 값입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개를 만들며 <xref:System.Windows.Forms.Button> 폼에서 제어 하 고 다양 한 크기 및 위치 관련 속성을 사용 하 여 해당 크기와 위치를 설정 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하에 너비와 높이가 이상 300 픽셀입니다.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 컨테이너의 왼쪽 위 모퉁이를 기준으로 컨트롤의 왼쪽 위 모퉁이의 좌표를 가져오거나 설정합니다.</summary>
        <value>해당 컨테이너의 왼쪽 위 모퉁이를 기준으로 하여 컨트롤의 왼쪽 위 모퉁이를 나타내는 <see cref="T:System.Drawing.Point" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때문에 <xref:System.Drawing.Point> 클래스는 값 형식 (`Structure` Visual Basic의 `struct` Visual C#), 컨트롤의 왼쪽 위 지점이의 복사본을 반환 하는 속성에 액세스를 의미 하는 값으로 반환 됩니다. 따라서 조정는 <xref:System.Drawing.Point.X%2A> 또는 <xref:System.Drawing.Point.Y%2A> 의 속성에서 <xref:System.Drawing.Point> 이에서 반환 된 속성에 영향을 주지 것입니다는 <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, 또는 <xref:System.Windows.Forms.Control.Bottom%2A> 컨트롤의 속성 값입니다. 각 속성 값을 개별적으로 설정 하거나 설정 이러한 속성을 조정 하는 <xref:System.Windows.Forms.Control.Location%2A> 를 새 속성 <xref:System.Drawing.Point>합니다.  
  
 경우는 <xref:System.Windows.Forms.Control> 는 <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Location%2A> 속성 값의 왼쪽 위 모퉁이 나타내는 <xref:System.Windows.Forms.Form> 화면 좌표에서입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Windows.Forms.GroupBox> 공통 속성 중 일부를 설정 합니다. 이 예에서는 만듭니다는 <xref:System.Windows.Forms.TextBox> 설정 하 고 해당 <xref:System.Windows.Forms.Control.Location%2A> 그룹 상자 내에서. 그런 다음 설정의 <xref:System.Windows.Forms.Control.Text%2A> 그룹 상자 및 폼의 위쪽에 도킹 된 그룹 상자 속성입니다. 마지막으로, 그룹 상자 설정 하 여 비활성화는 <xref:System.Windows.Forms.Control.Enabled%2A> 속성을 `false`, 사용 하지 않도록 설정할 그룹 상자에 포함 된 모든 컨트롤에 이르게 됩니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Location" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Location%2A> 속성이 상호 작용을 통해 또는 프로그래밍 방식으로 수정으로 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 발생은 <xref:System.Windows.Forms.Control.LocationChanged> 이벤트에는 <xref:System.Windows.Forms.StatusStrip> 폼 크기를 조정할 때.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">변환할 논리 값입니다.</param>
        <summary>논리적 DPI 값을 동등한 DeviceUnit DPI 값으로 변환합니다.</summary>
        <returns>결과 DeviceUnit 값입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 포커스를 잃을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 키보드 (TAB, SHIFT + TAB 등)를 사용 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Select%2A> 또는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드를 설정 하거나는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> 속성을 현재 폼으로 포커스 이벤트가 다음 순서 대로 발생:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 마우스를 사용 하거나 호출 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드, 포커스 이벤트가 다음 순서 대로 발생 합니다.  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
 경우는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성은 <xref:System.ComponentModel.CancelEventArgs> 로 설정 된 `true` 에 <xref:System.Windows.Forms.Control.Validating> 후 일반적으로 발생 하는 모든 이벤트, 이벤트 대리자는 <xref:System.Windows.Forms.Control.Validating> 이벤트는 표시 되지 않습니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.GotFocus> 및 <xref:System.Windows.Forms.Control.LostFocus> 이벤트는 WM_KILLFOCUS 및 WM_SETFOCUS Windows 메시지에 연결 된 하위 수준 포커스 이벤트입니다. 일반적으로 <xref:System.Windows.Forms.Control.GotFocus> 및 <xref:System.Windows.Forms.Control.LostFocus> 이벤트는 업데이트할 때에 사용 되 <xref:System.Windows.Forms.UICues> 때나 사용자 지정 컨트롤을 작성 합니다. 대신는 <xref:System.Windows.Forms.Control.Enter> 및 <xref:System.Windows.Forms.Control.Leave> 제외한 모든 컨트롤에 사용할 이벤트는 <xref:System.Windows.Forms.Form> 클래스를 사용 하는 <xref:System.Windows.Forms.Form.Activated> 및 <xref:System.Windows.Forms.Form.Deactivate> 이벤트입니다. 에 대 한 자세한 내용은 <xref:System.Windows.Forms.Control.GotFocus> 및 <xref:System.Windows.Forms.Control.LostFocus> 이벤트 참조는 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) 및 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) 항목입니다.  
  
> [!CAUTION]
>  내에서 포커스를 설정 하지 마십시오는 <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, 또는 <xref:System.Windows.Forms.Control.Validated> 이벤트 처리기입니다. 이렇게 하면 응용 프로그램 또는 운영 체제 응답 하지 발생할 수 있습니다. 자세한 내용은 참조는 [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) 항목입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 TextBox1에 대 한 텍스트 유효성을 검사 하는 방법을 보여 줍니다. 처리 하는 방법도 보여 줍니다는 <xref:System.Windows.Forms.Control.LostFocus> 설정 하 여 이벤트는 <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> 텍스트 TextBox1에는 속성입니다. 사용 되는 코드 예제는 <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType> 파일 대화 상자를 열기 전에 오류에 대 한 검사 하도록 합니다. 이 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여는 <xref:System.Windows.Forms.TextBox> 라는 `TextBox1`, <xref:System.Windows.Forms.OpenFileDialog> 라는 `OpenFileDialog1`, <xref:System.Windows.Forms.Button> 라는 `Button1`, 및 <xref:System.Windows.Forms.ErrorProvider> 라는 `ErrorProvider1`합니다. 모든 이벤트가 해당 이벤트 처리기와 연결 되어 있는지 확인 합니다.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 사이의 공백을 가져오거나 설정합니다.</summary>
        <value>컨트롤 사이의 공백을 나타내는 <see cref="T:System.Windows.Forms.Padding" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에 대 한 기본값을 받을 <xref:System.Windows.Forms.Control.Margin%2A> 합리적으로 Windows 사용자 인터페이스 지침 가까운 않은 합니다. 약간씩 조정 특정 응용 프로그램에 필요할 수 있습니다.  
  
> [!NOTE]
>  설정의 <xref:System.Windows.Forms.Control.Margin%2A> 도킹된 된 컨트롤에 속성에는 해당 컨테이너의 가장자리에서 컨트롤의 거리에 대 한 영향을 주지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 여백이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.MarginChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.MarginChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />에서 지정할 수 있는 상한을 나타내는 크기를 가져오거나 설정합니다.</summary>
        <value>사각형의 너비와 높이를 나타내는 <see cref="T:System.Drawing.Size" /> 형식의 정렬된 쌍입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />에서 지정할 수 있는 하한을 나타내는 크기를 가져오거나 설정합니다.</summary>
        <value>사각형의 너비와 높이를 나타내는 <see cref="T:System.Drawing.Size" /> 형식의 정렬된 쌍입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>누른 상태에 있는 보조키(SHIFT, CTRL 및 ALT)를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Keys" /> 값의 비트 조합입니다. 기본값은 <see cref="F:System.Windows.Forms.Keys.None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 단추를 클릭 하는 동안 CTRL 키를 누르면 단추를 숨깁니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Button> 라는 `button1` 에 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>누른 상태에 있는 마우스 단추를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.MouseButtons" /> 열거형 값의 비트 조합입니다. 기본값은 <see cref="F:System.Windows.Forms.MouseButtons.None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, 및 <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> 멤버입니다. Form1 이라는 폼에는 예제를 실행 하려면 다음 코드를 붙여 여러 개의 컨트롤이 들어 있습니다. 이 예제에서는 <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, 및 <xref:System.Windows.Forms.Control.MouseUp> 이벤트가 예에서 정의 된 이벤트 처리기에 연결 합니다.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 마우스 캡처를 잃을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 드문 경우 예기치 않은 입력을 검색 해야 합니다. 예를 들어 다음과 같은 시나리오를 고려 합니다.  
  
-   마우스 작업을 사용 하는 동안 사용자는 Windows 키 또는 CTRL + ESC를 눌러 시작 메뉴를 엽니다.  
  
-   마우스 작업을 사용 하는 동안 사용자가 ALT + TAB을 눌러 다른 프로그램으로 전환 합니다.  
  
-   마우스 작업을 사용 하는 동안 다른 프로그램에는 창 또는 현재 응용 프로그램에서 포커스를 사용 하는 메시지 상자가 표시 됩니다.  
  
 폼 또는 컨트롤에서 마우스를 누르고 마우스 작업 포함 하거나 수행 마우스 끌기 작업. 컨트롤이 이러한 마우스 캡처를 손실 또는 양식 검색할 수 있는 경우 사용할 수 있습니다 관련된 예기치 않은 시나리오는 <xref:System.Windows.Forms.Control.MouseCaptureChanged> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Control.MouseCaptureChanged> 에 대 한 이벤트는 <xref:System.Windows.Forms.Button> 제어 합니다.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 이 예제를 테스트 하려면 f5 키를 눌러 디버거 실행 합니다. 열기는 **출력** Visual Studio의 창 이벤트는 발생 볼 수 있도록 합니다. 클릭는 <xref:System.Windows.Forms.Button> 는 다음과 같은 출력을 확인 합니다.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 이제를 누른 채로 마우스 왼쪽된 단추는 <xref:System.Windows.Forms.Button> 제어 합니다. 마우스 클릭 한 상태를 다른 프로그램으로 전환 하려면 ALT + TAB 키를 누릅니다. 에 <xref:System.Windows.Forms.Control.MouseCaptureChanged> 잠재적으로이 시나리오를 처리할 수 있도록 이벤트가 발생 합니다. 작업에 따라는 <xref:System.Windows.Forms.Control.MouseUp> 이벤트가 발생할 수 있습니다. Windows 키 또는 CTRL + ESC를 사용 하 여이 테스트를 시도할 수 있습니다.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 마우스로 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 커서가 컨트롤 위에 있을 때 마우스 단추를 누르면 다음 일련을의 컨트롤에서 이벤트를 발생 시킵니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> 이벤트  
  
2.  <xref:System.Windows.Forms.Control.Click> 이벤트  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> 이벤트  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> 이벤트  
  
 이 위해서는 컨트롤의 클래스에서 다양 한 이벤트를 해제할 수 없습니다.  
  
 두 번 클릭을 시간 내에 사용자의 운영 체제의 마우스 설정에서 결정 된 대로 생성 됩니다 발생 하는 한 <xref:System.Windows.Forms.Control.MouseDoubleClick> 이벤트 대신 두 번째 <xref:System.Windows.Forms.Control.MouseClick> 이벤트입니다.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click> 이벤트는 컨트롤의 논리적으로 더 높은 수준의 이벤트입니다. 이러한 이벤트는 대개 컨트롤에 포커스가 있을 때 ENTER 키를 누르는 것과 같은 다른 작업에 의해 발생 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.MouseClick> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.MouseClick> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 마우스로 두 번 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.MouseDoubleClick> 이벤트 커서가 컨트롤 위에 있을 때 두 번 연속적으로에서 마우스 단추를 누를 때 발생 합니다. 시간 간격을 두 번 클릭에서 두 번 클릭을 구분 하는 사용자의 운영 체제의 마우스 설정에서 결정 됩니다.  
  
 다음과 같은 일련의 이벤트는 이러한 사용자 작업이 실행 될 때 컨트롤에 의해 발생 합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> 이벤트  
  
2.  <xref:System.Windows.Forms.Control.Click> 이벤트  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> 이벤트  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> 이벤트  
  
5.  <xref:System.Windows.Forms.Control.MouseDown> 이벤트  
  
6.  <xref:System.Windows.Forms.Control.DoubleClick> 이벤트  
  
7.  <xref:System.Windows.Forms.Control.MouseDoubleClick> 이벤트  
  
8.  <xref:System.Windows.Forms.Control.MouseUp> 이벤트  
  
 이 위해서는 컨트롤의 클래스에서 다양 한 이벤트를 해제할 수 없습니다.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick> 이벤트는 컨트롤의 논리적으로 더 높은 수준의 이벤트입니다. 이러한 바로 가기 키 조합 등의 다른 사용자 작업에 의해 발생할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.MouseDoubleClick> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.MouseDoubleClick> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 컨트롤 위에 있을 때 마우스 단추를 클릭하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 마우스 이벤트는 다음 순서대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 여러 마우스 이벤트를 사용 하 여 마우스의 경로에 그리는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Panel>합니다. 선 세그먼트에 추가 되는 <xref:System.Drawing.Drawing2D.GraphicsPath> 각 <xref:System.Windows.Forms.Control.MouseMove> 및 <xref:System.Windows.Forms.Control.MouseDown> 발생 하는 이벤트입니다. 그래픽을 업데이트 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.Panel> 각 `MouseDown` 및 `MouseUp` 이벤트입니다. 그래픽 경로 때 위아래로 스크롤할 또한는 <xref:System.Windows.Forms.Control.MouseWheel> 이벤트가 발생 합니다. 와 같은 추가 마우스 이벤트 <xref:System.Windows.Forms.Control.MouseHover>, 화면에서 식별 됩니다. 마우스에 대 한 추가 정보는 화면에 표시 된 <xref:System.Windows.Forms.SystemInformation> 클래스입니다.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 컨트롤에 들어가면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 마우스 이벤트는 다음 순서대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 여러 마우스 이벤트를 사용 하 여 마우스의 경로에 그리는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Panel>합니다. 선 세그먼트에 추가 되는 <xref:System.Drawing.Drawing2D.GraphicsPath> 각 <xref:System.Windows.Forms.Control.MouseMove> 및 <xref:System.Windows.Forms.Control.MouseDown> 발생 하는 이벤트입니다. 그래픽을 업데이트 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.Panel> 각 `MouseDown` 및 `MouseUp` 이벤트입니다. 그래픽 경로 때 위아래로 스크롤할 또한는 <xref:System.Windows.Forms.Control.MouseWheel> 이벤트가 발생 합니다. 와 같은 추가 마우스 이벤트 <xref:System.Windows.Forms.Control.MouseHover>, 화면에서 식별 됩니다. 마우스에 대 한 추가 정보는 화면에 표시 된 <xref:System.Windows.Forms.SystemInformation> 클래스입니다.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 컨트롤 위에 있을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적인 사용 <xref:System.Windows.Forms.Control.MouseHover> ("호버 사각형")는 컨트롤 주위의 지정된 된 영역 내에서 컨트롤에서 마우스를 놓을 때 도구 설명 표시 하는 것입니다. 이 이벤트를 발생 하는 데 필요한 일시 중지 하 여 밀리초 단위로 지정 된는 <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> 속성입니다.  
  
 <xref:System.Windows.Forms.Control.MouseHover> 이벤트 정의 되 고 연결 하 여 검색 된 <xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A> 및 <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> 속성입니다.  
  
 마우스 이벤트는 다음 순서대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 여러 마우스 이벤트를 사용 하 여 마우스의 경로에 그리는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Panel>합니다. 선 세그먼트에 추가 되는 <xref:System.Drawing.Drawing2D.GraphicsPath> 각 <xref:System.Windows.Forms.Control.MouseMove> 및 <xref:System.Windows.Forms.Control.MouseDown> 발생 하는 이벤트입니다. 그래픽을 업데이트 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.Panel> 각 `MouseDown` 및 `MouseUp` 이벤트입니다. 그래픽 경로 때 위아래로 스크롤할 또한는 <xref:System.Windows.Forms.Control.MouseWheel> 이벤트가 발생 합니다. 와 같은 추가 마우스 이벤트 <xref:System.Windows.Forms.Control.MouseHover>, 화면에서 식별 됩니다. 마우스에 대 한 추가 정보는 화면에 표시 된 <xref:System.Windows.Forms.SystemInformation> 클래스입니다.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 컨트롤을 벗어나면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 마우스 이벤트는 다음 순서대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 여러 마우스 이벤트를 사용 하 여 마우스의 경로에 그리는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Panel>합니다. 선 세그먼트에 추가 되는 <xref:System.Drawing.Drawing2D.GraphicsPath> 각 <xref:System.Windows.Forms.Control.MouseMove> 및 <xref:System.Windows.Forms.Control.MouseDown> 발생 하는 이벤트입니다. 그래픽을 업데이트 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.Panel> 각 `MouseDown` 및 `MouseUp` 이벤트입니다. 그래픽 경로 때 위아래로 스크롤할 또한는 <xref:System.Windows.Forms.Control.MouseWheel> 이벤트가 발생 합니다. 와 같은 추가 마우스 이벤트 <xref:System.Windows.Forms.Control.MouseHover>, 화면에서 식별 됩니다. 마우스에 대 한 추가 정보는 화면에 표시 된 <xref:System.Windows.Forms.SystemInformation> 클래스입니다.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터를 컨트롤 위로 이동하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적 사용 범위 <xref:System.Windows.Forms.Control.MouseMove> 컨트롤 주위에 나타나는 사각형을 그리는 데 또는 컨트롤의 색을 변경 합니다.  
  
 마우스 이벤트는 다음 순서대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 여러 마우스 이벤트를 사용 하 여 마우스의 경로에 그리는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Panel>합니다. 선 세그먼트에 추가 되는 <xref:System.Drawing.Drawing2D.GraphicsPath> 각 <xref:System.Windows.Forms.Control.MouseMove> 및 <xref:System.Windows.Forms.Control.MouseDown> 발생 하는 이벤트입니다. 그래픽을 업데이트 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.Panel> 각 `MouseDown` 및 `MouseUp` 이벤트입니다. 그래픽 경로 때 위아래로 스크롤할 또한는 <xref:System.Windows.Forms.Control.MouseWheel> 이벤트가 발생 합니다. 와 같은 추가 마우스 이벤트 <xref:System.Windows.Forms.Control.MouseHover>, 화면에서 식별 됩니다. 마우스에 대 한 추가 정보는 화면에 표시 된 <xref:System.Windows.Forms.SystemInformation> 클래스입니다.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>화면 좌표에서 마우스 커서의 위치를 가져옵니다.</summary>
        <value>화면의 왼쪽 위 모퉁이를 기준으로 마우스 커서의 좌표가 포함된 <see cref="T:System.Drawing.Point" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.MousePosition%2A> 속성에서 반환 된 <xref:System.Drawing.Point> 은 속성이 참조 하는 시간에 마우스 커서 위치를 나타내는입니다. 좌표는 컨트롤을 기준으로 하지 않고 화면에서의 위치와 커서가 컨트롤 위에 위치 하는지 여부에 관계 없이 반환 됩니다. 화면의 왼쪽 위 모퉁이의 좌표는 0, 0입니다.  
  
 <xref:System.Windows.Forms.Control.MousePosition%2A> 속성은 동일는 <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배치는 <xref:System.Windows.Forms.TreeNode> 레이블을 마우스 커서가 트리 노드 위에 있는 동안 사용자가 ALT + E를 누를 때 편집 가능한 상태에 있습니다. 사용자를 완료 한 후 레이블의 편집 레이블을 편집할 수 없는 다시 다시 키 조합 ALT + E를 누를 때까지 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.TreeView> 에 <xref:System.Windows.Forms.Form>합니다. 트리 뷰에 있는 하나 이상의 <xref:System.Windows.Forms.TreeNode> 에 해당 <xref:System.Windows.Forms.TreeView.Nodes%2A> 컬렉션입니다.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 컨트롤 위에 있을 때 마우스 단추를 눌렀다 놓으면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 마우스 이벤트는 다음 순서대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  에 대 한 다음과 같은 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Forms.TabControl> 하나 이상 있으면 클래스 <xref:System.Windows.Forms.TabPage> 에 <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> 컬렉션: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> 및 <xref:System.Windows.Forms.Control.MouseMove>합니다. 둘 이상 있는 경우 <xref:System.Windows.Forms.TabPage> 컬렉션에 사용자 탭 컨트롤의 헤더 상호 작용 하 고 (여기서는 <xref:System.Windows.Forms.TabPage> 이름이 표시), <xref:System.Windows.Forms.TabControl> 적절 한 이벤트를 발생 시킵니다. 그러나 사용자 상호 작용 탭 페이지의 클라이언트 영역 내에 있으면는 <xref:System.Windows.Forms.TabPage> 적절 한 이벤트를 발생 시킵니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 여러 마우스 이벤트를 사용 하 여 마우스의 경로에 그리는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Panel>합니다. 선 세그먼트에 추가 되는 <xref:System.Drawing.Drawing2D.GraphicsPath> 각 <xref:System.Windows.Forms.Control.MouseMove> 및 <xref:System.Windows.Forms.Control.MouseDown> 발생 하는 이벤트입니다. 그래픽을 업데이트 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.Panel> 각 `MouseDown` 및 `MouseUp` 이벤트입니다. 그래픽 경로 때 위아래로 스크롤할 또한는 <xref:System.Windows.Forms.Control.MouseWheel> 이벤트가 발생 합니다. 와 같은 추가 마우스 이벤트 <xref:System.Windows.Forms.Control.MouseHover>, 화면에서 식별 됩니다. 마우스에 대 한 추가 정보는 화면에 표시 된 <xref:System.Windows.Forms.SystemInformation> 클래스입니다.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 포커스가 있을 때 마우스 휠을 움직이면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리 하는 경우는 <xref:System.Windows.Forms.Control.MouseWheel> 마우스 휠과 사용 하 여 관련 사용자 인터페이스 (UI) 표준을 준수 해야 하는 이벤트입니다. <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType> 속성 값 크기 마우스 휠을 이동 되었는지 나타냅니다. 델타 때 누적 된 델타 더하기 또는 빼기 120입니다. 델타에서 반환 되는 논리 줄의 수는 <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> 모든 델타 값에 대 한 속성에 도달 합니다. 스크롤할 수도 있습니다 더 원활 하 게에서 더 작은 120 단위 증가 시키는 그대로 유지, 즉 있지만 <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> 줄 비율은 120 델타 단위당 스크롤됩니다.  
  
 마우스 휠 메시지를 처리 하는 방법에 대 한 자세한 내용은 참조는[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx)항목입니다.  
  
 마우스 이벤트는 다음 순서대로 발생합니다.  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 여러 마우스 이벤트를 사용 하 여 마우스의 경로에 그리는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Panel>합니다. 선 세그먼트에 추가 되는 <xref:System.Drawing.Drawing2D.GraphicsPath> 각 <xref:System.Windows.Forms.Control.MouseMove> 및 <xref:System.Windows.Forms.Control.MouseDown> 발생 하는 이벤트입니다. 그래픽을 업데이트 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 에 대 한 메서드는 <xref:System.Windows.Forms.Panel> 각 `MouseDown` 및 `MouseUp` 이벤트입니다. 그래픽 경로 때 위아래로 스크롤할 또한는 <xref:System.Windows.Forms.Control.MouseWheel> 이벤트가 발생 합니다. 와 같은 추가 마우스 이벤트 <xref:System.Windows.Forms.Control.MouseHover>, 화면에서 식별 됩니다. 마우스에 대 한 추가 정보는 화면에 표시 된 <xref:System.Windows.Forms.SystemInformation> 클래스입니다.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 이동하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Move> 폼의 캡션 표시줄에 화면 좌표에서 폼의 위치를 표시 하는 이벤트입니다.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 이름을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 이름입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Name%2A> 속성 있습니다 사용할 런타임 시 개체를 확인할 이름 보다는 형식 및 프로그래밍 방식으로 이름으로 합니다. 때문에 <xref:System.Windows.Forms.Control.Name%2A> 속성에서 반환은 <xref:System.String> 유형, 대/소문자 스타일 논리 문을에서 확인할 수 있습니다 (`Select` Visual Basic의 문 `switch` 문을 Visual C# 및 [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]).  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Control.Name%2A> 컨트롤에 대 한 <xref:System.Windows.Forms.MessageBox> 컨트롤 추가 또는 폼에서 제거할 때.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">무효화할 영역을 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <summary>무효화할 컨트롤의 지정한 영역에서 <see cref="E:System.Windows.Forms.Control.Invalidated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.AutoSizeChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.CausesValidationChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.UICuesEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ChangeUICues" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnChangeUICues%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Click" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnClick%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.OnClick%2A> 파생된 클래스에서 메서드. 이 예제를 실행 하려면 같은 파일에 폼 클래스 뒤 다음 코드를 붙여 넣습니다. 형식의 텍스트 상자 추가 `SingleClickTextBox` 양식입니다.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 다음 코드 예제에서는의 여러 기능 중 하나는 <xref:System.Windows.Forms.Control.Click> 이벤트와 이벤트 처리기입니다.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ClientSizeChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.ControlEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ControlAdded" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자식 컨트롤이 컨트롤에 추가 될 때 호출 됩니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnControlAdded%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.ControlAdded> 폼에 컨트롤을 추가 하려면에 추가 된 컨트롤의 이름을 표시 한 <xref:System.Windows.Forms.MessageBox>합니다.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.ControlEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ControlRemoved" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자식 컨트롤이 컨트롤에서 제거 될 때 호출 됩니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnControlRemoved%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.ControlRemoved> 양식에서 컨트롤을 제거 하려면에 제거 된 컨트롤의 이름을 표시 한 <xref:System.Windows.Forms.MessageBox>합니다.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.Control.CreateControl" /> 메서드를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnCreateControl%2A> 메서드 컨트롤을 처음으로 만들어질 때 호출 됩니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnCreateControl%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnCreateControl" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.CursorChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnCursorChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DockChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnDockChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DoubleClick" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnDoubleClick%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.DoubleClick> 의 이벤트는 <xref:System.Windows.Forms.ListBox> 에 나열 된 텍스트 파일을 로드 하는 <xref:System.Windows.Forms.ListBox> 에 <xref:System.Windows.Forms.TextBox> 제어 합니다.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DragEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragDrop" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnDragDrop%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DragEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragEnter" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnDragEnter%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragLeave" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnDragLeave%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DragEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragOver" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnDragOver%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Enter" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnEnter%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Enter> 의 전경색과 배경색 색을 변경 하는 이벤트는 <xref:System.Windows.Forms.TextBox> 특정 조건 하에서 합니다.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.FontChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnFontChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.GiveFeedback" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.GotFocus" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnGotFocus%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnHandleCreated%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.HelpEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.HelpRequested" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnHelpRequested%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ImeModeChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.InvalidateEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Invalidated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnInvalidated%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.KeyEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.KeyDown" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnKeyDown%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.KeyDown> 컨트롤에 입력 한 문자 형식을 결정 하는 이벤트입니다.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.KeyPressEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.KeyPress" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnKeyPress%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.KeyPress> 문자가 컨트롤에 진입 하지 못하도록 하는 이벤트입니다.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.KeyEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.KeyUp" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnKeyUp%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.KeyUp> 인 이벤트는 <xref:System.Windows.Forms.Help> 사용자에 게 팝업 스타일 도움말을 표시 하는 클래스입니다.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.LayoutEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Layout" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnLayout%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 하 고 있는 일반 도킹 및 고정 기능이 작동 하도록 합니다. 파생된 클래스는 사용자 지정 레이아웃 논리를 수행 하기 위해이 메서드를 재정의 해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Leave" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnLeave%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Leave> 컨트롤을 이전 상태로 다시 설정 하는 이벤트입니다.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.LocationChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnLocationChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.LostFocus" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnLostFocus%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MarginChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMarginChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MouseEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseClick" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseClick%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MouseEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseDoubleClick" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MouseEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseDown" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseDown%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseEnter" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseEnter%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseHover" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseHover%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.OnMouseHover%2A> 및 <xref:System.Windows.Forms.Control.OnMouseMove%2A> 파생된 클래스에서 메서드. 예를 실행 하 고 새 폼에 다음 코드를 붙여 넣습니다.이 클래스를 붙여를 같은 파일 형식을 만듭니다. 형식의 단추 추가 `FunButton` 양식입니다.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseLeave" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseLeave%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MouseEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseMove" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseMove%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.OnMouseHover%2A> 및 <xref:System.Windows.Forms.Control.OnMouseMove%2A> 파생된 클래스에서 메서드. 예를 실행 하 고 새 폼에 다음 코드를 붙여 넣습니다.이 클래스를 붙여를 같은 파일 형식을 만듭니다. 형식의 단추 추가 `FunButton` 양식입니다.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MouseEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseUp" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseUp%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MouseEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.MouseWheel" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMouseWheel%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Move" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnMove%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Move> 폼의 캡션 표시줄에 화면 좌표에서 폼의 위치를 표시 하는 이벤트입니다.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Windows 메시지를 나타내는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>컨트롤에 Windows 메시지를 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnNotifyMessage%2A> 경우 메서드는 컨트롤의 `EnableNotifyMessage` 에 스타일 비트가 설정 <xref:System.Windows.Forms.ControlStyles>합니다. `EnableNotifyMessage` 에 스타일을 <xref:System.Windows.Forms.ControlStyles> 컨트롤 될 때 알림을 받으려면을 <xref:System.Windows.Forms.Control.WndProc%2A> 메서드는 Windows 메시지를 수신 합니다. 이 메서드로 부분적으로 신뢰할 수 있는 컨트롤 메시지를 수정 하려면을 사용 하지 않고 Windows 메시지 수신할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> 파생된 클래스에서 기본 클래스의 호출 <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> 초기 구현이 없기 때문에 메서드는 필요 없습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.PaddingChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.PaintEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Paint" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnPaint%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이미지 또는 이미지 파일을 폼으로 끌어을 하 게 삭제 된 지점에 표시 될 수 있습니다. <xref:System.Windows.Forms.Control.OnPaint%2A> 메서드는 폼을 그릴 될 때마다 이미지를 다시 그리기 위해 재정의 됩니다; 그렇지 않은 경우 이미지는 다음에 다시 그릴 때까지 유지만 합니다. <xref:System.Windows.Forms.Control.DragEnter> 이벤트 처리 메서드는 형식으로 끌고 있는 데이터의 형식을 결정 하 고 적절 한 피드백을 제공 합니다. <xref:System.Windows.Forms.Control.DragDrop> 경우 이벤트 처리 메서드는 폼에 이미지를 표시 한 <xref:System.Drawing.Image> 데이터에서 만들 수 있습니다. 때문에 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> 값은 화면 좌표를 사용 하 여는 <xref:System.Windows.Forms.Control.PointToClient%2A> 메서드를 클라이언트 좌표로 변환 합니다.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">그리려는 컨트롤에 대한 정보가 포함된 <see cref="T:System.Windows.Forms.PaintEventArgs" />입니다.</param>
        <summary>컨트롤의 배경을 그립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnPaintBackground%2A> 메서드 사용 하면 파생된 클래스가 Windows 백그라운드 처리를 지우기 요청입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>클래스를 상속 하는 windows에서 배경 지우기 요청을 처리 하려면이 메서드를 재정의 해야 합니다. 재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> 파생된 클래스에서 필요한 경우가 아니라면 기본 클래스를 호출 하려면 <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />합니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.BackColor" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.BindingContext" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.ParentChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.CursorChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.Enabled" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.FontChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.Font" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentFontChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.ForeColor" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.RightToLeft" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>컨트롤 컨테이너의 <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> 속성 값이 변경되면 <see cref="P:System.Windows.Forms.Control.Visible" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.PreviewKeyDown" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.PaintEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Paint" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `UserPaint` 비트의 <xref:System.Windows.Forms.ControlStyles> 재정의할 수 있습니다 설정 <xref:System.Windows.Forms.Control.OnPrint%2A> 계층적으로 그릴를 합니다. 자세한 내용은 <xref:System.Windows.Forms.Control.SetStyle%2A>를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.QueryContinueDrag" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 반복적으로 호출 끌기가 시작 되는 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 끌기 작업 취소 또는 완료 될 때까지 합니다.  
  
> [!NOTE]
>  끌기가 취소 또는 놓기가 발생 시점을 변경 하려는 경우이 메서드를 재정의 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.RegionChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.Control.OnRegionChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Resize" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnResize%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> 메서드를 호출해야 합니다. <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> 메서드 생성 되는 동안 재정의 하는 경우 그렇게 <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> 컨트롤 생성자가 호출 되기 전에 호출할 수 있습니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.SizeChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnSizeChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.StyleChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnStyleChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.TabIndexChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.TabStopChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnTabStopChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.TextChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnTextChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Validated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnValidated%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.CancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.Validating" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnValidating%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.Control.OnVisibleChanged%2A> 메서드도 사용 하면 파생된 클래스가 대리자를 연결 하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트를 발생 시키는 방법이 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 `On` *PropertyName* `Changed` 해당 발생 하는 *PropertyName* `Changed` 이벤트 때는 *PropertyName* 값이 변경 (*PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 하는 클래스를 파생 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제에서는 있어야에서 파생 되는 클래스는 <xref:System.Windows.Forms.TextBox> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 클래스에서 <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 안쪽 여백을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 내부 간격 특성을 나타내는 <see cref="T:System.Windows.Forms.Padding" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 같은 컨테이너에 대 한 <xref:System.Windows.Forms.GroupBox> 및 <xref:System.Windows.Forms.TabControl>, <xref:System.Windows.Forms.Control.Padding%2A> 속성 가져오거나 각각의 해당 <xref:System.Windows.Forms.Control.DisplayRectangle%2A> 속성입니다. <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType> 속성이 해당 <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType> 속성입니다.  
  
 컨트롤에 대 한 기본값을 받을 <xref:System.Windows.Forms.Control.Padding%2A> 합리적으로 Windows 사용자 인터페이스 지침 가까운 않은 합니다. 약간씩 조정 특정 응용 프로그램에 필요할 수 있습니다.  
  
 구현 하는 모든 컨트롤 <xref:System.Windows.Forms.Control.GetPreferredSize%2A> 크기에 따라 확대 <xref:System.Windows.Forms.Control.Padding%2A> 때 <xref:System.Windows.Forms.Control.AutoSize%2A> 은 `true`합니다.  
  
 다음과 같은 컨트롤을 사용 하지 않는 <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   구현 하지 않는 컨트롤 <xref:System.Windows.Forms.Control.AutoSize%2A> 통해 <xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   직접 상속 하는 사용자 지정 컨트롤 <xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 안쪽 여백이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.PaddingChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.PaddingChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤을 다시 그리면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Paint> 이벤트는 컨트롤을 다시 그리면 발생 합니다. 인스턴스를 전달 <xref:System.Windows.Forms.PaintEventArgs> 를 처리 하는 메서드에 <xref:System.Windows.Forms.Control.Paint> 이벤트입니다.  
  
 재정의 하 여 컨트롤을 렌더링 하는 코드를 제공 해야와 모양이 다른 새 사용자 지정 컨트롤 또는 상속된 된 컨트롤을 만들 때의 <xref:System.Windows.Forms.Control.OnPaint%2A> 메서드. 자세한 내용은 참조 [OnPaint 메서드 재정의](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) 및 [사용자 지정 컨트롤 그리기 및 렌더링](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md)합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.PictureBox> 의 폼에 사용 하 여 컨트롤의 <xref:System.Windows.Forms.Control.Paint> 를 그리려면 이벤트입니다.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 부모 컨테이너를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 부모 또는 컨테이너 컨트롤을 나타내는 <see cref="T:System.Windows.Forms.Control" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정의 <xref:System.Windows.Forms.Control.Parent%2A> 속성 값을 `null` 에서 컨트롤이 제거는 <xref:System.Windows.Forms.Control.ControlCollection> 현재 부모 컨트롤의 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.Parent%2A> 속성 및 <xref:System.Windows.Forms.Control.FindForm%2A> 메서드를 부모 컨트롤은 단추와 해당 폼의 속성을 설정 합니다.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성 값을 가져오는 모든 창입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Parent" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Parent%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤이 자식 컨트롤에 레이아웃 논리를 강제로 적용하도록 합니다.</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤이 모든 자식 컨트롤에 레이아웃 논리를 강제로 적용하도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 메서드가 호출 하기 전에 <xref:System.Windows.Forms.Control.PerformLayout%2A> 메서드는 <xref:System.Windows.Forms.Control.Layout> 이벤트가 발생 하지 않습니다.  
  
 <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> 및 <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> 의 속성은 <xref:System.Windows.Forms.LayoutEventArgs> 로 설정 하는 생성 된 `null` 때 지정 된 값이 없으면는 <xref:System.Windows.Forms.Control.PerformLayout%2A> 메서드를 호출 했습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.PerformLayout%2A> 메서드를 사용하는 방법을 보여 줍니다. 방식도 보여 줍니다는 <xref:System.Windows.Forms.Control.Layout> 이벤트가 발생 합니다. 이 예제는 `Click` 에 대 한 이벤트 처리기 `Button1` 명시적으로 호출 <xref:System.Windows.Forms.Control.PerformLayout%2A>합니다. `Click` 에 대 한 이벤트 처리기 `Button2` 암시적으로 호출 <xref:System.Windows.Forms.Control.PerformLayout%2A>합니다. <xref:System.Windows.Forms.Control.PerformLayout%2A> 양식이 로드 될 때 호출 또한 됩니다. `Button3` 컨트롤을 로드할 때의 상태로 돌아갑니다. 각각의 경우에는 <xref:System.Windows.Forms.Control.Layout> 이벤트가 발생 합니다.  
  
 전체 예제입니다. 이 예제를 실행 하려면 빈 폼에 다음 코드를 붙여 넣습니다.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">가장 최근에 변경된 컨트롤을 나타내는 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <param name="affectedProperty">컨트롤에서 가장 최근에 변경된 속성의 이름입니다.</param>
        <summary>컨트롤이 모든 자식 컨트롤에 레이아웃 논리를 강제로 적용하도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 메서드가 호출 하기 전에 <xref:System.Windows.Forms.Control.PerformLayout%2A> 메서드는 <xref:System.Windows.Forms.Control.Layout> 이벤트가 발생 하지 않습니다.  
  
 `affectedControl` 및 `affectedProperty` 매개 변수 둘 다로 설정할 수 있습니다 `null`합니다. 이렇게 하면는 <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> 및 <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> 의 속성은 <xref:System.Windows.Forms.LayoutEventArgs> 로 설정 하기 위해 만든 `null`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.PerformLayout%2A> 메서드를 사용하는 방법을 보여 줍니다. 방식도 보여 줍니다는 <xref:System.Windows.Forms.Control.Layout> 이벤트가 발생 합니다. 이 예제는 `Click` 에 대 한 이벤트 처리기 `Button1` 명시적으로 호출 <xref:System.Windows.Forms.Control.PerformLayout%2A>합니다. `Click` 에 대 한 이벤트 처리기 `Button2` 암시적으로 호출 <xref:System.Windows.Forms.Control.PerformLayout%2A>합니다. <xref:System.Windows.Forms.Control.PerformLayout%2A> 양식이 로드 될 때 호출 또한 됩니다. `Button3` 컨트롤을 로드할 때의 상태로 돌아갑니다. 각각의 경우에는 <xref:System.Windows.Forms.Control.Layout> 이벤트가 발생 합니다.  
  
 전체 예제입니다. 이 예제를 실행 하려면 빈 폼에 다음 코드를 붙여 넣습니다.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">변환할 화면 좌표 <see cref="T:System.Drawing.Point" />입니다.</param>
        <summary>특정 화면 지점의 위치를 클라이언트 좌표로 계산합니다.</summary>
        <returns>변환된 <see cref="T:System.Drawing.Point" />인 <see cref="T:System.Drawing.Point" />를 클라이언트 좌표로 나타내는 <paramref name="p" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 사용자 이미지 또는 이미지 파일을 폼으로 끌어 지점에 표시 되도록가를 놓이고는 다음 코드 예제에서는 합니다. <xref:System.Windows.Forms.Control.OnPaint%2A> 메서드는 폼을 그릴 될 때마다 이미지를 다시 그리기 위해 재정의 됩니다; 그렇지 않은 경우 이미지는 다음에 다시 그릴 때까지 유지만 합니다. <xref:System.Windows.Forms.Control.DragEnter> 이벤트 처리 메서드는 형식으로 끌고 있는 데이터의 형식을 결정 하 고 적절 한 피드백을 제공 합니다. <xref:System.Windows.Forms.Control.DragDrop> 경우 이벤트 처리 메서드는 폼에 이미지를 표시 한 <xref:System.Drawing.Image> 데이터에서 만들 수 있습니다. 때문에 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> 값은 화면 좌표를 사용 하 여는 <xref:System.Windows.Forms.Control.PointToClient%2A> 메서드를 클라이언트 좌표로 변환 합니다.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">변환할 클라이언트 좌표 <see cref="T:System.Drawing.Point" />입니다.</param>
        <summary>특정 클라이언트 지점의 위치를 화면 좌표로 계산합니다.</summary>
        <returns>변환된 <see cref="T:System.Drawing.Point" />인 <see cref="T:System.Drawing.Point" />를 화면 좌표로 나타내는 <paramref name="p" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, 및 <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> 멤버입니다. Form1 이라는 폼에는 예제를 실행 하려면 다음 코드를 붙여 여러 개의 컨트롤이 들어 있습니다. 이 예제에서는 <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, 및 <xref:System.Windows.Forms.Control.MouseUp> 이벤트가 예에서 정의 된 이벤트 처리기에 연결 합니다.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 들어갈 수 있는 사각형 영역의 크기를 가져옵니다.</summary>
        <value>너비와 높이가 포함된 <see cref="T:System.Drawing.Size" />(픽셀)입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">처리할 메시지를 나타내는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>메시지 루프 내에 있는 키보드 또는 입력 메시지를 전처리한 다음 디스패치합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.PreProcessControlState" />가 <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> 또는 <see langword="true" />인지 여부와 <see langword="false" />나 <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />가 <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> 또는 <see langword="true" />인지 여부에 따라 다른 <see langword="false" /> 값 중 하나입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">처리할 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다. 가능한 값은 WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR 및 WM_SYSCHAR입니다.</param>
        <summary>메시지 루프 내에 있는 키보드 또는 입력 메시지를 전처리한 다음 디스패치합니다.</summary>
        <returns>
          컨트롤이 메시지를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> 디스패치 되기 전에 입력된 메시지를 전처리 하는 응용 프로그램의 메시지 루프에 의해 호출 됩니다. 에 가능한 값은 `msg` 매개 변수는 WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR 및 wm_syschar입니다.  
  
 재정의 하는 경우 <xref:System.Windows.Forms.Control.PreProcessMessage%2A>, 컨트롤은 반환 `true` 메시지 처리 했음을 나타냅니다. 컨트롤의 결과 의해 처리 되지 않은 메시지에 대 한 `base.PreProcessMessage` 반환 되어야 합니다. 컨트롤은 일반적으로 더 특수 한 방법 중 하나와 같은 재정의 <xref:System.Windows.Forms.Control.IsInputChar%2A>, <xref:System.Windows.Forms.Control.IsInputKey%2A>, <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>, 또는 <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> 재정의 하는 대신 <xref:System.Windows.Forms.Control.PreProcessMessage%2A>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 직접 실행 호출자의 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤에 포커스가 있는 동안 키를 누르면 <see cref="E:System.Windows.Forms.Control.KeyDown" /> 이벤트 전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 입력된 키 누름을 간주 되지 않는 때문에 일부 키 누름 탭, 리턴, esc를 누르고 화살표 키 등은 일반적으로 일부 컨트롤에서 무시 됩니다. 예를 들어 기본적으로 <xref:System.Windows.Controls.Button> 컨트롤 화살표 키를 무시 합니다. 일반적으로 화살표 키를 누르면 포커스가 이전 또는 다음 컨트롤로 이동 하면 됩니다. 화살표 키 탐색 키 및 키를 눌러 이러한 키가 일반적으로 발생 하지 않는 것으로 간주 된 <xref:System.Windows.Forms.Control.KeyDown> 에 대 한 이벤트는 <xref:System.Windows.Controls.Button>합니다. 그러나에 대 한 키의 화살표를 누르면는 <xref:System.Windows.Controls.Button> 발생지 않습니다는 <xref:System.Windows.Forms.Control.PreviewKeyDown> 이벤트입니다. 처리 하 여는 <xref:System.Windows.Forms.Control.PreviewKeyDown> 에 대 한 이벤트는 <xref:System.Windows.Controls.Button> 설정는 <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> 속성을 `true`를 발생 시킬 수 있습니다는 <xref:System.Windows.Forms.Control.KeyDown> 화살표 키를 누를 때 이벤트입니다. 그러나 화살표 키를 처리 하는 경우 이전 또는 다음 컨트롤로 포커스가 이동 더 이상 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Button> 포함 하는 <xref:System.Windows.Forms.ContextMenuStrip>합니다. 경우는 <xref:System.Windows.Forms.Button> 포커스가 있고 위쪽 화살표 또는 아래쪽 화살표 키를 눌러는 <xref:System.Windows.Forms.ContextMenuStrip> 나타납니다. <xref:System.Windows.Forms.Control.PreviewKeyDown> 위쪽 화살표 또는 아래쪽 화살표 키를 누를 때 검색 하 고 설정 하는 이벤트 처리기는 <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> 속성을 `true`합니다. 이 <xref:System.Windows.Forms.Control.KeyDown> 이벤트 표시할 수 있도록는 <xref:System.Windows.Forms.ContextMenuStrip>합니다. 두어서는 안됩니다 논리는 <xref:System.Windows.Forms.Control.PreviewKeyDown> 설정 이외의 다른 이벤트 처리기는 <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> 속성입니다. 대신에 논리를 삽입 해야는 <xref:System.Windows.Forms.Control.KeyDown> 이벤트 처리기입니다.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <param name="keyData">처리할 키를 나타내는 <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>명령 키를 처리합니다.</summary>
        <returns>
          컨트롤이 문자를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 명령 키를 처리 하기 위해 메시지 전처리 하는 동안 호출 됩니다. 명령 키가 일반 입력된 키 보다 항상 우선 하는 키입니다. 명령 키의 예로 액셀러레이터 키 및 바로 가기 메뉴를 들 수 있습니다. 메서드 반환 해야 `true` 명령 키가 처리 되었는지 나타내는 또는 `false` 키 명령 키 임을 나타냅니다. 이 메서드는 컨트롤은 ActiveX 컨트롤 또는 Windows Forms 응용 프로그램에서 호스트 되는 경우에 호출 됩니다.  
  
 <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> 메서드는 컨트롤에 있는지 먼저 확인는 <xref:System.Windows.Forms.ContextMenu>, 그렇다면 수 있도록는 <xref:System.Windows.Forms.ContextMenu> 명령 키를 처리 합니다. 부모에 전달 된 키에 명령 키가 메뉴 바로 가기 하는 경우 컨트롤에 부모 <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> 메서드. 한 순수 효과 키 있게 됩니다"컨트롤 계층 구조는 명령입니다. 사용자가 누른 키 뿐만 아니라 키 데이터도 나타냅니다에 누른 보조키 있는 경우 키와 같은 시간입니다. 보조키는 SHIFT, CTRL 및 ALT 키를 포함 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">및에 대 한 직접 실행 호출자 클래스 상속이 메서드를 호출 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> 파생된 클래스에서 메서드를 컨트롤은 반환 <see langword="true" /> 키가 처리 되었는지 나타냅니다. 컨트롤의 기본 클래스의 호출 결과 의해 처리 되지 않은 키에 대 한 <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> 메서드를 반환 해야 합니다. 컨트롤 거의 얻어지는 경우 할이 메서드를 재정의할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">처리할 문자입니다.</param>
        <summary>대화 상자 문자를 처리합니다.</summary>
        <returns>
          컨트롤이 문자를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 메시지를 전처리 컨트롤 니모닉 같은 대화 상자 문자를 처리 하는 동안 호출 됩니다. 이 메서드는 경우에는 <xref:System.Windows.Forms.Control.IsInputChar%2A> 메서드는 제어 문자를 처리 하지 않는다는 것을 나타냅니다. <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> 메서드를 부모의 문자를 단순히 보냅니다 <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> 메서드나 반환 `false` 컨트롤 부모가 없는 경우. <xref:System.Windows.Forms.Form> 클래스 대화 상자 문자의 실제 처리를 수행 하려면이 메서드를 재정의 합니다. 이 메서드는 컨트롤은 ActiveX 컨트롤 또는 Windows Forms 응용 프로그램에서 호스트 되는 경우에 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> 파생된 클래스에서 메서드를 컨트롤은 반환 <see langword="true" /> 문자 처리 했음을 나타냅니다. 컨트롤의 기본 클래스의 호출 결과 의해 처리 되지 않은 문자에 대 한 <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> 메서드를 반환 해야 합니다. 컨트롤 거의 얻어지는 경우 할이 메서드를 재정의할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">처리할 키를 나타내는 <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>대화 상자 키를 처리합니다.</summary>
        <returns>
          컨트롤이 키를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 탭, 리턴, esc를 누르고 화살표 키 등의 대화 상자 문자를 처리 하기 위해 메시지를 전처리 하는 동안 호출 됩니다. 이 메서드는 경우에는 <xref:System.Windows.Forms.Control.IsInputKey%2A> 메서드 컨트롤이 키를 처리 하지 않는다는 것을 나타냅니다. <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> 부모의 문자를 단순히 보냅니다 <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> 메서드나 반환 `false` 컨트롤 부모가 없는 경우. <xref:System.Windows.Forms.Form> 클래스 대화 상자 키의 실제 처리를 수행 하려면이 메서드를 재정의 합니다. 이 메서드는 컨트롤은 ActiveX 컨트롤 또는 Windows Forms 응용 프로그램에서 호스트 되는 경우에 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" /> 파생된 클래스에서 메서드를 컨트롤은 반환 <see langword="true" /> 키가 처리 되었는지 나타냅니다. 컨트롤의 기본 클래스의 호출 결과 의해 처리 되지 않은 키에 대 한 <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> 메서드를 반환 해야 합니다. 컨트롤 거의 얻어지는 경우 할이 메서드를 재정의할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>키 메시지를 처리하고 적합한 컨트롤 이벤트를 생성합니다.</summary>
        <returns>
          컨트롤이 메시지를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 키보드 메시지를 받을 때 호출 됩니다. 메서드를 호출 하 여 메시지에 대 한 적절 한 키 이벤트를 생성 하는 <xref:System.Windows.Forms.Control.OnKeyPress%2A>, <xref:System.Windows.Forms.Control.OnKeyDown%2A>, 또는 <xref:System.Windows.Forms.Control.OnKeyUp%2A> 메서드. `m` 매개 변수를 처리 해야 하는 창 메시지를 포함 합니다. 에 가능한 값은 <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> 속성은 WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP, 및 WM_IME_CHAR 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 직접 실행 호출자입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> 파생된 클래스에서 메서드를 컨트롤은 반환 <see langword="true" /> 키가 처리 되었는지 나타냅니다. 컨트롤의 기본 클래스의 호출 결과 의해 처리 되지 않은 키에 대 한 <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> 메서드를 반환 해야 합니다. 컨트롤 거의 얻어지는 경우 할이 메서드를 재정의할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>키보드 메시지를 처리합니다.</summary>
        <returns>
          컨트롤이 메시지를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 키보드 메시지를 받을 때 호출 됩니다. 메서드는 먼저 컨트롤에 부모; 여부 확인 따라서 부모 항목을 호출 하는 경우 <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> 메서드. 경우 부모의 <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> 방법은 메시지를 처리 하지 않습니다는 다음 <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A> 메서드는 적절 한 키보드 이벤트를 생성 합니다. `m` 매개 변수를 처리 해야 하는 창 메시지를 포함 합니다. 에 가능한 값의 <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, 및 WM_SYSKEYUP 속성이 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" /> 메서드, 컨트롤은 반환 <see langword="true" /> 키가 처리 되었는지 나타냅니다. 컨트롤의 기본 클래스의 결과 의해 처리 되지 않은 키에 대 한 <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> 반환 되어야 합니다. 컨트롤 거의 얻어지는 경우 할이 메서드를 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>키보드 메시지를 미리 봅니다.</summary>
        <returns>
          컨트롤이 메시지를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 자식 컨트롤이 키보드 메시지를 수신할 때 자식 컨트롤에 의해 호출 됩니다. 자식 컨트롤의 메시지에 대 한 키보드 이벤트를 생성 하기 전에이 메서드를 호출 합니다. 이 메서드가 반환 하는 경우 `true`, 자식 컨트롤에서 메시지가 처리 및 키보드 이벤트를 생성 하지 않습니다. `m` 매개 변수를 미리 보려면 창 메시지를 포함 합니다. 에 가능한 값의 <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, 및 WM_SYSKEYUP 속성이 됩니다. <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> 메서드를 부모의 문자를 단순히 보냅니다 <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> 메서드나 반환 `false` 컨트롤 부모가 없는 경우. <xref:System.Windows.Forms.Form> 클래스 대화 상자 키의 실제 처리를 수행 하려면이 메서드를 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 직접 실행 호출자입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> 파생된 클래스에서 메서드를 컨트롤은 반환 <see langword="true" /> 키가 처리 되었는지 나타냅니다. 컨트롤의 기본 클래스의 호출 결과 의해 처리 되지 않은 키에 대 한 <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> 메서드를 반환 해야 합니다.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">처리할 문자입니다.</param>
        <summary>니모닉 문자를 처리합니다.</summary>
        <returns>
          컨트롤이 문자를 니모닉으로 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 컨트롤의 니모닉 문자를 처리할 수 있도록 지정 합니다. 호출 됩니다. 메서드가 결정 해야 컨트롤을 니모닉 처리 하는 상태에 있는지 여부와 지정 된 문자를 니모닉 나타내는지 합니다. 하는 경우,이 메서드는 수행 돌아가 니모닉와 연결 된 동작 `true`합니다. 메서드가 반환 하지, 하면 `false`합니다. 이 메서드의 구현에서는 자주 사용 하 여는 <xref:System.Windows.Forms.Control.IsMnemonic%2A> 메서드를 지정 된 문자는 컨트롤의 텍스트에 니모닉과 일치 하는지 확인 합니다.  
  
 예:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 이 기본 구현은 <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> 메서드는 반환 `false` 컨트롤에 없는 니모닉 있음을 나타내기 위해.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 단추 클래스의 확장은 <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> 메서드를 사용자 지정 동작을 노출 합니다. 이 예제에서는 또한의 사용법을 보여줍니다는 <xref:System.Windows.Forms.Control.CanSelect%2A> 및 <xref:System.Windows.Forms.Control.IsMnemonic%2A> 속성입니다. 이 예에서는 실행 하려면 같은 파일에 폼 클래스 뒤 다음 코드를 붙여 넣습니다. 형식의 단추 추가 `MnemonicButton` 양식입니다.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 클래스 상속을 위한 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 포함된 어셈블리의 제품 이름을 가져옵니다.</summary>
        <value>컨트롤이 포함된 어셈블리의 제품 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductName%2A> 속성은 읽기 전용 속성입니다. 이 속성의 값을 변경 하려면는 <xref:System.Reflection.AssemblyProductAttribute.Product%2A> 의 속성 값은 <xref:System.Reflection.AssemblyProductAttribute>합니다. C# 코드 집합의 다음 줄은 <xref:System.Windows.Forms.Control.ProductName%2A> 속성입니다.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  회사 이름, 제품 이름 및 제품 버전을 제공 하는 것이 좋습니다. 이 정보를 제공 사용할 수 있도록 Windows Forms 기능와 같은 <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> "Certified for Windows" 프로그램 준수 하는 응용 프로그램을 작성할을 보다 쉽게 만들어 주는 합니다. Certified for Windows 프로그램에 대 한 자세한 내용은 참조 http://msdn.microsoft.com/certification합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 응용 프로그램에 대 한 정보를 표시 한 <xref:System.Windows.Forms.Label> 에 포함 된 한 <xref:System.Windows.Forms.Form>합니다. 이 예제에서는 <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> 및 <xref:System.Windows.Forms.Control.ProductVersion%2A> 설정 되었습니다.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 포함된 어셈블리의 버전을 가져옵니다.</summary>
        <value>컨트롤이 포함된 어셈블리의 파일 버전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductVersion%2A> 속성은 읽기 전용 속성입니다. 이 속성의 값을 변경 하려면는 <xref:System.Reflection.AssemblyVersionAttribute.Version%2A> 의 속성 값은 <xref:System.Reflection.AssemblyVersionAttribute>합니다. C# 코드 집합의 다음 줄은 <xref:System.Windows.Forms.Control.ProductVersion%2A> 속성입니다.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  회사 이름, 제품 이름 및 제품 버전을 제공 하는 것이 좋습니다. 이 정보를 제공 사용할 수 있도록 Windows Forms 기능와 같은 <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> "Certified for Windows" 프로그램 준수 하는 응용 프로그램을 작성할을 보다 쉽게 만들어 주는 합니다. Certified for Windows 프로그램에 대 한 자세한 내용은 참조 http://msdn.microsoft.com/certification합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 응용 프로그램에 대 한 정보를 표시 한 <xref:System.Windows.Forms.Label> 에 포함 된 한 <xref:System.Windows.Forms.Form>합니다. 이 예제에서는 <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> 및 <xref:System.Windows.Forms.Control.ProductVersion%2A> 설정 되었습니다.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>전파 IME 모드를 나타내는 개체를 가져옵니다.</summary>
        <value>전파 IME 모드를 나타내는 개체입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.AccessibleObject" />가 내게 필요한 옵션 지원 응용 프로그램에 도움말을 제공하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 해야는 <xref:System.Windows.Forms.HelpProvider> 클래스를 사용 하는 사용자가 F1 키를 눌러 액세스 가능한 개체에 대 한 도움말을 호출할 수 있습니다. 사용 하는 <xref:System.Windows.Forms.HelpProvider> 에 완전 한 정보를 제공는 <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>합니다. 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 내게 필요한 옵션 인식 차트를 만드는 방법을 보여 줍니다. 컨트롤을 사용 하는 <xref:System.Windows.Forms.AccessibleObject> 및 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 클래스 액세스할 수 있는 정보를 표시 합니다. 컨트롤은 범례를 따라 두 곡선을 그립니다. `ChartControlAccessibleObject` 클래스에서 파생 되 `ControlAccessibleObject`에 사용 되는 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 메서드는 차트 컨트롤에 대 한 사용자 지정 액세스할 수 있는 정보를 제공 합니다. 차트 범례는 실제 <xref:System.Windows.Forms.Control> -컨트롤을 따르지만 그려지며 차트 컨트롤에서 액세스할 수 있는 기본 제공 정보를 포함 하지 않습니다. 이 인해는 `ChartControlAccessibleObject` 재정의 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 반환 하는 메서드는 `CurveLegendAccessibleObject` 범례의 각 부분에 액세스할 수 있는 정보를 나타내는입니다. 액세스할 수 있는 인식 응용 프로그램이이 제어를 사용 하는 경우 컨트롤은 필요한 액세스 가능 정보를 제공할 수 있습니다.  
  
 이 코드 발췌 예에는 처리 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.QueryAccessibilityHelp> 이벤트입니다. 참조는 <xref:System.Windows.Forms.AccessibleObject> 전체 코드 예제에 대 한 클래스 개요입니다.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>끌어서 놓기 작업 중에 발생하며 끌기 소스가 끌어서 놓기 작업을 취소해야 할지를 결정하도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트는 끌어서 놓기 작업 중 키보드 또는 마우스 단추 상태가 변경 될 때 발생 합니다. <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트를 사용 하면 끌기 소스가 끌어서 놓기 작업을 취소 해야 할지를 결정 하도록 합니다.  
  
 다음에서는 끌어서 놓기 작업이 발생하는 방식 및 시기에 대해 설명합니다.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드는 현재 커서 위치에서 컨트롤을 확인 합니다. 그런 다음 컨트롤은 유효한 놓기 대상 인지 확인 합니다.  
  
 컨트롤이 유효한 놓기 대상일 경우는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 지정 된 끌어서 놓기 효과 함께 발생 합니다. 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
 마우스 커서 위치, 키보드 상태 및 마우스 단추 상태의 변경 내용을 추적합니다.  
  
-   사용자가 창의 외부로 이동하면 <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생합니다.  
  
-   마우스를 다른 컨트롤로 가져가면 해당 컨트롤에 대한 <xref:System.Windows.Forms.Control.DragEnter>가 발생합니다.  
  
-   마우스를 동일한 컨트롤 내에서 이동하면 <xref:System.Windows.Forms.Control.DragOver> 이벤트가 발생합니다.  
  
 키보드 또는 마우스 단추 상태가 변경 될 경우는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트가 발생 하 고 데이터를 끌기를 계속할지 여부를 결정 하거나의 값을 기준으로 작업을 취소 하는 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 이벤트의 속성 <xref:System.Windows.Forms.QueryContinueDragEventArgs>합니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Continue`, <xref:System.Windows.Forms.Control.DragOver> 이벤트 작업을 계속 하려면는 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 적절 한 시각적 피드백이 설정 될 수 있도록 새로운 효과 함께 발생 합니다. 유효한 끌어서 놓기 작업 결과 목록에 대한 자세한 내용은 <xref:System.Windows.Forms.DragDropEffects> 열거형을 참조하십시오.  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver> 및 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트는 쌍을 이루고 있어서 마우스가 놓기 대상을 통과할 사용자에 게 마우스 위치에 대 한 최신 피드백이 제공 됩니다.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Drop`, 놓기 효과 값이 원본에 반환, 되므로 소스 응용 프로그램이 소스 데이터에 대해 적절 한 작업을 수행할 수 예를 들어 데이터 잘라내기 작업이 이동 인 경우.  
  
-   하는 경우의 값 <xref:System.Windows.Forms.DragAction> 은 `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> 이벤트가 발생 합니다.  
  
 기본적으로는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트 설정 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 를 `Cancel` 에 <xref:System.Windows.Forms.DragAction> ESC 키를 누른 설정 하는 경우 <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> 를 `Drop` 에 <xref:System.Windows.Forms.DragAction> 왼쪽, 가운데 또는 오른쪽 마우스 단추를 누를 경우.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 끌어서 놓기 작업을 보여 줍니다. <xref:System.Windows.Forms.ListBox> 컨트롤입니다. 예제에서는 호출은 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 끌기 작업이 시작 될 때 메서드. 마우스를 이동 하는 경우 끌기 작업이 시작 이상 <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> 하는 동안 마우스 위치에서의 <xref:System.Windows.Forms.Control.MouseDown> 이벤트입니다. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 메서드 결정 하는 동안 끌어 항목의 인덱스를 사용 하는 `MouseDown` 이벤트입니다.  
  
 또한이 예제에서는 끌어서 놓기 작업에 대 한 사용자 지정 커서를 사용 하 여 보여 줍니다. 이 예제를 실행 하려면 커서 파일`3dwarro.cur` 및 `3dwno.cur`, 사용자 지정 끌어서에 대 한 응용 프로그램 디렉터리에 있으면 놓기-커서, 각각. 사용자 지정 커서 사용 하는 경우는 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> 을 선택 합니다. 에 설정 된 사용자 지정 커서는 <xref:System.Windows.Forms.Control.GiveFeedback> 이벤트 처리기입니다.  
  
 키보드 상태에서 평가 됩니다는 <xref:System.Windows.Forms.Control.DragOver> 오른쪽에 대 한 이벤트 처리기 `ListBox`항목 끌기 작업을 결정 하는, SHIFT, CTRL 및 ALT, CTRL + ALT 키의 상태를 기반 합니다. 위치는 `ListBox` 삭제가 발생 중도 결정 됩니다는 `DragOver` 이벤트입니다. 삭제할 데이터가 아닌 경우는 `String`, 하면 <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> 로 설정 된 `None` 에서 <xref:System.Windows.Forms.DragDropEffects>합니다. 드롭다운 상태에 표시 되는 마지막으로,는 `DropLocationLabel` <xref:System.Windows.Forms.Label>합니다.  
  
 데이터를 오른쪽에 대 한 drop `ListBox` 에 따라 결정 됩니다는 <xref:System.Windows.Forms.Control.DragDrop> 이벤트 처리기 및 `String` 적절 한 위치에서 값이 추가 `ListBox`합니다. 끌기 작업, 폼의 경계를 벗어나면 경우에서 끌어서 놓기 작업이 취소 되 고 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트 처리기입니다.  
  
 이 코드 발췌 한 구문을 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.Control.QueryContinueDrag> 이벤트입니다. 참조는 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 전체 코드 예제에 대 한 메서드.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">발생시킬 이벤트입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DragEventArgs" />입니다.</param>
        <summary>적합한 끌기 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">발생시킬 이벤트입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.KeyEventArgs" />입니다.</param>
        <summary>적합한 키 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">발생시킬 이벤트입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MouseEventArgs" />입니다.</param>
        <summary>적합한 마우스 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">발생시킬 이벤트입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.PaintEventArgs" />입니다.</param>
        <summary>적합한 Paint 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 컨트롤의 핸들을 강제로 다시 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RecreateHandle%2A> 메서드는 새 컨트롤에 대 한 매개 변수가 필요 하지만 코드에서 호출을 사용 하 여 <xref:System.Windows.Forms.Control.UpdateStyles%2A> 를 <xref:System.Windows.Forms.Control.CreateParams%2A> 충분 하지 않습니다. 이 메서드를 호출 또한 <xref:System.Windows.Forms.Control.DestroyHandle%2A> 및 <xref:System.Windows.Forms.Control.CreateHandle%2A> 설정 <xref:System.Windows.Forms.Control.RecreatingHandle%2A> 를 `true`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 현재 자신의 핸들을 다시 만들고 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤이 현재 자신의 핸들을 다시 만들고 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RecreatingHandle%2A> 속성에서 반환 `true` 경우는 <xref:System.Windows.Forms.Control.RecreateHandle%2A> 메서드 컨트롤에서 계속 실행 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">변환할 화면 좌표 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <summary>지정된 화면 사각형의 크기와 위치를 클라이언트 좌표로 계산합니다.</summary>
        <returns>변환된 <see cref="T:System.Drawing.Rectangle" />인 <see cref="T:System.Drawing.Rectangle" />를 클라이언트 좌표로 나타내는 <paramref name="r" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">변환할 클라이언트 좌표 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <summary>지정된 클라이언트 사각형의 크기와 위치를 화면 좌표로 계산합니다.</summary>
        <returns>변환된 <see cref="T:System.Drawing.Rectangle" />인 <see cref="T:System.Drawing.Rectangle" />를 화면 좌표로 나타내는 <paramref name="p" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, 및 <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> 멤버입니다. 이라는 폼에는 예제를 실행 하려면 다음 코드를 붙여 **Form1** 여러 개의 컨트롤이 들어 있습니다. 이 예제에서는 <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, 및 <xref:System.Windows.Forms.Control.MouseUp> 이벤트가 예에서 정의 된 이벤트 처리기에 연결 합니다.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">메시지를 반영할 컨트롤 핸들을 나타내는 <see cref="T:System.IntPtr" />입니다.</param>
        <param name="m">반영할 Windows 메시지를 나타내는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>지정된 메시지를 특정 핸들에 바인딩된 컨트롤에 반영합니다.</summary>
        <returns>
          메시지가 반영되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ReflectMessage%2A> 메서드는 인프라 메서드이며 및 일반적으로 코드에서 호출 해야 합니다.  
  
 경우는 `hWnd` 매개 변수가 유효한 제어를 나타내지 않을 <xref:System.Windows.Forms.Control.ReflectMessage%2A> 메서드 반환 `false`합니다.  
  
 Windows 메시지 최상위 창에 반환 되므로 <xref:System.Windows.Forms.Control.ReflectMessage%2A> 메서드 메시지를 보낸 컨트롤에 반환 메시지를 전파 하는 데 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 모든 창입니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤이 해당 컨트롤의 클라이언트 영역을 강제로 무효화하도록 하고 컨트롤 자체와 모든 자식 컨트롤을 즉시 다시 그리도록 합니다.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.Refresh" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.Refresh" /> 메서드 컨트롤과 해당 자식 컨트롤을 무효화 하 고 다시 그립니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤과 연결된 창 영역을 가져오거나 설정합니다.</summary>
        <value>컨트롤과 연결된 창 <see cref="T:System.Drawing.Region" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창 영역은 운영 체제에서 그리기가 허용 하는 창 내의 픽셀의 컬렉션입니다. 운영 체제 창의 창 영역 외부에 있는 모든 부분을 표시 되지 않습니다. 컨트롤의 영역 좌표가 되지 않은 컨트롤의 클라이언트 영역 컨트롤의 왼쪽 위 모퉁이 기준으로 합니다.  
  
> [!NOTE]
>  영역과 함께 포함 되는 픽셀 컬렉션 인접 하지 않은 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.Region%2A> 라운드 단추 만들어 속성입니다. 예제를 실행 하려면 다음 코드를 붙여 이라는 단추가 있는 형태로 `roundButton`합니다. 이 예제에서는 <xref:System.Windows.Forms.Control.Paint> 이벤트가 예에서 정의 된 이벤트 처리기에 연결 되어 있습니다.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성 값을 설정 하려면 모든 창입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Region" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.RegionChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.RegionChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 더 이상 사용되지 않습니다.</summary>
        <value>
          컨트롤이 오른쪽에서 왼쪽으로 렌더링되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">변경 전의 DPI 값입니다.</param>
        <param name="deviceDpiNew">변경 후의 DPI 값입니다.</param>
        <summary>DPI가 변경될 때 컨트롤 크기를 재조정하기 위한 상수를 제공합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.BackColor" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.BindingSource" />에 바인딩된 컨트롤에서 목록의 모든 항목을 다시 읽고 표시된 값을 새로 고치도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Cursor" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Font" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ForeColor" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.ImeMode" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤을 다시 설정하여 <see cref="E:System.Windows.Forms.Control.MouseLeave" /> 이벤트를 처리합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.RightToLeft" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Text" /> 속성을 기본값(<see cref="F:System.String.Empty" />)으로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 디자이너를 만들거나 하는 경우 일반적으로이 메서드를 사용는 <xref:System.Windows.Forms.Control> 포함 하는 사용자 고유의 컨트롤을 만드는 또는 <xref:System.Windows.Forms.Control>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 크기를 조정하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결정 하는 <xref:System.Windows.Forms.Control.Size%2A> 크기가 조정된 된 컨트롤의 캐스팅할 수 있습니다는 `sender` 의 등록 된 매개 변수 <xref:System.Windows.Forms.ControlEventHandler> 메서드를 한 <xref:System.Windows.Forms.Control> 가져오고, 해당 <xref:System.Windows.Forms.Control.Size%2A> 속성 (또는 <xref:System.Windows.Forms.Control.Height%2A> 및 <xref:System.Windows.Forms.Control.Width%2A> 속성 개별적으로).  
  
 사용자 지정 레이아웃을 처리 하려면는 <xref:System.Windows.Forms.Control.Layout> 크기 조정 이벤트 대신 이벤트입니다. <xref:System.Windows.Forms.Control.Layout> 에 대 한 응답 이벤트는 사용자가 <xref:System.Windows.Forms.Control.Resize> 뿐만 아니라 다른 변경 사항에 따라 컨트롤의 레이아웃에 영향을 주는 이벤트입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 핸들의 <xref:System.Windows.Forms.Control.Resize> 의 이벤트는 <xref:System.Windows.Forms.Form>합니다. 폼 크기를 조정 하는 경우 이벤트 처리기 폼 제곱 하 게 유지 하면 (해당 <xref:System.Windows.Forms.Control.Height%2A> 및 <xref:System.Windows.Forms.Control.Width%2A> 와 같도록 그대로 유지). 이 예제를 실행 하려면 있어야 하 고이 이벤트 처리 메서드를 폼의 연결 <xref:System.Windows.Forms.Control.Resize> 이벤트입니다.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>크기를 조정하는 경우 컨트롤이 자신을 다시 그리는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          크기를 조정하는 경우 컨트롤이 자신을 다시 그리면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ResizeRedraw%2A> 속성 값은 반환 값에 해당 하는 <xref:System.Windows.Forms.Control.GetStyle%2A> 전달 하는 경우 메서드는 <xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType> 값을 매개 변수로 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>일반 레이아웃 논리를 다시 시작합니다.</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>일반 레이아웃 논리를 다시 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 보류 중인 레이아웃 요청 되어 있는 경우 메서드 강제로 즉시 레이아웃 합니다.  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 및 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드는 동시에 표시 하지 않는 데 여러 <xref:System.Windows.Forms.Control.Layout> 컨트롤의 여러 속성을 조정 하는 동안 이벤트입니다. 예를 들어 일반적으로 호출 하는 것의 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 메서드를 설정 합니다는 <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, 또는 <xref:System.Windows.Forms.Control.Dock%2A> 호출 고 컨트롤의 속성은 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드 변경 내용을 적용 하려면 사용할 수 있도록 합니다.  
  
 에 대 한 보류 중인 호출 해야 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 에 대 한 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 성공적으로 호출할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 두 개의 단추를 추가합니다. 예제에서는 트랜잭션을 사용 하 여 단추를 추가 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 및 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout">
          보류 중인 레이아웃 요청을 실행하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>일반 레이아웃 논리를 다시 시작하여 필요에 따라 보류 중인 레이아웃 요청을 강제로 즉시 레이아웃합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 보류 중인 레이아웃 요청 되어 있는 경우 메서드 강제로 즉시 레이아웃 합니다. 경우는 `performLayout` 로 설정 된 `true`, 즉시 레이아웃 보류 중인 레이아웃 요청 되어 있는 경우에 발생 합니다.  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 및 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드는 동시에 표시 하지 않는 데 여러 <xref:System.Windows.Forms.Control.Layout> 컨트롤의 여러 속성을 조정 하는 동안 이벤트입니다. 예를 들어 일반적으로 호출 하는 것의 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 메서드를 설정 합니다는 <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, 또는 <xref:System.Windows.Forms.Control.Dock%2A> 호출 고 컨트롤의 속성은 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드 변경 내용을 적용 하려면 사용할 수 있도록 합니다.  
  
 에 대 한 보류 중인 호출 해야 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 에 대 한 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 성공적으로 호출할 수 있습니다.  
  
> [!NOTE]
>  여러 컨트롤에 부모 컨트롤을 추가할 때 것이 좋습니다를 호출 하는 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 추가할 컨트롤을 초기화 하기 전에 메서드. 부모 컨트롤에 컨트롤을 추가한 후 호출 된 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드. 이렇게 하면 컨트롤이 많은 응용 프로그램의 성능을 늘어납니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 오른쪽 가장자리와 해당 컨테이너 클라이언트 영역의 왼쪽 가장자리 사이의 거리(픽셀)를 가져옵니다.</summary>
        <value>컨트롤의 오른쪽 가장자리와 해당 컨테이너 클라이언트 영역의 왼쪽 가장자리 사이의 거리(픽셀)를 나타내는 <see cref="T:System.Int32" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.Windows.Forms.Control.Right%2A> 속성은의 합계에는 <xref:System.Windows.Forms.Control.Left%2A> 속성 값 및 <xref:System.Windows.Forms.Control.Width%2A> 속성 값입니다.  
  
 <xref:System.Windows.Forms.Control.Right%2A> 속성은 읽기 전용입니다. 변경할 수 있습니다이 속성 값이 직접의 값을 변경 하 여는 <xref:System.Windows.Forms.Control.Left%2A> 또는 <xref:System.Windows.Forms.Control.Width%2A> 속성 또는 호출의 <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, 또는 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개를 만들며 <xref:System.Windows.Forms.Button> 폼에서 제어 하 고 다양 한 크기 및 위치 관련 속성을 사용 하 여 해당 크기와 위치를 설정 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하에 너비와 높이가 이상 300 픽셀입니다.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>오른쪽에서 왼쪽으로 쓰는 글꼴을 사용하는 로캘을 지원하도록 컨트롤 요소가 정렬되어 있는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Forms.RightToLeft" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성이 앰비언트 속성입니다. 그렇지 않은 경우, 즉 앰비언트 속성은 컨트롤 속성 설정, 부모 컨트롤에서 검색 됩니다. 예를 들어 한 <xref:System.Windows.Forms.Button> 같은 가질 수 <xref:System.Windows.Forms.Control.BackColor%2A> 부모로 <xref:System.Windows.Forms.Form> 기본적으로 합니다. 앰비언트 속성에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.AmbientProperties> 클래스 또는 <xref:System.Windows.Forms.Control> 클래스 개요입니다.  
  
 <xref:System.Windows.Forms.Control.RightToLeft%2A> 히브리어나 아랍어와 같이 왼쪽, 오른쪽에서 쓰는 속성 국가별 응용 프로그램에 사용 됩니다. 이 속성이로 설정 된 경우 <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>, 오른쪽에서 왼쪽으로 텍스트를 포함 하는 컨트롤 요소가 표시 됩니다.  
  
> [!NOTE]
>  하는 경우의 값은 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성이 런타임 시 변경 될, 서식 없이 원시 텍스트만 보존 됩니다.  
  
 다음은 몇 가지 방법을 제어 요소 영향을 받는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 값이 <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType> :  
  
-   스크롤 가능한 컨트롤의 오른쪽이 아닌 왼쪽에 세로 스크롤 막대가 표시 됩니다 (예를 들어 <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Panel>여러 줄, <xref:System.Windows.Forms.TextBox>, 및 <xref:System.Windows.Forms.RichTextBox>).  
  
-   가로 스크롤 막대 오른쪽 맞춤 스크롤 상자 (thumb)로 시작 합니다.  
  
-   에 의해 제어 확인란 요소 맞춤은 `CheckAlign` 에 대 한 속성을 반대로 되어 <xref:System.Windows.Forms.CheckBox> 및 <xref:System.Windows.Forms.RadioButton> 컨트롤입니다.  
  
-   목록 상자, 콤보 상자 및 up-down 컨트롤의 항목은 오른쪽에 맞춰집니다.  
  
-   에 왼쪽 맞춤 됩니다. 위쪽 및 아래쪽 단추 <xref:System.Windows.Forms.NumericUpDown> 및 <xref:System.Windows.Forms.DomainUpDown> 컨트롤입니다.  
  
-   메뉴 (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, 및 <xref:System.Windows.Forms.ContextMenu>) 오른쪽 맞춤으로 표시 됩니다.  
  
-   도구 모음 단추 맞춤은 <xref:System.Windows.Forms.ToolBar> 컨트롤 또는의 텍스트 맞춤은 <xref:System.Windows.Forms.ToolBarButton> 영향을 받지 않습니다는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성입니다.  
  
-   <xref:System.Windows.Forms.AxHost> 오른쪽에서 왼쪽 맞춤; 지원 그러나 ActiveX 컨트롤에 대 한 영향을 컨트롤 작성자는 오른쪽에서 왼쪽으로 표시에 대 한 지원 구현 하는 범위 내에 따라 다릅니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">할당된 값이 <see cref="T:System.Windows.Forms.RightToLeft" /> 값 중 하나가 아닌 경우</exception>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.RightToLeft" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.RightToLeft" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.RightToLeft" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.RightToLeft" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 되는 이벤트 처리기 될 때 실행 되는 <xref:System.Windows.Forms.Control.Text%2A> 속성 값이 변경 합니다. <xref:System.Windows.Forms.Control> 클래스에 이름 패턴이 인 메서드가 *PropertyName* `Changed` 있는 될 때 발생 하는 해당 *PropertyName* 값이 변경 (* PropertyName* 해당 속성의 이름을 나타내는).  
  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오른쪽에서 왼쪽으로 쓰는 텍스트를 지원하려면 현재 맞춤을 적합한 맞춤으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">
          <see cref="T:System.Drawing.ContentAlignment" /> 값 중 하나입니다.</param>
        <summary>오른쪽에서 왼쪽으로 쓰는 텍스트를 지원하려면 지정된 <see cref="T:System.Drawing.ContentAlignment" />를 적절한 <see cref="T:System.Drawing.ContentAlignment" />로 변환합니다.</summary>
        <returns>
          <see cref="T:System.Drawing.ContentAlignment" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 <xref:System.Windows.Forms.RightToLeft> 로 설정 된 `No`, 반환 값이 같지는 `align` 매개 변수가 전달 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">
          <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 값 중 하나입니다.</param>
        <summary>오른쪽에서 왼쪽으로 쓰는 텍스트를 지원하려면 지정된 <see cref="T:System.Windows.Forms.HorizontalAlignment" />를 적절한 <see cref="T:System.Windows.Forms.HorizontalAlignment" />로 변환합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 <xref:System.Windows.Forms.RightToLeft> 로 설정 된 `No`, 반환 값이 같지는 `align` 매개 변수가 전달 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">
          <see cref="T:System.Windows.Forms.LeftRightAlignment" /> 값 중 하나입니다.</param>
        <summary>오른쪽에서 왼쪽으로 쓰는 텍스트를 지원하려면 지정된 <see cref="T:System.Windows.Forms.LeftRightAlignment" />를 적절한 <see cref="T:System.Windows.Forms.LeftRightAlignment" />로 변환합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.LeftRightAlignment" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 <xref:System.Windows.Forms.RightToLeft> 로 설정 된 `No`, 반환 값이 같지는 `align` 매개 변수가 전달 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">
          <see cref="T:System.Drawing.ContentAlignment" /> 값 중 하나입니다.</param>
        <summary>오른쪽에서 왼쪽으로 쓰는 텍스트를 지원하려면 지정된 <see cref="T:System.Drawing.ContentAlignment" />를 적절한 <see cref="T:System.Drawing.ContentAlignment" />로 변환합니다.</summary>
        <returns>
          <see cref="T:System.Drawing.ContentAlignment" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 <xref:System.Windows.Forms.RightToLeft> 로 설정 된 `No`, 반환 값이 같지는 `align` 매개 변수가 전달 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">
          <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 값 중 하나입니다.</param>
        <summary>오른쪽에서 왼쪽으로 쓰는 텍스트를 지원하려면 지정된 <see cref="T:System.Windows.Forms.HorizontalAlignment" />를 적절한 <see cref="T:System.Windows.Forms.HorizontalAlignment" />로 변환합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 <xref:System.Windows.Forms.RightToLeft> 로 설정 된 `No`, 반환 값이 같지는 `align` 매개 변수가 전달 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">
          <see cref="T:System.Windows.Forms.LeftRightAlignment" /> 값 중 하나입니다.</param>
        <summary>오른쪽에서 왼쪽으로 쓰는 텍스트를 지원하려면 지정된 <see cref="T:System.Windows.Forms.LeftRightAlignment" />를 적절한 <see cref="T:System.Windows.Forms.LeftRightAlignment" />로 변환합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.LeftRightAlignment" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 속성 <xref:System.Windows.Forms.RightToLeft> 로 설정 된 `No`, 반환 값이 같지는 `align` 매개 변수가 전달 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤과 자식 컨트롤의 배율을 조정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="factor">가로 및 세로 배율 인수가 포함된 <see cref="T:System.Drawing.SizeF" />입니다.</param>
        <summary>컨트롤과 모든 자식 컨트롤의 배율을 지정한 배율 인수로 조정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Scale%2A> 메서드 지정 된 크기 조정 하 여 컨트롤을 확장 `factor`합니다. 이 경우 재귀적으로 모든 자식 컨트롤을 조정 하는 또한는 <xref:System.Windows.Forms.Control.ScaleChildren%2A> 속성은 `true`합니다. 이 메서드를 호출 내부적으로 <xref:System.Windows.Forms.Control.ScaleControl%2A> 각 컨트롤의 배율을 조정 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">배율 조정에 사용할 비율입니다.</param>
        <summary>컨트롤과 자식 컨트롤의 배율을 조정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">가로 배율 인수입니다.</param>
        <param name="dy">세로 배율 인수입니다.</param>
        <summary>전체 컨트롤과 자식 컨트롤의 배율을 조정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">크기를 조정할 비트맵입니다.</param>
        <summary>DPI가 변경될 때 논리적 비트맵 값을 동등한 장치 단위 값으로 크기 조정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>자식 컨트롤의 배율을 결정하는 값을 가져옵니다.</summary>
        <value>
          이 컨트롤에서 <see langword="true" /> 메서드가 호출될 때 자식 컨트롤의 배율이 조정되면 <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.Control.ScaleChildren%2A> 속성은 `true`, 하면 <xref:System.Windows.Forms.Control.Scale%2A> 메서드 재귀적으로 호출 합니다는 <xref:System.Windows.Forms.Control.ScaleControl%2A> 각 컨트롤은 자식 컨트롤의 메서드.  
  
 기본 구현은 <xref:System.Windows.Forms.Control.ScaleChildren%2A> 항상 반환 `true`합니다. 파생된 클래스에서 재정의할 수 <xref:System.Windows.Forms.Control.ScaleChildren%2A> 반환할 `false` 크기 조정을 수행 해야 함을 하지 자식 요소에 나타냅니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">컨트롤의 높이와 너비 크기를 조정하는 인수입니다.</param>
        <param name="specified">컨트롤의 크기와 위치를 정의할 때 사용할 컨트롤 범위를 지정하는 <see cref="T:System.Windows.Forms.BoundsSpecified" /> 값입니다.</param>
        <summary>컨트롤의 위치, 크기, 안쪽 여백 및 여백을 조정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 최상위 컨트롤을 사용 하는 경우 컨트롤의 위치를 조정 하지 않습니다. 자식 또는 자동으로 조정된 된 컨트롤의 크기에는 확장 되지 않습니다. 값을 변경 하 여 임의의 방향으로 확장을 생략할 수 있습니다는 `specified` 매개 변수입니다.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">가로 배율 인수입니다.</param>
        <param name="dy">세로 배율 인수입니다.</param>
        <summary>이 메서드는 이 클래스와 관련이 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤을 활성화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤을 활성화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Select%2A> 메서드 컨트롤을 활성화 하는 경우 컨트롤의 `Selectable` 스타일 비트가 `true` 에 <xref:System.Windows.Forms.ControlStyles>를 다른 컨트롤에 포함 된와 모든 부모 컨트롤이 표시 되 고 사용할 합니다.  
  
 다음 목록에 Windows Forms 컨트롤은 선택할 수 있습니다. 목록에서 컨트롤에서 파생 된 컨트롤은 또한 선택할 수 없습니다.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (이 경우 컨트롤에 링크가)  
  
   
  
## Examples  
 다음 코드 예제에서는 지정 된 선택 <xref:System.Windows.Forms.Control>선택 가능한 경우, 합니다.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">
          선택할 컨트롤의 방향을 지정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="forward">
          탭 순서에서 앞으로 이동하려면 <see langword="true" />이고, 뒤로 이동하려면 <see langword="false" />입니다.</param>
        <summary>자식 컨트롤을 활성화합니다. 또한 필요에 따라 컨트롤을 선택할 탭 순서의 방향을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `directed` 및 `forward` 컨테이너 스타일 컨트롤에서 매개 변수를 사용 합니다. 경우는 `directed` 로 설정 된 `true`, `forward` 매개 변수는 선택할 컨트롤을 결정 하도록 평가 됩니다. 때 `forward` 로 설정 된 `true`, 탭 순서의 다음 컨트롤로 확인란이; 때 `false`, 탭 순서의 이전 컨트롤을 선택 합니다.  
  
 <xref:System.Windows.Forms.Control.Select%2A> 메서드 컨트롤을 활성화 하는 경우 컨트롤의 `Selectable` 스타일 비트가 `true` 에 <xref:System.Windows.Forms.ControlStyles>를 다른 컨트롤에 포함 된와 모든 부모 컨트롤이 표시 되 고 사용할 합니다.  
  
 다음 목록에 Windows Forms 컨트롤은 선택할 수 있습니다. 목록에서 컨트롤에서 파생 된 컨트롤은 또한 선택할 수 없습니다.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (이 경우 컨트롤에 링크가)  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">검색을 시작할 <see cref="T:System.Windows.Forms.Control" />입니다.</param>
        <param name="forward">
          탭 순서에서 앞으로 이동하려면 <see langword="true" />이고, 뒤로 이동하려면 <see langword="false" />입니다.</param>
        <param name="tabStopOnly">
          <see langword="true" /> 속성이 <see cref="P:System.Windows.Forms.Control.TabStop" />로 설정된 컨트롤을 무시하려면 <see langword="false" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="nested">
          중첩된(자식 컨트롤의 자식) 자식 컨트롤을 포함시키려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="wrap">
          탭 순서의 마지막 컨트롤에 도달한 후 첫째 컨트롤부터 검색을 계속하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>다음 컨트롤을 활성화합니다.</summary>
        <returns>
          컨트롤이 활성화되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드 탭 순서의 다음 컨트롤로 활성화 하는 경우 컨트롤의 `Selectable` 스타일 비트가 `true` 에 <xref:System.Windows.Forms.ControlStyles>, 다른 컨트롤에 포함 된 및 모든 부모 컨트롤이 표시 되 고 사용 하도록 설정 되어 있습니다.  
  
 다음 목록에 Windows Forms 컨트롤은 선택할 수 있습니다. 목록에서 컨트롤에서 파생 된 컨트롤은 또한 선택할 수 없습니다.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (이 경우 컨트롤에 링크가)  
  
 호출 하 여 키보드 (TAB, SHIFT + TAB 등)를 사용 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Select%2A> 또는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드를 설정 하거나는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> 속성을 현재 폼으로 포커스 이벤트가 다음 순서 대로 발생:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 exampleshows는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드 일부 제어 기능을 포함 하는 폼에서 사용 되 고 있습니다. 폼을 클릭할 때마다 다음 컨트롤이 활성화 됩니다. <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> 속성 컨테이너 컨트롤에서 현재 활성 컨트롤을 가져옵니다.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 다음 코드 예제는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 있는 폼에 사용 되는 메서드는 <xref:System.Windows.Forms.Button> 및 다른 컨트롤입니다. 클릭는 <xref:System.Windows.Forms.Button>, 후 다음 컨트롤로 <xref:System.Windows.Forms.Button> 활성화 됩니다. 부모를 가져올 것을 확인할는 <xref:System.Windows.Forms.Button> 제어 합니다. 이후 <xref:System.Windows.Forms.Button> 컨테이너가, 호출 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 에서 직접는 <xref:System.Windows.Forms.Button> 활성화 변경 되지 않습니다.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤을 Z 순서의 맨 뒤로 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤을 z 순서의 맨 뒤로 이동 합니다. 다른 컨트롤의 자식 컨트롤을 사용 하는 경우 자식 컨트롤을 z 순서의 맨 뒤로 이동 합니다. 컨트롤이 최상위 컨트롤이 면 컨트롤이 활성화 된 경우가 아니면이 메서드가 제대로 작동 하지 않습니다. 최상위 컨트롤은 컨트롤을와 같은 한 <xref:System.Windows.Forms.Form>, 즉 자식도 아닌 다른 컨트롤의 합니다. 활성 컨트롤은 표시 컨트롤에 입력 포커스가입니다. 사용 하는 <xref:System.Windows.Forms.Control.SendToBack%2A> 메서드 비활성 최상위 컨트롤 호출 먼저는 <xref:System.Windows.Forms.Control.BringToFront%2A> 컨트롤 대 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" />
      </Parameters>
      <Docs>
        <param name="mode">
          <see cref="T:System.Windows.Forms.AutoSizeMode" /> 값 중 하나입니다.</param>
        <summary>해당 <see cref="P:System.Windows.Forms.Control.AutoSize" /> 속성을 사용할 수 있을 때 컨트롤이 동작하는 방법을 나타내는 값을 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤의 범위를 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Left" /> 속성 값입니다.</param>
        <param name="y">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Top" /> 속성 값입니다.</param>
        <param name="width">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Width" /> 속성 값입니다.</param>
        <param name="height">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Height" /> 속성 값입니다.</param>
        <summary>컨트롤의 범위를 지정된 위치와 크기로 설정합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Left" /> 속성 값입니다.</param>
        <param name="y">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Top" /> 속성 값입니다.</param>
        <param name="width">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Width" /> 속성 값입니다.</param>
        <param name="height">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Height" /> 속성 값입니다.</param>
        <param name="specified">
          <see cref="T:System.Windows.Forms.BoundsSpecified" /> 값의 비트 조합입니다. 매개 변수를 지정하지 않으면 현재 값이 사용됩니다.</param>
        <summary>컨트롤의 지정된 범위를 특정 위치와 크기로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 센터는 <xref:System.Windows.Forms.Form> 화면에서 <xref:System.Windows.Forms.Control.Layout> 이벤트입니다. 이렇게 하면 사용자가 크기 조정으로 가운데 맞춤 폼을 유지 됩니다. 이 예제에서는 만든는 <xref:System.Windows.Forms.Form> 제어 합니다.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Left" /> 속성 값입니다.</param>
        <param name="y">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Top" /> 속성 값입니다.</param>
        <param name="width">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Width" /> 속성 값입니다.</param>
        <param name="height">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Height" /> 속성 값입니다.</param>
        <param name="specified">
          <see cref="T:System.Windows.Forms.BoundsSpecified" /> 값의 비트 조합입니다.</param>
        <summary>이 컨트롤의 지정된 범위를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 포함 되지 범위에 해당 하는 매개 변수 일반적으로 `specified` 매개 변수는 현재 값과 함께 전달 됩니다. 예를 들어는 <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A>, 또는 <xref:System.Drawing.Point.X%2A> 또는 <xref:System.Drawing.Point.Y%2A> 의 속성은 <xref:System.Windows.Forms.Control.Location%2A> 속성 컨트롤의 현재 인스턴스에 대 한 참조를 사용 하 여 전달 될 수 있습니다. 그러나에 전달 된 모든 값 유지 하 고 컨트롤에 적용 됩니다.  
  
 `boundsSpecified` 매개 변수는 컨트롤의 요소를 나타냅니다 <xref:System.Windows.Forms.Control.Bounds%2A> 응용 프로그램에 의해 변경 합니다. 예를 들어, 변경 하는 경우는 <xref:System.Windows.Forms.Control.Size%2A> 컨트롤의는 `boundsSpecified` 매개 변수 값이는 `Size` 값 <xref:System.Windows.Forms.BoundsSpecified>합니다. 그러나 경우는 <xref:System.Windows.Forms.Control.Size%2A> 대 한 응답으로 조정 되는 <xref:System.Windows.Forms.Control.Dock%2A> 속성이 설정 되 고는 `boundsSpecified` 매개 변수 값이는 `None` 값 <xref:System.Windows.Forms.BoundsSpecified>합니다.  
  
> [!NOTE]
>  Windows Server 2003 시스템의 크기는 <xref:System.Windows.Forms.Form> 최대 픽셀 너비와 높이 모니터에 의해 제한 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Windows.Forms.Control.SetBoundsCore%2A> 메서드를 유지 하는 컨트롤 크기가 고정 되어 있습니다. 이 예제에서는 있어야에서 직접 또는 간접적으로 파생 된 클래스는 <xref:System.Windows.Forms.Control> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 메서드를 변경 하려면 컨트롤의 범위입니다. 파생된 클래스에는 크기 제한을 추가할 수는 <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 메서드.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">클라이언트 영역의 너비(픽셀)입니다.</param>
        <param name="y">클라이언트 영역의 높이(픽셀)입니다.</param>
        <summary>컨트롤 클라이언트 영역의 크기를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클라이언트 영역에서 시작 하는 (0, 0) 위치를 확장 하 고는 (`x`, `y`) 위치입니다.  
  
 일반적으로 설정 하면 안 된 <xref:System.Windows.Forms.Control.ClientSize%2A> 컨트롤의 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> 메서드 컨트롤 정사각형 유지 되도록 합니다. 이 예제에서는 있어야에서 직접 또는 간접적으로 파생 된 클래스는 <xref:System.Windows.Forms.Control> 클래스입니다.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> 메서드 있도록는 <see cref="P:System.Windows.Forms.Control.ClientSize" /> 속성 조정 됩니다.  
  
 컨트롤에서 그리기에 대 한 자세한 내용은 참조 [Windows Forms 컨트롤 렌더링](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">설정할 <see cref="T:System.Windows.Forms.ControlStyles" /> 비트입니다.</param>
        <param name="value">
          지정된 스타일을 컨트롤에 적용하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.Forms.ControlStyles" /> 플래그를 <see langword="true" /> 또는 <see langword="false" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤 스타일 비트 플래그는 지원 되는 동작을 분류 하는 데 사용 됩니다. 컨트롤을 호출 하 여 스타일을 사용 하도록 설정할 수는 <xref:System.Windows.Forms.Control.SetStyle%2A> 메서드와 적절 한 전달 <xref:System.Windows.Forms.ControlStyles> 비트 (또는 비트) 및 비트가 설정 되도록는 부울 값입니다. 에 지정 된 할당 된 값을 확인 하려면 <xref:System.Windows.Forms.ControlStyles> 를 사용 하 여는 <xref:System.Windows.Forms.Control.GetStyle%2A> 메서드와 전달은 <xref:System.Windows.Forms.ControlStyles> 평가 하는 멤버입니다.  
  
> [!CAUTION]
>  컨트롤 스타일 비트를 설정 하 고 컨트롤의 동작을 충분히 변경할 수 있습니다. 검토는 <xref:System.Windows.Forms.ControlStyles> 열거형 설명서 컨트롤 스타일 비트 호출 하기 전에 변경에 따른 영향을 이해 하는 <xref:System.Windows.Forms.Control.SetStyle%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에 이중 버퍼링을 사용 하면 한 <xref:System.Windows.Forms.Form> 하 고 변경 내용을 반영 하기 위해 스타일을 업데이트 합니다.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          컨트롤을 최상위 컨트롤로 설정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>컨트롤을 최상위 컨트롤로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우는 <xref:System.Windows.Forms.Control.SetTopLevel%2A> 의 메서드는 <xref:System.Windows.Forms.Form> 의 값을 전달 하 고 `false`를 호출할 때까지 폼 표시 되지 것입니다 <xref:System.Windows.Forms.Control.SetTopLevel%2A> 다시의 값을 전달 `true`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 매개 변수가 <see langword="true" />로 설정되고 해당 컨트롤이 ActiveX 컨트롤인 경우</exception>
        <exception cref="T:System.Exception">
          <see cref="M:System.Windows.Forms.Control.GetTopLevel" /> 반환 값이 <paramref name="value" /> 매개 변수와 같지 않고 <see cref="P:System.Windows.Forms.Control.Parent" /> 속성이 <see langword="null" />이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">이외의 다른 모든 종류의이 컨트롤을 최상위 컨트롤로 설정 하려면 <see cref="T:System.Windows.Forms.Form" />합니다. 이 사용 권한은 경우에 필요는 <paramref name="value" /> 매개 변수는 <see langword="true" /> 컨트롤은 ActiveX 컨트롤이 아닙니다. 연관 된 열거형: <see langword="AllWindows" /> 값 <see cref="T:System.Security.Permissions.UIPermissionWindow" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          컨트롤을 표시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>컨트롤을 지정된 표시 상태로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로이 메서드는 컨트롤의 표시 동작을 변경 하려면 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> 메서드를 변경 하려면 컨트롤의 표시 여부입니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤을 사용자에게 표시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤을 표시 설정에 해당 하는 <xref:System.Windows.Forms.Control.Visible%2A> 속성을 `true`합니다. 후의 <xref:System.Windows.Forms.Control.Show%2A> 메서드가 호출 되는 <xref:System.Windows.Forms.Control.Visible%2A> 속성의 값을 반환 `true` 될 때까지 <xref:System.Windows.Forms.Control.Hide%2A> 메서드를 호출 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 표시 하는 대화 상자에 대 한를 일시적으로 해당 화면에 있는 파란색 사각형을 그립니다. 이 예제에서 파생 되는 클래스를 정의 하려면 <xref:System.Windows.Forms.Form> 라는 `AboutDialog`합니다.  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤이 포커스 영역을 표시할지를 나타내는 값을 가져옵니다.</summary>
        <value>
          컨트롤이 포커스 영역을 표시하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 기능에 대 한 자세한 내용은 참조는[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx), 및 [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)항목입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자 인터페이스가 키보드 액셀러레이터 키를 표시하는지 아니면 숨기는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          키보드 액셀러레이터 키가 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Forms 디자이너에서 만든 컨트롤에서는 키보드 액셀러레이터 키가 기본적으로 표시 합니다.  
  
 이 기능에 대 한 자세한 내용은 참조는[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx), 및 [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)항목입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 사이트를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" />가 있는 경우 이것과 관련된 <see cref="T:System.Windows.Forms.Control" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 높이와 너비를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 높이와 너비를 픽셀 단위로 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때문에 <xref:System.Drawing.Size> 클래스는 값 형식 (`Structure` Visual Basic의 `struct` Visual C#), 컨트롤의 크기의 복사본을 반환 하는 속성에 액세스를 의미 하는 값으로 반환 됩니다. 따라서 조정는 <xref:System.Drawing.Size.Width%2A> 또는 <xref:System.Drawing.Size.Height%2A> 의 속성은 <xref:System.Drawing.Size> 이에서 반환 된 속성에 영향을 주지 것입니다는 <xref:System.Windows.Forms.Control.Width%2A> 또는 <xref:System.Windows.Forms.Control.Height%2A> 컨트롤의 합니다. 조정 하는 <xref:System.Windows.Forms.Control.Width%2A> 또는 <xref:System.Windows.Forms.Control.Height%2A> 컨트롤의 컨트롤의 설정 해야 <xref:System.Windows.Forms.Control.Width%2A> 또는 <xref:System.Windows.Forms.Control.Height%2A> 속성을 설정 하거나는 <xref:System.Windows.Forms.Control.Size%2A> 를 새 속성 <xref:System.Drawing.Size>합니다.  
  
> [!NOTE]
>  더 나은 성능을 유지 하기 위해 설정 하지 않으면는 <xref:System.Drawing.Size> 생성자에서 컨트롤의 합니다. 재정의 하는 메서드가 좋습니다는 <xref:System.Windows.Forms.Control.DefaultSize%2A> 속성입니다.  
  
> [!NOTE]
>  Windows Server 2003 시스템의 크기는 <xref:System.Windows.Forms.Form> 최대 픽셀 너비와 높이 모니터에 의해 제한 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추가 <xref:System.Windows.Forms.Button> 폼에 일반적인 속성 중 일부를 설정 합니다. 이 예제에서는 폼 크기가 조정 될 때의 상대 위치를 유지할 수 있도록 폼의 오른쪽 아래 모서리에 있는 단추를 고정 합니다. 그런 다음 설정의 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 단추와 같은 크기를 조정 하 고는 <xref:System.Drawing.Image>합니다. 설정한 후의 <xref:System.Windows.Forms.Control.TabStop%2A> 를 `true` 설정 하 고는 <xref:System.Windows.Forms.Control.TabIndex%2A> 속성입니다. 마지막으로 처리 하는 이벤트 처리기 추가 <xref:System.Windows.Forms.Control.Click> 단추의 이벤트가 있습니다. 이 예제를 실행 하려면 프로그램 <xref:System.Windows.Forms.ImageList> 라는 `imageList1`합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Size" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 것이 좋습니다는 <xref:System.Windows.Forms.Control.Layout> 사용자 지정 레이아웃을 처리 하는 이벤트입니다. <xref:System.Windows.Forms.Control.Layout> 대 한 응답으로 이벤트는 <xref:System.Windows.Forms.Control.Resize> 레이아웃 적용 해야 할 수는 다른 상황에서 뿐만 아니라 이벤트입니다.  
  
 이 이벤트는 <xref:System.Windows.Forms.Control.Size%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Control.SizeChanged> 이벤트입니다. 인스턴스는 <xref:System.Windows.Forms.Button> 컨트롤은 가로 및 세로로 확장 될 수 있습니다 제공 되었습니다. A <xref:System.Windows.Forms.NumericUpDown> 인스턴스 가로 및 세로 배율 값을 제공 합니다. <xref:System.Windows.Forms.Button> 명명 된 인스턴스 **확인** 배율 값을 설정 하는 데 사용 되는 <xref:System.Windows.Forms.Button> 컨트롤 인스턴스. 변경 될 때마다 컨트롤의 크기, 연결 된 이벤트 처리기는 <xref:System.Windows.Forms.Control.SizeChanged> 컨트롤의 이벤트 라고 합니다. 이 이벤트 처리기는 컨트롤의 크기 변경 되었음을 나타내는 메시지 상자를 표시 합니다.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="clientSize">컨트롤에 있는 클라이언트 영역의 높이와 너비를 나타내는 <see cref="T:System.Drawing.Size" /> 값입니다.</param>
        <summary>해당 클라이언트 영역의 높이와 너비로 전체 컨트롤의 크기를 확인합니다.</summary>
        <returns>전체 컨트롤의 높이와 너비를 나타내는 <see cref="T:System.Drawing.Size" /> 값입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 스타일이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.StyleChanged> 이벤트가 발생할 때 <xref:System.Windows.Forms.ControlStyles> 추가 되거나 변경 된 플래그입니다.  
  
 이 이벤트는 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 컨트롤 스타일이 변경 되 면 발생 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.StyleChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.StyleChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤의 레이아웃 논리를 임시로 일시 중단합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 레이아웃 논리 될 때까지 일시 중단 되는 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드를 호출 합니다.  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 및 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드는 동시에 표시 하지 않는 데 여러 <xref:System.Windows.Forms.Control.Layout> 컨트롤의 여러 속성을 조정 하는 동안 이벤트입니다. 예를 들어 일반적으로 호출 하는 것의 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 메서드를 설정 합니다는 <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, 또는 <xref:System.Windows.Forms.Control.Dock%2A> 호출 고 컨트롤의 속성은 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드 변경 내용을 적용 하려면 사용할 수 있도록 합니다.  
  
 에 대 한 보류 중인 호출 해야 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 에 대 한 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 성공적으로 호출할 수 있습니다.  
  
> [!NOTE]
>  여러 컨트롤에 부모 컨트롤을 추가할 때 것이 좋습니다를 호출 하는 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 추가할 컨트롤을 초기화 하기 전에 메서드. 부모 컨트롤에 컨트롤을 추가한 후 호출 된 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드. 이렇게 하면 컨트롤이 많은 응용 프로그램의 성능을 늘어납니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 두 개의 단추를 추가합니다. 예제에서는 트랜잭션을 사용 하 여 단추를 추가 <xref:System.Windows.Forms.Control.SuspendLayout%2A> 및 <xref:System.Windows.Forms.Control.ResumeLayout%2A> 메서드.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DragEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragDrop" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DragEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragEnter" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragLeave" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DragEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.DragOver" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>시스템 색이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Drawing.SystemColors> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 변경 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.SystemColorsChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.SystemColorsChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 컨테이너 내의 컨트롤 탭 순서를 가져오거나 설정합니다.</summary>
        <value>해당 컨테이너 내의 컨트롤 집합에 있는 컨트롤의 인덱스 값입니다. 컨테이너의 컨트롤은 탭 순서에 포함됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탭 순서에서 앞에 0 개, 더 낮은 숫자 보다 크거나 같은 임의의 유효한 정수 탭 인덱스를 구성할 수 있습니다. 같은 부모 컨트롤에 대 한 개 이상의 컨트롤이 동일한 탭 인덱스 있으면, 컨트롤의 z 순서 컨트롤 전체를 순환 하려면 순서를 결정 합니다.  
  
 탭 순서에 포함 되도록 컨트롤에 대 한 해당 <xref:System.Windows.Forms.Control.TabStop%2A> 속성으로 설정 되어 있어야 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추가 <xref:System.Windows.Forms.Button> 폼에 일반적인 속성 중 일부를 설정 합니다. 이 예제에서는 폼 크기가 조정 될 때의 상대 위치를 유지할 수 있도록 폼의 오른쪽 아래 모서리에 있는 단추를 고정 합니다. 그런 다음 설정의 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 단추와 같은 크기를 조정 하 고는 <xref:System.Drawing.Image>합니다. 설정한 후의 <xref:System.Windows.Forms.Control.TabStop%2A> 를 `true` 설정 하 고는 <xref:System.Windows.Forms.Control.TabIndex%2A> 속성입니다. 마지막으로 처리 하는 이벤트 처리기 추가 <xref:System.Windows.Forms.Control.Click> 단추의 이벤트가 있습니다. 이 예제를 실행 하려면 프로그램 <xref:System.Windows.Forms.ImageList> 라는 `imageList1`합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.TabIndex" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.TabIndex%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.TabIndexChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.TabIndexChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tab 키를 사용하여 이 컨트롤의 포커스를 이동할 수 있는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          Tab 키를 사용하여 컨트롤의 포커스를 이동할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.  
  
 <block subset="none" type="note"><para>  
 이 속성은 <see langword="true" /> 클래스의 인스턴스에 대해 항상 <see cref="T:System.Windows.Forms.Form" />를 반환합니다.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 TAB 키를 누르면 입력된 포커스가 탭 순서의 다음 컨트롤로 설정 됩니다. 컨트롤과 <xref:System.Windows.Forms.Control.TabStop%2A> 속성 값이 `false` 탭 순서에 컨트롤의 컬렉션에 포함 되지 않습니다. 탭 순서는 컨트롤을 설정 하 여 조작할 수 <xref:System.Windows.Forms.Control.TabIndex%2A> 속성 값입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추가 <xref:System.Windows.Forms.Button> 폼에 일반적인 속성 중 일부를 설정 합니다. 이 예제에서는 폼 크기가 조정 될 때의 상대 위치를 유지할 수 있도록 폼의 오른쪽 아래 모서리에 있는 단추를 고정 합니다. 그런 다음 설정의 <xref:System.Windows.Forms.Control.BackgroundImage%2A> 단추와 같은 크기를 조정 하 고는 <xref:System.Drawing.Image>합니다. 설정한 후의 <xref:System.Windows.Forms.Control.TabStop%2A> 를 `true` 설정 하 고는 <xref:System.Windows.Forms.Control.TabIndex%2A> 속성입니다. 마지막으로 처리 하는 이벤트 처리기 추가 <xref:System.Windows.Forms.Control.Click> 단추의 이벤트가 있습니다. 이 예제를 실행 하려면 프로그램 <xref:System.Windows.Forms.ImageList> 라는 `imageList1`합니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.TabStop" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.TabStop%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Control.TabStopChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.Control>와 같은 한 <xref:System.Windows.Forms.Button> 또는 <xref:System.Windows.Forms.ComboBox>합니다. 다음 인스턴스 이름을 `Control1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.Control.TabStopChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 대한 데이터가 포함된 개체를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 대한 데이터가 포함된 <see cref="T:System.Object" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 모든 형식에서 <xref:System.Object> 클래스는이 속성에 할당할 수 있습니다. 경우는 <xref:System.Windows.Forms.Control.Tag%2A> Windows Forms 디자이너를 통해 속성이 설정 되어 있으면 텍스트만 지정할 수 있습니다.  
  
 에 대 한 일반적인 용도 <xref:System.Windows.Forms.Control.Tag%2A> 속성은 컨트롤과 밀접 하 게 관련 된 데이터를 저장 합니다. 예를 들어 고객에 대 한 정보를 표시 하는 컨트롤을 사용 하는 경우 저장할 수 있습니다는 <xref:System.Data.DataSet> 해당 컨트롤의 고객의 주문 기록이 들어 있는 <xref:System.Windows.Forms.Control.Tag%2A> 속성 데이터를 신속 하 게 액세스할 수 있도록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼을 표시 하 고 저장 한 `Customer` 에 해당 <xref:System.Windows.Forms.Control.Tag%2A> 속성입니다. 이 예제에서 파생 되는 클래스를 정의 하려면 <xref:System.Windows.Forms.Form> 라는 `CustomerForm` 및 사용자가 정의한는 `Customer`합니다.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤과 관련된 텍스트를 가져오거나 설정합니다.</summary>
        <value>이 컨트롤과 관련된 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Text%2A> 각 파생된 클래스에서 컨트롤의 속성을 다르게 사용 합니다. 예를 들어는 <xref:System.Windows.Forms.Control.Text%2A> 속성은 <xref:System.Windows.Forms.Form> 폼의 상단에 있는 제목 표시줄에 표시 됩니다, 문자 수가 매우 적고 이며 일반적으로 응용 프로그램이 나 문서 이름이 표시 됩니다. 그러나는 <xref:System.Windows.Forms.Control.Text%2A> 속성은 <xref:System.Windows.Forms.RichTextBox> 매우 커질 수 있으며 텍스트의 서식을 지정 하는 데 사용 되는 다양 한 표시 되지 않는 문자를 포함할 수 있습니다. 예를 들어 표시 되는 텍스트는 <xref:System.Windows.Forms.RichTextBox> 조정 하 여 형식을 지정할 수는 <xref:System.Drawing.Font> 속성 또는 공백 또는 탭 문자 텍스트를 추가 하 여 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Windows.Forms.GroupBox> 공통 속성 중 일부를 설정 합니다. 이 예에서는 만듭니다는 <xref:System.Windows.Forms.TextBox> 설정 하 고 해당 <xref:System.Windows.Forms.Control.Location%2A> 그룹 상자 내에서. 그런 다음 설정의 <xref:System.Windows.Forms.Control.Text%2A> 그룹 상자 및 폼의 위쪽에 도킹 된 그룹 상자 속성입니다. 마지막으로, 그룹 상자 설정 하 여 비활성화는 <xref:System.Windows.Forms.Control.Enabled%2A> 속성을 `false`, 사용 하지 않도록 설정할 그룹 상자에 포함 된 모든 컨트롤에 이르게 됩니다.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우는 <see cref="P:System.Windows.Forms.Control.Text" /> 파생된 클래스에서 속성의 기본 클래스를 사용 하 여 <see cref="P:System.Windows.Forms.Control.Text" /> 속성을 기본 구현을 확장 합니다. 그렇지 않으면 모든 구현을 제공 해야 합니다. 모두 재정의할 필요 하지는 <see langword="get" /> 및 <see langword="set" /> 의 접근자는 <see cref="P:System.Windows.Forms.Control.Text" /> 속성 필요한 경우 하나만 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Text" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Text%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 변경 된 <xref:System.Windows.Forms.Control.ForeColor%2A> 의 <xref:System.Windows.Forms.TextBox> 통화 데이터를 표시 합니다. 이 예제에서는 텍스트는 10 진수 및 변경 내용에 변환에서 <xref:System.Windows.Forms.Control.ForeColor%2A> 를 <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> 숫자가 음수 이면 및 <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> 숫자가 양수 이면 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 위쪽 가장자리와 해당 컨테이너 클라이언트 영역의 위쪽 가장자리 사이의 거리(픽셀)를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 아래쪽 가장자리와 해당 컨테이너 클라이언트 영역의 위쪽 가장자리 사이의 거리(픽셀)를 나타내는 <see cref="T:System.Int32" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Top%2A> 속성 값은 해당 하는 <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> 의 속성은 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤의 속성 값입니다.  
  
 변경 내용을 <xref:System.Windows.Forms.Control.Height%2A> 및 <xref:System.Windows.Forms.Control.Top%2A> 속성 값은 <xref:System.Windows.Forms.Control.Bottom%2A> 변경 하려면 컨트롤의 속성 값입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개를 만들며 <xref:System.Windows.Forms.Button> 폼에서 제어 하 고 다양 한 크기 및 위치 관련 속성을 사용 하 여 해당 크기와 위치를 설정 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하에 너비와 높이가 이상 300 픽셀입니다.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>다른 Windows Forms 컨트롤에 의해 부모로 지정될 수 없는 부모 컨트롤을 가져옵니다. 일반적으로 이것은 컨트롤이 포함된 가장 바깥쪽 <see cref="T:System.Windows.Forms.Form" />입니다.</summary>
        <value>현재 컨트롤이 포함된 최상위 컨트롤을 나타내는 <see cref="T:System.Windows.Forms.Control" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부모 컨트롤의 자식이 다른 Windows Forms 컨트롤을 최상위 컨트롤 정의 되어 있습니다. 일반적으로 이것은 컨트롤이 포함된 가장 바깥쪽 <xref:System.Windows.Forms.Form>입니다. 예를 들어 컨트롤이 MDI 자식에 포함 된 경우 <xref:System.Windows.Forms.Form>, 최상위 컨트롤은 문서 MDI (다중 인터페이스) 부모 <xref:System.Windows.Forms.Form>합니다. 에 컨트롤의 부모가 없는 경우는 <xref:System.Windows.Forms.Form>,이 속성은 반환 `null`합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성 값을 가져오는 모든 창입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 컨트롤이 컨트롤의 클라이언트 영역 내에 무효화된 영역을 다시 그리게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 그리기에 대 한 보류 중인 요청을 실행 합니다.  
  
 두 가지 방법을 사용 하 여 폼과 해당 내용을 다시 그릴 수 있습니다.  
  
-   오버 로드 중 하나를 사용할 수는 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드는 <xref:System.Windows.Forms.Control.Update%2A> 메서드.  
  
-   호출할 수 있습니다는 <xref:System.Windows.Forms.Control.Refresh%2A> 강제로 컨트롤 자체와 모든 자식 다시 그리게 합니다. 이 설정에 해당 하는 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드를 `true` 와 함께 사용 하 <xref:System.Windows.Forms.Control.Update%2A>합니다.  
  
 <xref:System.Windows.Forms.Control.Invalidate%2A> 어떤 그리거나 다시 그리는 메서드를 제어 합니다. <xref:System.Windows.Forms.Control.Update%2A> 그리기 또는 다시 그리기 발생 하면 메서드를 제어 합니다. 사용 하는 경우는 <xref:System.Windows.Forms.Control.Invalidate%2A> 및 <xref:System.Windows.Forms.Control.Update%2A> 메서드를 호출 하는 대신 함께 <xref:System.Windows.Forms.Control.Refresh%2A>의 오버 로드에 따라 달라 집니다 다시 그리는 내용은 무엇 <xref:System.Windows.Forms.Control.Invalidate%2A> 사용 합니다. <xref:System.Windows.Forms.Control.Update%2A> 방금 메서드를 통해 즉시 그릴 컨트롤이 컨트롤 이지만 <xref:System.Windows.Forms.Control.Invalidate%2A> 메서드를 호출 하는 경우 그리고 가져옵니다 기능 제어는 <xref:System.Windows.Forms.Control.Update%2A> 메서드.  
  
 자세한 내용은 참조는[WM_PAINT](http://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx)항목입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>컨트롤의 범위를 업데이트합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 크기와 위치를 사용하여 컨트롤의 범위를 업데이트합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 새 <xref:System.Windows.Forms.Control.Size%2A> 컨트롤의와 다르면 이전 <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> 이벤트가 발생 합니다. 마찬가지로, 하는 경우는 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤 변경의 <xref:System.Windows.Forms.Control.LocationChanged> 이벤트가 발생 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">컨트롤의 <see cref="P:System.Drawing.Point.X" /> 좌표입니다.</param>
        <param name="y">컨트롤의 <see cref="P:System.Drawing.Point.Y" /> 좌표입니다.</param>
        <param name="width">컨트롤의 <see cref="P:System.Drawing.Size.Width" />입니다.</param>
        <param name="height">컨트롤의 <see cref="P:System.Drawing.Size.Height" />입니다.</param>
        <summary>지정된 크기와 위치를 사용하여 컨트롤의 범위를 업데이트합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 새 <xref:System.Windows.Forms.Control.Size%2A> 이전와 다른 경우 컨트롤의 <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> 이벤트가 발생 합니다. 마찬가지로,이 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤 변경의 <xref:System.Windows.Forms.Control.LocationChanged> 이벤트가 발생 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">컨트롤의 <see cref="P:System.Drawing.Point.X" /> 좌표입니다.</param>
        <param name="y">컨트롤의 <see cref="P:System.Drawing.Point.Y" /> 좌표입니다.</param>
        <param name="width">컨트롤의 <see cref="P:System.Drawing.Size.Width" />입니다.</param>
        <param name="height">컨트롤의 <see cref="P:System.Drawing.Size.Height" />입니다.</param>
        <param name="clientWidth">컨트롤의 클라이언트 <see cref="P:System.Drawing.Size.Width" />입니다.</param>
        <param name="clientHeight">컨트롤의 클라이언트 <see cref="P:System.Drawing.Size.Height" />입니다.</param>
        <summary>지정된 크기, 위치 및 클라이언트 크기를 사용하여 컨트롤의 범위를 업데이트합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 새 <xref:System.Windows.Forms.Control.Size%2A> 컨트롤의와 다르면 이전 <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> 이벤트가 발생 합니다. 마찬가지로, 하는 경우는 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤 변경의 <xref:System.Windows.Forms.Control.LocationChanged> 이벤트가 발생 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>할당된 스타일이 컨트롤에 강제로 다시 적용되도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출는 <xref:System.Windows.Forms.Control.CreateParams%2A> 메서드를 적용할 스타일을 가져옵니다. 에 할당 된 스타일은 <xref:System.Windows.Forms.CreateParams.Style%2A> 및 <xref:System.Windows.Forms.CreateParams.ExStyle%2A> 의 속성은 <xref:System.Windows.Forms.CreateParams> 는 컨트롤에 할당 된 <xref:System.Windows.Forms.Control.CreateParams%2A> 속성 다시 적용 됩니다. 필요한 경우 스타일 변경 내용에 맞게 컨트롤 다시 그려집니다.  
  
 <xref:System.Windows.Forms.Control.UpdateStyles%2A> 경우 메서드는 아무런 영향을 주지는 <xref:System.Windows.Forms.Control.IsHandleCreated%2A> 속성 값은 `false`합니다.  
  
   
  
## Examples  
 다음 코드 예제에 이중 버퍼링을 사용 하면 한 <xref:System.Windows.Forms.Form> 하 고 변경 내용을 반영 하기 위해 스타일을 업데이트 합니다.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤 부모의 Z 순서대로 컨트롤을 업데이트합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.UpdateZOrder%2A> 메서드 부모 컨트롤의 z 순서에서 컨트롤의 위치를 업데이트 합니다. 이 컨트롤은 새로 만든 제어 하는 경우에 예를 들어 추가한는 <xref:System.Windows.Forms.Control.ControlCollection>, z-순서 뒤에 추가 하 고 새 컨트롤으로 업데이트 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 컨트롤과 모든 자식 컨트롤에 대기 커서를 사용할지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          현재 컨트롤과 모든 자식 컨트롤에 WaitCursor를 사용하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 시간이 오래 걸리는 작업을 수행할 때마다 대기 커서를 사용 합니다. 그러나 UI 스레드를 차단 하는 작업 acursor 변경도 차단 됩니다 note 합니다. 따라서이 속성은 다른 스레드에서 시간이 많이 걸리는 작업을 수행할 때만 사용 해야 합니다. 즉시 전역적으로 커서를 변경 하려면 참조 하십시오. <xref:System.Windows.Forms.Cursor.Current%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 유효성 검사가 완료되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 키보드 (TAB, SHIFT + TAB 등)를 사용 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Select%2A> 또는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드를 설정 하거나는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> 속성을 현재 폼으로 포커스 이벤트가 다음 순서 대로 발생:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 마우스를 사용 하거나 호출 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드, 포커스 이벤트가 다음 순서 대로 발생 합니다.  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
 경우는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성은 <xref:System.ComponentModel.CancelEventArgs> 로 설정 된 `true` 에 <xref:System.Windows.Forms.Control.Validating> 후 일반적으로 발생 하는 모든 이벤트, 이벤트 대리자는 <xref:System.Windows.Forms.Control.Validating> 이벤트는 표시 되지 않습니다.  
  
> [!CAUTION]
>  내에서 포커스를 설정 하지 마십시오는 <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, 또는 <xref:System.Windows.Forms.Control.Validated> 이벤트 처리기입니다. 이렇게 하면 응용 프로그램 또는 운영 체제 응답 하지 발생할 수 있습니다. 자세한 내용은 참조는[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)항목과의 "메시지 교착 상태" 섹션에서 [에 대 한 메시지와 메시지 큐](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) 항목입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Windows.Forms.TextBox> 고 사용자가 입력 하는 전자 메일 주소 유효성을 검사 합니다. 표준 형식으로 전자 메일 주소가 없으면 (포함 된 "@" and "."), 유효성 검사에 실패는 <xref:System.Windows.Forms.ErrorProvider> 이벤트가 취소 되 고 아이콘이 표시 됩니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 및 <xref:System.Windows.Forms.ErrorProvider> 폼에 컨트롤을 만들었습니다.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 유효성을 검사할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 키보드 (TAB, SHIFT + TAB 등)를 사용 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Select%2A> 또는 <xref:System.Windows.Forms.Control.SelectNextControl%2A> 메서드를 설정 하거나는 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> 속성을 현재 폼으로 포커스 이벤트가 다음 순서 대로 발생:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 마우스를 사용 하거나 호출 하 여 포커스를 변경 하면는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드, 포커스 이벤트가 다음 순서 대로 발생 합니다.  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 경우는 <xref:System.Windows.Forms.Control.CausesValidation%2A> 속성이 `false`, <xref:System.Windows.Forms.Control.Validating> 및 <xref:System.Windows.Forms.Control.Validated> 이벤트는 표시 되지 않습니다.  
  
 경우는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성은 <xref:System.ComponentModel.CancelEventArgs> 로 설정 된 `true` 에 <xref:System.Windows.Forms.Control.Validating> 후 일반적으로 발생 하는 모든 이벤트, 이벤트 대리자는 <xref:System.Windows.Forms.Control.Validating> 이벤트는 표시 되지 않습니다.  
  
> [!CAUTION]
>  내에서 포커스를 설정 하지 마십시오는 <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, 또는 <xref:System.Windows.Forms.Control.Validated> 이벤트 처리기입니다. 이렇게 하면 응용 프로그램 또는 운영 체제 응답 하지 발생할 수 있습니다. 자세한 내용은 참조는 `WM_KILLFOCUS` "키보드 입력 참조" 섹션과 MSDN library에서 "에 대 한 메시지 및 메시지 큐" 항목의 "메시지 교착 상태" 섹션의 항목을 http://msdn.microsoft.com/library합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Windows.Forms.TextBox> 고 사용자가 입력 하는 전자 메일 주소 유효성을 검사 합니다. 표준 형식으로 전자 메일 주소가 없으면 (포함 된 "@" and "."), 유효성 검사에 실패는 <xref:System.Windows.Forms.ErrorProvider> 이벤트가 취소 되 고 아이콘이 표시 됩니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 및 <xref:System.Windows.Forms.ErrorProvider> 폼에 컨트롤을 만들었습니다.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤과 모든 해당 자식 컨트롤이 표시되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          컨트롤과 모든 해당 자식 컨트롤이 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 해당 `Visible` 로 설정 된 `true`, 다른 컨트롤 뒤에 가려져 경우 컨트롤 사용자에 게 표시 되지 않을 수도 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Windows.Forms.VScrollBar> 및 <xref:System.Windows.Forms.HScrollBar> 설정 및 해당 <xref:System.Windows.Forms.Control.Visible%2A> 속성 값의 크기에 따라는 <xref:System.Drawing.Image> 에 표시 되는 <xref:System.Windows.Forms.PictureBox> 컨트롤입니다. 이 예제에서는 한 <xref:System.Windows.Forms.PictureBox> 폼에 만든 <xref:System.Windows.Forms.HScrollBar> 및 <xref:System.Windows.Forms.VScrollBar> 폼에 <xref:System.Windows.Forms.PictureBox>합니다. 이 코드를 호출 해야 이미지가 로드 될 때 및 그림 상자에는 <xref:System.Windows.Forms.Control.Resize> 폼의 이벤트입니다.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.Control.Visible" /> 속성 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 <xref:System.Windows.Forms.Control.Visible%2A> 프로그래밍 방식으로 수정 되거나 사용자 상호 작용 하 여 속성이 변경 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 발생은 <xref:System.Windows.Forms.Control.VisibleChanged> 이벤트 때는 <xref:System.Windows.Forms.Control.Visible%2A> 의 속성 값은 <xref:System.Windows.Forms.Label> 컨트롤이 변경 합니다.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 너비를 가져오거나 설정합니다.</summary>
        <value>컨트롤의 너비(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변경 내용을 <xref:System.Windows.Forms.Control.Width%2A> 및 <xref:System.Windows.Forms.Control.Left%2A> 속성 값은 <xref:System.Windows.Forms.Control.Right%2A> 변경 하려면 컨트롤의 속성 값입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개를 만들며 <xref:System.Windows.Forms.Button> 폼에서 제어 하 고 다양 한 크기 및 위치 관련 속성을 사용 하 여 해당 크기와 위치를 설정 합니다. 이 예제를 실행 하려면는 <xref:System.Windows.Forms.Form> 하에 너비와 높이가 이상 300 픽셀입니다.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>컨트롤에 포함된 NativeWindow입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">처리할 Windows <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <summary>Windows 메시지를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 메시지는 <xref:System.Windows.Forms.Control.WndProc%2A> 메서드를 통해 필터링 된 후의 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> 메서드.  
  
 <xref:System.Windows.Forms.Control.WndProc%2A> 메서드는 Windows `WindowProc` 함수와 같습니다. Windows 메시지를 처리 하는 방법에 대 한 자세한 내용은 참조는 [WindowProc 함수](http://go.microsoft.com/fwlink/?LinkId=181565)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.WndProc%2A> 에서 식별 된 운영 체제 메시지를 처리 하는 메서드는 <xref:System.Windows.Forms.Message> 구조입니다. [WM_ACTIVATEAPP](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)다른 응용 프로그램이 활성화 되 면 알아야이 예에서 운영 체제 메시지를 처리 합니다. 사용 가능한 이해 하려면 다음 항목을 참조 <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>, 및 <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType> 값입니다. 상수 값을 실제 Windows.h 헤더 파일에 있습니다.  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 직접 실행 호출자입니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>상속 하는 컨트롤의 기본 클래스를 호출 해야 <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> 메서드를 처리 하지 않는 메시지를 처리 합니다.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>