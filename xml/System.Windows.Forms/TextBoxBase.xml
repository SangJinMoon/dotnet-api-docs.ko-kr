<Type Name="TextBoxBase" FullName="System.Windows.Forms.TextBoxBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="25fbcea5e9d3c82473c620da28c72036585f91c3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36513943" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TextBoxBase : System.Windows.Forms.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TextBoxBase extends System.Windows.Forms.Control" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TextBoxBase&#xA;Inherits Control" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBoxBase abstract : System::Windows::Forms::Control" />
  <TypeSignature Language="F#" Value="type TextBoxBase = class&#xA;    inherit Control" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultBindingProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("TextChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implements the basic functionality required by text controls.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스와 같은 텍스트 조작 컨트롤의 핵심 기능을 구현 <xref:System.Windows.Forms.TextBox> 및 <xref:System.Windows.Forms.RichTextBox>합니다. 텍스트 선택, 여기에 **클립보드** 기능과 여러 줄 텍스트 컨트롤을 지 원하는 많은 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 여러 줄을 만들려는 <xref:System.Windows.Forms.TextBox> 세로 스크롤 막대가 있는 컨트롤입니다. 또한이 예제에서는 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 및 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성을 여러 줄 텍스트 상자 컨트롤을 텍스트 문서를 만드는 데 유용 합니다.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>일반적으로 상속 되지 않는 <see cref="T:System.Windows.Forms.TextBoxBase" />합니다. 상속 텍스트 컨트롤 클래스를 만들려면 <see cref="T:System.Windows.Forms.TextBox" /> 또는 <see cref="T:System.Windows.Forms.RichTextBox" />합니다.</para>
    </block>
    <altmember cref="T:System.Windows.Forms.TextBox" />
    <altmember cref="T:System.Windows.Forms.RichTextBox" />
  </Docs>
  <Members>
    <Member MemberName="AcceptsTab">
      <MemberSignature Language="C#" Value="public bool AcceptsTab { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsTab" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptsTab As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcceptsTab { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptsTab : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.AcceptsTab" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether pressing the TAB key in a multiline text box control types a TAB character in the control instead of moving the focus to the next control in the tab order.</summary>
        <value>
          <see langword="true" /> TAB 키를 사용 하 여 여러 줄 텍스트 상자에 탭을 입력할 수 있는 경우 <see langword="false" /> TAB 키를 누르면 포커스가 이동 하는 경우. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성 수도 있어야 `true` 컨트롤의 탭 문자를 가져올 수 있습니다.  
  
 경우는 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 속성이로 설정 되어 `true`, 사용자가 탭 순서의 다음 컨트롤로 포커스를 이동 하려면 CTRL + TAB 키를 누르면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 여러 줄을 만들려는 <xref:System.Windows.Forms.TextBox> 세로 스크롤 막대가 있는 컨트롤입니다. 또한이 예제에서는 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 및 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성을 여러 줄 텍스트 상자 컨트롤을 텍스트 문서를 만드는 데 유용 합니다.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBox.AcceptsReturn" />
      </Docs>
    </Member>
    <Member MemberName="AcceptsTabChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AcceptsTabChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AcceptsTabChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AcceptsTabChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AcceptsTabChanged;" />
      <MemberSignature Language="F#" Value="member this.AcceptsTabChanged : EventHandler " Usage="member this.AcceptsTabChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.TextBoxBase.AcceptsTabChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.TextBoxBase>와 같은 한 <xref:System.Windows.Forms.TextBox> 또는 <xref:System.Windows.Forms.TextBoxBase>합니다. 다음 인스턴스 이름을 `TextBoxBase1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.TextBoxBase.AcceptsTabChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#241](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#241)]
 [!code-vb[System.Windows.Forms.EventExamples#241](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#241)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.AppendText : string -&gt; unit" Usage="textBoxBase.AppendText text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The text to append to the current contents of the text box.</param>
        <summary>Appends text to the current text of a text box.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 텍스트 연결 연산자 (+)를 사용 하 여 텍스트를 연결 하는 대신 해당 컨트롤의 기존 텍스트를 추가 하려면이 메서드를 사용는 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.TextBoxBase.AppendText%2A> 메서드 및 <xref:System.Windows.Forms.TextBoxBase.TextLength%2A> 하나에서 텍스트를 복사 하려면 속성 <xref:System.Windows.Forms.TextBox> 다른 합니다. 이 예제를 실행 하려면 <xref:System.Windows.Forms.TextBox> 명명 된 인스턴스인지 컨트롤 `textBox1` 및 `textBox2`, 폼에 추가 된 `textBox1` 에 할당 된 텍스트에 해당 <xref:System.Windows.Forms.Control.Text%2A> 속성입니다.  
  
 [!code-cpp[TextBoxBase.AppendText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TextBoxBase.AppendText/CPP/form1.cpp#1)]
 [!code-csharp[TextBoxBase.AppendText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TextBoxBase.AppendText/CS/form1.cs#1)]
 [!code-vb[TextBoxBase.AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TextBoxBase.AppendText/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the height of the control automatically adjusts when the font assigned to the control is changed.</summary>
        <value>
          <see langword="true" /> 컨트롤의 높이 글꼴 변경 되 면 자동으로 조정 하는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하는 경우는 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 속성을 `true` 에 대 한는 <xref:System.Windows.Forms.TextBox>때는 <xref:System.Windows.Forms.Control.Font%2A> 변경은 <xref:System.Windows.Forms.TextBox> 확장 또는 축소 되는 <xref:System.Windows.Forms.Control.Height%2A> 더 크거나 작은 텍스트를 수용 합니다. <xref:System.Windows.Forms.Control.Width%2A> 의 <xref:System.Windows.Forms.TextBox> 변경 되지 않습니다.  
  
 사용자가 텍스트 컨트롤의 크기를 변경 하려는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 사용 하 여 해당 <xref:System.Windows.Forms.RichTextBox.ContentsResized> 의 크기를 변경 하는 이벤트입니다.  
  
   
  
## Examples  
 이 예제에서는 두 개의 텍스트 상자, 두 개의 단추를 사용 하 여 폼 있고 각 단추에 대 한 click 이벤트 예제에 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 속성을 설정 하 여 `true` 한 텍스트 상자에 대 한 및 `false` 다른 합니다. 한 개의 단추를 클릭할 때 텍스트 상자는 더 작은 텍스트로 채워지고 다른 단추를 클릭할 때 텍스트 상자 더 큰 텍스트로 채워집니다. 포함 된 입력란이 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 로 설정 `true` 큰 텍스트에 맞게 높이가 확장 합니다. 너비를 변경 하지 않습니다.  
  
 [!code-csharp[SystemWindowsFormsAutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemWindowsFormsAutoSize/CS/Form1.cs#1)]
 [!code-vb[SystemWindowsFormsAutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemWindowsFormsAutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is not relevant for this class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.TextBoxBase.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the background color of the control.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> 컨트롤의 배경색을 나타내는입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 폼의 색 구성표에 맞게 텍스트 컨트롤의 배경색을 변경할 속성입니다.  
  
 컨트롤 내의 텍스트의 색을 변경 하려면 사용 된 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 속성입니다. 설정할 때의 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> text 컨트롤의 속성 확인 선택한 색 사라질 때까지 컨트롤의 텍스트 발생 하지 않습니다. 예를 들어 경우는 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 및 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 속성 둘 다로 설정 `Color.Black`, textbox 컨트롤 내의 텍스트를 볼 수 없게 됩니다.  
  
 이 속성 경우 재정의 될 수 있습니다는 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 의 속성은 <xref:System.Windows.Forms.TextBoxBase> 로 설정 된 `true`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.TextBoxBase.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This property is not relevant for this class.</summary>
        <value>개체에 대 한 배경 이미지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.BackgroundImage" /> property changes. This event is not relevant for this class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.TextBoxBase.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This property is not relevant for this class.</summary>
        <value>
          <see cref="T:System.Windows.Forms.ImageLayout" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.BackgroundImageLayout" /> property changes. This event is not relevant for this class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.BorderStyle : System.Windows.Forms.BorderStyle with get, set" Usage="System.Windows.Forms.TextBoxBase.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the border type of the text box control.</summary>
        <value>A <see cref="T:System.Windows.Forms.BorderStyle" /> 텍스트 상자 컨트롤의 테두리 형식을 나타내는입니다. 기본값은 <see langword="Fixed3D" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A> 속성 기본 3 차원 제어 외에 테두리가 없는 평면 스타일 컨트롤을 만듭니다.  
  
> [!NOTE]
>  파생된 클래스 <xref:System.Windows.Forms.RichTextBox>, 지원 하지 않습니다는 `BorderStyle.FixedSingle` 스타일입니다. 이 스타일 하면는 <xref:System.Windows.Forms.BorderStyle> 사용 하는 `BorderStyle.Fixed3D` 대신 스타일입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 단일 테두리가 있는 20 포인트 Arial를 사용 하 여 텍스트를 올바르게 표시할 수 있는 텍스트 상자를 만듭니다. 사용 하 여이 예제는 <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> 글꼴 후 컨트롤의 적절 한 높이 결정 하는 속성 및 <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A> 컨트롤에 할당 되었습니다.  
  
 [!code-cpp[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">A value that is not within the range of valid values for the enumeration was assigned to the property.</exception>
      </Docs>
    </Member>
    <Member MemberName="BorderStyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BorderStyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BorderStyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BorderStyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BorderStyleChanged;" />
      <MemberSignature Language="F#" Value="member this.BorderStyleChanged : EventHandler " Usage="member this.BorderStyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.TextBoxBase.BorderStyleChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.TextBoxBase>와 같은 한 <xref:System.Windows.Forms.TextBox> 또는 <xref:System.Windows.Forms.TextBoxBase>합니다. 다음 인스턴스 이름을 `TextBoxBase1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.TextBoxBase.BorderStyleChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#242](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#242)]
 [!code-vb[System.Windows.Forms.EventExamples#242](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#242)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected override bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.TextBoxBase.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="P:System.Windows.Forms.Control.ImeMode" /> property can be set to an active value, to enable IME support.</summary>
        <value>
          <see langword="false" /> 경우는 <see cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" /> 속성은 <see langword="true" /> 이 또는 <see cref="T:System.Windows.Forms.TextBoxBase" /> 클래스 암호 마스크를 사용 하도록 설정 되 고, 그렇지 않으면 문자 <see langword="true" />합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanUndo">
      <MemberSignature Language="C#" Value="public bool CanUndo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanUndo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CanUndo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanUndo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanUndo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanUndo : bool" Usage="System.Windows.Forms.TextBoxBase.CanUndo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the user can undo the previous operation in a text box control.</summary>
        <value>
          <see langword="true" /> 텍스트 상자 컨트롤;에서 수행 하는 이전 작업을 실행 취소할 수 있는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 `true`를 호출할 수 있습니다는 <xref:System.Windows.Forms.TextBoxBase.Undo%2A> 메서드를 텍스트 상자의 마지막 작업을 취소 합니다. 이 메서드를 사용할 수 있습니다는 <xref:System.Windows.Forms.MenuItem.Popup> 의 이벤트는 <xref:System.Windows.Forms.MenuItem>, 또는에서 단추의 상태를 관리 하는 코드는 <xref:System.Windows.Forms.ToolBar> 텍스트 상자 컨트롤에서 이전 작업 실행 취소 하는 기능을 사용할지 여부를 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="textBoxBase.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all text from the text box control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 할당 하는 대신 컨트롤의 내용을 삭제 하는 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성에 빈 문자열입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스에 대 한 이벤트 처리기를 만들려면는 <xref:System.Windows.Forms.Control.TextChanged> 이벤트입니다. 이벤트 처리기 내에서 코드를 숫자로 데이터를 제한합니다. 컨트롤에 텍스트를 입력 한 후 코드 입력 한 텍스트 숫자 인지를 확인 합니다. 코드 컨트롤에서 텍스트를 지웁니다 숫자는 텍스트가 아닌 경우 및 <xref:System.Windows.Forms.MessageBox> 숫자만 허용 되는 사용자 경고를 표시 합니다. 예제를 실행 하려면는 `Boolean` 라는 변수 `flag` 및 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 이 메서드 외부에서 정의 됩니다. 연속 이벤트를 방지 하기 위해 변수를 사용 하는 방법을 보여 주는이 예제는 <xref:System.Windows.Forms.Control.TextChanged> 이벤트입니다.  
  
 [!code-cpp[Classic TextBoxBase.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ClearUndo" />
      </Docs>
    </Member>
    <Member MemberName="ClearUndo">
      <MemberSignature Language="C#" Value="public void ClearUndo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearUndo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ClearUndo" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearUndo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearUndo();" />
      <MemberSignature Language="F#" Value="member this.ClearUndo : unit -&gt; unit" Usage="textBoxBase.ClearUndo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears information about the most recent operation from the undo buffer of the text box.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반복 실행 취소 작업을 방지 하기 위해 응용 프로그램의 상태에 따라이 방법을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the text box is clicked.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 처리 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.TextBoxBase.Click> 이벤트입니다. 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.TextBox> TextBox1 라는 컨트롤입니다. 이 예제에서는 이벤트 처리 메서드에와 관련 된는 <xref:System.Windows.Forms.TextBoxBase.Click> 이벤트입니다.  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public void Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Sub Copy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; unit" Usage="textBoxBase.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies the current selection in the text box to the **Clipboard**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 사용 하는 대신는 <xref:System.Windows.Forms.Clipboard> 텍스트 상자에 텍스트를 복사 하 여에 배치할 클래스는 **클립보드**합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberSignature Language="F#" Value="override this.CreateHandle : unit -&gt; unit" Usage="textBoxBase.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a handle for the control.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 비관리 코드와 작동 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.TextBoxBase.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the required creation parameters when the control handle is created.</summary>
        <value>컨트롤 핸들을 만들 때 필요한 작성 매개 변수가 포함된 <see cref="T:System.Windows.Forms.CreateParams" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public void Cut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Cut" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cut();" />
      <MemberSignature Language="F#" Value="member this.Cut : unit -&gt; unit" Usage="textBoxBase.Cut " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Moves the current selection in the text box to the **Clipboard**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에서 텍스트를 선택한 경우이 메서드 입력란에서 텍스트를 잘라내어만 됩니다. 이 메서드를 사용 하 여 사용 하는 대신는 <xref:System.Windows.Forms.Clipboard> 텍스트 상자에 텍스트를 복사 하 여로 이동 하면 클래스는 **클립보드**합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.TextBoxBase.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default cursor for the control.</summary>
        <value>현재 기본 커서를 나타내는 <see cref="T:System.Windows.Forms.Cursor" /> 형식의 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 재정의 <xref:System.Windows.Forms.TextBoxBase.DefaultCursor%2A> 를 컨트롤에 대 한 기본 커서를 구성 합니다. 이 컨트롤의 생성자에 커서를 설정 하는 보다 더 효율적 이며 자동 지원 특정 커서와 관련 된 디자이너 기능에 대 한 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.TextBoxBase.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default size of the control.</summary>
        <value>컨트롤의 기본 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DeselectAll">
      <MemberSignature Language="C#" Value="public void DeselectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeselectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.DeselectAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeselectAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeselectAll();" />
      <MemberSignature Language="F#" Value="member this.DeselectAll : unit -&gt; unit" Usage="textBoxBase.DeselectAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Specifies that the value of the <see cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" /> property is zero so that no characters are selected in the control.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected override bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether control drawing is done in a buffer before the control is displayed. This property is not relevant for this class.</summary>
        <value>
          <see langword="true" /> 컨트롤에 이중 버퍼링을 구현 하려면 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.TextBoxBase.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the foreground color of the control.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> 컨트롤의 전경색을 나타내는입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 속성 폼에서 다른 컨트롤의 텍스트와 일치 하도록 컨트롤 내의 텍스트의 색을 변경 합니다. 또한 잘못 된 값을 포함 하는 특정 텍스트 상자에 강조 표시 하려면이 속성을 사용할 수 있습니다.  
  
 컨트롤의 배경색을 변경 하려면 사용 된 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 속성입니다. 설정할 때의 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> text 컨트롤의 속성 확인 선택한 색 사라질 때까지 컨트롤의 텍스트 발생 하지 않습니다. 예를 들어 경우는 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 및 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 속성 둘 다로 설정 `Color.Black`, textbox 컨트롤 내의 텍스트를 볼 수 없게 됩니다.  
  
 이 속성 경우 재정의 될 수 있습니다는 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 의 속성은 <xref:System.Windows.Forms.TextBoxBase> 로 설정 된 `true`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharFromPosition">
      <MemberSignature Language="C#" Value="public virtual char GetCharFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char GetCharFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharFromPosition (pt As Point) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual char GetCharFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="abstract member GetCharFromPosition : System.Drawing.Point -&gt; char&#xA;override this.GetCharFromPosition : System.Drawing.Point -&gt; char" Usage="textBoxBase.GetCharFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">The location from which to seek the nearest character.</param>
        <summary>Retrieves the character that is closest to the specified location within the control.</summary>
        <returns>The character at the specified location.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위치에 지정 하는 경우는 `pt` 매개 변수는 문자열에 지정 된 지점에 가장 가까운의 첫 번째 문자는 컨트롤의 클라이언트 영역 외부 `pt` 반환 됩니다. 컨트롤 내에서 특정 지점 근처에 있는 문자를 확인 하려면이 메서드를 사용할 수 있습니다. 그런 다음 해당 위치에서 텍스트에 대 한 작업을 수행 하려면이 값을 사용할 수 있습니다.  
  
> [!NOTE]
>  경우에 지정된 된 위치는 `pt` 매개 변수는 문자열에 지정 된 지점에 가장 가까운의 마지막 문자는 컨트롤의 클라이언트 영역 오른쪽에 있는 `pt` 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public virtual int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="abstract member GetCharIndexFromPosition : System.Drawing.Point -&gt; int&#xA;override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="textBoxBase.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">The location to search.</param>
        <summary>Retrieves the index of the character nearest to the specified location.</summary>
        <returns>The zero-based character index at the specified location.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 위치와 가장 가까운 문자 인덱스를 반환 하는이 메서드는 `pt` 매개 변수입니다. 문자 인덱스에는 공백을 포함 하 여 컨트롤의에서 텍스트의 0부터 시작 인덱스가입니다. 텍스트에는 사용자에이 메서드를 마우스 좌표를 전달 하 여 마우스를 확인 하려면이 메서드를 사용할 수 있습니다. 이 컨트롤의 텍스트에 포함 된 단어 위에 마우스 포인터를 놓을 때 작업을 수행 하려는 경우에 유용할 수 있습니다.  
  
> [!IMPORTANT]
>  지정된 된 위치는 컨트롤의 클라이언트 영역 내에 없으면 컨트롤에서 마지막 문자 뒤, 반환 값은 마지막 문자의 인덱스입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetFirstCharIndexFromLine">
      <MemberSignature Language="C#" Value="public int GetFirstCharIndexFromLine (int lineNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFirstCharIndexFromLine(int32 lineNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstCharIndexFromLine (lineNumber As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFirstCharIndexFromLine(int lineNumber);" />
      <MemberSignature Language="F#" Value="member this.GetFirstCharIndexFromLine : int -&gt; int" Usage="textBoxBase.GetFirstCharIndexFromLine lineNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineNumber">The line for which to get the index of its first character.</param>
        <summary>Retrieves the index of the first character of a given line.</summary>
        <returns>The zero-based index of the first character in the specified line.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 텍스트 상자에 줄 번호는 0에서 시작 합니다. 경우는 `lineNumber` 매개 변수는 입력란의 마지막 줄에서는 보다 큰 <xref:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine%2A> -1을 반환 합니다.  
  
 <xref:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine%2A> 실제 줄의 첫 번째 문자 인덱스를 반환합니다. 실제 줄은 표시 된 줄을 할당 된 줄에 없습니다. 표시 된 줄 수 할당 된 줄 바꿈으로 인해 개수 보다 클 수 있습니다. 예를 들어, 두 줄에 할당 하는 경우는 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 설정 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 및 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 를 `true`, 두 할당 된 긴 줄 될 4 개의 물리적 (또는 줄으로 표시).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of the <paramref name="lineNumber" /> parameter is less than zero.</exception>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="GetFirstCharIndexOfCurrentLine">
      <MemberSignature Language="C#" Value="public int GetFirstCharIndexOfCurrentLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFirstCharIndexOfCurrentLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexOfCurrentLine" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstCharIndexOfCurrentLine () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFirstCharIndexOfCurrentLine();" />
      <MemberSignature Language="F#" Value="member this.GetFirstCharIndexOfCurrentLine : unit -&gt; int" Usage="textBoxBase.GetFirstCharIndexOfCurrentLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves the index of the first character of the current line.</summary>
        <returns>The zero-based character index in the current line.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public virtual int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetLineFromCharIndex : int -&gt; int&#xA;override this.GetLineFromCharIndex : int -&gt; int" Usage="textBoxBase.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The character index position to search.</param>
        <summary>Retrieves the line number from the specified character position within the text of the control.</summary>
        <returns>The zero-based line number in which the character index is located.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면에 지정 된 문자 인덱스를 기반으로 하는 줄 번호를 확인 하는 `index` 는 메서드의 매개 변수입니다. 컨트롤의에서 텍스트의 첫 번째 줄 0 값을 반환합니다. <xref:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex%2A> 메서드 인덱싱된 문자는 컨트롤 내에 있는 실제 줄 번호 반환 합니다. 다음 줄으로 된 컨트롤이 래핑될 만큼 하는 경우에 텍스트의 첫 번째 논리 줄의 일부 예를 들어는 <xref:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex%2A> 메서드 두 번째 실제 줄을 지정된 된 문자 인덱스에 있는 문자가 래핑하면 경우 1을 반환 합니다. 경우 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 로 설정 된 `false`, 다음 줄의 없습니다 일부가 래핑하면 및 메서드가 지정된 된 문자 인덱스에 대 한 0을 반환 합니다. 이 메서드를 확인 하려면 줄 특정 문자 인덱스 내에서 사용할 수 있습니다. 예를 들어 호출한 후는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 텍스트를 검색할 수 있는 메서드는 검색 결과 찾을 위치에 문자 인덱스를 가져올 수 있습니다. 반환 된 문자 인덱스에 있는이 메서드를 호출할 수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 단어 줄을 확인할 메서드를 찾을 수 있습니다.  
  
> [!NOTE]
>  문자 인덱스에 지정 된 경우는 `index` 매개 변수를 사용할 수 있는 컨트롤에 포함 된 줄 수가 이외의 않으면 마지막 줄 번호가 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetPositionFromCharIndex : int -&gt; System.Drawing.Point&#xA;override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="textBoxBase.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The index of the character for which to retrieve the location.</param>
        <summary>Retrieves the location within the control at the specified character index.</summary>
        <returns>The location of the specified character within the client rectangle of the control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 컨트롤에 특정 문자 인덱스가 위치한 확인할 수 있습니다. 컨트롤에는 단어에 대 한 바로 가기 메뉴 항목 또는 도움말 정보를 표시 하는 등의 작업에 대 한이 메서드를 사용할 수 있습니다. 예를 들어 사용자 컨트롤의 단어 마우스 오른쪽 단추로 클릭할 때 사용자에 게 옵션 메뉴를 표시 하려는이 메서드를 사용 하 여 제대로 표시 하려면 word의 위치를 결정할 수 있습니다는 <xref:System.Windows.Forms.ContextMenu> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HideSelection">
      <MemberSignature Language="C#" Value="public bool HideSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HideSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.HideSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property HideSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HideSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HideSelection : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.HideSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the selected text in the text box control remains highlighted when the control loses focus.</summary>
        <value>
          <see langword="true" /> 선택한 텍스트 표시 되지 않으면 강조 표시 된 텍스트 상자 컨트롤; 포커스를 잃으면 <see langword="false" />경우 textbox 컨트롤이 포커스를 잃을 때 선택한 텍스트가 강조 표시 됩니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 맞춤법 검사기 대화 상자와 같은 다른 양식 또는 대화 상자에 포커스가 있을 때 텍스트 상자 컨트롤에서 강조 표시 하는 텍스트를 유지 하려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.TextBoxBase.HideSelection%2A> 속성입니다. 예제를 실행 하는 폼에 다음 코드를 붙여넣습니다. 호출 된 `InitializeTextBox` 폼의 생성자 또는 `Load` 메서드.  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HideSelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler HideSelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HideSelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HideSelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HideSelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.HideSelectionChanged : EventHandler " Usage="member this.HideSelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.HideSelection" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.TextBoxBase.HideSelectionChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.TextBoxBase>와 같은 한 <xref:System.Windows.Forms.TextBox> 또는 <xref:System.Windows.Forms.TextBoxBase>합니다. 다음 인스턴스 이름을 `TextBoxBase1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.TextBoxBase.HideSelectionChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#245](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#245)]
 [!code-vb[System.Windows.Forms.EventExamples#245](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#245)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.HideSelection" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.TextBoxBase.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the Input Method Editor (IME) mode of a control.</summary>
        <value>컨트롤의 IME 모드입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected override bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="textBoxBase.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">One of the Keys value.</param>
        <summary>Determines whether the specified key is an input key or a special key that requires preprocessing.</summary>
        <returns>
          <see langword="true" /> if the specified key is an input key; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.IsInputKey%2A> 메서드 반환 `true` 때는 `keyData` 매개 변수에 포함 됩니다는 <xref:System.Windows.Forms.Keys.Tab> 값 및 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 속성은 `true`합니다. <xref:System.Windows.Forms.TextBoxBase.IsInputKey%2A> 반환 `false` 경우 `keyData` 둘 다 포함 되어 <xref:System.Windows.Forms.Keys.Tab> 및 <xref:System.Windows.Forms.Keys.Control>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lines">
      <MemberSignature Language="C#" Value="public string[] Lines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Lines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Lines" />
      <MemberSignature Language="VB.NET" Value="Public Property Lines As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Lines { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Lines : string[] with get, set" Usage="System.Windows.Forms.TextBoxBase.Lines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the lines of text in a text box control.</summary>
        <value>TextBox 컨트롤의 텍스트가 포함된 문자열 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열의 각 요소에에서 텍스트 상자 컨트롤에서 텍스트의 줄이 됩니다. 경우는 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 텍스트 상자 컨트롤의 속성이로 설정 되어 `true` 및 줄 바꿈 문자가 텍스트에 나타나는, 줄 바꿈 문자 다음의 텍스트 배열에 새 요소에 추가 되 고 별도 줄에 표시 됩니다.  
  
> [!NOTE]
>  기본적으로 줄의 컬렉션은 읽기 전용 복사본에 있는 줄의 <xref:System.Windows.Forms.TextBox>합니다. 줄의 쓰기 가능한 컬렉션을 가져오려면 다음과 유사한 코드를 사용 합니다. `textBox1.Lines = new string[] { "abcd" };`  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 여러 줄 텍스트 상자 컨트롤에서 텍스트의 모든 문자열을 추출 하 고 표시를 사용 하는 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 메서드. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 컨트롤을 만든 명명 된 `textBox1`, 및 텍스트 줄으로 채워져 있습니다.  
  
 [!code-cpp[Classic TextBoxBase.Lines Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Lines Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Lines Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public virtual int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.TextBoxBase.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(32767)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of characters the user can type or paste into the text box control.</summary>
        <value>컨트롤에 입력할 수 있는 문자 수입니다. 기본값은 32767입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 우편 번호 및 전화 번호 등의 값에 대 한 컨트롤에 입력 된 텍스트의 길이 제한 하거나 데이터를 데이터베이스에 입력 해야 할 때 입력 한 텍스트의 길이 제한 수에 사용할 수 있습니다. 데이터베이스의 해당 필드의 최대 길이 컨트롤에 입력 한 텍스트를 제한할 수 있습니다.  
  
> [!NOTE]
>  코드에서의 값을 설정할 수는 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성에는 지정 된 값 보다 큰 값으로는 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 속성입니다. 이 속성은 런타임 시 컨트롤에 입력 된 텍스트를만 영향을 줍니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생된 클래스를 사용 하 여 <xref:System.Windows.Forms.TextBox>, 암호를 적용 하는 데 사용 되는 텍스트 상자를 만듭니다. 사용 하 여이 예제는 <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> 대문자로 입력 한 모든 문자를 변경 하는 속성 및 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 암호 길이를 8 자로 제한 하는 속성입니다. 또한이 예제에서는 <xref:System.Windows.Forms.TextBox.TextAlign%2A> 속성에 암호를 가운데에 <xref:System.Windows.Forms.TextBox> 제어 합니다.  
  
 [!code-cpp[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value assigned to the property is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modified">
      <MemberSignature Language="C#" Value="public bool Modified { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modified" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Modified" />
      <MemberSignature Language="VB.NET" Value="Public Property Modified As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modified { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Modified : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.Modified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates that the text box control has been modified by the user since the control was created or its contents were last set.</summary>
        <value>
          <see langword="true" /> 컨트롤의 내용이 수정 되었습니다; 하는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 텍스트 상자 컨트롤의 내용을 수정 되었는지 확인 하려면이 속성을 사용할 수 있습니다. 또한 응용 프로그램에서 변경 내용을 텍스트 상자 컨트롤에 적용 된 코드에이 속성을 설정할 수 있습니다. 변경 된 내용의 유효성을 검사 하거나 저장할 수 있도록 텍스트 상자 컨트롤에 변경 내용이 있는지 확인 하려면 유효성 검사 및 데이터 저장 메서드에서이 속성을 사용할 수 있습니다.  
  
 변경 하는 경우는 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성 프로그래밍 방식으로 <xref:System.Windows.Forms.TextBoxBase.Modified%2A> 속성 되돌아갑니다 `false`합니다. 이 발생 하지 않습니다는 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Control.TextChanged> 에 대 한 이벤트는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 확인 하려면 내용의 <xref:System.Windows.Forms.TextBox> 컨트롤에 컨트롤을 데이터로 채운 후 변경 된 것입니다. 이 예제에서는 컨트롤의 원래 내용을 저장 하는 문자열을 사용 하 고의 내용과 비교는 <xref:System.Windows.Forms.TextBox> 내용이 변경 될 경우를 확인 하려면. 내용이 변경 될 경우는 <xref:System.Windows.Forms.TextBoxBase.Modified%2A> 속성이 `true`합니다. 그렇지 않은 경우에 다시 설정 되기 `false`합니다. 이 예제에서는 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만든 하 고는 `String` 라는 변수 `originalText` 만든에 대 한 원래 텍스트를 저장 하는 <xref:System.Windows.Forms.TextBox> 제어 합니다.  
  
 [!code-cpp[Classic TextBoxBase.Modified Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Modified Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Modified Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifiedChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ModifiedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ModifiedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ModifiedChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ModifiedChanged;" />
      <MemberSignature Language="F#" Value="member this.ModifiedChanged : EventHandler " Usage="member this.ModifiedChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.Modified" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변경 하는 경우는 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성 프로그래밍 방식으로 <xref:System.Windows.Forms.TextBoxBase.Modified%2A> 속성 되돌아갑니다 `false`합니다. 이 발생 하지 않습니다는 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 이벤트입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.TextBoxBase>와 같은 한 <xref:System.Windows.Forms.TextBox> 또는 <xref:System.Windows.Forms.TextBoxBase>합니다. 다음 인스턴스 이름을 `TextBoxBase1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#246](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#246)]
 [!code-vb[System.Windows.Forms.EventExamples#246](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#246)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Modified" />
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the control is clicked by the mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox> 컨트롤 발생 하지 않는 한 <xref:System.Windows.Forms.TextBoxBase.Click> 에 대 한 이벤트를 마우스 오른쪽 단추로 클릭 합니다. <xref:System.Windows.Forms.TextBoxBase.MouseClick> 이벤트에 해당 하는 기능을 제공 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.TextBoxBase.MouseClick> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.TextBoxBase>와 같은 한 <xref:System.Windows.Forms.TextBox> 또는 <xref:System.Windows.Forms.TextBoxBase>합니다. 다음 인스턴스 이름을 `TextBoxBase1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.TextBoxBase.MouseClick> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#244](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#244)]
 [!code-vb[System.Windows.Forms.EventExamples#244](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#244)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public virtual bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether this is a multiline text box control.</summary>
        <value>
          <see langword="true" /> 컨트롤이 여러 줄 텍스트 상자 컨트롤; 인 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 줄 텍스트 상자에는 두 줄 이상의 텍스트 컨트롤에 표시할 수 있습니다. 경우는 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성이 `true`, 여러 줄 텍스트 상자에 입력 한 텍스트 컨트롤의 다음 줄으로 줄 바꿈됩니다. 경우는 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성이 `false`, 여러 줄 텍스트 상자 컨트롤에 입력 한 텍스트 줄 바꿈 문자를 입력할 때까지 같은 줄에 표시 됩니다.  
  
 다음 줄 바꿈 문자로 사용할 수 있습니다.  
  
-   <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>  
  
-   ControlChars.CrLf  
  
-   vbCrLf (Visual Basic 전용)  
  
 스크롤 막대를 사용 하 여 텍스트 상자에 추가할 수 있습니다는 <xref:System.Windows.Forms.TextBox.ScrollBars%2A> 속성을 가로 또는 세로 스크롤 막대를 표시 합니다. 이 사용자를 컨트롤의 크기를 초과 하는 텍스트를 스크롤할 수 있습니다.  
  
> [!NOTE]
>  때문에 기본값인은 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성은 `false`의 기본 크기는 <xref:System.Windows.Forms.TextBox> 크기를 조정 하는 경우에 글꼴 크기에 따라 수는 <xref:System.Windows.Forms.TextBox>합니다. 에 대 한 일관 된 크기를 가져오려면 사용자 <xref:System.Windows.Forms.TextBox>설정, 해당 <xref:System.Windows.Forms.TextBox.Multiline%2A> 속성을 `true`합니다.  
  
> [!NOTE]
>  일본어 운영 체제의 경우는 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성이 `true`설정는 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> 속성 체제 암호의 텍스트를 표시 합니다. 따라서 일본어 운영 체제에서 설정 하는 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성을 `false` 설정 하는 경우는 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> 속성입니다.  
  
> [!NOTE]
>  이 속성이 `false` 를 파생 클래스 모두에 대해 기본적으로는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다.  
  
 에 대 한는 <xref:System.Windows.Forms.RichTextBox> 컨트롤의 <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> 속성 컨트롤은 자동으로 조정, 다음과 같이 여부에 영향을 줍니다.  
  
-   경우 <xref:System.Windows.Forms.RichTextBox.AutoSize%2A?displayProperty=nameWithType> 로 설정 된 `true` 및 <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> 로 설정 된 `true`, <xref:System.Windows.Forms.RichTextBox> 자동으로 크기가 조정 되지 것입니다.  
  
-   경우 <xref:System.Windows.Forms.RichTextBox.AutoSize%2A?displayProperty=nameWithType> 로 설정 된 `true` 및 <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> 로 설정 된 `false`, <xref:System.Windows.Forms.RichTextBox> 자동 조정 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 여러 줄을 만들려는 <xref:System.Windows.Forms.TextBox> 세로 스크롤 막대가 있는 컨트롤입니다. 또한이 예제에서는 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 및 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성을 여러 줄 텍스트 상자 컨트롤을 텍스트 문서를 만드는 데 유용 합니다.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.WordWrap" />
        <altmember cref="P:System.Windows.Forms.TextBox.ScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="MultilineChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MultilineChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MultilineChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.MultilineChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MultilineChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MultilineChanged;" />
      <MemberSignature Language="F#" Value="member this.MultilineChanged : EventHandler " Usage="member this.MultilineChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.Multiline" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.TextBoxBase.MultilineChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.TextBoxBase>와 같은 한 <xref:System.Windows.Forms.TextBox> 또는 <xref:System.Windows.Forms.TextBoxBase>합니다. 다음 인스턴스 이름을 `TextBoxBase1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.TextBoxBase.MultilineChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#247](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#247)]
 [!code-vb[System.Windows.Forms.EventExamples#247](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#247)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="OnAcceptsTabChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAcceptsTabChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAcceptsTabChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAcceptsTabChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAcceptsTabChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAcceptsTabChanged : EventArgs -&gt; unit&#xA;override this.OnAcceptsTabChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnAcceptsTabChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBorderStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBorderStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBorderStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBorderStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBorderStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBorderStyleChanged : EventArgs -&gt; unit&#xA;override this.OnBorderStyleChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnBorderStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.FontChanged" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="textBoxBase.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.HandleCreated" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="textBoxBase.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHideSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnHideSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHideSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHideSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHideSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHideSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnHideSelectionChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnHideSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raise the <see cref="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.HideSelection" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnModifiedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnModifiedChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnModifiedChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnModifiedChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnModifiedChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnModifiedChanged : EventArgs -&gt; unit&#xA;override this.OnModifiedChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnModifiedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.TextBoxBase.OnModifiedChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Modified" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberSignature Language="F#" Value="override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="textBoxBase.OnMouseUp mevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="mevent">The event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.MouseUp" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMultilineChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMultilineChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMultilineChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMultilineChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMultilineChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMultilineChanged : EventArgs -&gt; unit&#xA;override this.OnMultilineChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnMultilineChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.TextBoxBase.MultilineChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.TextBoxBase.OnMultilineChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.MultilineChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected override void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>This method is not relevant for this class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnReadOnlyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnReadOnlyChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnReadOnlyChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnReadOnlyChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnReadOnlyChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnReadOnlyChanged : EventArgs -&gt; unit&#xA;override this.OnReadOnlyChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnReadOnlyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" /> 메서드 등록 된 대리자가 이벤트를 받도록 합니다.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Control.TextChanged" /> event.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.TextBoxBase.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This property is not relevant for this class.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Padding" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is not relevant for this class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the control is redrawn. This event is not relevant for this class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Paste" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste();" />
      <MemberSignature Language="F#" Value="member this.Paste : unit -&gt; unit" Usage="textBoxBase.Paste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Replaces the current selection in the text box with the contents of the **Clipboard**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.Paste%2A> 메서드 붙여넣습니다 텍스트 컨트롤에 텍스트에 현재 저장 되어 있는 경우는 **클립보드**합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">읽을 * * 클립보드 * *입니다. 연관 된 열거형:는 <see langword="AllClipboard" /> 값 <see cref="T:System.Security.Permissions.UIPermissionClipboard" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreferredHeight">
      <MemberSignature Language="C#" Value="public int PreferredHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.PreferredHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredHeight : int" Usage="System.Windows.Forms.TextBoxBase.PreferredHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the preferred height for a text box.</summary>
        <value>입력란의 기본 설정된 높이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 되는 크기의 입력란 글꼴 높이 테두리 스타일을 기반으로 합니다. 컨트롤의 텍스트가 제대로 표시 되는지 확인 하려면 입력란의 적절 한 크기를 확인 하려면이 속성을 사용할 수 있습니다. 이 속성에서 반환 되는 값은 픽셀입니다.  
  
 값 <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> 위쪽 이나 아래쪽에 있는 텍스트를 클리핑 없이 한 줄 텍스트를 표시 하기 위해 텍스트 상자 있어야 최소 높이 나타냅니다. 이 값은 동일 여부는 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성이 `true` 또는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AutoSize" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="textBoxBase.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">A <see cref="T:System.Windows.Forms.Message" />, passed by reference that represents the window message to process.</param>
        <param name="keyData">One of the <see cref="T:System.Windows.Forms.Keys" /> values that represents the shortcut key to process.</param>
        <summary>Processes a command key.</summary>
        <returns>
          <see langword="true" /> if the command key was processed by the control; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 비관리 코드와 작동 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="textBoxBase.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">One of the <see cref="T:System.Windows.Forms.Keys" /> values that represents the key to process.</param>
        <summary>Processes a dialog key.</summary>
        <returns>
          <see langword="true" /> if the key was processed by the control; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether text in the text box is read-only.</summary>
        <value>
          <see langword="true" /> 텍스트 상자 읽기 전용인 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이로 설정 된 경우 `true`, 런타임 시 사용자가 컨트롤의 콘텐츠를 변경할 수 없습니다. 이 속성 설정 하 여 `true`, 값을 설정할 수는 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 코드에서 속성입니다. 이 기능을 사용 하 여 사용 하 여 컨트롤을 사용 하지 않도록 설정 하는 대신는 <xref:System.Windows.Forms.Control.Enabled%2A> 내용을 복사를 허용 하는 속성 및 도구 설명 표시 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnlyChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ReadOnlyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ReadOnlyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReadOnlyChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ReadOnlyChanged;" />
      <MemberSignature Language="F#" Value="member this.ReadOnlyChanged : EventHandler " Usage="member this.ReadOnlyChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the value of the <see cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" /> property has changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [NIB: 이벤트 사용](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.TextBoxBase.ReadOnlyChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면에서 상속 되는 형식의 인스턴스를 포함 하는 프로젝트에 붙여 <xref:System.Windows.Forms.TextBoxBase>와 같은 한 <xref:System.Windows.Forms.TextBox> 또는 <xref:System.Windows.Forms.TextBoxBase>합니다. 다음 인스턴스 이름을 `TextBoxBase1` 이벤트 처리기가 연결 확인 하 고는 <xref:System.Windows.Forms.TextBoxBase.ReadOnlyChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#248](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#248)]
 [!code-vb[System.Windows.Forms.EventExamples#248](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#248)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToCaret">
      <MemberSignature Language="C#" Value="public void ScrollToCaret ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToCaret() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ScrollToCaret" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToCaret ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToCaret();" />
      <MemberSignature Language="F#" Value="member this.ScrollToCaret : unit -&gt; unit" Usage="textBoxBase.ScrollToCaret " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Scrolls the contents of the control to the current caret position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 컨트롤의 표시 영역 내에서 캐럿이 컨트롤의 내용을 스크롤할 수 있습니다. 캐럿은 컨트롤의 표시 영역 아래에 배치 하는 경우는 <xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A> 캐럿 컨트롤의 아래쪽에 표시 될 때까지 메서드는 컨트롤의 내용이 스크롤됩니다. 컨트롤의 표시 영역 위에 캐럿이 캐럿 컨트롤의 위쪽에 표시 될 때까지이 메서드는 컨트롤의 내용을 스크롤합니다. 컨트롤의 표시 영역 내에 현재 텍스트 진입점 인지 확인 하는 여러 줄 텍스트 상자에이 메서드를 사용할 수 있습니다.  
  
> [!NOTE]
>  컨트롤에 포커스가 없으면 또는 컨트롤의 표시 영역에 캐럿이 이미 있는 경우 효과가 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Keys> 열거형 및 <xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A> 되는지 알아보려면 캐럿으로 표시 되는 텍스트 삽입 지점으로 항상 화면에 표시 한 후 ENTER 키를 눌렀음을 메서드. 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.TextBox> 이라는 컨트롤 `TextBox1` 및 <xref:System.Windows.Forms.RichTextBox> 이라는 컨트롤 `RichTextBox1`합니다. 이 예제에서는 이벤트 처리 메서드에와 관련 된는 <xref:System.Windows.Forms.Control.KeyDown> 이벤트입니다.  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(int start, int length);" />
      <MemberSignature Language="F#" Value="override this.Select : int * int -&gt; unit" Usage="textBoxBase.Select (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">The position of the first character in the current text selection within the text box.</param>
        <param name="length">The number of characters to select.</param>
        <summary>Selects a range of text in the text box.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤의 텍스트에서 첫 번째 문자로 시작 위치를 설정 하려는 경우 설정의 `start` 매개 변수를 0입니다. 이 메서드를 사용 하 여 예를 들어 텍스트의 부분 문자열을 선택 하는 컨트롤의 텍스트를 검색 하 고 정보를 바꾸는 합니다.  
  
> [!NOTE]
>  설정 하 여 입력란 내에서 캐럿을 프로그래밍 방식으로 이동할 수는 `start` 캐럿을 이동 하 고 설정을 텍스트 상자 내에서 위치 매개 변수는 `length` 매개 변수 값을 영 (0). 캐럿을 이동 하려면 텍스트 상자에 포커스가 있어야 합니다.  
  
> [!NOTE]
>  이 메서드가 매개 변수 없이 호출 되는 다른 방법을 사용 됩니다. 상속 되는 대체 방법을 <xref:System.Windows.Forms.Control> 클래스입니다. 호출 컨트롤에 입력된 포커스를 설정 하 고 컨트롤의 내용을 선택 합니다. 자세한 내용은 <xref:System.Windows.Forms.Control.Select%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 "fox" 라는 단어의 인스턴스에 대 한 컨트롤의 내용을 검색 합니다. 하는 경우 발견 된 코드에서 단어를 선택 사용 하 여 컨트롤의 <xref:System.Windows.Forms.TextBoxBase.Select%2A> 메서드. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 `textBox1` 만든 및 해당 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 속성 "무궁화 꽃이 활짝 이동 합니다." 이라는 문장이 포함  
  
 [!code-cpp[Classic TextBoxBase.Select Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Select Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of the <paramref name="start" /> parameter is less than zero.</exception>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.SelectAll" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public void SelectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.SelectAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectAll();" />
      <MemberSignature Language="F#" Value="member this.SelectAll : unit -&gt; unit" Usage="textBoxBase.SelectAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Selects all text in the text box.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 컨트롤 내에서 모든 텍스트를 선택 합니다. 이 메서드를 사용 하 여 함께에서 <xref:System.Windows.Forms.TextBoxBase.Cut%2A> 텍스트를 컨트롤의 전체 내용을 잘라내고 붙여 넣으면 컨트롤에서 선택할 수를 시켜야 하는 방법의 **클립보드**합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 컨트롤에서 모든 텍스트를 선택한 경우를 확인 하려면 클래스를 파생 합니다. 호출 된 선택한 텍스트가 없는 경우는 <xref:System.Windows.Forms.TextBoxBase.SelectAll%2A> 컨트롤의 콘텐츠를 복사 하기 전에 메서드는 **클립보드**합니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 만든 명명 된 `textBox1`합니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public virtual string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.TextBoxBase.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating the currently selected text in the control.</summary>
        <value>텍스트 상자에서 현재 선택한 텍스트를 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 텍스트 상자에서 현재 선택한 텍스트를 변경 하려면이 속성에 텍스트를 할당할 수 있습니다. 텍스트 상자에 텍스트가 현재 선택이 속성에 길이가 0 인 문자열을 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public virtual int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.TextBoxBase.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of characters selected in the text box.</summary>
        <value>텍스트 상자에서 선택 된 문자의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 모든 문자에서에서 현재 선택 된 텍스트 상자 컨트롤에는 선택한 텍스트에 대 한 작업을 수행 하기 전에 확인 하려면이 속성을 사용할 수 있습니다. 때의 값은 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성의 값이 컨트롤의 텍스트 내에서 문자 수보다 큰 값으로 설정 되어는 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 는 변수의값을뺀컨트롤내의텍스트의전체길이속성은<xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A>속성 (모든 값을 지정 하는 경우는 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 속성).  
  
> [!NOTE]
>  설정 하 여 입력란 내에서 캐럿을 프로그래밍 방식으로 이동할 수는 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 캐럿을 이동 하 고 설정을 텍스트 상자 내에서 위치에는 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성을 같은 영 (0)의 값입니다. 캐럿을 이동 하려면 텍스트 상자에 포커스가 있어야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The assigned value is less than zero.</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionStart">
      <MemberSignature Language="C#" Value="public int SelectionStart { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionStart As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionStart { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionStart : int with get, set" Usage="System.Windows.Forms.TextBoxBase.SelectionStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the starting point of text selected in the text box.</summary>
        <value>텍스트 상자에서 선택한 텍스트의 시작 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에서 선택한 텍스트가 없는 경우이 속성의 삽입 지점 또는 캐럿 새 텍스트를 나타냅니다. 컨트롤에서 텍스트의 길이 초과 위치에이 속성을 설정 하는 경우 선택 시작 위치 마지막 문자 뒤에 놓입니다. 이 속성을 변경의 값을 줄이려면 수 텍스트가 텍스트 상자 컨트롤에서 선택 하는 경우는 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성입니다. 컨트롤 위치 뒤에 나머지 텍스트를 가리키는 경우는 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 속성의 값 보다 작으면는 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성 값는 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성은 자동으로 감소 합니다. 값은 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 속성 증가 생성 하지 않습니다는 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성입니다.  
  
 설정 하 여 입력란 내에서 선택 영역을 프로그래밍 방식으로 이동할 수는 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 및 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성입니다.  
  
 설정 하 여 입력란 내에서 캐럿을 프로그래밍 방식으로 이동할 수는 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 캐럿을 이동 하 고 설정을 텍스트 상자 내에서 위치에는 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 속성을 같은 영 (0)의 값입니다.  
  
 <xref:System.Windows.Forms.TextBox> 선택 영역 또는 캐럿을 이동할 수 있도록 포커스가 있어야 합니다. 설정할 수 있습니다는 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 속성은 <xref:System.Windows.Forms.TextBox> 즉 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 지정 하 여는 <xref:System.Windows.Forms.Control.Focus%2A> 첫 번째입니다.  
  
   
  
## Examples  
 **예 1**  
  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 **예제 2**  
  
 다음 예에서는 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 속성은 <xref:System.Windows.Forms.TextBox> 즉 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 지정 하 여는 <xref:System.Windows.Forms.Control.Focus%2A> 첫 번째입니다.  
  
 [!code-csharp[SystemWindowsFormsTextBoxBase#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemWindowsFormsTextBoxBase/CS/Form1.cs#1)]
 [!code-vb[SystemWindowsFormsTextBoxBase#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemWindowsFormsTextBoxBase/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The assigned value is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="textBoxBase.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">The new <see cref="P:System.Windows.Forms.Control.Left" /> property value of the control.</param>
        <param name="y">The new <see cref="P:System.Windows.Forms.Control.Top" /> property value of the control.</param>
        <param name="width">The new <see cref="P:System.Windows.Forms.Control.Width" /> property value of the control.</param>
        <param name="height">Not used.</param>
        <param name="specified">A bitwise combination of the <see cref="T:System.Windows.Forms.BoundsSpecified" /> values.</param>
        <summary>Sets the specified bounds of the <see cref="T:System.Windows.Forms.TextBoxBase" /> control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase> 컨트롤이 사용 하는 <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> 속성 범위를 설정 하는 경우는 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 속성은 `true` 및 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성은 `false`합니다.  
  
 에 포함 되지 범위에 해당 하는 매개 변수 일반적으로 `specified` 매개 변수는 현재 값과 함께 전달 됩니다. 예를 들어는 <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A>, 또는 <xref:System.Drawing.Point.X%2A> 또는 <xref:System.Drawing.Point.Y%2A> 의 속성은 <xref:System.Windows.Forms.Control.Location%2A> 속성 컨트롤의 현재 인스턴스에 대 한 참조를 사용 하 여 전달 될 수 있습니다. 그러나에 전달 된 모든 값 유지 하 고 컨트롤에 적용 됩니다.  
  
 `specified` 매개 변수는 컨트롤의 요소를 나타냅니다 <xref:System.Windows.Forms.Control.Bounds%2A> 응용 프로그램에 의해 변경 합니다. 예를 들어, 변경 하는 경우는 <xref:System.Windows.Forms.Control.Size%2A> 컨트롤의는 `specified` 매개 변수 값이는 `Size` 값 <xref:System.Windows.Forms.BoundsSpecified>합니다. 그러나 경우는 <xref:System.Windows.Forms.Control.Size%2A> 대 한 응답으로 조정 되는 <xref:System.Windows.Forms.Control.Dock%2A> 속성이 설정 되 고는 `specified` 매개 변수 값이는 `None` 값 <xref:System.Windows.Forms.BoundsSpecified>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 메서드를 변경 하려면 컨트롤의 범위입니다. 파생된 클래스에는 크기 제한을 추가할 수는 <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ShortcutsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool ShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.ShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the defined shortcuts are enabled.</summary>
        <value>
          <see langword="true" /> 에서 바로 가기 키를 사용 하도록 설정 하려면 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Forms.TextBoxBase.ShortcutsEnabled%2A> 속성을 사용 하도록 설정 하거나 다음과 같은 바로 가기 키 조합 및 컨트롤의 바로 가기 메뉴를 사용 하지 않도록 설정 합니다.  
  
-   Ctrl+Z  
  
-   Ctrl+E  
  
-   Ctrl+C  
  
-   Ctrl+Y  
  
-   Ctrl+X  
  
-   Ctrl+백스페이스  
  
-   Ctrl+V  
  
-   Ctrl+Delete  
  
-   Ctrl+A  
  
-   SHIFT + DELETE  
  
-   Ctrl+L  
  
-   SHIFT + INSERT  
  
-   Ctrl+R  
  
 다른 바로 가기 키를 지정 하려면이 속성을 재정의할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.TextBoxBase.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current text in the text box.</summary>
        <value>컨트롤에 표시된 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 텍스트 상자에 여러 줄의 텍스트를 표시 하려면 설정는 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성을 `true`합니다. 읽거나 설정 텍스트 여러 줄 텍스트 상자를 사용 하 여는 <xref:System.Windows.Forms.TextBoxBase.Lines%2A> 속성입니다. 에 입력할 수 있는 텍스트의 크기는 <xref:System.Windows.Forms.RichTextBox> 컨트롤 사용 가능한 시스템 메모리에 의해서만 제한 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 여러 줄을 만들려는 <xref:System.Windows.Forms.TextBox> 세로 스크롤 막대가 있는 컨트롤입니다. 또한이 예제에서는 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 및 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성을 여러 줄 텍스트 상자 컨트롤을 텍스트 문서를 만드는 데 유용 합니다.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public virtual int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.TextBoxBase.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of text in the control.</summary>
        <value>컨트롤의 텍스트에 포함된 문자의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자의 총 수를 알 필요는 특정 컨트롤의 텍스트 내에서 텍스트 문자열에 대 한 검색 등과 같은 작업에 대 한 문자열의 문자 수를 확인 하려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.TextBoxBase.AppendText%2A> 메서드 및 <xref:System.Windows.Forms.TextBoxBase.TextLength%2A> 하나에서 텍스트를 복사 하려면 속성 <xref:System.Windows.Forms.TextBox> 다른 합니다. 이 예제를 실행 하려면 <xref:System.Windows.Forms.TextBox> 명명 된 인스턴스인지 컨트롤 `textBox1` 및 `textBox2`, 폼에 추가 된 `textBox1` 에 할당 된 텍스트에 해당 <xref:System.Windows.Forms.Control.Text%2A> 속성입니다.  
  
 [!code-cpp[TextBoxBase.AppendText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TextBoxBase.AppendText/CPP/form1.cpp#1)]
 [!code-csharp[TextBoxBase.AppendText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TextBoxBase.AppendText/CS/form1.cs#1)]
 [!code-vb[TextBoxBase.AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TextBoxBase.AppendText/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="textBoxBase.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string that represents the <see cref="T:System.Windows.Forms.TextBoxBase" /> control.</summary>
        <returns>A string that represents the current <see cref="T:System.Windows.Forms.TextBoxBase" />. The string includes the type and the <see cref="T:System.Windows.Forms.TextBoxBase" /> property of the control.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Undo">
      <MemberSignature Language="C#" Value="public void Undo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Undo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Undo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Undo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Undo();" />
      <MemberSignature Language="F#" Value="member this.Undo : unit -&gt; unit" Usage="textBoxBase.Undo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Undoes the last edit operation in the text box.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 마지막 실행 취소 됩니다 **클립보드** 또는 텍스트 변경 하는 경우 텍스트 상자 컨트롤에서 수행 하는 작업은 <xref:System.Windows.Forms.TextBoxBase.CanUndo%2A> 속성에서 반환 `true`합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBoxBase.Undo%2A> 메서드는 사용 하지는 <xref:System.Windows.Forms.Control.KeyPress> 또는 <xref:System.Windows.Forms.Control.TextChanged> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 즉 클래스를 파생 합니다. 제공 <xref:System.Windows.Forms.MenuItem.Click> 에 대 한 이벤트 처리기 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사, 붙여넣기 및 실행 취소 작업을 수행 하는 개체입니다. 이 예제에서는 한 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1` 만들어졌습니다.  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="textBoxBase.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">The Windows <see cref="T:System.Windows.Forms.Message" /> to process.</param>
        <summary>Processes Windows messages.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="WordWrap">
      <MemberSignature Language="C#" Value="public bool WordWrap { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WordWrap" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.WordWrap" />
      <MemberSignature Language="VB.NET" Value="Public Property WordWrap As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WordWrap { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WordWrap : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.WordWrap" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether a multiline text box control automatically wraps words to the beginning of the next line when necessary.</summary>
        <value>
          <see langword="true" /> 여러 줄 텍스트 상자 컨트롤에는 단어; 래핑하는 경우 <see langword="false" /> 경우 텍스트 상자 컨트롤에는 자동으로 컨트롤을 가로로 스크롤합니다 컨트롤의 오른쪽 가장자리 지난 충분할 때. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 `true`에 관계 없이 가로 스크롤 막대가 표시 되지 않으면는 <xref:System.Windows.Forms.TextBox.ScrollBars%2A> 속성을 설정 합니다.  
  
> [!NOTE]
>  파생된 클래스에서 <xref:System.Windows.Forms.TextBox>, 컨트롤 내의 텍스트는 항상 줄 바꿈이 적용이 속성의 속성 설정에 관계 없이 <xref:System.Windows.Forms.TextBox.TextAlign%2A> 속성이 `HorizontalAlignment.Left`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.TextBox>, 파생 클래스를 여러 줄을 만들려는 <xref:System.Windows.Forms.TextBox> 세로 스크롤 막대가 있는 컨트롤입니다. 또한이 예제에서는 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 및 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성을 여러 줄 텍스트 상자 컨트롤을 텍스트 문서를 만드는 데 유용 합니다.  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>