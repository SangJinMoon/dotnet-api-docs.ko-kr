<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="bb7d9-101">LINQ to SQL 프레임워크의 주 진입점을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-101">Represents the main entry point for the LINQ to SQL framework.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-102"><xref:System.Data.Linq.DataContext> 매핑된 데이터베이스 연결을 통해 모든 엔터티의의 원본인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-102">The <xref:System.Data.Linq.DataContext> is the source of all entities mapped over a database connection.</span></span> <span data-ttu-id="bb7d9-103">검색 된 모든 엔터티에 대 한 변경 내용을 추적 하 고 여러 번 검색 된 엔터티 보증으로 표현 되는 "id 캐시" 유지 관리 동일한 개체 인스턴스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-103">It tracks changes that you made to all retrieved entities and maintains an "identity cache" that guarantees that entities retrieved more than one time are represented by using the same object instance.</span></span>  
  
 <span data-ttu-id="bb7d9-104">그러나 일반적으로 <xref:System.Data.Linq.DataContext> 인스턴스는 하나의 "작업 단위"에 대 한 마지막 응용 프로그램에서 해당 용어를 정의 하는 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-104">In general, a <xref:System.Data.Linq.DataContext> instance is designed to last for one "unit of work" however your application defines that term.</span></span> <span data-ttu-id="bb7d9-105">A <xref:System.Data.Linq.DataContext> 간단 하며 만들려면 비용이 많이 들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-105">A <xref:System.Data.Linq.DataContext> is lightweight and is not expensive to create.</span></span> <span data-ttu-id="bb7d9-106">일반적인 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 응용 프로그램이 만드는 <xref:System.Data.Linq.DataContext> 메서드 범위에서 또는의 논리 집합을 나타내는 수명이 짧은 클래스의 멤버로 인스턴스 관련 데이터베이스 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-106">A typical [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] application creates <xref:System.Data.Linq.DataContext> instances at method scope or as a member of short-lived classes that represent a logical set of related database operations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bb7d9-107"><see cref="T:System.Data.Linq.DataContext" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-107">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class.</span></span> <span data-ttu-id="bb7d9-108">사용하는 연결 문자열은 ADO.NET 연결 문자열일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-108">The connection string you use can be an ADO.NET connection string.</span></span> <span data-ttu-id="bb7d9-109">또한 파일 이름을 SQL Server Express 또는 SQL Server Compact 파일로 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-109">You can also specify a filename to a SQL Server Express or SQL Server Compact file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection"><span data-ttu-id="bb7d9-110">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]에서 사용하는 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-110">The connection used by the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span></param>
        <summary><span data-ttu-id="bb7d9-111">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]에서 사용하는 연결을 참조하여 <see cref="T:System.Data.Linq.DataContext" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-111">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing the connection used by the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-112">A <xref:System.Data.Linq.DataContext> 열고 닫힌된 연결 또는 연결 문자열을 제공 하는 경우 필요에 따라 데이터베이스 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-112">A <xref:System.Data.Linq.DataContext> opens and closes a database connection as needed if you provide a closed connection or a connection string.</span></span> <span data-ttu-id="bb7d9-113">일반적으로 필요는 호출할 `Dispose` 에 <xref:System.Data.Linq.DataContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-113">In general, you should never have to call `Dispose` on a <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="bb7d9-114">열려 있는 연결을 제공 하는 경우는 <xref:System.Data.Linq.DataContext> 닫히지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-114">If you provide an open connection, the <xref:System.Data.Linq.DataContext> will not close it.</span></span> <span data-ttu-id="bb7d9-115">따라서 인스턴스화할 수 없습니다는 <xref:System.Data.Linq.DataContext> 열린 연결으로이 작업을 수행 하는 좋은 이유가 없으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-115">Therefore, do not instantiate a <xref:System.Data.Linq.DataContext> with an open connection unless you have a good reason to do this.</span></span> <span data-ttu-id="bb7d9-116">에 <xref:System.Transactions> 트랜잭션에 <xref:System.Data.Linq.DataContext> 열거나 승격이 발생 하지 않도록 하는 연결을 닫이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-116">In a <xref:System.Transactions> transaction, a <xref:System.Data.Linq.DataContext> will not open or close a connection to avoid promotion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection"><span data-ttu-id="bb7d9-117">.NET Framework에서 사용하는 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-117">The connection used by the .NET Framework.</span></span></param>
        <param name="mapping"><span data-ttu-id="bb7d9-118">매핑할 원본입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-118">A source for mapping.</span></span></param>
        <summary><span data-ttu-id="bb7d9-119">연결 및 매핑 소스를 참조하여 <see cref="T:System.Data.Linq.DataContext" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-119">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing a connection and a mapping source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection"><span data-ttu-id="bb7d9-120">이 인수로 다음 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-120">This argument can be any one of the following:</span></span>  
  
 <span data-ttu-id="bb7d9-121">SQL Server Express 데이터베이스가 있는 파일의 이름</span><span class="sxs-lookup"><span data-stu-id="bb7d9-121">The name of a file where a SQL Server Express database resides.</span></span>  
  
 <span data-ttu-id="bb7d9-122">데이터베이스가 있는 서버의 이름.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-122">The name of a server where a database is present.</span></span> <span data-ttu-id="bb7d9-123">이 경우 공급자는 사용자의 기본 데이터베이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-123">In this case the provider uses the default database for a user.</span></span>  
  
 <span data-ttu-id="bb7d9-124">전체 연결 문자열.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-124">A complete connection string.</span></span> [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]<span data-ttu-id="bb7d9-125">에서는 문자열을 수정하지 않고 공급자에 그대로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-125"> just passes the string to the provider without modification.</span></span></param>
        <param name="mapping"><span data-ttu-id="bb7d9-126">매핑할 원본입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-126">A source for mapping.</span></span></param>
        <summary><span data-ttu-id="bb7d9-127">파일 소스 및 매핑 소스를 참조하여 <see cref="T:System.Data.Linq.DataContext" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-127">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing a file source and a mapping source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">To be added.</param>
        <param name="connectionString">To be added.</param>
        <summary><span data-ttu-id="bb7d9-128">파일 소스를 참조하여 <see cref="T:System.Data.Linq.DataContext" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-128">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing a file source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-129"><see cref="M:System.Data.Linq.DataContext.SubmitChanges" />를 호출했을 때 동시성 충돌이 발생한 개체의 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-129">Gets a collection of objects that caused concurrency conflicts when <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> was called.</span></span></summary>
        <value><span data-ttu-id="bb7d9-130">동시성 충돌이 발생한 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-130">A collection of objects that caused concurrency conflicts.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-131">다음 예제에서는 어떻게 컬렉션을 반복 하 충돌 정보 검색을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-131">The following example shows how the collection can be iterated over to retrieve conflict information.</span></span>  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-132">기본 제한 시간을 적용하면 시간이 초과될 수 있는 쿼리에 대한 제한 시간을 늘리는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-132">Gets or sets a value that increases the time-out period for queries that would otherwise time out during the default time-out period.</span></span></summary>
        <value><span data-ttu-id="bb7d9-133">기본 제한 시간을 적용하면 시간이 초과될 수 있는 쿼리에 대한 제한 시간을 늘리는 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-133">An integer value that increases the time-out period for queries that would otherwise time out during the default time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-134">이 속성 생성된 명령을 실행 하는 데 사용 하는 명령 제한 시간을 가져오거나 설정 합니다. (`IDbCommands`).</span><span class="sxs-lookup"><span data-stu-id="bb7d9-134">This property gets or sets the command time-out used to execute generated commands (`IDbCommands`).</span></span> <span data-ttu-id="bb7d9-135">자세한 내용은 <xref:System.Data.IDbCommand.CommandTimeout%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-135">For more information, see <xref:System.Data.IDbCommand.CommandTimeout%2A>.</span></span>  
  
 <span data-ttu-id="bb7d9-136">이 속성이 설정 되지 않은 경우, 기본값인 <xref:System.Data.IDbCommand.CommandTimeout%2A> 쿼리 명령 실행에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-136">When this property is not set, the default value of <xref:System.Data.IDbCommand.CommandTimeout%2A> is used for query command execution.</span></span> <span data-ttu-id="bb7d9-137">기본 값이 저장소 공급자가 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-137">This default value is set by the storage provider.</span></span> <span data-ttu-id="bb7d9-138">이 값은 0이 아닌 값으로 설정 하는 경우 일부 공급자가 예외를 throw 할 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-138">Note that some providers may throw exceptions if this value is set to a non-zero value.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-139">프레임워크에서 사용하는 연결을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-139">Gets the connection used by the framework.</span></span></summary>
        <value><span data-ttu-id="bb7d9-140">프레임워크에서 사용하는 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-140">The connection used by the framework.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-141">관계형 ADO.NET 코드와 상호 운용 하도록이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-141">You can use this property to interoperate with relational ADO.NET code.</span></span>  
  
 <span data-ttu-id="bb7d9-142">사용자가 명시적으로 열 렸 경우가 아니면 반환 된 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-142">The returned connection will be closed unless it has been explicitly opened by the user.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bb7d9-143">서버에 데이터베이스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-143">Creates a database on the server.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-144">데이터베이스의 이름은 다음과 같은 알고리즘을 사용 하 여 파생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-144">The name of the database is derived by using the following algorithm:</span></span>  
  
-   <span data-ttu-id="bb7d9-145">데이터베이스 연결 문자열에 식별 되 면 해당 이름이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-145">If a database is identified in the connection string, its name is used.</span></span>  
  
-   <span data-ttu-id="bb7d9-146">경우는 <xref:System.Data.Linq.Mapping.DatabaseAttribute> 특성이 있으면 해당 <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> 속성은 데이터베이스의 이름으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-146">If a <xref:System.Data.Linq.Mapping.DatabaseAttribute> attribute is present, its <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> property is used as the name of the database.</span></span>  
  
-   <span data-ttu-id="bb7d9-147">연결 문자열 및 강력한 형식의 데이터베이스 태그가 없는 경우 <xref:System.Data.Linq.DataContext> 사용 하는 경우와 동일한 이름을 가진 데이터베이스는 <xref:System.Data.Linq.DataContext> 클래스 상속을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-147">If there is no database tag in the connection string and a strongly typed <xref:System.Data.Linq.DataContext> is used, a database that has the same name as the <xref:System.Data.Linq.DataContext> inheriting class is checked.</span></span>  
  
-   <span data-ttu-id="bb7d9-148">약한 형식화 경우 <xref:System.Data.Linq.DataContext> 는 사용 하는 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-148">If a weakly typed <xref:System.Data.Linq.DataContext> is used, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="bb7d9-149">경우는 <xref:System.Data.Linq.DataContext> 만든 파일 이름을 사용 하 여 해당 파일 이름에 해당 데이터베이스가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-149">If the <xref:System.Data.Linq.DataContext> has been created by using a file name, the database corresponding to that file name is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb7d9-150">다음 코드에는 임시 데이터베이스를 설정 하 고 제거 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-150">The following code shows how to set up a temporary database and then remove it.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="bb7d9-151">반환되는 컬렉션에 있는 요소의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-151">The type of the elements in the returned collection.</span></span></typeparam>
        <param name="instance"><span data-ttu-id="bb7d9-152">메서드 호출의 인스턴스(현재 개체)입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-152">The instance of the method invocation (the current object).</span></span></param>
        <param name="methodInfo"><span data-ttu-id="bb7d9-153">데이터베이스 메서드에 해당하는 CLR 메서드를 식별하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-153">The <see cref="T:System.Reflection.MethodInfo" /> that identifies the CLR method that corresponds to a database method.</span></span></param>
        <param name="parameters"><span data-ttu-id="bb7d9-154">명령에 전달할 매개 변수 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-154">The array of parameters to be passed to the command.</span></span></param>
        <summary><span data-ttu-id="bb7d9-155">지정된 CLR 메서드에 연결된 테이블 반환 데이터베이스 함수를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-155">Executes the table-valued database function associated with the specified CLR method.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-156">데이터베이스 쿼리에서 반환된 결과 값의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-156">A collection of resultant values returned by the database query.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-157"><xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> 메서드 자동으로 생성 된 코드에 사용 되 고 데이터베이스 함수에 대 한 프록시 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-157">The <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> method is used in automatically generated code and acts as a proxy to database functions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bb7d9-158">관련 데이터베이스를 열 수 있는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-158">Determines whether the associated database can be opened.</span></span></summary>
        <returns>
          <span data-ttu-id="bb7d9-159">지정된 데이터베이스를 열 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-159"><see langword="true" /> if the specified database can be opened; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-160">연결을 사용 하 여이 메서드는 <xref:System.Data.Linq.DataContext.Connection%2A> 속성을 연결된 된 데이터베이스를 열려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-160">This method uses the connection in the <xref:System.Data.Linq.DataContext.Connection%2A> property to attempt to open the associated database.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb7d9-161">다음 예제에서는이 메서드를 사용 하 여 데이터베이스가 이미 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-161">The following example uses this method to determine whether a database already exists.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-162">일대다 또는 일대일 관계를 지연 로드하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-162">Gets or sets a value that indicates whether to delay-load one-to-many or one-to-one relationships.</span></span></summary>
        <value>
          <span data-ttu-id="bb7d9-163">지연된 로드가 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-163"><see langword="true" /> if deferred loading is enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-164">코드 null 이러한 관계 중 하나에 액세스할 때 관계는 한 일, 다를 경우에 빈 컬렉션이 반환 됩니다 하는 경우 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-164">When the code accesses one of these relationships, null is returned if the relationship is one-to-one, and an empty collection is returned if it is one-to-many.</span></span> <span data-ttu-id="bb7d9-165">관계 여전히 설정 하 여 채울 수는 <xref:System.Data.Linq.DataContext.LoadOptions%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-165">The relationships can still be filled by setting the <xref:System.Data.Linq.DataContext.LoadOptions%2A> property.</span></span>  
  
 <span data-ttu-id="bb7d9-166">이 속성에 대 한 주요 시나리오는 개체 모델의 일부를 추출 하 고 (예를 들어 웹 서비스)에 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-166">The main scenario for this property is to enable you to extract a piece of the object model and send it out (for example, to a Web service).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bb7d9-167">이 속성은로 설정 하는 경우 `false` 쿼리 실행 된 후 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-167">If this property is set to `false` after a query has been executed, an exception is thrown.</span></span> <span data-ttu-id="bb7d9-168">참조는 **유효한 모드** 자세한 내용은 아래 섹션.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-168">See the **Valid Modes** section below for more information.</span></span>  
  
## <a name="valid-modes"></a><span data-ttu-id="bb7d9-169">사용할 수 있는 모드</span><span class="sxs-lookup"><span data-stu-id="bb7d9-169">Valid modes</span></span>  
 <span data-ttu-id="bb7d9-170">지연 된 로드 개체 추적이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-170">Deferred loading requires object tracking.</span></span> <span data-ttu-id="bb7d9-171">다음 세 가지 모드에만 적용 하는 유효한은 같습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-171">Only the following three modes are valid:</span></span>  
  
-   <span data-ttu-id="bb7d9-172"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-172"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`.</span></span> <span data-ttu-id="bb7d9-173"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 무시 되 고 것으로 유추 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-173"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> is ignored and inferred to be `false`.</span></span> <span data-ttu-id="bb7d9-174">이 문제는 읽기 전용에 해당 <xref:System.Data.Linq.DataContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-174">This behavior corresponds to a read-only <xref:System.Data.Linq.DataContext>.</span></span>  
  
-   <span data-ttu-id="bb7d9-175"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-175"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`.</span></span> <span data-ttu-id="bb7d9-176"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-176"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`.</span></span> <span data-ttu-id="bb7d9-177">이 경우에 해당 하는 <xref:System.Data.Linq.DataContext> 를 사용 하 여 개체 그래프를 로드, 사용자가 허용 <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> 지시문 하지만 지연 된 로드를 사용 하지 않는 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-177">This situation corresponds to a <xref:System.Data.Linq.DataContext> that allows users to load an object graph by using <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> directives, but it does not enable deferred loading.</span></span>  
  
-   <span data-ttu-id="bb7d9-178">둘 다로 설정 된 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-178">Both are set to `true`.</span></span> <span data-ttu-id="bb7d9-179">이 값이 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-179">This is the default.</span></span>  
  
 <span data-ttu-id="bb7d9-180">쿼리를 실행 한 후 플래그를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-180">The flags may not be changed after a query has been executed.</span></span> <span data-ttu-id="bb7d9-181">사용 하는 첫 번째 쿼리를 실행 한 후 모든 변경 <xref:System.Data.Linq.DataContext> 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-181">Any change after the execution of the first query that uses that <xref:System.Data.Linq.DataContext> throws an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bb7d9-182">관련 데이터베이스를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-182">Deletes the associated database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-183">연결을 사용 하 여이 메서드는 <xref:System.Data.Linq.DataContext.Connection%2A> 속성을 삭제할 데이터베이스를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-183">This method uses the connection in the <xref:System.Data.Linq.DataContext.Connection%2A> property to identify the database to be deleted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb7d9-184">다음 예제에서는 일시적으로 작성 된 데이터베이스를 삭제 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-184">The following example shows how to delete a database that has been temporarily created.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bb7d9-185"><see cref="T:System.Data.Linq.DataContext" /> 클래스에서 사용하는 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-185">Releases the resources used by the <see cref="T:System.Data.Linq.DataContext" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bb7d9-186"><see cref="T:System.Data.Linq.DataContext" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-186">Releases all resources used by the current instance of the <see cref="T:System.Data.Linq.DataContext" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="bb7d9-187">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-187"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="bb7d9-188"><see cref="T:System.Data.Linq.DataContext" /> 클래스에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-188">Releases the unmanaged resources used by the <see cref="T:System.Data.Linq.DataContext" /> class and optionally releases the managed resource.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command"><span data-ttu-id="bb7d9-189">실행할 SQL 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-189">The SQL command to be executed.</span></span></param>
        <param name="parameters"><span data-ttu-id="bb7d9-190">명령에 전달할 매개 변수 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-190">The array of parameters to be passed to the command.</span></span> <span data-ttu-id="bb7d9-191">다음 동작에 유의하십시오.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-191">Note the following behavior:</span></span>  
  
 <span data-ttu-id="bb7d9-192">배열의 개체 수가 명령 문자열에 지정된 최대 개수보다 작으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-192">If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</span></span>  
  
 <span data-ttu-id="bb7d9-193">명령 문자열에서 참조되지 않은 개체가 배열에 있는 경우에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-193">If the array contains objects that are not referenced in the command string, no exception is thrown.</span></span>  
  
 <span data-ttu-id="bb7d9-194">null인 매개 변수는 <see langword="DBNull.Value" />로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-194">If any one of the parameters is null, it is converted to <see langword="DBNull.Value" />.</span></span></param>
        <summary><span data-ttu-id="bb7d9-195">데이터베이스에 대해 직접 SQL 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-195">Executes SQL commands directly on the database.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-196">명령을 실행하여 수정된 행 수입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-196">The number of rows modified by the executed command.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-197">이 메서드는 사례에 대 한 통과 메커니즘 여기서 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 특정 시나리오에 적절 하 게 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-197">This method is a pass-through mechanism for cases where [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] does not adequately provide for a particular scenario.</span></span>  
  
 <span data-ttu-id="bb7d9-198">명령에 대 한 구문은 구문을 사용 하는 ADO.NET 만들어와 거의 동일 `DataCommand`합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-198">The syntax for the command is almost the same as the syntax used to create an ADO.NET `DataCommand`.</span></span> <span data-ttu-id="bb7d9-199">유일한 차이점은 매개 변수를 지정 하는 방법을입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-199">The only difference is in how the parameters are specified.</span></span> <span data-ttu-id="bb7d9-200">중괄호 ({...})로 묶어 매개 변수를 지정 하 고 열거 하는 구체적으로, 0에서 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-200">Specifically, you specify parameters by enclosing them in braces ({…}) and enumerate them starting from 0.</span></span> <span data-ttu-id="bb7d9-201">매개 변수는 매개 변수 배열에 있는 동일 하 게 번호가 매겨진된 개체와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-201">The parameter is associated with the equally numbered object in the parameters array.</span></span>  
  
 <span data-ttu-id="bb7d9-202">`ExecuteQuery` 및 `ExecuteCommand` 가변 개수의 매개 변수 대체에 대 한 인수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-202">`ExecuteQuery` and `ExecuteCommand` allow you to specify a variable number of arguments for parameter substitution.</span></span> <span data-ttu-id="bb7d9-203">예를 들어 ExecuteQuery를 호출할 때 매개 변수에 지정할 수 있습니다\<TResult >:</span><span class="sxs-lookup"><span data-stu-id="bb7d9-203">For example, you can specify the parameters when invoking ExecuteQuery\<TResult>:</span></span>  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 <span data-ttu-id="bb7d9-204">그리고 또 다른 예.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-204">And, another example:</span></span>  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 <span data-ttu-id="bb7d9-205">다음 예제에서는 연결을 열고 전달 SQL `UPDATE` SQL 엔진에 명령 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-205">The following example opens a connection and passes a SQL `UPDATE` command to the SQL engine.</span></span>  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity"><span data-ttu-id="bb7d9-206">삭제할 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-206">The entity to be deleted.</span></span></param>
        <summary><span data-ttu-id="bb7d9-207">삭제 재정의 메서드 내에서 삭제 작업을 위한 동적 SQL을 생성하여 실행하는 작업을 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]에 다시 위임할 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-207">Executes, inside delete override methods, to redelegate to [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] the task of generating and executing dynamic SQL for delete operations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-208"><xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-208">See <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity"><span data-ttu-id="bb7d9-209">삽입할 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-209">The entity to be inserted.</span></span></param>
        <summary><span data-ttu-id="bb7d9-210">삽입 재정의 메서드 내에서 삽입 작업을 위한 동적 SQL을 생성하여 실행하는 작업을 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]에 다시 위임할 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-210">Executes, inside insert override methods, to redelegate to [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] the task of generating and executing dynamic SQL for insert operations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-211">다음 사항을 note:</span><span class="sxs-lookup"><span data-stu-id="bb7d9-211">Note the following considerations:</span></span>  
  
-   <span data-ttu-id="bb7d9-212">서브클래싱 해야 사용할 메서드가 보호 된 한정자가 있으므로 <xref:System.Data.Linq.DataContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-212">Because the method has a protected modifier, its use requires subclassing <xref:System.Data.Linq.DataContext>.</span></span>  
  
-   <span data-ttu-id="bb7d9-213">이 작업 내 호출 하지 않은 경우 예외가 throw 되는 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-213">An exception is thrown if this operation is not called inside a <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operation.</span></span> <span data-ttu-id="bb7d9-214">범위 밖에 서 독립 실행형 작업으로 호출에 적합 하지 않습니다는 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-214">It is not intended to be called as a stand-alone operation outside the scope of a <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operation.</span></span> <span data-ttu-id="bb7d9-215"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> 자체 호출 메서드를 재정의 구현 하 고 이전 메서드를 재정의 메서드 호출 하도록 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-215"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> itself calls override methods if they are implemented and the previous methods are intended to be called inside the override methods.</span></span>  
  
-   <span data-ttu-id="bb7d9-216">것은 올바른 엔터티를 전달 하는 개발자의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-216">It is the responsibility of the developer to pass in the correct entity.</span></span> <span data-ttu-id="bb7d9-217">구현에 전달 된 엔터티를 추적 하는 것을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-217">The implementation verifies that the passed-in entity is tracked.</span></span> <span data-ttu-id="bb7d9-218">그러나 되기 순서 유지 관리 또는 두 번 동일한 엔터티를 전달 하는 개발자의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-218">However, it is the responsibility of the developer to maintain the order or pass in the same entity two times.</span></span>  
  
-   <span data-ttu-id="bb7d9-219">것은 올바른 동적 API를 호출 하는 개발자의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-219">It is the responsibility of the developer to invoke the correct dynamic API.</span></span> <span data-ttu-id="bb7d9-220">예를 들어는 `Update` 재정의 메서드에서 <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-220">For example, in the `Update` override method, only the <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> method can be called.</span></span> [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]<span data-ttu-id="bb7d9-221">에서는 호출된 동적 메서드가 적용 가능한 작업과 일치하는지 여부를 감지하거나 확인하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-221"> does not detect or verify whether the invoked dynamic method matches the applicable operation.</span></span> <span data-ttu-id="bb7d9-222">적용할 수 없는 메서드를 호출 하면 결과가 정의 되지 않습니다 (예를 들어 호출 <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> 업데이트할 개체에 대 한).</span><span class="sxs-lookup"><span data-stu-id="bb7d9-222">The results are undefined if an inapplicable method is called (for example, calling <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> for an object to be updated).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity"><span data-ttu-id="bb7d9-223">업데이트할 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-223">The entity to be updated.</span></span></param>
        <summary><span data-ttu-id="bb7d9-224">업데이트 재정의 메서드 내에서 업데이트 작업을 위한 동적 SQL을 생성하여 실행하는 작업을 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]에 다시 위임할 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-224">Executes, inside update override methods, to redelegate to [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] the task of generating and executing dynamic SQL for update operations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-225"><xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-225">See <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="bb7d9-226">메서드 호출의 인스턴스(현재 개체)입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-226">The instance of the method invocation (the current object).</span></span></param>
        <param name="methodInfo"><span data-ttu-id="bb7d9-227">데이터베이스 메서드에 해당하는 CLR 메서드를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-227">Identifies the CLR method that corresponds to a database method.</span></span></param>
        <param name="parameters"><span data-ttu-id="bb7d9-228">명령에 전달할 매개 변수 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-228">The array of parameters to be passed to the command.</span></span></param>
        <summary><span data-ttu-id="bb7d9-229">지정된 CLR 메서드에 연결된 저장 데이터베이스 프로시저 또는 스칼라 함수를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-229">Executes the stored database procedure or scalar function associated with the specified CLR method.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-230">지정된 메서드를 실행한 결과(반환 값 및 출력 매개 변수)입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-230">The result (the return value and output parameters) of executing the specified method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-231"><xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> 메서드 자동으로 생성 된 코드에 사용 되 고 데이터베이스 함수에 대 한 프록시 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-231">The <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> method is used in automatically generated code and acts as a proxy to database functions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="bb7d9-232">반환될 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-232">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be returned.</span></span>  
  
 <span data-ttu-id="bb7d9-233">쿼리 결과의 열을 개체의 필드 또는 속성과 일치시키는 알고리즘은 다음과 같이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-233">The algorithm for matching columns in the result of the query to fields or properties in the object works as follows:</span></span>  
  
 <span data-ttu-id="bb7d9-234">필드 또는 속성이 특정 열 이름에 매핑된 경우 해당 열 이름이 결과 집합에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-234">If a field or property is mapped to a particular column name, that column name is expected in the resultset.</span></span>  
  
 <span data-ttu-id="bb7d9-235">필드 또는 속성이 매핑되지 않은 경우 필드 또는 속성과 이름이 같은 열이 결과 집합에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-235">If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</span></span>  
  
 <span data-ttu-id="bb7d9-236">우선 대/소문자를 구분하여 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-236">The comparison is performed by looking for a case-sensitive match first.</span></span> <span data-ttu-id="bb7d9-237">일치 항목이 없으면 대/소문자를 구분하지 않고 다시 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-237">If this match is not found, a subsequent search occurs for a case-insensitive match.</span></span>  
  
 <span data-ttu-id="bb7d9-238">다음 조건에 모두 해당하는 경우 쿼리는 지연 로드가 적용되는 항목과 별도로 개체의 모든 추적된 필드 및 속성을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-238">The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</span></span>  
  
 <span data-ttu-id="bb7d9-239"><c>T</c>가 <see cref="T:System.Data.Linq.DataContext" />에서 명시적으로 추적되는 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-239"><c>T</c> is an entity explicitly tracked by the <see cref="T:System.Data.Linq.DataContext" />.</span></span>  
  
 <span data-ttu-id="bb7d9-240"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />가 <see langword="true" />인 경우</span><span class="sxs-lookup"><span data-stu-id="bb7d9-240"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> is <see langword="true" />.</span></span>  
  
 <span data-ttu-id="bb7d9-241">엔터티에 기본 키가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-241">The entity has a primary key.</span></span>  
  
 <span data-ttu-id="bb7d9-242">그렇지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-242">Otherwise an exception is thrown.</span></span></param>
        <param name="query"><span data-ttu-id="bb7d9-243">실행할 SQL 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-243">The SQL query to be executed.</span></span></param>
        <param name="parameters"><span data-ttu-id="bb7d9-244">명령에 전달할 매개 변수 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-244">The array of parameters to be passed to the command.</span></span> <span data-ttu-id="bb7d9-245">다음 동작에 유의하십시오.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-245">Note the following behavior:</span></span>  
  
 <span data-ttu-id="bb7d9-246">배열의 개체 수가 명령 문자열에 지정된 최대 개수보다 작으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-246">If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</span></span>  
  
 <span data-ttu-id="bb7d9-247">명령 문자열에서 참조되지 않은 개체가 배열에 있는 경우에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-247">If the array contains objects that are not referenced in the command string, no exception is thrown.</span></span>  
  
 <span data-ttu-id="bb7d9-248"><see langword="null" />인 매개 변수는 <see langword="DBNull.Value" />로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-248">If a parameter is <see langword="null" />, it is converted to <see langword="DBNull.Value" />.</span></span></param>
        <summary><span data-ttu-id="bb7d9-249">데이터베이스에 대해 직접 SQL 쿼리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-249">Executes SQL queries directly on the database.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-250">쿼리에서 반환된 개체의 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-250">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of objects returned by the query.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="bb7d9-251">반환되는 컬렉션에 있는 요소의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-251">The type of the elements in the returned collection.</span></span></typeparam>
        <param name="query"><span data-ttu-id="bb7d9-252">실행할 SQL 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-252">The SQL query to be executed.</span></span></param>
        <param name="parameters"><span data-ttu-id="bb7d9-253">명령에 전달할 매개 변수 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-253">The array of parameters to be passed to the command.</span></span> <span data-ttu-id="bb7d9-254">다음 동작에 유의하십시오.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-254">Note the following behavior:</span></span>  
  
 <span data-ttu-id="bb7d9-255">배열의 개체 수가 명령 문자열에 지정된 최대 개수보다 작으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-255">If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</span></span>  
  
 <span data-ttu-id="bb7d9-256">명령 문자열에서 참조되지 않은 개체가 배열에 있는 경우에는 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-256">If the array contains objects that are not referenced in the command string, no exception is thrown.</span></span>  
  
 <span data-ttu-id="bb7d9-257">null인 매개 변수는 <see langword="DBNull.Value" />로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-257">If a parameter is null, it is converted to <see langword="DBNull.Value" />.</span></span></param>
        <summary><span data-ttu-id="bb7d9-258">데이터베이스에 대해 직접 SQL 쿼리를 실행하고 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-258">Executes SQL queries directly on the database and returns objects.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-259">쿼리에서 반환된 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-259">A collection of objects returned by the query.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-260">이 메서드는 사례에 대 한 통과 메커니즘 여기서 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 특정 시나리오를 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-260">This method is a pass-through mechanism for cases where [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] does not provide for a particular scenario.</span></span>  
  
 <span data-ttu-id="bb7d9-261">개체의 속성과 필드에 대 한 쿼리의 결과에 일치 하는 열에 대 한 알고리즘은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-261">The algorithm for matching columns in the result of the query to fields and properties in the object works as follows:</span></span>  
  
-   <span data-ttu-id="bb7d9-262">필드 또는 속성이 특정 열 이름에 매핑된 경우 해당 열 이름이 결과 집합에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-262">If a field or property is mapped to a particular column name, that column name is expected in the resultset.</span></span>  
  
-   <span data-ttu-id="bb7d9-263">필드 또는 속성이 매핑되지 않은 경우 필드 또는 속성과 이름이 같은 열이 결과 집합에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-263">If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</span></span>  
  
-   <span data-ttu-id="bb7d9-264">비교는 대/소문자 구분 일치 하는 첫 번째 검색 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-264">The comparison is performed by first looking for a case-sensitive match.</span></span> <span data-ttu-id="bb7d9-265">일치 하는 항목이 없는 경우 대/소문자 구분 일치 하는 항목이 다시 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-265">If such a match is not found, a subsequent search occurs for a case-insensitive match.</span></span>  
  
-   <span data-ttu-id="bb7d9-266">쿼리는 모든 추적 된 필드 및 (되는 항목과 별도로 지연 된 로드에 따라) 개체의 속성을 반환 해야 다음 작업을 모두 충족 되는 경우:</span><span class="sxs-lookup"><span data-stu-id="bb7d9-266">The query must return all the tracked fields and properties of the object (apart from those subject to deferred loading) when all the following are true:</span></span>  
  
    -   <span data-ttu-id="bb7d9-267">경우 `<T>` 엔터티 명시적으로에서 추적 되는 <xref:System.Data.Linq.DataContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-267">If `<T>` is an entity explicitly tracked by the <xref:System.Data.Linq.DataContext>.</span></span>  
  
    -   <span data-ttu-id="bb7d9-268">ObjectTrackingEnabled 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-268">ObjectTrackingEnabled is true.</span></span>  
  
    -   <span data-ttu-id="bb7d9-269">엔터티에 기본 키가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-269">The entity has a primary key.</span></span>  
  
     <span data-ttu-id="bb7d9-270">그렇지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-270">Otherwise an exception is thrown.</span></span>  
  
-   <span data-ttu-id="bb7d9-271">다른 모든 경우 쿼리는 추적 된 필드 및 개체에 대 한 속성의 일부만을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-271">In all other cases, the query can retrieve just a subset of the tracked fields and properties for the object.</span></span>  
  
 <span data-ttu-id="bb7d9-272">다음 C# 조각은이 메서드에 대 한 사용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-272">The following C# snippet shows one use for this method:</span></span>  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 <span data-ttu-id="bb7d9-273">Visual Basic에서는</span><span class="sxs-lookup"><span data-stu-id="bb7d9-273">In Visual Basic</span></span>  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bb7d9-274"><see cref="T:System.Data.Linq.DataContext" />에서 추적하는 수정된 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-274">Gets the modified objects tracked by <see cref="T:System.Data.Linq.DataContext" />.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-275">개체 집합은 세 개의 읽기 전용 컬렉션으로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-275">The set of objects is returned as three read-only collections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-276">다음 사항을 note:</span><span class="sxs-lookup"><span data-stu-id="bb7d9-276">Note the following considerations:</span></span>  
  
-   <span data-ttu-id="bb7d9-277"><xref:System.Data.Linq.DataContext.GetChangeSet%2A> 유추의 삽입과 같은 부작용 및 삭제 작업 시 일반적으로 수행 하는 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-277"><xref:System.Data.Linq.DataContext.GetChangeSet%2A> might have side effects, such as inference of insert and delete operations that are usually performed at the time of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="bb7d9-278">예를 들어, 다음 작업에 사용 되는 개체는 다음 목록에 해당 작업이 유추를 만들 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="bb7d9-278">For example, objects that are used in the following operations can create corresponding inferred operations in the following list:</span></span>  
  
    -   <span data-ttu-id="bb7d9-279"><xref:System.Data.Linq.EntitySet%601.Add%2A> <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-279"><xref:System.Data.Linq.EntitySet%601.Add%2A> to <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.</span></span>  
  
    -   <span data-ttu-id="bb7d9-280"><xref:System.Data.Linq.EntityRef%601> null에 대 한 할당 (가능으로 인해 <xref:System.Data.Linq.EntitySet%601.Remove%2A> 를 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-280"><xref:System.Data.Linq.EntityRef%601> assignment to null (possibly because of <xref:System.Data.Linq.EntitySet%601.Remove%2A> to <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.</span></span>  
  
-   <span data-ttu-id="bb7d9-281">집합 foreign key 제약 조건에 따라 정렬 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-281">The set may not be ordered according to foreign key constraints.</span></span>  
  
-   <span data-ttu-id="bb7d9-282">데이터베이스에서 생성 된 값 (예를 들어, 기본 및 외래 키 값, 타임 스탬프 등)를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-282">Database-generated values (for example, primary and foreign key values, timestamps, and so forth) are not available.</span></span> <span data-ttu-id="bb7d9-283">이러한 정보는 데이터베이스 명령 실행 하 고 검색 된 정보 (예를 들어 기본 키에서 외래 키)의 전파 아마도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-283">Such information requires database command execution and perhaps the propagation of retrieved information (for example, foreign key from primary key).</span></span>  
  
-   <span data-ttu-id="bb7d9-284">변경 된 개체 집합이 호출 시 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-284">The set of changed objects is computed at the time of the call.</span></span> <span data-ttu-id="bb7d9-285">에 대 한 후속 호출 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 추가로 변경 내용이 있는 경우 다른 집합을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-285">Subsequent calls to <xref:System.Data.Linq.DataContext.SubmitChanges%2A> can produce a different set if additional changes are made.</span></span>  
  
 <span data-ttu-id="bb7d9-286">변경 내용을 적용 된 경우의 출력을 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-286">Output when no changes have been made appears as follows:</span></span>  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query"><span data-ttu-id="bb7d9-287">SQL 명령 정보를 검색할 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-287">The query whose SQL command information is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="bb7d9-288">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]에서 생성한 SQL 명령에 대한 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-288">Gets the information about SQL commands generated by [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)].</span></span></summary>
        <returns><span data-ttu-id="bb7d9-289">요청된 명령 정보 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-289">The requested command information object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-290">이 방법은 getter에만 영향을 주지 않습니다 뛰어나며 <xref:System.Data.Linq.DataContext> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-290">This method is only a getter and does not affect <xref:System.Data.Linq.DataContext> state.</span></span>  
  
 <span data-ttu-id="bb7d9-291">다음 사항을 note:</span><span class="sxs-lookup"><span data-stu-id="bb7d9-291">Note the following considerations:</span></span>  
  
-   <span data-ttu-id="bb7d9-292">인수는 null 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-292">The argument must be non-null.</span></span> <span data-ttu-id="bb7d9-293">그렇지 않으면 null 인수 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-293">Otherwise, a null argument exception is thrown.</span></span>  
  
-   <span data-ttu-id="bb7d9-294">하는 동안 발생 하는 일반적인 쿼리 변환 예외 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 쿼리 실행 변환할 수 없는 쿼리에 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-294">Normal query translation exceptions thrown during [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] query execution apply for a query that cannot be translated.</span></span>  
  
-   <span data-ttu-id="bb7d9-295">첫 번째 쿼리 명령이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-295">Only the first query command is returned.</span></span> <span data-ttu-id="bb7d9-296">즉시 로드에 사용 되는 추가 명령이 특히 (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>)는 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-296">Specifically, additional commands that are used for eager loading (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) are not included.</span></span>  
  
-   <span data-ttu-id="bb7d9-297"><xref:System.Data.Linq.DataContext> 명령을 사용 하 여 사용자가을 추적 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-297"><xref:System.Data.Linq.DataContext> does not track what the user does with the command.</span></span> <span data-ttu-id="bb7d9-298">반환 된 명령을 실행 한 결과 추적 되지 않으며 영향을 주지 않습니다 예를 들어 <xref:System.Data.Linq.DataContext> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-298">For example, results from the execution of the returned command are not tracked and do not affect <xref:System.Data.Linq.DataContext> state.</span></span>  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="bb7d9-299">반환될 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-299">The type of the objects to be returned.</span></span></param>
        <summary><span data-ttu-id="bb7d9-300"><paramref name="type" /> 매개 변수로 정의된 특정 형식의 개체 컬렉션을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-300">Returns a collection of objects of a particular type, where the type is defined by the <paramref name="type" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-301"><paramref name="type" /> 매개 변수에 의해 정의된 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-301">A collection of objects defined by the <paramref name="type" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-302">이의 약한 형식의 버전 <xref:System.Data.Linq.DataContext.GetTable%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-302">This is a weakly typed version of <xref:System.Data.Linq.DataContext.GetTable%2A>.</span></span> <span data-ttu-id="bb7d9-303">쿼리를 동적으로 생성 하는 상대적으로 일반적인 좋습니다 이기 때문에 약한 형식의 버전을 포함 하는 것이 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-303">It is important to have a weakly typed version because it is a relatively common practice to construct queries dynamically.</span></span> <span data-ttu-id="bb7d9-304">하기란 리플렉션을 사용 하 여 올바른 제네릭 메서드를 호출 하면 응용 프로그램을 편리 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-304">It would be inconvenient to force the application to use reflection to call the correct generic method.</span></span>  
  
 <span data-ttu-id="bb7d9-305">특정 형식에 대 한 컬렉션이 없는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-305">If there is no collection for a particular type, an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity"><span data-ttu-id="bb7d9-306">반환될 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-306">The type of the objects to be returned.</span></span></typeparam>
        <summary><span data-ttu-id="bb7d9-307"><paramref name="TEntity" /> 매개 변수로 정의된 특정 형식의 개체 컬렉션을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-307">Returns a collection of objects of a particular type, where the type is defined by the <paramref name="TEntity" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-308"><paramref name="TEntity" /> 매개 변수에 의해 정의된 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-308">A collection of objects defined by the <paramref name="TEntity" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-309">이 메서드는 쿼리를 위한 기본 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-309">This method is the main entry point for querying.</span></span> <span data-ttu-id="bb7d9-310">강력한 형식의 경우 <xref:System.Data.Linq.DataContext> 새로 생성 된 속성은이 메서드의 호출 캡슐화 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-310">When a strongly typed <xref:System.Data.Linq.DataContext> is created, new generated properties encapsulate calls to this method.</span></span> <span data-ttu-id="bb7d9-311">예를 들어 한 `Customers` 속성이 반환 하는 생성 된 `GetTable<Customer>`합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-311">For example, a `Customers` property is generated that returns `GetTable<Customer>`.</span></span>  
  
 <span data-ttu-id="bb7d9-312">특정 형식에 대 한 컬렉션이 없는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-312">If there is no collection for a particular type, an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-313">이 <see cref="T:System.Data.Linq.DataLoadOptions" />에 연결된 <see cref="T:System.Data.Linq.DataContext" />를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-313">Gets or sets the <see cref="T:System.Data.Linq.DataLoadOptions" /> associated with this <see cref="T:System.Data.Linq.DataContext" />.</span></span></summary>
        <value><span data-ttu-id="bb7d9-314">관련 데이터에 대한 프리페치 로드 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-314">The prefetch load options for related data.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-315">이 속성에는 지연 로드 된 멤버와 관련 된 컬렉션의 멤버 자격에 대 한 사전 인출 동작을 정의 하는 데 사용 되는 옵션을 설정 하거나 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-315">This property gets or sets the options that are used to define prefetch behavior for deferred-loaded members and membership of related collections.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-316">SQL 쿼리 또는 명령을 쓸 대상을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-316">Gets or sets the destination to write the SQL query or command.</span></span></summary>
        <value><span data-ttu-id="bb7d9-317">명령을 쓰는 데 사용할 <see cref="T:System.IO.TextReader" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-317">The <see cref="T:System.IO.TextReader" /> to use for writing the command.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-318">이 속성을 설정 `null` 명령 로깅을 사용 하지 않으려면입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-318">Set this property to `null` to disable command logging.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb7d9-319">다음 예에서는 쿼리의 결과 표시 하기 전에 콘솔 창에 생성 된 SQL을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-319">The following example displays generated SQL in the console window before it displays the results of the query.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-320">매핑의 기반이 되는 <see cref="T:System.Data.Linq.Mapping.MetaModel" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-320">Gets the <see cref="T:System.Data.Linq.Mapping.MetaModel" /> on which the mapping is based.</span></span></summary>
        <value><span data-ttu-id="bb7d9-321">데이터베이스와 도메인 개체 사이의 매핑입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-321">The mapping between a database and domain objects.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-322">개체 추적이 사용되는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-322">Gets or sets a value that indicates whether object tracking is enabled.</span></span></summary>
        <value>
          <span data-ttu-id="bb7d9-323">개체 추적을 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-323"><see langword="true" /> if the object tracking is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="bb7d9-324">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-324">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-325">이 속성을 설정 `false` 사용 되므로 적은 추적할 항목을 검색할 때 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-325">Setting this property to `false` improves performance at retrieval time, because there are fewer items to track.</span></span>  
  
 <span data-ttu-id="bb7d9-326">예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-326">An exception is thrown:</span></span>  
  
-   <span data-ttu-id="bb7d9-327">속성이로 설정 된 경우 `false` 쿼리가 실행 된 후입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-327">If the property is set to `false` after a query has been executed.</span></span>  
  
     <span data-ttu-id="bb7d9-328">자세한 내용은 사용할 수 있는 모드 섹션을 참조 <xref:System.Data.Linq.DataContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-328">For more information, see the Valid Modes section in <xref:System.Data.Linq.DataContext>.</span></span>  
  
-   <span data-ttu-id="bb7d9-329">속성이로 설정 된 경우 `false` 및 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-329">If the property is set to `false` and <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="bb7d9-330">경우 <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> 은 `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 은 무시 되 고로 처리 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-330">If <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> is `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> is ignored and treated as `false`.</span></span> <span data-ttu-id="bb7d9-331">이 경우에 <xref:System.Data.Linq.DataContext> 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-331">In this case, the <xref:System.Data.Linq.DataContext> is read-only.</span></span>  
  
 <span data-ttu-id="bb7d9-332">경우 <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> 은 `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 은 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-332">If <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> is `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> is `false`.</span></span> <span data-ttu-id="bb7d9-333">이 경우 <xref:System.Data.Linq.DataContext> 개체 그래프를 사용 하 여 로드할 수 있게 해 <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> 지시문 하지만 지연 된 로드를 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-333">In this case, <xref:System.Data.Linq.DataContext> allows you to load an object graph by using <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> directives, but does not enable deferred loading.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bb7d9-334">데이터베이스의 데이터를 사용하여 개체 상태를 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-334">Refreshes object state by using data in the database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-335">이 메서드는 또 다른 시도 대 한 상태 항목을 낙관적 동시성 오류가 발생 한 후 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-335">This method is useful after an optimistic concurrency error to bring items into a state for another attempt.</span></span> <span data-ttu-id="bb7d9-336">기본 필드 및 개체에 속성의 상태를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-336">It updates the state of the primitive fields and properties on the objects.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bb7d9-337">개체가 있는 경우에 *많은* 대 다 관계 개체에서 외래 키 쪽 설정 되 고 관계의 다른 쪽에 대 한 개체 포인터를 새 값으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-337">If an object is on the *many* side of a one-to-many relationship, the foreign key on the object will be set and the object pointer for the other side of the relationship will be set to the new value.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="bb7d9-338">낙관적 동시성 충돌을 처리하는 방법을 지정하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-338">A value that specifies how optimistic concurrency conflicts are handled.</span></span></param>
        <param name="entities"><span data-ttu-id="bb7d9-339">새로 고칠 엔터티의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-339">The collection of entities to be refreshed.</span></span></param>
        <summary><span data-ttu-id="bb7d9-340">지정된 모드에 따라 엔터티 개체의 컬렉션을 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-340">Refreshes a collection of entity objects according to the specified mode.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="bb7d9-341">낙관적 동시성 충돌을 처리하는 방법을 지정하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-341">A value that specifies how optimistic concurrency conflicts are handled.</span></span></param>
        <param name="entity"><span data-ttu-id="bb7d9-342">새로 고칠 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-342">The object to be refreshed.</span></span></param>
        <summary><span data-ttu-id="bb7d9-343">지정된 모드에 따라 엔터티 개체를 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-343">Refreshes an entity object according to the specified mode.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="bb7d9-344">낙관적 동시성 충돌을 처리하는 방법을 지정하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-344">A value that specifies how optimistic concurrency conflicts are handled.</span></span></param>
        <param name="entities"><span data-ttu-id="bb7d9-345">새로 고칠 엔터티 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-345">The array of entity objects to be refreshed.</span></span></param>
        <summary><span data-ttu-id="bb7d9-346">지정된 모드에 따라 엔터티 개체의 배열을 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-346">Refreshes an array of entity objects according to the specified mode.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bb7d9-347">삽입, 업데이트 또는 삭제될 수정된 개체 집합을 계산하고 적절한 명령을 실행하여 데이터베이스를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-347">Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-348">Insert, update 또는 delete에 대 한 재정의 메서드 없으면 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 기본값 대신 이러한 메서드를 실행 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-348">If override methods are present for insert, update, or delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> executes these methods instead of the default [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] commands.</span></span>  
  
 <span data-ttu-id="bb7d9-349"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> 트랜잭션을 시작 하 고 예외가 발생 하는 경우 롤백합니다 동안 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-349"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> starts a transaction and will roll back if an exception occurs while <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is executing.</span></span> <span data-ttu-id="bb7d9-350">그러나이 롤백되지 않습니다 변경 내용이 메모리에 또는 파일에서 추적 되는 <xref:System.Data.Linq.DataContext>; 변경 내용을 수동으로 롤백해야 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-350">However, this does not roll back the changes in memory or tracked by the <xref:System.Data.Linq.DataContext>; those changes will need to be rolled back manually.</span></span> <span data-ttu-id="bb7d9-351">새 인스턴스를 시작할 수는 <xref:System.Data.Linq.DataContext> 메모리에 변경이 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-351">You can start with a new instance of the <xref:System.Data.Linq.DataContext> if the changes in memory are to be discarded.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bb7d9-352">삽입, 업데이트 또는 삭제될 수정된 개체 집합을 계산하고 적절한 명령을 실행하여 데이터베이스를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-352">Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-353">Insert, update 또는 delete에 대 한 재정의 메서드 없으면 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 기본값 대신 이러한 메서드를 실행 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-353">If override methods are present for insert, update, or delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> executes these methods instead of the default [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] commands.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode"><span data-ttu-id="bb7d9-354">전송에 실패할 때 수행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-354">The action to be taken if the submission fails.</span></span> <span data-ttu-id="bb7d9-355">유효한 인수는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-355">Valid arguments are as follows:</span></span>  
  
 <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary><span data-ttu-id="bb7d9-356">검색된 개체에 대한 변경 내용을 내부 데이터베이스에 보내고, 전송에 실패할 때 수행할 작업을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-356">Sends changes that were made to retrieved objects to the underlying database, and specifies the action to be taken if the submission fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-357">기본 오류 모드는 <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-357">Default failure mode is <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.</span></span>  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bb7d9-358">데이터베이스에 액세스하는 데 사용할 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]의 로컬 트랜잭션을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-358">Gets or sets a local transaction for the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] to use to access the database.</span></span></summary>
        <value><span data-ttu-id="bb7d9-359">쿼리와 명령을 실행할 때 <see cref="T:System.Data.Linq.DataContext" />에서 사용되는 트랜잭션 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-359">The transaction object used by the <see cref="T:System.Data.Linq.DataContext" /> when executing queries and commands.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-360">이 속성에 대 한 기본 시나리오는 관계형와 상호 운용성 [!INCLUDE[vstecado](~/includes/vstecado-md.md)] 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-360">The primary scenario for this property is interoperability with relational [!INCLUDE[vstecado](~/includes/vstecado-md.md)] code.</span></span> <span data-ttu-id="bb7d9-361">직접 작성 하는 경우이 속성을 사용 하 여 예를 들어 `Create` / `Update` / `Delete` 설정 하는 메서드는 `Transaction` ADO 속성 `Command` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-361">For example, use this property when you write your own `Create`/`Update`/`Delete` methods to set the `Transaction` property on the ADO `Command` object.</span></span>  
  
 <span data-ttu-id="bb7d9-362">다음 사항에 유의하십시오.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-362">Note the following:</span></span>  
  
-   <span data-ttu-id="bb7d9-363">이 속성이 명시적으로 설정 되지 않은 경우 getter는 null을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-363">If this property has not been explicitly set, the getter returns null.</span></span>  
  
-   <span data-ttu-id="bb7d9-364">코드에서 실행 되는 경우는 <xref:System.Transactions.Transaction> 예외를 throw 하는 컨텍스트를이 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-364">If the code is executing in a <xref:System.Transactions.Transaction> context, setting this property throws an exception.</span></span>  
  
-   <span data-ttu-id="bb7d9-365">이 속성이 설정 되 고 새 경우 <xref:System.Transactions.Transaction> 가 열려 예외가 쿼리 또는 업데이트가 실행 될 때입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-365">If this property is set and a new <xref:System.Transactions.Transaction> is opened, an exception is thrown when a query or update is executed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bb7d9-366">기존 <see cref="T:System.Data.IDataReader" />를 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-366">Converts an existing <see cref="T:System.Data.IDataReader" /> to objects.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb7d9-367">각 행에는 <xref:System.Data.IDataReader> 개체에 변환는 <xref:System.Collections.Generic.IEnumerable%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-367">Each row in the <xref:System.Data.IDataReader> is converted to an object in the <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 <span data-ttu-id="bb7d9-368">설명:이 메서드는 기존 변환 하는 <xref:System.Data.Common.DbDataReader> 개체에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-368">Description: This method is used to convert an existing <xref:System.Data.Common.DbDataReader> to objects.</span></span> <span data-ttu-id="bb7d9-369">각 행에는 <xref:System.Data.Common.DbDataReader> 개체에 변환는 <xref:System.Collections.Generic.IEnumerable%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-369">Each row in the <xref:System.Data.Common.DbDataReader> is converted to an object in the <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="bb7d9-370">**제네릭 매개 변수:**</span><span class="sxs-lookup"><span data-stu-id="bb7d9-370">**Generic parameters:**</span></span>  
  
 <span data-ttu-id="bb7d9-371">`T`: 참조 <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-371">`T`: See <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.</span></span>  
  
 <span data-ttu-id="bb7d9-372">**매개 변수:**</span><span class="sxs-lookup"><span data-stu-id="bb7d9-372">**Parameters:**</span></span>  
  
 <span data-ttu-id="bb7d9-373">`Query`:에서 명령에 대 한 설명을 참조 하십시오. <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-373">`Query`: See the description for command under <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.</span></span>  
  
 <span data-ttu-id="bb7d9-374">`Parameters`:에서 매개 변수에 대 한 설명을 참조 하십시오. <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-374">`Parameters`: See the description for parameters under <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.</span></span>  
  
 <span data-ttu-id="bb7d9-375">**반환 형식:**</span><span class="sxs-lookup"><span data-stu-id="bb7d9-375">**Return type:**</span></span>  
  
 <span data-ttu-id="bb7d9-376"><xref:System.Collections.Generic.IEnumerable%601>: 변환에 의해 반환 되는 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-376"><xref:System.Collections.Generic.IEnumerable%601>: collection of objects returned by the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="bb7d9-377">변환될 <see cref="T:System.Data.IDataReader" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-377">The <see cref="T:System.Data.IDataReader" /> to be converted.</span></span></param>
        <summary><span data-ttu-id="bb7d9-378">기존 <see cref="T:System.Data.Common.DbDataReader" />를 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-378">Converts an existing <see cref="T:System.Data.Common.DbDataReader" /> to objects.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-379">변환 후 반환된 개체의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-379">A list of objects returned by the conversion.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="bb7d9-380">반환될 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-380">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be returned.</span></span>  
  
 <span data-ttu-id="bb7d9-381">결과의 열을 개체의 필드 및 속성과 일치시키는 알고리즘은 다음과 같이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-381">The algorithm for matching columns in the result to fields and properties in the object works as follows:</span></span>  
  
 <span data-ttu-id="bb7d9-382">필드 또는 속성이 특정 열 이름에 매핑된 경우 해당 열 이름이 결과 집합에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-382">If a field or property is mapped to a particular column name, that column name is expected in the resultset.</span></span>  
  
 <span data-ttu-id="bb7d9-383">필드 또는 속성이 매핑되지 않은 경우 필드 또는 속성과 이름이 같은 열이 결과 집합에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-383">If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</span></span>  
  
 <span data-ttu-id="bb7d9-384">우선 대/소문자를 구분하여 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-384">The comparison is performed by looking for a case-sensitive match first.</span></span> <span data-ttu-id="bb7d9-385">일치 항목이 없으면 대/소문자를 구분하지 않고 다시 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-385">If this match is not found, a subsequent search is occurs for a case-insensitive match.</span></span>  
  
 <span data-ttu-id="bb7d9-386">다음 조건에 모두 해당하는 경우 쿼리는 지연 로드가 적용되는 항목과 별도로 개체의 모든 추적된 필드 및 속성을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-386">The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</span></span>  
  
 <span data-ttu-id="bb7d9-387"><c>T</c>가 <see cref="T:System.Data.Linq.DataContext" />에서 명시적으로 추적되는 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-387"><c>T</c> is an entity explicitly tracked by the <see cref="T:System.Data.Linq.DataContext" />.</span></span>  
  
 <span data-ttu-id="bb7d9-388"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />가 <see langword="true" />인 경우</span><span class="sxs-lookup"><span data-stu-id="bb7d9-388"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> is <see langword="true" />.</span></span>  
  
 <span data-ttu-id="bb7d9-389">엔터티에 기본 키가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-389">The entity has a primary key.</span></span>  
  
 <span data-ttu-id="bb7d9-390">그렇지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-390">Otherwise an exception is thrown.</span></span></param>
        <param name="reader"><span data-ttu-id="bb7d9-391">변환될 <see cref="T:System.Data.IDataReader" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-391">The <see cref="T:System.Data.IDataReader" /> to be converted.</span></span></param>
        <summary><span data-ttu-id="bb7d9-392">기존 <see cref="T:System.Data.Common.DbDataReader" />를 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-392">Converts an existing <see cref="T:System.Data.Common.DbDataReader" /> to objects.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-393">변환 후 반환된 개체의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-393">A list of objects returned by the conversion.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="bb7d9-394">반환될 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-394">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be returned.</span></span></typeparam>
        <param name="reader"><span data-ttu-id="bb7d9-395">변환될 <see cref="T:System.Data.IDataReader" />입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-395">The <see cref="T:System.Data.IDataReader" /> to be converted.</span></span></param>
        <summary><span data-ttu-id="bb7d9-396">기존 <see cref="T:System.Data.Common.DbDataReader" />를 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-396">Converts an existing <see cref="T:System.Data.Common.DbDataReader" /> to objects.</span></span></summary>
        <returns><span data-ttu-id="bb7d9-397">변환 후 반환된 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bb7d9-397">A collection of objects returned by the conversion.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>