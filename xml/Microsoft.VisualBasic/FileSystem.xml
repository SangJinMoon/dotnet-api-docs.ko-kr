<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="26db1-101"><see langword="FileSystem" /> 모듈에는 파일, 디렉터리 또는 폴더 및 시스템 작업을 수행하는 데 사용되는 프로시저가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span></span> <span data-ttu-id="26db1-102"><see langword="My" /> 기능을 사용하면 <see langword="FileSystem" /> 모듈을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span></span> <span data-ttu-id="26db1-103">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-104">이 모듈은 Visual Basic 언어 키워드 및 파일 및 폴더에 액세스 하는 런타임 라이브러리 멤버를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-105">사용 하 여이 예제는 `GetAttr` 파일 및 디렉터리 또는 폴더의 특성을 결정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="26db1-106">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-106">Required.</span></span> <span data-ttu-id="26db1-107">새 기본 디렉터리 또는 폴더가 될 대상을 식별하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-107">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span></span> <span data-ttu-id="26db1-108"><c>Path</c>에는 드라이브가 포함될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-108"><c>Path</c> may include the drive.</span></span> <span data-ttu-id="26db1-109">드라이브를 지정하지 않은 경우 <see langword="ChDir" />을 사용하면 현재 드라이브의 기본 디렉터리나 폴더를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-109">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span></span></param>
        <summary><span data-ttu-id="26db1-110">현재 디렉터리나 폴더를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-110">Changes the current directory or folder.</span></span> <span data-ttu-id="26db1-111"><see langword="My" /> 기능을 사용하면 <see langword="ChDir" /> 함수를 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-111">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span></span> <span data-ttu-id="26db1-112">자세한 내용은 <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-112">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-113">`ChDir` 함수는 기본 드라이브는 기본 디렉터리를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-113">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="26db1-114">예를 들어 기본 드라이브는 C, 다음 문은 D 드라이브의 기본 디렉터리 변경 C 기본 드라이브는 그대로:</span><span class="sxs-lookup"><span data-stu-id="26db1-114">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="26db1-115">상대를 만들 수 있습니다 디렉터리 변경 하는 두 개의 마침표를 다음과 같이 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-115">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-116">`ChDir` 함수 비관리 코드 권한이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-116">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="26db1-117">자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-117">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-118">사용 하 여이 예제는 `ChDir` 함수는 현재 디렉터리 또는 폴더를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-118">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-119"><paramref name="Path" />가 비어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-119"><paramref name="Path" /> is empty.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="26db1-120">드라이브를 잘못 지정했거나 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-120">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-121">현재 드라이브를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-121">Changes the current drive.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="26db1-122">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-122">Required.</span></span> <span data-ttu-id="26db1-123">기존 드라이브를 지정하는 문자열 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-123">String expression that specifies an existing drive.</span></span> <span data-ttu-id="26db1-124">길이가 0인 문자열("")을 지정하면 현재 드라이브가 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-124">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="26db1-125"><c>Drive</c> 인수가 여러 문자로 된 문자열인 경우 <see langword="ChDrive" />는 첫 글자만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-125">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="26db1-126">현재 드라이브를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-126">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-127">`ChDrive` 함수 비관리 코드 권한이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-127">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="26db1-128">자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-128">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-129">사용 하 여이 예제는 `ChDrive` 함수 현재 드라이브를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-129">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="26db1-130">함수는 드라이브 존재 하지 않는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-130">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-131">드라이브를 잘못 지정했거나 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-131">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="26db1-132">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-132">Required.</span></span> <span data-ttu-id="26db1-133">기존 드라이브를 지정하는 문자열 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-133">String expression that specifies an existing drive.</span></span> <span data-ttu-id="26db1-134">길이가 0인 문자열("")을 지정하면 현재 드라이브가 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-134">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="26db1-135"><c>Drive</c> 인수가 여러 문자로 된 문자열인 경우 <see langword="ChDrive" />는 첫 글자만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-135">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="26db1-136">현재 드라이브를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-136">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-137">`ChDrive` 함수 비관리 코드 권한이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-137">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="26db1-138">자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-138">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-139">사용 하 여이 예제는 `ChDrive` 함수 현재 드라이브를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-139">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="26db1-140">함수는 드라이브 존재 하지 않는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-140">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-141">드라이브를 잘못 지정했거나 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-141">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-142">현재 경로를 나타내는 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-142">Returns a string representing the current path.</span></span> <span data-ttu-id="26db1-143"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="CurDir" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-143">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="26db1-144">자세한 내용은 <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-144">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26db1-145">현재 경로를 나타내는 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-145">Returns a string representing the current path.</span></span> <span data-ttu-id="26db1-146"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="CurDir" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-146">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="26db1-147">자세한 내용은 <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-147">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="26db1-148">현재 경로를 나타내는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-148">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26db1-149">사용 하 여이 예제는 `CurDir` 함수는 현재 경로를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-149">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="26db1-150">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-150">Optional.</span></span> <span data-ttu-id="26db1-151">기존 드라이브를 지정하는 <see langword="Char" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-151"><see langword="Char" /> expression that specifies an existing drive.</span></span> <span data-ttu-id="26db1-152">드라이브를 지정하지 않거나 <c>Drive</c>가 길이가 0인 문자열("")인 경우 <see langword="CurDir" />은 현재 드라이브에 대한 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-152">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span></span></param>
        <summary><span data-ttu-id="26db1-153">현재 경로를 나타내는 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-153">Returns a string representing the current path.</span></span> <span data-ttu-id="26db1-154"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="CurDir" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="26db1-155">자세한 내용은 <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="26db1-156">현재 경로를 나타내는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-156">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26db1-157">사용 하 여이 예제는 `CurDir` 함수는 현재 경로를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-158">지정한 패턴이나 파일 특성과 일치하는 파일, 디렉터리 또는 폴더의 이름을 나타내는 문자열 또는 드라이브의 볼륨 레이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-158">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="26db1-159"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="Dir" /> 함수를 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-159">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="26db1-160">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-160">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26db1-161">지정한 패턴이나 파일 특성과 일치하는 파일, 디렉터리 또는 폴더의 이름을 나타내는 문자열 또는 드라이브의 볼륨 레이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-161">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="26db1-162"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="Dir" /> 함수를 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="26db1-163">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-163">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="26db1-164">지정된 패턴이나 파일 특성과 일치하는 파일, 디렉터리 또는 폴더의 이름을 나타내는 문자열 또는 드라이브의 볼륨 레이블입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-164">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-165">`Dir` 함수 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-165">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="26db1-166">`VbVolume` 특정 파일 이름 대신 드라이브 볼륨 레이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-166">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="26db1-167">제공 해야 합니다는 `PathName` 처음으로 호출 하는 `Dir` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-167">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="26db1-168">다음 항목을 검색 하려면에 대 한 후속 호출을 만들 수 있습니다는 `Dir` 매개 변수 없이 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-168">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-169">제대로 실행 하려면는 `Dir` 함수에 필요는 <xref:System.Security.Permissions.FileIOPermissionAccess.Read> 및 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> 의 플래그를 지정 <xref:System.Security.Permissions.FileIOPermission> 를 실행 중인 코드에 부여 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-169">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="26db1-170">자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-170">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="26db1-171">`Attributes` 인수 열거형 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-171">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="26db1-172">값</span><span class="sxs-lookup"><span data-stu-id="26db1-172">Value</span></span>|<span data-ttu-id="26db1-173">상수</span><span class="sxs-lookup"><span data-stu-id="26db1-173">Constant</span></span>|<span data-ttu-id="26db1-174">설명</span><span class="sxs-lookup"><span data-stu-id="26db1-174">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="26db1-175">기본.</span><span class="sxs-lookup"><span data-stu-id="26db1-175">Default.</span></span> <span data-ttu-id="26db1-176">특성이 없는 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-176">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="26db1-177">읽기 전용 파일 및 파일 특성 없이 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-177">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="26db1-178">숨겨진된 파일 및 파일 특성 없이 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-178">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="26db1-179">시스템 파일 및 특성이 없는 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-179">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="26db1-180">볼륨 레이블;를 지정합니다. 다른 특성을 지정 하는 경우 `vbVolume` 는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-180">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="26db1-181">디렉터리 또는 폴더 및 특성이 없는 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-181">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="26db1-182">마지막 백업 이후에 파일이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-182">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="26db1-183">파일에 다른 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-183">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="26db1-184">이 열거형은 Visual Basic 언어에 의해 지정 되며 실제 값 대신 코드에서 어디서 나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-184">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-185">사용 하 여이 예제는 `Dir` 을 특정 파일 및 디렉터리가 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-185">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="26db1-186">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-186">Optional.</span></span> <span data-ttu-id="26db1-187">파일 이름, 디렉터리나 폴더 이름 또는 드라이브 볼륨 레이블을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-187"><see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span></span> <span data-ttu-id="26db1-188"><c>PathName</c>이 없으면 길이가 0인 문자열(<see langword="&quot;&quot;" />)이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-188">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span></span></param>
        <param name="Attributes"><span data-ttu-id="26db1-189">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-189">Optional.</span></span> <span data-ttu-id="26db1-190">파일 특성을 지정하는 값을 가진 열거형 또는 숫자 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-190">Enumeration or numeric expression whose value specifies file attributes.</span></span> <span data-ttu-id="26db1-191">이 매개 변수를 생략하면 <see langword="Dir" />은 <c>PathName</c>과 일치하지만 특성이 없는 파일을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-191">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span></span></param>
        <summary><span data-ttu-id="26db1-192">지정한 패턴이나 파일 특성과 일치하는 파일, 디렉터리 또는 폴더의 이름을 나타내는 문자열 또는 드라이브의 볼륨 레이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-192">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="26db1-193"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="Dir" /> 함수를 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-193">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="26db1-194">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-194">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="26db1-195">지정된 패턴이나 파일 특성과 일치하는 파일, 디렉터리 또는 폴더의 이름을 나타내는 문자열 또는 드라이브의 볼륨 레이블입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-195">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-196">`Dir` 함수 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-196">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="26db1-197">`VbVolume` 특정 파일 이름 대신 드라이브 볼륨 레이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-197">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="26db1-198">제공 해야 합니다는 `PathName` 처음으로 호출 하는 `Dir` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-198">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="26db1-199">다음 항목을 검색 하려면에 대 한 후속 호출을 만들 수 있습니다는 `Dir` 매개 변수가 없는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-199">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-200">제대로 실행 하려면는 `Dir` 함수에 필요는 <xref:System.Security.Permissions.FileIOPermissionAccess.Read> 및 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> 의 플래그를 지정 <xref:System.Security.Permissions.FileIOPermission> 를 실행 중인 코드에 부여 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-200">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="26db1-201">자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-201">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="26db1-202">`Attributes` 인수 열거형 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-202">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="26db1-203">값</span><span class="sxs-lookup"><span data-stu-id="26db1-203">Value</span></span>|<span data-ttu-id="26db1-204">상수</span><span class="sxs-lookup"><span data-stu-id="26db1-204">Constant</span></span>|<span data-ttu-id="26db1-205">설명</span><span class="sxs-lookup"><span data-stu-id="26db1-205">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="26db1-206">기본.</span><span class="sxs-lookup"><span data-stu-id="26db1-206">Default.</span></span> <span data-ttu-id="26db1-207">특성이 없는 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-207">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="26db1-208">특성이 없는 파일 외에도 읽기 전용 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-208">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="26db1-209">특성이 없는 파일 뿐만 아니라 숨겨진된 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-209">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="26db1-210">특성이 없는 파일 외에도 시스템 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-210">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="26db1-211">볼륨 레이블;를 지정합니다. 다른 특성을 지정 하는 경우 `vbVolume` 는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-211">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="26db1-212">디렉터리나 파일 특성이 없는 뿐만 아니라 폴더를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-212">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="26db1-213">마지막 백업 이후에 파일이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-213">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="26db1-214">파일에 다른 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-214">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="26db1-215">이 열거형은 Visual Basic 언어에 의해 지정 되며 실제 값 대신 코드에서 어디서 나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-215">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-216">사용 하 여이 예제는 `Dir` 을 특정 파일 및 디렉터리가 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-216">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-217">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-217">Required.</span></span> <span data-ttu-id="26db1-218">유효한 파일 번호가 포함된 <see langword="Integer" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-218">An <see langword="Integer" /> that contains any valid file number.</span></span></param>
        <summary><span data-ttu-id="26db1-219"><see langword="True" /> 또는 순차적인 <see langword="Random" />용으로 연 파일의 끝에 도달하면 부울 값 <see langword="Input" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-219">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></summary>
        <returns><span data-ttu-id="26db1-220"><see langword="True" /> 또는 순차적인 <see langword="Random" />용으로 연 파일의 끝에 도달하면 부울 값 <see langword="Input" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-220">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-221">사용 하 여 `EOF` 입력을 가져올 파일의 끝을 지나서에 의해 생성 된 오류를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-221">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="26db1-222">`EOF` 함수에서 반환 `False` 파일의 끝에 도달할 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-222">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="26db1-223">연 파일 `Random` 또는 `Binary` 액세스 `EOF` 반환 `False` 는 마지막으로 실행 될 때까지 `FileGet` 함수는 전체 레코드를 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-223">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="26db1-224">연 파일 `Binary` 액세스를 사용 하 여 파일을 통해 읽지는 `Input` 될 때까지 작동 `EOF` 반환 `True` 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-224">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="26db1-225">사용 하 여는 `LOF` 및 `Loc` 대신 함수 `EOF` 때 이진 파일을 읽는 `Input`, 사용 또는 `Get` 사용 하는 경우는 `EOF` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-225">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="26db1-226">연 파일 `Output`, `EOF` 항상 반환 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-226">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-227">사용 하 여이 예제는 `EOF` 함수는 파일의 끝을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-227">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="26db1-228">이 예에서는 가정 하는 `Testfile` 은 여러 줄의 텍스트를 포함 하는 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-228">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-229">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-229">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-230">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-230">Required.</span></span> <span data-ttu-id="26db1-231"><see langword="Integer" />.</span><span class="sxs-lookup"><span data-stu-id="26db1-231"><see langword="Integer" />.</span></span> <span data-ttu-id="26db1-232">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-232">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="26db1-233"><see langword="FileOpen" /> 함수를 사용하여 연 파일의 파일 모드를 나타내는 열거형을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-233">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-234"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="FileAttr" /> 함수를 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-234">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span></span> <span data-ttu-id="26db1-235">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-235">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="26db1-236">다음 열거형 값은 파일 액세스 모드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-236">The following enumeration values indicate the file access mode:</span></span>  
  
 <span data-ttu-id="26db1-237"><list type="table"><item><term> 값</span><span class="sxs-lookup"><span data-stu-id="26db1-237"><list type="table"><item><term> Value</span></span>  
  
 <span data-ttu-id="26db1-238"></term><description> 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-238"></term><description> Mode</span></span>  
  
 <span data-ttu-id="26db1-239"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="26db1-239"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="26db1-240"></term><description><see langword="OpenMode.Input" /></description></item><item><term> 2</span><span class="sxs-lookup"><span data-stu-id="26db1-240"></term><description><see langword="OpenMode.Input" /></description></item><item><term> 2</span></span>  
  
 <span data-ttu-id="26db1-241"></term><description><see langword="OpenMode.Output" /></description></item><item><term> 4</span><span class="sxs-lookup"><span data-stu-id="26db1-241"></term><description><see langword="OpenMode.Output" /></description></item><item><term> 4</span></span>  
  
 <span data-ttu-id="26db1-242"></term><description><see langword="OpenMode.Random" /></description></item><item><term> 8</span><span class="sxs-lookup"><span data-stu-id="26db1-242"></term><description><see langword="OpenMode.Random" /></description></item><item><term> 8</span></span>  
  
 <span data-ttu-id="26db1-243"></term><description><see langword="OpenMode.Append" /></description></item><item><term> 32</span><span class="sxs-lookup"><span data-stu-id="26db1-243"></term><description><see langword="OpenMode.Append" /></description></item><item><term> 32</span></span>  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-244">사용 하 여 연 파일에 대 한 파일 모드를 나타내는 열거형을 반환 하는이 함수는 `FileOpen` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-244">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-245">사용 하 여이 예제는 `FileAttr` 함수 열려 있는 파일의 파일 모드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-245">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers"><span data-ttu-id="26db1-246">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-246">Optional.</span></span> <span data-ttu-id="26db1-247">닫을 0개 이상의 채널에 대한 매개 변수 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-247">Parameter array of 0 or more channels to be closed.</span></span></param>
        <summary><span data-ttu-id="26db1-248"><see langword="FileOpen" /> 함수를 사용하여 연 파일에 대한 입출력(I/O)을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-248">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-249"><see langword="My" />를 사용하면 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-249"><see langword="My" /> gives you better productivity and performance in file I/O operations.</span></span> <span data-ttu-id="26db1-250">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-250">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-251">`FileClose` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-251">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-252">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-252">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-253">자세한 내용은 참조 [하는 방법: StreamReader 사용 하 여 파일에서 텍스트 읽기](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[하는 방법: StreamWriter 사용 하 여 파일에 텍스트 쓰기](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), 및 [연습: 조작 파일 및 디렉터리에서 Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-253">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="26db1-254">생략 하면 `FileNumbers`, 모든 활성 파일에서 연는 `FileOpen` 함수 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-254">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="26db1-255">에 대 한 연 파일을 닫을 때 `Output` 또는 `Append`, 출력의 마지막 버퍼 해당 파일에 대 한 운영 체제 버퍼에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-255">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="26db1-256">모든 버퍼 공간 닫힌와 연결 된 파일을 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-256">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="26db1-257">경우는 `FileClose` 함수 실행 되 고, 해당 파일이 있는 파일의 연결 끝 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-257">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-258">사용 하 여이 예제는 `FileClose` 파일을 닫으려면 함수에 대 한 열린 `Input`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-258">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="26db1-259"><paramref name="FileNumber" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-259"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source"><span data-ttu-id="26db1-260">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-260">Required.</span></span> <span data-ttu-id="26db1-261">복사할 파일의 이름을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-261"><see langword="String" /> expression that specifies the name of the file to be copied.</span></span> <span data-ttu-id="26db1-262"><c>Source</c>에는 소스 파일의 디렉터리나 폴더 및 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-262"><c>Source</c> may include the directory or folder, and drive, of the source file.</span></span></param>
        <param name="Destination"><span data-ttu-id="26db1-263">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-263">Required.</span></span> <span data-ttu-id="26db1-264">대상 파일 이름을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-264"><see langword="String" /> expression that specifies the destination file name.</span></span> <span data-ttu-id="26db1-265"><c>Destination</c>에는 대상 파일의 디렉터리나 폴더 및 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-265"><c>Destination</c> may include the directory or folder, and drive, of the destination file.</span></span></param>
        <summary><span data-ttu-id="26db1-266">파일을 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-266">Copies a file.</span></span> <span data-ttu-id="26db1-267"><see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 사용하면 <see langword="FileCopy" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-267">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span></span> <span data-ttu-id="26db1-268">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-268">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-269">사용 하려는 경우는 `FileCopy` 함수 현재 열려 있는 파일에 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-269">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="26db1-270">`FileCopy` 로컬 드라이브에서 작동 하도록 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-270">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-271">사용 하 여이 예제는 `FileCopy` 하나의 파일 간에 복사 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-271">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="26db1-272">이 예제에서는 한다고 가정 `SrcFile` 는 데이터가 포함 된 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-272">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-273"><paramref name="Source" /> 또는 <paramref name="Destination" />이 잘못되었거나 지정되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-273"><paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-274">파일이 이미 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-274">File is already open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="26db1-275">파일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-275">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="26db1-276">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-276">Required.</span></span> <span data-ttu-id="26db1-277">파일 이름을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-277"><see langword="String" /> expression that specifies a file name.</span></span> <span data-ttu-id="26db1-278"><c>PathName</c>은 디렉터리 또는 폴더와 드라이브를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-278"><c>PathName</c> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="26db1-279">파일을 기록한 날짜와 시간을 나타내는 <see langword="Date" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-279">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span></span> <span data-ttu-id="26db1-280"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileDateTime" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-280">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span></span> <span data-ttu-id="26db1-281">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-281">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span></span></summary>
        <returns>
          <span data-ttu-id="26db1-282">파일을 만들거나 마지막으로 수정한 날짜와 시간을 나타내는 <see langword="Date" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-282"><see langword="Date" /> value that indicates the date and time a file was created or last modified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26db1-283">사용 하 여이 예제는 `FileDateTime` 함수는 날짜를 파일 시간을 만들거나 마지막으로 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-283">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="26db1-284">날짜 및 시간 표시의 형식은 시스템의 로캘 설정을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-284">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-285"><paramref name="PathName" />이 잘못되었거나 와일드카드를 포함하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-285"><paramref name="PathName" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="26db1-286">대상 파일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-286">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-287">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-287">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-288"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-288">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-289">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-289">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-290">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-290">Required.</span></span> <span data-ttu-id="26db1-291">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-291">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-292">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-292">Required.</span></span> <span data-ttu-id="26db1-293">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-293">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-294">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-294">Optional.</span></span> <span data-ttu-id="26db1-295">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-295">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-296">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-296">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-297"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-297">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-298">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-298">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-299">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-299">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-300">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-300">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-301">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-301">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-302">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-302">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-303">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-303">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-304">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-304">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-305">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-305">Random Mode</span></span>  
 <span data-ttu-id="26db1-306">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-306">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-307">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-307">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-308">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-308">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-309">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-309">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-310">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-310">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-311">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-311">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-312">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-312">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-313">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-313">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-314">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-314">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-315">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-315">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-316">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-316">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-317">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-317">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-318">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-318">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-319">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-319">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-320">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-320">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-321">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-321">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-322">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-322">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-323">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-323">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-324">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-324">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-325">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-325">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-326">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-326">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-327">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-327">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-328">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-328">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-329">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-329">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-330">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-330">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-331">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-331">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-332">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-332">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-333">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-333">Binary Mode</span></span>  
 <span data-ttu-id="26db1-334">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-334">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-335">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-335">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-336">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-336">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-337">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-337">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-338">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-338">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-339">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-339">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-340">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-340">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-341">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-341">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-342">사용 하 여 파일에서 읽기는`FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-342">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-343"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-343"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-344">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-344">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-345">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-345">Required.</span></span> <span data-ttu-id="26db1-346">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-346">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-347">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-347">Required.</span></span> <span data-ttu-id="26db1-348">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-348">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-349">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-349">Optional.</span></span> <span data-ttu-id="26db1-350">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-350">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-351">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-351">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-352"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-352">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-353">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-353">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-354">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-354">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-355">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-355">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-356">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-356">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-357">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-357">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-358">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-358">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-359">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-359">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-360">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-360">Random Mode</span></span>  
 <span data-ttu-id="26db1-361">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-361">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-362">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-362">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-363">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-363">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-364">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-364">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-365">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-365">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-366">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-366">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-367">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-367">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-368">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-368">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-369">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-369">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-370">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-370">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-371">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-371">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-372">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-372">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-373">설명자 사용 하지 않는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-373">If the descriptor is not used.</span></span> <span data-ttu-id="26db1-374">에 전달 된 크기와 배열 범위 다음 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-374">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-375">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-375">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-376">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-376">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-377">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-377">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-378">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-378">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-379">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-379">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-380">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-380">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-381">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-381">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-382">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-382">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-383">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-383">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-384">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-384">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-385">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-385">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-386">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-386">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-387">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-387">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-388">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-388">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-389">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-389">Binary Mode</span></span>  
 <span data-ttu-id="26db1-390">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-390">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-391">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-391">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-392">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-392">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-393">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-393">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-394">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-394">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-395">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-395">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-396">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-396">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-397">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-397">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-398">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-398">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-399"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-399"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-400">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-400">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-401">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-401">Required.</span></span> <span data-ttu-id="26db1-402">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-402">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-403">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-403">Required.</span></span> <span data-ttu-id="26db1-404">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-404">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-405">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-405">Optional.</span></span> <span data-ttu-id="26db1-406">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-406">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-407">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-407">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-408"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-408">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-409">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-409">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-410">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-410">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-411">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-411">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-412">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-412">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-413">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-413">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-414">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-414">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-415">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-415">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-416">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-416">Random Mode</span></span>  
 <span data-ttu-id="26db1-417">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-417">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-418">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-418">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-419">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-419">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-420">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-420">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-421">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-421">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-422">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-422">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-423">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-423">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-424">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-424">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-425">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-425">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-426">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-426">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-427">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-427">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-428">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-428">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-429">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-429">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-430">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-430">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-431">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-431">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-432">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-432">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-433">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-433">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-434">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-434">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-435">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-435">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-436">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-436">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-437">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-437">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-438">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-438">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-439">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-439">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-440">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-440">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-441">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-441">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-442">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-442">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-443">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-443">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-444">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-444">Binary Mode</span></span>  
 <span data-ttu-id="26db1-445">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-445">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-446">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-446">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-447">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-447">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-448">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-448">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-449">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-449">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-450">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-450">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-451">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-451">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-452">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-452">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-453">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-453">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-454"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-454"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-455">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-455">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-456">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-456">Required.</span></span> <span data-ttu-id="26db1-457">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-457">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-458">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-458">Required.</span></span> <span data-ttu-id="26db1-459">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-459">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-460">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-460">Optional.</span></span> <span data-ttu-id="26db1-461">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-461">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-462">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-462">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-463"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-463">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-464">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-464">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-465">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-465">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-466">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-466">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-467">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-467">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-468">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-468">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-469">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-469">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-470">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-470">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-471">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-471">Random Mode</span></span>  
 <span data-ttu-id="26db1-472">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-472">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-473">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수`FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-473">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-474">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-474">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-475">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-475">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-476">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-476">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-477">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-477">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-478">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-478">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-479">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-479">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-480">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-480">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-481">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-481">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-482">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-482">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-483">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-483">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-484">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-484">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-485">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-485">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-486">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-486">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-487">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-487">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-488">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-488">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-489">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-489">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-490">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-490">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-491">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-491">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-492">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-492">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-493">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-493">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-494">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-494">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-495">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-495">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-496">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-496">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-497">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-497">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-498">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-498">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-499">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-499">Binary Mode</span></span>  
 <span data-ttu-id="26db1-500">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-500">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-501">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-501">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-502">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-502">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-503">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-503">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-504">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-504">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-505">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-505">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-506">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-506">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-507">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-507">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-508">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-508">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-509"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-509"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-510">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-510">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-511">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-511">Required.</span></span> <span data-ttu-id="26db1-512">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-512">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-513">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-513">Required.</span></span> <span data-ttu-id="26db1-514">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-514">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-515">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-515">Optional.</span></span> <span data-ttu-id="26db1-516">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-516">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-517">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-517">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-518"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-518">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-519">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-519">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-520">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-520">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-521">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-521">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-522">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-522">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-523">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-523">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-524">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-524">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-525">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-525">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-526">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-526">Random Mode</span></span>  
 <span data-ttu-id="26db1-527">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-527">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-528">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-528">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-529">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-529">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-530">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-530">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-531">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-531">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-532">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-532">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-533">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-533">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-534">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-534">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-535">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-535">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-536">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-536">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-537">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-537">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-538">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-538">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-539">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-539">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-540">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-540">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-541">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-541">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-542">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-542">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-543">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-543">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-544">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-544">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-545">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-545">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-546">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-546">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-547">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-547">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-548">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-548">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-549">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-549">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-550">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-550">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-551">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-551">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-552">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-552">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-553">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-553">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-554">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-554">Binary Mode</span></span>  
 <span data-ttu-id="26db1-555">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-555">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-556">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-556">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-557">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-557">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-558">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-558">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-559">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-559">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-560">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-560">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-561">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-561">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-562">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-562">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-563">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-563">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-564"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-564"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-565">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-565">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-566">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-566">Required.</span></span> <span data-ttu-id="26db1-567">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-567">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-568">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-568">Required.</span></span> <span data-ttu-id="26db1-569">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-569">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-570">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-570">Optional.</span></span> <span data-ttu-id="26db1-571">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-571">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-572">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-572">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-573"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-573">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-574">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-574">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-575">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-575">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-576">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-576">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-577">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-577">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-578">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-578">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-579">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-579">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-580">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-580">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-581">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-581">Random Mode</span></span>  
 <span data-ttu-id="26db1-582">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-582">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-583">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-583">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-584">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-584">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-585">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-585">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-586">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-586">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-587">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-587">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-588">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-588">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-589">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-589">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-590">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-590">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-591">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-591">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-592">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-592">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-593">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-593">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-594">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-594">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-595">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-595">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-596">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-596">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-597">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-597">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-598">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-598">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-599">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-599">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-600">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-600">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-601">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-601">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-602">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-602">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-603">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-603">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-604">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-604">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-605">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-605">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-606">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-606">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-607">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-607">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-608">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-608">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-609">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-609">Binary Mode</span></span>  
 <span data-ttu-id="26db1-610">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-610">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-611">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-611">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-612">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-612">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-613">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-613">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-614">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-614">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-615">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-615">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-616">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-616">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-617">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-617">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-618">사용 하 여 파일에서 읽기는`FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-618">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-619"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-619"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-620">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-620">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-621">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-621">Required.</span></span> <span data-ttu-id="26db1-622">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-622">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-623">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-623">Required.</span></span> <span data-ttu-id="26db1-624">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-624">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-625">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-625">Optional.</span></span> <span data-ttu-id="26db1-626">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-626">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-627">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-627">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-628"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-628">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-629">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-629">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-630">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-630">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-631">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-631">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-632">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-632">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-633">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-633">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-634">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-634">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-635">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-635">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-636">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-636">Random Mode</span></span>  
 <span data-ttu-id="26db1-637">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-637">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-638">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-638">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-639">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-639">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-640">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-640">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-641">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-641">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-642">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-642">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-643">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-643">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-644">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-644">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-645">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-645">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-646">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-646">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-647">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-647">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-648">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-648">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-649">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-649">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-650">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-650">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-651">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-651">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-652">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-652">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-653">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-653">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-654">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-654">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-655">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-655">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-656">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-656">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-657">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-657">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-658">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-658">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-659">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-659">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-660">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-660">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-661">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-661">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-662">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-662">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-663">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-663">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-664">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-664">Binary Mode</span></span>  
 <span data-ttu-id="26db1-665">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-665">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-666">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-666">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-667">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-667">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-668">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-668">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-669">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-669">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-670">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-670">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-671">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-671">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-672">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-672">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-673">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-673">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-674"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-674"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-675">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-675">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-676">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-676">Required.</span></span> <span data-ttu-id="26db1-677">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-677">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-678">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-678">Required.</span></span> <span data-ttu-id="26db1-679">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-679">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-680">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-680">Optional.</span></span> <span data-ttu-id="26db1-681">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-681">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-682">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-682">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-683"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-683">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-684">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-684">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-685">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-685">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-686">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-686">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-687">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-687">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-688">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-688">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-689">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-689">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-690">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-690">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-691">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-691">Random Mode</span></span>  
 <span data-ttu-id="26db1-692">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-692">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-693">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-693">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-694">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-694">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-695">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-695">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-696">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-696">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-697">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-697">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-698">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-698">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-699">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-699">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-700">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-700">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-701">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-701">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-702">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-702">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-703">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-703">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-704">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-704">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-705">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-705">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-706">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-706">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-707">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-707">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-708">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-708">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-709">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-709">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-710">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-710">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-711">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-711">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-712">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-712">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-713">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-713">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-714">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-714">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-715">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-715">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-716">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-716">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-717">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-717">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-718">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-718">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-719">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-719">Binary Mode</span></span>  
 <span data-ttu-id="26db1-720">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-720">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-721">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-721">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-722">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-722">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-723">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-723">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-724">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-724">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-725">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-725">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-726">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-726">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-727">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-727">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-728">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-728">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-729"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-729"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-730">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-730">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-731">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-731">Required.</span></span> <span data-ttu-id="26db1-732">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-732">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-733">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-733">Required.</span></span> <span data-ttu-id="26db1-734">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-734">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-735">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-735">Optional.</span></span> <span data-ttu-id="26db1-736">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-736">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-737">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-737">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-738"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-738">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-739">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-739">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-740">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-740">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-741">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-741">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-742">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-742">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-743">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-743">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-744">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-744">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-745">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-745">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-746">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-746">Random Mode</span></span>  
 <span data-ttu-id="26db1-747">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-747">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-748">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-748">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-749">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-749">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-750">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-750">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-751">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-751">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-752">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-752">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-753">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-753">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-754">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-754">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-755">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-755">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-756">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-756">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-757">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-757">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-758">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-758">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-759">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-759">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-760">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-760">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-761">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-761">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-762">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-762">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-763">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-763">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-764">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-764">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-765">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-765">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-766">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-766">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-767">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-767">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-768">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-768">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-769">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-769">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-770">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-770">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-771">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-771">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-772">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-772">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-773">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-773">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-774">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-774">Binary Mode</span></span>  
 <span data-ttu-id="26db1-775">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-775">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-776">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-776">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-777">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-777">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-778">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-778">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-779">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-779">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-780">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-780">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-781">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-781">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-782">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-782">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-783">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-783">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-784"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-784"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-785">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-785">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-786">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-786">Required.</span></span> <span data-ttu-id="26db1-787">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-787">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-788">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-788">Required.</span></span> <span data-ttu-id="26db1-789">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-789">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-790">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-790">Optional.</span></span> <span data-ttu-id="26db1-791">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-791">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-792">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-792">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-793"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-793">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-794">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-794">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-795">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-795">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-796">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-796">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-797">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-797">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-798">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-798">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-799">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-799">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-800">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-800">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-801">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-801">Random Mode</span></span>  
 <span data-ttu-id="26db1-802">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-802">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-803">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-803">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-804">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-804">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-805">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-805">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-806">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-806">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-807">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-807">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-808">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-808">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-809">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-809">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-810">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-810">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-811">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-811">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-812">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-812">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-813">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-813">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-814">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-814">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-815">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-815">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-816">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-816">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-817">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-817">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-818">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-818">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-819">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-819">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-820">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-820">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-821">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-821">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-822">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-822">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-823">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-823">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-824">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-824">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-825">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-825">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-826">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-826">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-827">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-827">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-828">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-828">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-829">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-829">Binary Mode</span></span>  
 <span data-ttu-id="26db1-830">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-830">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-831">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-831">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-832">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-832">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-833">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-833">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-834">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-834">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-835">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-835">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-836">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-836">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-837">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-837">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-838">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-838">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-839"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-839"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-840">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-840">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-841">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-841">Required.</span></span> <span data-ttu-id="26db1-842">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-842">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-843">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-843">Required.</span></span> <span data-ttu-id="26db1-844">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-844">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-845">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-845">Optional.</span></span> <span data-ttu-id="26db1-846">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-846">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-847">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-847">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-848"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-848">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-849">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-849">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-850">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-850">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-851">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-851">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-852">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-852">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-853">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-853">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-854">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-854">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-855">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-855">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-856">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-856">Random Mode</span></span>  
 <span data-ttu-id="26db1-857">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-857">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-858">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-858">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-859">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-859">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-860">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-860">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-861">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-861">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-862">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-862">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-863">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-863">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-864">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-864">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-865">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-865">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-866">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-866">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-867">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-867">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-868">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-868">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-869">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-869">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-870">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-870">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-871">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-871">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-872">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-872">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-873">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-873">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-874">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-874">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-875">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-875">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-876">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-876">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-877">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-877">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-878">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-878">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-879">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-879">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-880">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-880">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-881">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-881">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-882">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-882">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-883">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-883">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-884">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-884">Binary Mode</span></span>  
 <span data-ttu-id="26db1-885">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-885">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-886">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-886">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-887">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-887">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-888">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-888">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-889">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-889">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-890">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-890">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-891">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-891">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-892">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-892">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-893">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-893">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-894"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-894"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-895">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-895">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-896">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-896">Required.</span></span> <span data-ttu-id="26db1-897">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-897">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-898">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-898">Required.</span></span> <span data-ttu-id="26db1-899">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-899">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-900">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-900">Optional.</span></span> <span data-ttu-id="26db1-901">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-901">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="26db1-902">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-902">Optional.</span></span> <span data-ttu-id="26db1-903">문자열을 쓰는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-903">Applies only when writing a string.</span></span> <span data-ttu-id="26db1-904">길이를 설명하는 문자열에 대해 2바이트 설명자를 쓸 것인지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-904">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="26db1-905">기본값은 <see langword="False" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-905">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="26db1-906">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-906">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-907"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-907">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-908">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-908">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-909">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-909">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-910">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-910">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-911">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-911">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-912">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-912">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-913">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-913">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-914">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-914">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-915">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-915">Random Mode</span></span>  
 <span data-ttu-id="26db1-916">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-916">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-917">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-917">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-918">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-918">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-919">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-919">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-920">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-920">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-921">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-921">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-922">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-922">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-923">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-923">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-924">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-924">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-925">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-925">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-926">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-926">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-927">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-927">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-928">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-928">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-929">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-929">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-930">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-930">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-931">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-931">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-932">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-932">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-933">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-933">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-934">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-934">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-935">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-935">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-936">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-936">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-937">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-937">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-938">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-938">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-939">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-939">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-940">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-940">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-941">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-941">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-942">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-942">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-943">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-943">Binary Mode</span></span>  
 <span data-ttu-id="26db1-944">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-944">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-945">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-945">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-946">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-946">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-947">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-947">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-948">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-948">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-949">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-949">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-950">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-950">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-951">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-951">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-952">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-952">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-953"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-953"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-954">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-954">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-955">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-955">Required.</span></span> <span data-ttu-id="26db1-956">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-956">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-957">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-957">Required.</span></span> <span data-ttu-id="26db1-958">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-958">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-959">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-959">Optional.</span></span> <span data-ttu-id="26db1-960">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-960">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="26db1-961">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-961">Optional.</span></span> <span data-ttu-id="26db1-962">배열을 쓰는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-962">Applies only when writing an array.</span></span> <span data-ttu-id="26db1-963">배열을 동적으로 처리할 것인지의 여부와 배열의 크기와 범위를 설명하는 배열 설명자가 필요한지의 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-963">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="26db1-964">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-964">Optional.</span></span> <span data-ttu-id="26db1-965">문자열을 쓰는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-965">Applies only when writing a string.</span></span> <span data-ttu-id="26db1-966">길이를 설명하는 문자열에 대해 2바이트 설명자를 쓸 것인지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-966">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="26db1-967">기본값은 <see langword="False" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-967">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="26db1-968">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-968">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="26db1-969"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGet" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-969">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="26db1-970">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-970">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-971">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-971">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-972">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-972">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="26db1-973">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-973">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-974">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-974">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-975">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-975">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-976">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-976">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-977">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-977">Random Mode</span></span>  
 <span data-ttu-id="26db1-978">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-978">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-979">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-979">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-980">하나의 레코드의 끝와 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-980">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-981">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-981">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-982">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-982">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-983">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-983">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-984">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-984">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-985">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-985">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-986">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-986">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="26db1-987">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-987">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-988">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-988">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="26db1-989">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-989">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="26db1-990">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-990">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="26db1-991">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-991">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-992">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-992">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-993">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-993">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-994">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-994">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="26db1-995">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-995">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="26db1-996">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="26db1-996">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="26db1-997">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="26db1-997">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="26db1-998">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-998">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="26db1-999">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-999">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-1000">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1000">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-1001">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1001">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1002">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1002">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="26db1-1003">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1003">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-1004">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1004">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1005">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1005">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1006">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1006">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1007">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1007">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1008">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1008">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1009">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1009">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1010">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1010">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="26db1-1011">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1011">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="26db1-1012">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1012">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1013">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1013">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="26db1-1014">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1014">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1015"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1015"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1016">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1016">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1017">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1017">Required.</span></span> <span data-ttu-id="26db1-1018">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1018">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1019">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1019">Required.</span></span> <span data-ttu-id="26db1-1020">데이터를 읽어오는 올바른 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1020">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1021">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1021">Optional.</span></span> <span data-ttu-id="26db1-1022">읽기가 시작되는 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 번호(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1022">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1023">열린 디스크 파일의 데이터를 변수로 읽어옵니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1023">Reads data from an open disk file into a variable.</span></span>  <span data-ttu-id="26db1-1024"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileGetObject" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1024">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span></span> <span data-ttu-id="26db1-1025">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1025">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1026">`FileGetObject` 함수 대신 사용 됩니다 `FileGet` 경우 컴파일 타임에 모호성을 피할 수 형식 `Object` 와 같은 다른 형식 대신 반환 `Integer`, `Long`, `Short`, 등입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1026">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="26db1-1027">작성 하려는 경우는 `Variant` 형식 `FileGetObject` 가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1027">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="26db1-1028">확실 하지 않은, 두 번째 매개 변수에 대 한 개체 사용 중인 경우, 항상 좋습니다를 사용 하는 `FilePutObject` 및 `FileGetObject`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1028">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="26db1-1029">`FileGetObject` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1029">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1030">데이터를 읽을 `FileGetObject` 일반적으로 작성 된 `FilePutObject`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1030">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="26db1-1031">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1031">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1032">생략 하면 `RecordNumber`, `FileGetObject` 마지막 뒤 레코드 또는 바이트를 읽고 `FileGetObject` 또는 `FilePutObject` 함수 (또는 마지막에서 가리키는 `Seek` 함수).</span><span class="sxs-lookup"><span data-stu-id="26db1-1032">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1033">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1033">Random Mode</span></span>  
 <span data-ttu-id="26db1-1034">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1034">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1035">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGetObject` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1035">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1036">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1036">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1037">채워지는 데이터의 양은 정확 하 게 확인할 수 없습니다, 되므로 레코드 길이 읽을 데이터의 길이 일치 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1037">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="26db1-1038">읽을 변수가 기본적으로는 문자열이 `FileGetObject` 문자열 길이 포함 하는 2 바이트 설명자를 읽고 다음 변수에 전달 되는 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1038">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1039">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1039">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1040">Visual Basic 6.0 및 이전 버전에서는 고정 길이 문자열을 파일을 읽을 때 길이 설명자는 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1040">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="26db1-1041">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1041">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1042">으로 읽고 배열에 되 면 변수로 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1042">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1043">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1043">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1044">길이 2 + 8 시간 차원 수가: 2 + 8 \* 더한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1044">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="26db1-1045">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에:</span><span class="sxs-lookup"><span data-stu-id="26db1-1045">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="26db1-1046">218 바이트가 다음과 같이 배포 됩니다: (2 + 8 \* 2) 설명자에 대 한 18 바이트 및 (4 \* 5 \* 10) 데이터에 대 한 100 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1046">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="26db1-1047">`FileGetObject` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1047">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="26db1-1048">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePutObject`)는 설명자가 2 더하기 8 시간 차원 수가 옵니다: 2 + 8 \* 더한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1048">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="26db1-1049">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 모든 배열과 그 설명자를 포함 하 여 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1049">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="26db1-1050"><xref:Microsoft.VisualBasic.VBFixedStringAttribute> 클래스를 쓸 때 문자열의 크기를 나타내는 구조체의 string 필드에 적용할 수 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1050">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1051">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1051">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1052">연 파일에 `Binary` 모드의 모든는 `Random` 경우를이 제외 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1052">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="26db1-1053">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1053">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1054">`FileGetObject` 변수를 읽습니다 모든 디스크에서 연속적으로 즉, 레코드 간에 데이터가 채워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1054">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1055">구조에 포함 되지 않은 모든 배열에 대 한 `FileGetObject` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1055">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="26db1-1056">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1056">No descriptor is read.</span></span>  
  
 <span data-ttu-id="26db1-1057">`FileGetObject` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1057">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1058">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1058">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-1059">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1059">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-1060">예를 들어 Form1.vb 파일이 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1060">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1061">다음 예제에서는 레코드를 읽고 테스트 파일에 다음이 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1061">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="26db1-1062">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1062">Required.</span></span> <span data-ttu-id="26db1-1063">파일을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1063"><see langword="String" /> expression that specifies a file.</span></span> <span data-ttu-id="26db1-1064"><c>PathName</c>은 디렉터리 또는 폴더와 드라이브를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1064"><c>PathName</c> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="26db1-1065">파일 길이를 바이트로 지정하는 <see langword="Long" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1065">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span></span> <span data-ttu-id="26db1-1066"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileLen" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1066">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span></span> <span data-ttu-id="26db1-1067">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1067">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span></span></summary>
        <returns>
          <span data-ttu-id="26db1-1068">파일 길이를 바이트 단위로 지정하는 <see langword="Long" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1068"><see langword="Long" /> value that specifies the length of a file in bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1069">지정 된 파일은 열려 있는 경우는 `FileLen` 함수 호출 되 면 반환 된 값으로 열었을 때 파일의 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1069">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-1070">열려 있는 파일의 현재 길이 가져오려면는 `LOF` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1070">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1071">사용 하 여이 예제는 `FileLen` 함수를 파일의 길이 바이트 단위로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1071">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="26db1-1072">이 예제에서는 한다고 가정 `TestFile` 은 일부 데이터를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1072">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="26db1-1073">파일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1073">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1074">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1074">Required.</span></span> <span data-ttu-id="26db1-1075">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1075">Any valid file number.</span></span> <span data-ttu-id="26db1-1076">다음으로 사용 가능한 파일 번호를 가져오려면 <see langword="FreeFile" /> 함수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1076">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span></span></param>
        <param name="FileName"><span data-ttu-id="26db1-1077">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1077">Required.</span></span> <span data-ttu-id="26db1-1078">파일 이름을 지정하는 <see langword="String" /> 식으로, 디렉터리나 폴더 및 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1078"><see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span></span></param>
        <param name="Mode"><span data-ttu-id="26db1-1079">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1079">Required.</span></span> <span data-ttu-id="26db1-1080"><see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, <see langword="Random" /> 등의 파일 모드를 지정하는 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1080">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span></span> <span data-ttu-id="26db1-1081">자세한 내용은 <see cref="T:Microsoft.VisualBasic.OpenMode" />을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-1081">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span></span></param>
        <param name="Access"><span data-ttu-id="26db1-1082">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1082">Optional.</span></span> <span data-ttu-id="26db1-1083"><see langword="Read" />, <see langword="Write" />, <see langword="ReadWrite" /> 등 열려 있는 파일에 허용되는 작업을 지정하는 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1083">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span></span> <span data-ttu-id="26db1-1084">기본값은 <see langword="ReadWrite" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1084">Defaults to <see langword="ReadWrite" />.</span></span> <span data-ttu-id="26db1-1085">자세한 내용은 <see cref="T:Microsoft.VisualBasic.OpenAccess" />을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-1085">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span></span></param>
        <param name="Share"><span data-ttu-id="26db1-1086">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1086">Optional.</span></span> <span data-ttu-id="26db1-1087"><see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, <see langword="Lock Read Write" /> 등 열려 있는 파일에 대해 다른 프로세스에 허용되지 않는 작업을 지정하는 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1087">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="26db1-1088">기본값은 <see langword="Lock Read Write" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1088">Defaults to <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="26db1-1089">자세한 내용은 <see cref="T:Microsoft.VisualBasic.OpenShare" />을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-1089">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span></span></param>
        <param name="RecordLength"><span data-ttu-id="26db1-1090">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1090">Optional.</span></span> <span data-ttu-id="26db1-1091">32,767(바이트)보다 작거나 같은 수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1091">Number less than or equal to 32,767 (bytes).</span></span> <span data-ttu-id="26db1-1092">임의 액세스용으로 연 파일의 경우 이 값은 레코드 길이가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1092">For files opened for random access, this value is the record length.</span></span> <span data-ttu-id="26db1-1093">순차 파일의 경우 이 값은 버퍼링된 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1093">For sequential files, this value is the number of characters buffered.</span></span></param>
        <summary><span data-ttu-id="26db1-1094">입력 또는 출력할 파일을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1094">Opens a file for input or output.</span></span> <span data-ttu-id="26db1-1095"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileOpen" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1095">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span></span> <span data-ttu-id="26db1-1096">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1096">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1097">`FileOpen` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1097">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-1098">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1098">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-1099">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1099">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-1100">I/O 작업을 수행 하려면 먼저 파일을 열어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1100">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="26db1-1101">`FileOpen` 파일 I/O에 대 한 버퍼를 할당 하 고 버퍼와 함께 사용할 액세스 모드를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1101">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-1102">파일에 쓸 때 응용 프로그램 만들어야 할 수 파일을 작성 하려는 파일이 존재 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="26db1-1102">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="26db1-1103">이렇게 하려면 해당 파일이 만들어질 된 디렉터리에 대 한 권한이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1103">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="26db1-1104">그러나 하 여 지정한 파일이 있으면 `FileName` 존재 않는 응용 프로그램 요구 `Write` 파일 자체에 사용 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1104">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="26db1-1105">보안을 강화 하려면 가능한, 배포 및 부여 하는 동안 파일을 만들고 하는 아무 곳에 나 `Write` 해당 파일에 대 한 전체 디렉터리 대신만 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1105">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="26db1-1106">보안 향상을 위해 대신 사용자 디렉터리의 루트 디렉터리 또는 Program Files 디렉터리에 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1106">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="26db1-1107">사용 하 여 열려는 채널을 찾을 수 있습니다는 `FreeFile()` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1107">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-1108">`FileOpen` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1108">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="26db1-1109">자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1109">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1110">다양 한 용도 보여 주는이 예제는 `FileOpen` 함수를 입력 및 출력 파일을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1110">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="26db1-1111">다음 코드 파일을 열고 `TestFile` 에 `Input` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1111">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="26db1-1112">이 예제에서 파일을 열고 `Binary` 쓰기 작업용 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1112">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="26db1-1113">다음 예제에서는의 파일을 엽니다 `Random` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1113">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="26db1-1114">해당 파일의 구조는 레코드가 포함 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1114">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="26db1-1115">이 코드 예제에서 파일을 열고 `Output` 모드; 읽거나 파일에 쓸 모든 프로세스 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1115">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="26db1-1116">이 코드 예제에서 파일을 열고 `Binary` 읽기에 대 한 모드 다른 프로세스가 파일을 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1116">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="26db1-1117">레코드 길이가 음수입니다(–1은 아님).</span><span class="sxs-lookup"><span data-stu-id="26db1-1117">Record length is negative (and not equal to -1).</span></span></exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="26db1-1118"><paramref name="FileName" />이 이미 열려 있거나 <paramref name="FileName" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1118"><paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-1119">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1119">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1120"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1120">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1121">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-1121">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1122">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1122">Required.</span></span> <span data-ttu-id="26db1-1123">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1123">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1124">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1124">Required.</span></span> <span data-ttu-id="26db1-1125">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1125">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1126">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1126">Optional.</span></span> <span data-ttu-id="26db1-1127">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1127">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1128">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1128">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1129"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1129">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1130">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1130">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1131">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1131">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1132">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1132">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1133">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1133">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1134">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1134">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1135">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1135">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1136">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1136">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1137">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1137">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1138">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1138">Random Mode</span></span>  
 <span data-ttu-id="26db1-1139">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1139">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1140">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1140">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1141">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1141">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1142">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1142">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1143">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1143">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1144">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1144">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1145">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1145">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1146">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1146">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1147">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1147">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1148">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1148">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1149">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1149">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1150">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1150">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1151">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1151">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1152">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1152">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1153">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1153">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1154">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1154">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1155">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1155">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1156">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1156">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1157">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1157">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1158">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1158">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1159">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1159">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1160">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1160">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1161">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1161">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1162">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1162">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1163">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1163">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1164">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1164">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1165">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1165">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1166">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1166">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1167">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1167">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1168">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1168">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1169">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1169">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1170">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1170">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1171">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1171">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1172">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1172">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1173">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1173">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1174">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1174">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1175">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1175">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1176">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1176">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1177">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1177">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1178">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1178">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1179"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1179"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1180">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1180">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1181">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1181">Required.</span></span> <span data-ttu-id="26db1-1182">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1182">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1183">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1183">Required.</span></span> <span data-ttu-id="26db1-1184">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1184">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1185">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1185">Optional.</span></span> <span data-ttu-id="26db1-1186">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1186">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1187">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1187">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1188"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1188">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1189">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1189">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1190">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1190">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1191">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1191">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1192">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1192">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1193">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1193">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1194">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1194">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1195">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1195">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1196">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1196">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1197">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1197">Random Mode</span></span>  
 <span data-ttu-id="26db1-1198">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1198">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1199">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1199">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1200">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1200">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1201">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1201">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1202">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1202">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1203">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1203">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1204">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1204">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1205">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1205">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1206">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1206">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1207">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1207">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1208">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1208">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1209">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1209">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1210">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1210">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1211">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1211">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1212">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1212">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1213">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1213">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1214">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1214">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1215">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1215">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1216">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1216">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1217">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1217">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1218">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1218">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1219">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1219">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1220">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1220">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1221">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1221">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1222">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1222">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1223">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1223">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1224">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1224">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1225">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1225">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1226">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1226">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1227">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1227">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1228">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1228">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1229">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1229">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1230">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1230">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1231">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1231">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1232">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1232">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1233">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1233">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1234">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1234">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1235">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1235">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1236">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1236">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1237">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1237">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1238"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1238"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1239">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1239">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1240">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1240">Required.</span></span> <span data-ttu-id="26db1-1241">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1241">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1242">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1242">Required.</span></span> <span data-ttu-id="26db1-1243">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1243">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1244">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1244">Optional.</span></span> <span data-ttu-id="26db1-1245">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1245">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1246">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1246">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1247"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1247">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1248">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1248">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1249">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1249">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1250">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1250">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1251">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1251">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1252">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1252">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1253">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1253">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1254">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1254">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1255">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1255">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1256">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1256">Random Mode</span></span>  
 <span data-ttu-id="26db1-1257">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1257">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1258">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1258">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1259">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1259">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1260">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1260">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1261">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1261">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1262">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1262">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1263">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1263">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1264">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1264">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1265">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1265">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1266">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1266">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1267">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1267">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1268">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1268">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1269">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1269">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1270">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1270">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1271">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1271">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1272">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1272">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1273">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1273">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1274">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1274">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1275">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1275">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1276">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1276">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1277">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1277">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1278">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1278">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1279">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1279">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1280">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1280">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1281">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1281">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1282">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1282">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1283">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1283">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1284">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1284">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1285">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1285">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1286">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1286">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1287">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1287">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1288">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1288">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1289">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1289">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1290">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1290">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1291">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1291">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1292">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1292">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1293">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1293">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1294">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1294">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1295">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1295">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1296">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1296">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1297"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1297"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1298">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1298">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1299">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1299">Required.</span></span> <span data-ttu-id="26db1-1300">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1300">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1301">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1301">Required.</span></span> <span data-ttu-id="26db1-1302">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1302">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1303">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1303">Optional.</span></span> <span data-ttu-id="26db1-1304">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1304">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1305">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1305">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1306"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1306">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1307">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1307">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1308">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1308">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1309">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1309">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1310">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1310">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1311">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1311">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1312">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1312">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1313">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1313">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1314">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1314">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1315">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1315">Random Mode</span></span>  
 <span data-ttu-id="26db1-1316">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1316">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1317">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1317">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1318">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1318">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1319">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1319">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1320">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1320">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1321">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1321">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1322">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1322">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1323">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1323">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1324">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1324">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1325">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1325">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1326">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1326">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1327">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1327">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1328">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1328">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1329">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1329">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1330">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1330">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1331">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1331">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1332">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1332">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1333">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1333">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1334">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1334">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1335">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1335">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1336">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1336">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1337">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1337">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1338">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1338">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1339">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1339">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1340">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1340">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1341">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1341">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1342">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1342">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1343">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1343">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1344">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1344">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1345">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1345">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1346">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1346">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1347">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1347">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1348">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1348">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1349">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1349">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1350">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1350">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1351">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1351">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1352">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1352">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1353">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1353">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1354">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1354">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1355">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1355">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1356"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1356"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1357">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1357">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1358">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1358">Required.</span></span> <span data-ttu-id="26db1-1359">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1359">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1360">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1360">Required.</span></span> <span data-ttu-id="26db1-1361">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1361">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1362">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1362">Optional.</span></span> <span data-ttu-id="26db1-1363">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1363">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1364">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1364">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1365"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1365">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1366">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1366">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1367">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1367">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1368">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1368">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1369">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1369">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1370">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1370">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1371">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1371">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1372">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1372">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1373">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1373">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1374">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1374">Random Mode</span></span>  
 <span data-ttu-id="26db1-1375">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1375">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1376">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1376">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1377">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1377">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1378">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1378">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1379">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1379">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1380">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1380">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1381">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1381">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1382">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1382">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1383">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1383">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1384">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1384">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1385">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1385">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1386">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1386">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1387">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1387">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1388">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1388">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1389">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1389">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1390">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1390">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1391">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1391">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1392">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1392">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1393">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1393">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1394">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1394">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1395">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1395">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1396">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1396">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1397">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1397">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1398">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1398">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1399">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1399">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1400">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1400">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1401">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1401">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1402">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1402">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1403">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1403">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1404">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1404">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1405">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1405">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1406">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1406">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1407">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1407">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1408">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1408">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1409">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1409">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1410">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1410">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1411">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1411">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1412">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1412">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1413">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1413">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1414">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1414">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1415"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1415"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1416">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1416">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1417">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1417">Required.</span></span> <span data-ttu-id="26db1-1418">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1418">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1419">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1419">Required.</span></span> <span data-ttu-id="26db1-1420">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1420">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1421">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1421">Optional.</span></span> <span data-ttu-id="26db1-1422">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1422">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1423">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1423">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1424"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1424">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1425">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1425">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1426">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1426">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1427">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1427">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1428">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1428">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1429">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1429">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1430">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1430">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1431">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1431">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1432">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1432">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1433">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1433">Random Mode</span></span>  
 <span data-ttu-id="26db1-1434">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1434">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1435">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1435">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1436">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1436">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1437">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1437">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1438">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1438">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1439">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1439">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1440">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1440">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1441">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1441">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1442">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1442">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1443">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1443">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1444">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1444">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1445">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1445">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1446">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1446">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1447">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1447">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1448">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1448">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1449">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1449">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1450">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1450">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1451">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1451">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1452">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1452">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1453">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1453">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1454">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1454">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1455">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1455">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1456">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1456">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1457">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1457">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1458">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1458">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1459">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1459">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1460">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1460">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1461">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1461">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1462">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1462">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1463">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1463">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1464">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1464">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1465">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1465">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1466">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1466">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1467">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1467">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1468">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1468">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1469">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1469">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1470">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1470">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1471">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1471">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1472">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1472">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1473">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1473">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1474"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1474"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1475">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1475">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1476">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1476">Required.</span></span> <span data-ttu-id="26db1-1477">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1477">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1478">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1478">Required.</span></span> <span data-ttu-id="26db1-1479">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1479">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1480">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1480">Optional.</span></span> <span data-ttu-id="26db1-1481">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1481">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1482">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1482">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1483"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1483">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1484">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1484">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1485">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1485">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1486">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1486">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1487">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1487">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1488">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1488">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1489">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1489">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1490">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1490">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1491">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1491">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1492">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1492">Random Mode</span></span>  
 <span data-ttu-id="26db1-1493">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1493">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1494">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1494">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1495">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1495">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1496">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1496">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1497">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1497">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1498">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1498">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1499">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1499">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1500">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1500">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1501">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1501">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1502">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1502">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1503">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는`VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1503">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1504">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1504">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1505">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1505">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1506">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1506">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1507">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1507">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1508">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1508">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1509">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1509">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1510">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1510">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1511">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1511">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1512">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1512">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1513">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1513">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1514">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1514">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1515">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1515">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1516">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1516">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1517">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1517">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1518">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1518">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1519">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1519">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1520">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1520">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1521">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1521">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1522">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1522">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1523">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1523">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1524">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1524">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1525">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1525">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1526">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1526">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1527">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1527">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1528">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1528">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1529">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1529">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1530">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1530">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1531">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1531">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1532">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1532">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1533"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1533"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1534">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1534">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1535">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1535">Required.</span></span> <span data-ttu-id="26db1-1536">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1536">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1537">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1537">Required.</span></span> <span data-ttu-id="26db1-1538">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1538">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1539">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1539">Optional.</span></span> <span data-ttu-id="26db1-1540">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1540">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1541">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1541">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1542"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1542">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1543">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1543">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1544">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1544">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1545">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1545">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1546">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1546">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1547">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1547">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1548">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1548">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1549">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1549">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1550">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1550">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1551">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1551">Random Mode</span></span>  
 <span data-ttu-id="26db1-1552">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1552">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1553">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1553">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1554">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1554">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1555">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1555">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1556">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1556">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1557">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1557">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1558">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1558">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1559">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1559">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1560">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1560">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1561">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1561">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1562">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1562">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1563">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1563">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1564">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1564">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1565">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1565">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1566">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1566">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1567">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1567">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1568">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1568">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1569">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1569">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1570">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1570">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1571">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1571">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1572">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1572">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1573">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1573">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1574">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1574">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1575">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1575">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1576">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1576">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1577">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1577">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1578">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1578">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1579">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1579">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1580">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1580">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1581">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1581">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1582">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1582">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1583">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1583">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1584">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1584">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1585">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1585">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1586">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1586">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1587">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1587">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1588">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1588">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1589">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1589">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1590">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1590">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1591">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1591">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1592"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1592"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1593">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1593">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1594">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1594">Required.</span></span> <span data-ttu-id="26db1-1595">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1595">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1596">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1596">Required.</span></span> <span data-ttu-id="26db1-1597">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1597">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1598">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1598">Optional.</span></span> <span data-ttu-id="26db1-1599">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1599">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1600">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1600">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1601"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1601">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1602">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1602">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1603">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1603">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1604">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1604">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1605">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1605">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1606">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1606">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1607">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1607">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1608">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1608">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1609">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1609">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1610">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1610">Random Mode</span></span>  
 <span data-ttu-id="26db1-1611">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1611">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1612">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1612">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1613">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1613">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1614">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1614">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1615">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1615">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1616">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1616">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1617">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1617">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1618">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1618">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1619">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1619">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1620">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1620">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1621">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1621">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1622">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1622">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1623">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1623">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1624">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1624">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1625">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1625">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1626">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1626">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1627">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1627">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1628">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1628">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1629">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1629">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1630">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1630">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1631">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1631">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1632">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1632">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1633">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1633">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1634">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1634">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1635">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1635">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1636">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1636">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1637">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1637">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1638">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1638">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1639">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1639">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1640">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1640">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1641">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1641">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1642">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1642">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1643">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1643">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1644">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1644">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1645">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1645">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1646">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1646">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1647">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1647">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1648">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1648">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1649">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1649">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1650">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1650">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1651"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1651"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1652">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1652">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1653">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1653">Required.</span></span> <span data-ttu-id="26db1-1654">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1654">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1655">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1655">Required.</span></span> <span data-ttu-id="26db1-1656">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1656">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1657">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1657">Optional.</span></span> <span data-ttu-id="26db1-1658">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1658">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1659">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1659">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1660"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1660">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1661">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1661">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1662">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1662">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1663">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1663">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1664">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1664">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1665">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1665">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1666">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1666">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1667">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1667">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1668">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1668">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1669">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1669">Random Mode</span></span>  
 <span data-ttu-id="26db1-1670">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1670">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1671">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1671">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1672">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1672">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1673">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1673">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1674">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1674">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1675">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1675">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1676">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1676">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1677">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1677">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1678">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1678">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1679">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1679">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1680">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1680">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1681">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1681">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1682">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1682">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1683">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1683">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1684">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1684">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1685">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1685">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1686">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1686">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1687">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1687">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1688">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1688">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1689">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1689">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1690">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1690">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1691">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1691">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1692">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1692">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1693">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1693">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1694">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1694">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1695">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1695">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1696">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1696">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1697">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1697">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1698">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1698">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1699">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1699">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1700">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1700">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1701">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1701">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1702">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1702">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1703">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1703">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1704">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1704">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1705">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1705">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1706">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1706">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1707">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1707">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1708">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1708">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1709">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1709">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1710"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1710"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1711">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1711">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1712">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1712">Required.</span></span> <span data-ttu-id="26db1-1713">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1713">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1714">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1714">Required.</span></span> <span data-ttu-id="26db1-1715">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1715">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1716">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1716">Optional.</span></span> <span data-ttu-id="26db1-1717">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1717">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1718">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1718">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1719"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1719">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1720">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1720">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1721">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1721">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1722">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1722">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1723">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1723">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1724">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1724">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1725">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1725">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1726">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1726">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1727">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1727">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1728">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1728">Random Mode</span></span>  
 <span data-ttu-id="26db1-1729">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1729">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1730">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는`RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1730">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1731">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1731">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1732">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1732">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1733">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1733">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1734">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1734">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1735">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1735">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1736">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1736">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1737">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1737">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1738">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1738">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1739">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1739">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1740">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1740">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1741">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1741">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1742">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1742">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1743">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1743">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1744">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1744">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1745">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1745">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1746">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1746">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1747">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1747">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1748">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1748">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1749">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1750">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1750">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1751">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1751">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1752">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1752">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1753">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1753">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1754">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1754">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1755">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1755">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1756">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1756">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1757">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1757">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1758">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1758">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1759">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1759">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1760">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1760">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1761">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1761">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1762">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1762">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1763">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1763">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1764">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1764">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1765">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1765">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1766">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1766">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1767">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1767">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1768">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1768">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1769"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1769"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1770">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1770">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1771">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1771">Required.</span></span> <span data-ttu-id="26db1-1772">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1772">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1773">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1773">Required.</span></span> <span data-ttu-id="26db1-1774">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1774">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1775">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1775">Optional.</span></span> <span data-ttu-id="26db1-1776">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1776">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1777">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1777">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1778"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1778">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1779">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1779">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1780">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1780">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1781">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1781">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1782">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1782">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1783">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1783">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1784">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1784">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1785">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1785">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1786">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1786">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1787">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1787">Random Mode</span></span>  
 <span data-ttu-id="26db1-1788">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1788">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1789">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1789">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1790">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1790">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1791">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1791">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1792">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1792">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1793">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1793">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1794">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1794">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1795">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1795">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1796">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1796">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1797">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1797">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1798">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1798">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1799">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1799">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1800">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1800">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1801">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1801">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1802">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1802">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1803">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1803">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1804">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1804">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1805">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1805">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1806">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1806">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1807">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1807">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1808">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1808">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1809">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1809">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1810">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1810">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1811">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1811">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1812">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1812">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1813">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1813">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1814">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1814">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1815">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1815">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1816">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1816">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1817">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1817">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1818">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1818">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1819">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1819">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1820">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1820">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1821">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1821">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1822">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1822">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1823">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1823">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1824">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1824">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1825">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1825">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1826">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1826">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1827">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1827">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1828"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1828"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1829">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1829">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1830">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1830">Required.</span></span> <span data-ttu-id="26db1-1831">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1831">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1832">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1832">Required.</span></span> <span data-ttu-id="26db1-1833">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1833">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1834">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1834">Optional.</span></span> <span data-ttu-id="26db1-1835">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1835">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="26db1-1836">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1836">Optional.</span></span> <span data-ttu-id="26db1-1837">문자열을 쓰는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1837">Applies only when writing a string.</span></span> <span data-ttu-id="26db1-1838">문자열에 대한 2바이트의 문자열 길이 설명자를 파일에 쓸지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1838">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="26db1-1839">기본값은 <see langword="False" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1839">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="26db1-1840">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1840">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1841"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1841">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1842">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-1842">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1843">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1843">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1844">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1844">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1845">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1845">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1846">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1846">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1847">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1847">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1848">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1848">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1849">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1849">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1850">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1850">Random Mode</span></span>  
 <span data-ttu-id="26db1-1851">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1851">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1852">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1852">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1853">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1853">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1854">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1854">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1855">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1855">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1856">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1856">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1857">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1857">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1858">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1858">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1859">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1859">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1860">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1860">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1861">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1861">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1862">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1862">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1863">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1863">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1864">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1864">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1865">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1865">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1866">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1866">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1867">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1867">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1868">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1868">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1869">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1869">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1870">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1870">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1871">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1871">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1872">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1872">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1873">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1873">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1874">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1874">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1875">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1875">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1876">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1876">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1877">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1877">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1878">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1878">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1879">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1879">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1880">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1880">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1881">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1881">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1882">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1882">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1883">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1883">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1884">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1884">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1885">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1885">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1886">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1886">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1887">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1887">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1888">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1888">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1889">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1889">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1890">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1890">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1891"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1891"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1892">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1892">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1893">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1893">Required.</span></span> <span data-ttu-id="26db1-1894">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1894">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1895">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1895">Required.</span></span> <span data-ttu-id="26db1-1896">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1896">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1897">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1897">Optional.</span></span> <span data-ttu-id="26db1-1898">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1898">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="26db1-1899">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1899">Optional.</span></span> <span data-ttu-id="26db1-1900">배열을 쓰는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1900">Applies only when writing an array.</span></span> <span data-ttu-id="26db1-1901">배열을 동적으로 처리할 것인지의 여부와 길이를 설명하는 문자열에 대한 배열 설명자를 쓸 것인지의 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1901">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="26db1-1902">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1902">Optional.</span></span> <span data-ttu-id="26db1-1903">문자열을 쓰는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1903">Applies only when writing a string.</span></span> <span data-ttu-id="26db1-1904">문자열에 대한 2바이트의 문자열 길이 설명자를 파일에 쓸지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1904">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="26db1-1905">기본값은 <see langword="False" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1905">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="26db1-1906">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1906">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="26db1-1907"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePut" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1907">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="26db1-1908">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1908">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1909">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1909">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1910">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1910">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="26db1-1911">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1911">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1912">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1912">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="26db1-1913">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1913">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1914">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1914">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1915">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1915">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1916">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1916">Random Mode</span></span>  
 <span data-ttu-id="26db1-1917">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1917">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1918">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1918">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1919">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1919">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1920">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1920">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1921">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1921">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1922">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1922">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="26db1-1923">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1923">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="26db1-1924">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1924">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1925">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1925">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1926">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1926">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1927">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1927">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1928">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1928">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1929">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1929">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1930">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1930">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="26db1-1931">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1931">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="26db1-1932">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1932">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="26db1-1933">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1933">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="26db1-1934">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1934">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="26db1-1935">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1935">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1936">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1936">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="26db1-1937">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1937">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1938">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1938">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="26db1-1939">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1939">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="26db1-1940">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1940">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="26db1-1941">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1941">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="26db1-1942">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1942">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="26db1-1943">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="26db1-1943">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1944">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1944">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1945">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1945">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="26db1-1946">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="26db1-1946">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="26db1-1947">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1947">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1948">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1948">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="26db1-1949">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1949">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="26db1-1950">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1950">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="26db1-1951">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1951">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="26db1-1952">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1952">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="26db1-1953">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1953">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="26db1-1954">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1954">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1955">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1955">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="26db1-1956">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1956">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-1957"><paramref name="RecordNumber" /> &lt; 1이고 -1과 같지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1957"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-1958">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-1958">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1959">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1959">Required.</span></span> <span data-ttu-id="26db1-1960">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1960">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-1961">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1961">Required.</span></span> <span data-ttu-id="26db1-1962">디스크에 쓴 데이터를 포함하는 유효한 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1962">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="26db1-1963">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1963">Optional.</span></span> <span data-ttu-id="26db1-1964">쓰기를 시작할 레코드 번호(<see langword="Random" /> 모드 파일) 또는 바이트 숫자(<see langword="Binary" /> 모드 파일)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1964">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="26db1-1965">변수의 데이터를 디스크 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1965">Writes data from a variable to a disk file.</span></span>  <span data-ttu-id="26db1-1966"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FilePutObject" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1966">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span></span> <span data-ttu-id="26db1-1967">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-1967">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-1968">`FilePutObject` 함수 대신 사용 됩니다 `FilePut` 경우 컴파일 타임에 모호성을 방지 하려면 형식 `Object` 와 같은 다른 형식 대신 전달 됩니다 `Integer`, `Long`, `Short`, 등입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1968">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="26db1-1969">`FilePutObject` 작성 하 고 개체를 설명 하는 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1969">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="26db1-1970">작성 하려는 경우는 `Variant` 형식 `FilePutObject` 가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1970">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="26db1-1971">확실 하지 않은, 두 번째 매개 변수에 대 한 개체 사용 중인 경우, 항상 사용 하는 권장 `FilePutObject` 및 `FileGetObject`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1971">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="26db1-1972">`FilePutObject` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1972">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-1973">`FilePutObject`로 작성된 데이터는 일반적으로 `FileGetObject`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1973">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="26db1-1974">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="26db1-1974">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="26db1-1975">생략 하면 `RecordNumber`, `FilePutObject` 지난 후 다음 레코드 또는 바이트를 쓰기 `FileGetObject` 또는 `FilePutObject` 함수 (또는 마지막에서 가리키는 레코드 또는 바이트 `Seek` 함수).</span><span class="sxs-lookup"><span data-stu-id="26db1-1975">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="26db1-1976">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1976">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="26db1-1977">`FilePutObject` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1977">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="26db1-1978">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePutObject`와 동일한 작업을 수행 해야 `FileGetObject`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1978">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="26db1-1979">임의 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1979">Random Mode</span></span>  
 <span data-ttu-id="26db1-1980">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1980">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="26db1-1981">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePutObject` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1981">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="26db1-1982">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1982">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="26db1-1983">채워지는 데이터의 양은 정확 하 게 확인할 수 없습니다, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1983">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="26db1-1984">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1984">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="26db1-1985">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePutObject` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1985">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="26db1-1986">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePutObject` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1986">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="26db1-1987">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1987">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="26db1-1988">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePutObject` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1988">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="26db1-1989">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1989">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="26db1-1990">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1990">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="26db1-1991">쓰고 배열 되 면 변수로 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1991">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="26db1-1992">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1992">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="26db1-1993">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="26db1-1993">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="26db1-1994">이진 모드</span><span class="sxs-lookup"><span data-stu-id="26db1-1994">Binary Mode</span></span>  
 <span data-ttu-id="26db1-1995">연 파일에 `Binary` 모드에서는 모든는 `Random` 모드 규칙 적용을 제외 하 고:</span><span class="sxs-lookup"><span data-stu-id="26db1-1995">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="26db1-1996">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1996">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="26db1-1997">`FilePutObject` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1997">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-1998">사용 하 여이 예제는 `FilePutObject` 문자열 파일에 기록 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-1998">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-1999">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-1999">Required.</span></span> <span data-ttu-id="26db1-2000">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2000">Any valid file number.</span></span></param>
        <param name="RecordWidth"><span data-ttu-id="26db1-2001">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2001">Required.</span></span> <span data-ttu-id="26db1-2002">0에서 255 사이의 숫자 식으로 새 줄이 시작되기 전에 줄에 표시되는 문자의 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2002">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span></span> <span data-ttu-id="26db1-2003"><c>RecordWidth</c>가 0이면 줄 길이에 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2003">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span></span> <span data-ttu-id="26db1-2004"><c>RecordWidth</c>의 기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2004">The default value for <c>RecordWidth</c> is 0.</span></span></param>
        <summary><span data-ttu-id="26db1-2005"><see langword="FileOpen" /> 함수를 사용하여 연 파일에 출력 줄 너비를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2005">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26db1-2006">사용 하 여이 예제는 `FileWidth` 파일에 대 한 출력 선 두께 설정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2006">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2007">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2007">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26db1-2008"><see langword="Integer" /> 함수에서 사용할 수 있는 다음 파일 번호를 나타내는 <see langword="FileOpen" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2008">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></summary>
        <returns><span data-ttu-id="26db1-2009"><see langword="Integer" /> 함수에서 사용할 수 있는 다음 파일 번호를 나타내는 <see langword="FileOpen" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2009">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2010">사용 하 여 `FreeFile` 을 이미 사용 되지 않는 파일 번호를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2010">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2011">사용 하 여이 예제는 `FreeFile` 다음 사용 가능한 파일 수를 반환 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2011">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="26db1-2012">5 개의 파일 출력 루프 내에 열리고 몇 가지 샘플 데이터에 각각 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2012">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2013">사용 중인 파일 수가 255개를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2013">More than 255 files are in use.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="26db1-2014">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2014">Required.</span></span> <span data-ttu-id="26db1-2015">파일, 디렉터리 또는 폴더 이름을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2015"><see langword="String" /> expression that specifies a file, directory, or folder name.</span></span> <span data-ttu-id="26db1-2016"><c>PathName</c>에는 디렉터리나 폴더 및 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2016"><c>PathName</c> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="26db1-2017">파일, 디렉터리 또는 폴더의 특성을 나타내는 <see langword="FileAttribute" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2017">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span></span> <span data-ttu-id="26db1-2018"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="FileAttribute" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2018">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span></span> <span data-ttu-id="26db1-2019">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2019">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="26db1-2020"><see langword="GetAttr" /> 함수에서 반환되는 값은 다음 열거형 값의 합입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2020">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span></span>  
  
 <span data-ttu-id="26db1-2021"><list type="table"><item><term> 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2021"><list type="table"><item><term> Value</span></span>  
  
 <span data-ttu-id="26db1-2022"></term><description> 상수</span><span class="sxs-lookup"><span data-stu-id="26db1-2022"></term><description> Constant</span></span>  
  
 <span data-ttu-id="26db1-2023"></description><description> 설명</span><span class="sxs-lookup"><span data-stu-id="26db1-2023"></description><description> Description</span></span>  
  
 <span data-ttu-id="26db1-2024"></description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> 일반 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2024"></description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.</span></span>  
  
 <span data-ttu-id="26db1-2025"></description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2025"></description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.</span></span>  
  
 <span data-ttu-id="26db1-2026"></description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> 숨겨져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2026"></description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.</span></span>  
  
 <span data-ttu-id="26db1-2027"></description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> 시스템 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2027"></description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.</span></span>  
  
 <span data-ttu-id="26db1-2028"></description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> 디렉터리 또는 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2028"></description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.</span></span>  
  
 <span data-ttu-id="26db1-2029"></description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> 마지막 백업 이후에 파일이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2029"></description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.</span></span>  
  
 <span data-ttu-id="26db1-2030"></description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> 파일에 다른 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2030"></description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.</span></span>  
  
 </description></item></list><block subset="none" type="note"><para>  
 <span data-ttu-id="26db1-2031">이러한 열거형은 Visual Basic 언어로 지정되며</span><span class="sxs-lookup"><span data-stu-id="26db1-2031">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="26db1-2032">코드의 모든 위치에서 실제 값 대신 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2032">The names can be used anywhere in your code in place of the actual values.</span></span>  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2033">사용 하 여 설정 된 특성을 확인 하려면는 `And` 연산자에서 반환 값의 비트 비교를 수행 하는 `GetAttr` 함수와 원하는 개별 파일 특성의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2033">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="26db1-2034">결과 0이 아니면 해당 특성은 명명된 된 파일에 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2034">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="26db1-2035">예를 들어, 다음의 반환 값 `And` 식은 경우에는 0는 `Archive` 특성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2035">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="26db1-2036">0이 아닌 값을 반환 된 `Archive` 특성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2036">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2037">사용 하 여이 예제는 `GetAttr` 파일 및 디렉터리 또는 폴더의 특성을 결정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2037">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="26db1-2038"><paramref name="Pathname" />이 잘못되었거나 와일드카드를 포함하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2038"><paramref name="Pathname" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="26db1-2039">대상 파일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2039">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-2040">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2040">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2041">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2041">Required.</span></span> <span data-ttu-id="26db1-2042">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2042">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2043">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2043">Required.</span></span> <span data-ttu-id="26db1-2044">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2044">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2045">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2045">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2046">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2046">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2047">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2047">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2048">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2048">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2049">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2049">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2050">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2050">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2051">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2051">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2052">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2052">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2053">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2053">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2054">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2054">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2055">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2055">Data</span></span>|<span data-ttu-id="26db1-2056">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2056">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2057">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2057">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2058">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2058">Empty</span></span>|  
|<span data-ttu-id="26db1-2059">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2059">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2060"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2060">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2061">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2061">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2062">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2062">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2063">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2063">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2064">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2064">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2065">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2065">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2066">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2066">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2067">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2067">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2068">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2068">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2069">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2069">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2070">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2070">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2071">이 예에서는 가정 하는 `TestFile` 은 파일을 사용 하 여 기록 된 데이터의 일부 줄입니다는 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2071">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2072">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2072">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2073">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2073">Required.</span></span> <span data-ttu-id="26db1-2074">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2074">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2075">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2075">Required.</span></span> <span data-ttu-id="26db1-2076">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2076">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2077">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2077">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2078">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2078">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2079">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2079">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2080">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2080">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2081">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2081">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2082">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2082">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2083">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2083">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2084">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2084">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2085">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2085">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2086">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2086">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2087">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2087">Data</span></span>|<span data-ttu-id="26db1-2088">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2088">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2089">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2089">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2090">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2090">Empty</span></span>|  
|<span data-ttu-id="26db1-2091">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2091">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2092"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2092">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2093">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2093">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2094">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2094">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2095">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2095">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2096">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2096">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2097">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2097">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2098">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2098">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2099">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2099">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2100">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2100">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2101">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2101">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2102">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2102">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2103">이 예에서는 가정 하는 `TestFile` 은 파일을 사용 하 여 기록 된 데이터의 일부 줄입니다는 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2103">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2104">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2104">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2105">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2105">Required.</span></span> <span data-ttu-id="26db1-2106">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2106">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2107">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2107">Required.</span></span> <span data-ttu-id="26db1-2108">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2108">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2109">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2109">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2110">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2110">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2111">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2111">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2112">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2112">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2113">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2113">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2114">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2114">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2115">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2115">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2116">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2116">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2117">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2117">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2118">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2118">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2119">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2119">Data</span></span>|<span data-ttu-id="26db1-2120">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2120">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2121">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2121">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2122">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2122">Empty</span></span>|  
|<span data-ttu-id="26db1-2123">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2123">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2124"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2124">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2125">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2125">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2126">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2126">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2127">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2127">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2128">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2128">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2129">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2129">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2130">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2130">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2131">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2131">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2132">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2132">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2133">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2133">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2134">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2134">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2135">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2135">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2136">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2136">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2137">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2137">Required.</span></span> <span data-ttu-id="26db1-2138">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2138">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2139">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2139">Required.</span></span> <span data-ttu-id="26db1-2140">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2140">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2141">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2141">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2142">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2142">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2143">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2143">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2144">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2144">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2145">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2145">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2146">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2146">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2147">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2147">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2148">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2148">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2149">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2149">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2150">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2150">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2151">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2151">Data</span></span>|<span data-ttu-id="26db1-2152">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2152">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2153">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2153">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2154">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2154">Empty</span></span>|  
|<span data-ttu-id="26db1-2155">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2155">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2156"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2156">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2157">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2157">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2158">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2158">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2159">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2159">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2160">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2160">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2161">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2161">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2162">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2162">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2163">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2163">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2164">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2164">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2165">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2165">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2166">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2166">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2167">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2167">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2168">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2168">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2169">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2169">Required.</span></span> <span data-ttu-id="26db1-2170">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2170">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2171">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2171">Required.</span></span> <span data-ttu-id="26db1-2172">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2172">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2173">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2173">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2174">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2174">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2175">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2175">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2176">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2176">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2177">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2177">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2178">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2178">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2179">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2179">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2180">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2180">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2181">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2181">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2182">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2182">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2183">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2183">Data</span></span>|<span data-ttu-id="26db1-2184">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2184">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2185">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2185">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2186">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2186">Empty</span></span>|  
|<span data-ttu-id="26db1-2187">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2187">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2188"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2188">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2189">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2189">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2190">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2190">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2191">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2191">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2192">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2192">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2193">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2193">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2194">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2194">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2195">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2195">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2196">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2196">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2197">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2197">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2198">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2198">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2199">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2199">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2200">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2200">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2201">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2201">Required.</span></span> <span data-ttu-id="26db1-2202">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2202">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2203">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2203">Required.</span></span> <span data-ttu-id="26db1-2204">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2204">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2205">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2205">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2206">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2206">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2207">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2207">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2208">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2208">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2209">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2209">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2210">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2210">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2211">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2211">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2212">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2212">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2213">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2213">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2214">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2214">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2215">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2215">Data</span></span>|<span data-ttu-id="26db1-2216">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2216">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2217">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2217">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2218">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2218">Empty</span></span>|  
|<span data-ttu-id="26db1-2219">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2219">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2220"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2220">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2221">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2221">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2222">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2222">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2223">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2223">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2224">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2224">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2225">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2225">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2226">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2226">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2227">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2227">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2228">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2228">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2229">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2229">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2230">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2230">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2231">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2231">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2232">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2232">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2233">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2233">Required.</span></span> <span data-ttu-id="26db1-2234">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2234">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2235">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2235">Required.</span></span> <span data-ttu-id="26db1-2236">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2236">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2237">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2237">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2238">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2238">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2239">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2239">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2240">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2240">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2241">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2241">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2242">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2242">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2243">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2243">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2244">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2244">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2245">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2245">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2246">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2246">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2247">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2247">Data</span></span>|<span data-ttu-id="26db1-2248">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2248">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2249">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2249">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2250">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2250">Empty</span></span>|  
|<span data-ttu-id="26db1-2251">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2251">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2252"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2252">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2253">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2253">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2254">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2254">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2255">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2255">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2256">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2256">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2257">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2257">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2258">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2258">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2259">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2259">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2260">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2260">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2261">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2261">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2262">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2262">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2263">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2263">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2264">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2264">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2265">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2265">Required.</span></span> <span data-ttu-id="26db1-2266">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2266">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2267">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2267">Required.</span></span> <span data-ttu-id="26db1-2268">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2268">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2269">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2269">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2270">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2270">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2271">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2271">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2272">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2272">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2273">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2273">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2274">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2274">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2275">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2275">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2276">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2276">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2277">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2277">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2278">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2278">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2279">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2279">Data</span></span>|<span data-ttu-id="26db1-2280">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2280">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2281">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2281">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2282">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2282">Empty</span></span>|  
|<span data-ttu-id="26db1-2283">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2283">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2284"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2284">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2285">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2285">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2286">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2286">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2287">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2287">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2288">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2288">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2289">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2289">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2290">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2290">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2291">예를 들어 독일어 버전에서 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2291">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2292">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2292">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2293">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2293">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2294">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2294">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2295">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2295">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2296">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2296">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2297">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2297">Required.</span></span> <span data-ttu-id="26db1-2298">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2298">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2299">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2299">Required.</span></span> <span data-ttu-id="26db1-2300">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2300">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2301">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2301">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2302">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2302">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2303">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2303">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2304">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2304">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2305">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2305">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2306">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2306">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2307">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2307">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2308">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2308">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2309">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2309">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2310">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2310">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2311">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2311">Data</span></span>|<span data-ttu-id="26db1-2312">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2312">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2313">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2313">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2314">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2314">Empty</span></span>|  
|<span data-ttu-id="26db1-2315">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2315">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2316"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2316">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2317">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2317">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2318">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2318">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2319">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2319">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2320">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2320">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2321">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2321">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2322">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2322">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2323">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2323">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2324">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2324">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2325">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2325">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2326">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2326">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2327">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2327">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2328">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2328">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2329">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2329">Required.</span></span> <span data-ttu-id="26db1-2330">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2330">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2331">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2331">Required.</span></span> <span data-ttu-id="26db1-2332">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2332">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2333">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2333">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2334">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2334">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2335">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2335">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2336">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2336">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2337">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2337">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2338">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2338">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2339">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2339">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2340">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2340">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2341">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2341">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2342">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2342">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2343">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2343">Data</span></span>|<span data-ttu-id="26db1-2344">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2344">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2345">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2345">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2346">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2346">Empty</span></span>|  
|<span data-ttu-id="26db1-2347">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2347">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2348"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2348">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2349">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2349">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2350">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2350">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2351">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2351">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2352">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2352">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2353">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2353">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2354">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2354">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2355">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2355">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2356">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2356">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2357">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2357">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2358">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2358">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2359">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2359">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2360">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2360">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2361">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2361">Required.</span></span> <span data-ttu-id="26db1-2362">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2362">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2363">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2363">Required.</span></span> <span data-ttu-id="26db1-2364">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2364">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2365">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2365">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2366">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2366">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2367">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2367">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2368">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2368">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2369">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2369">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2370">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2370">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2371">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2371">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2372">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2372">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2373">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2373">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2374">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2374">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2375">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2375">Data</span></span>|<span data-ttu-id="26db1-2376">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2376">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2377">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2377">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2378">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2378">Empty</span></span>|  
|<span data-ttu-id="26db1-2379">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2379">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2380"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2380">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2381">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2381">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2382">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2382">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2383">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2383">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2384">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2384">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2385">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2385">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2386">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2386">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2387">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2387">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2388">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2388">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2389">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2389">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2390">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2390">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2391">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2391">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2392">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2392">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2393">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2393">Required.</span></span> <span data-ttu-id="26db1-2394">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2394">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="26db1-2395">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2395">Required.</span></span> <span data-ttu-id="26db1-2396">파일에서 읽은 값이 할당된 변수로, 배열이나 개체 변수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2396">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="26db1-2397">열린 순차 파일에서 데이터를 읽어 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2397">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2398">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2398">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2399">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2399">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2400">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2400">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2401">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2401">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="26db1-2402">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2402">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2403">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2403">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2404">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2404">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="26db1-2405">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2405">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="26db1-2406">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2406">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="26db1-2407">데이터</span><span class="sxs-lookup"><span data-stu-id="26db1-2407">Data</span></span>|<span data-ttu-id="26db1-2408">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2408">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="26db1-2409">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2409">Delimiting comma or blank line</span></span>|<span data-ttu-id="26db1-2410">Empty</span><span class="sxs-lookup"><span data-stu-id="26db1-2410">Empty</span></span>|  
|<span data-ttu-id="26db1-2411">#NULL#</span><span class="sxs-lookup"><span data-stu-id="26db1-2411">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="26db1-2412"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="26db1-2412">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="26db1-2413">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="26db1-2413">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="26db1-2414">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="26db1-2414">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="26db1-2415">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="26db1-2415">#ERROR `errornumber`#</span></span>|<span data-ttu-id="26db1-2416">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="26db1-2416">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="26db1-2417">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2417">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2418">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2418">The `Input` function is not localized.</span></span> <span data-ttu-id="26db1-2419">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2419">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2420">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2420">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2421">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2421">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2422">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2422">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="26db1-2423">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="26db1-2423">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2424">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2424">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2425">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2425">Required.</span></span> <span data-ttu-id="26db1-2426">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2426">Any valid file number.</span></span></param>
        <param name="CharCount"><span data-ttu-id="26db1-2427">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2427">Required.</span></span> <span data-ttu-id="26db1-2428">읽을 문자의 수를 지정하는 임의의 유효한 숫자 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2428">Any valid numeric expression specifying the number of characters to read.</span></span></param>
        <summary><span data-ttu-id="26db1-2429"><see langword="String" /> 또는 <see langword="Input" /> 모드로 연 파일의 문자가 포함된 <see langword="Binary" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2429">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="26db1-2430"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="InputString" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2430">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span> <span data-ttu-id="26db1-2431">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2431">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="26db1-2432"><see langword="String" /> 또는 <see langword="Input" /> 모드로 연 파일의 문자가 포함된 <see langword="Binary" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2432">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="26db1-2433"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="InputString" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2433">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2434">`InputString` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2434">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2435">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2435">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2436">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2436">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2437">사용 하 여 읽은 데이터는 `InputString` 함수는 일반적으로 사용 하 여 파일에 기록 됩니다 `Print` 또는 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2437">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="26db1-2438">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2438">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="26db1-2439">와 달리는 `Input` 함수는 `InputString` 읽어 온 모든 문자가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2439">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="26db1-2440">여기에 쉼표, 캐리지 리턴, 줄 바꿈, 인용 부호 및 선행 공백을 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2440">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="26db1-2441">연 파일 `Binary` 액세스를 사용 하 여 파일을 통해 읽지는 `InputString` 될 때까지 작동 `EOF` 반환 `True` 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2441">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="26db1-2442">사용 하 여는 `LOF` 및 `Loc` 대신 함수 `EOF` 를 사용 하 여 이진 파일을 읽을 때 `InputString`, 사용 또는 `FileGet` 사용 하는 경우는 `EOF` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2442">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2443">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대해 보안 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2443">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="26db1-2444">예를 들어 Form1.vb 파일이 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2444">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2445">사용 하 여이 예제는 `InputString` 파일에서 한 번에 한 문자를 읽고 인쇄 하는 함수는 `Output` 창.</span><span class="sxs-lookup"><span data-stu-id="26db1-2445">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="26db1-2446">이 예에서는 가정 하는 `MyFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2446">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="26db1-2447"><paramref name="FileNumber" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2447"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-2448"><paramref name="CharCount" /> &lt; 0 또는 &gt; 214입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2448"><paramref name="CharCount" /> &lt; 0 or &gt; 214.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="26db1-2449">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2449">Required.</span></span> <span data-ttu-id="26db1-2450">삭제할 하나 이상의 파일 이름을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2450"><see langword="String" /> expression that specifies one or more file names to be deleted.</span></span> <span data-ttu-id="26db1-2451"><c>PathName</c>에는 디렉터리나 폴더 및 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2451"><c>PathName</c> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="26db1-2452">디스크에서 파일을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2452">Deletes files from a disk.</span></span> <span data-ttu-id="26db1-2453"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="Kill" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2453">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span></span> <span data-ttu-id="26db1-2454">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-2454">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2455">`Kill` 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2455">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="26db1-2456">**보안 정보** 을 실행 하려면는 `Kill` 함수 필요 `Read` 및 `PathDiscovery` 의 플래그 지정 <xref:System.Security.Permissions.FileIOPermission> 코드 실행에 부여할 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2456">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="26db1-2457">자세한 내용은 참조 <xref:System.Security.SecurityException> [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="26db1-2457">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2458">사용 하 여이 예제는 `Kill` 함수를 디스크에서 파일을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2458">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2459">대상 파일이 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2459">Target file(s) open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="26db1-2460">대상 파일을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2460">Target file(s) not found.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="26db1-2461">사용 권한이 거부되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2461">Permission denied.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2462">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2462">Required.</span></span> <span data-ttu-id="26db1-2463">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2463">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="26db1-2464">열려 있는 순차 파일에서 한 줄을 읽은 다음 <see langword="String" /> 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2464">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></summary>
        <returns><span data-ttu-id="26db1-2465">열려 있는 순차 파일에서 한 줄을 읽은 다음 <see langword="String" /> 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2465">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2466">`LineInput` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2466">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2467">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2467">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2468">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2468">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2469">데이터를 읽을 `LineInput` 를 사용 하 여 일반적으로 파일에 기록 `Print`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2469">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2470">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2470">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="26db1-2471">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2471">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="26db1-2472">`LineInput` 캐리지 리턴에 도달할 때까지 한 번에 파일 1 자에서 함수를 읽습니다 (`Chr(13)`) 또는 캐리지 리턴/줄 바꿈 (`Chr(13) + Chr(10)`) 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2472">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="26db1-2473">캐리지 리턴/줄 바꿈된 시퀀스 문자 문자열에 추가 하는 대신 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2473">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2474">사용 하 여 파일에서 읽기는 `LineInput` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2474">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2475">사용 하 여이 예제는 `LineInput` 함수 순차 파일에서 줄을 읽고을 변수에 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2475">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="26db1-2476">이 예에서는 가정 하는 `TestFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2476">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException"><span data-ttu-id="26db1-2477">파일의 끝에 도달했습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2477">End of file reached.</span></span></exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="26db1-2478"><paramref name="FileNumber" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2478"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2479">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2479">Required.</span></span> <span data-ttu-id="26db1-2480">임의의 유효한 <see langword="Integer" /> 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2480">Any valid <see langword="Integer" /> file number.</span></span></param>
        <summary><span data-ttu-id="26db1-2481">열려 있는 파일에서 현재의 읽기/쓰기 위치를 지정하는 <see langword="Long" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2481">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span></span></summary>
        <returns><span data-ttu-id="26db1-2482">열려 있는 파일에서 현재의 읽기/쓰기 위치를 지정하는 <see langword="Long" /> 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2482">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2483">`Loc` 함수는 0부터 시작; 파일의 첫 번째 바이트를 검색 하는 데 사용 하는 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2483">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="26db1-2484">`Loc` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2484">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2485">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2485">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2486">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2486">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2487">다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2487">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="26db1-2488">모드</span><span class="sxs-lookup"><span data-stu-id="26db1-2488">Mode</span></span>|<span data-ttu-id="26db1-2489">반환 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2489">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="26db1-2490">읽거나 파일에 쓴 마지막 레코드의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2490">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="26db1-2491">128로 구분해 서 파일의 현재 바이트 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2491">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="26db1-2492">그러나 정보를 반환할 `Loc` 순차적 파일 사용 아니고 필요한에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2492">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="26db1-2493">마지막 바이트 읽기 또는 쓰기의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2493">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2494">사용 하 여이 예제는 `Loc` 열려 있는 파일의 현재 읽기/쓰기 위치를 반환 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2494">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="26db1-2495">이 예에서는 가정 하는 `MyFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2495">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2496">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2496">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-2497"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2497">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2498"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2498">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2499">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2499">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2500">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2500">Required.</span></span> <span data-ttu-id="26db1-2501">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2501">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="26db1-2502"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2502">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2503"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2503">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2504">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2504">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2505">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2505">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="26db1-2506">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2506">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="26db1-2507">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2507">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="26db1-2508">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2508">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="26db1-2509">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2509">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="26db1-2510">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2510">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2511">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2511">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="26db1-2512">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2512">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2513">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2513">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2514">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2514">Required.</span></span> <span data-ttu-id="26db1-2515">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2515">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="26db1-2516">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2516">Optional.</span></span> <span data-ttu-id="26db1-2517">잠그거나 잠금을 해제할 레코드 또는 바이트 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2517">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="26db1-2518"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2518">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2519"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2519">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2520">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2520">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2521">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2521">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="26db1-2522">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2522">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="26db1-2523">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2523">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="26db1-2524">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2524">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="26db1-2525">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2525">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="26db1-2526">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2526">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2527">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2527">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="26db1-2528">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2528">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2529">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2529">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2530">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2530">Required.</span></span> <span data-ttu-id="26db1-2531">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2531">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="26db1-2532">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2532">Optional.</span></span> <span data-ttu-id="26db1-2533">잠그거나 잠금을 해제할 첫째 레코드 또는 바이트 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2533">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="26db1-2534">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2534">Optional.</span></span> <span data-ttu-id="26db1-2535">잠그거나 잠금을 해제할 마지막 레코드 또는 바이트 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2535">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="26db1-2536"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2536">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2537"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2537">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2538">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2538">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2539">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2539">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="26db1-2540">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2540">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="26db1-2541">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2541">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="26db1-2542">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2542">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="26db1-2543">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2543">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="26db1-2544">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2544">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2545">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2545">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="26db1-2546">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2546">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2547">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2547">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2548">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2548">Required.</span></span> <span data-ttu-id="26db1-2549">유효한 파일 번호가 포함된 <see langword="Integer" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2549">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="26db1-2550"><see langword="Long" /> 함수를 사용하여 연 파일의 크기(바이트)를 나타내는 <see langword="FileOpen" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2550">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-2551"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="LOF" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2551">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span> <span data-ttu-id="26db1-2552">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2552">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="26db1-2553"><see langword="Long" /> 함수를 사용하여 연 파일의 크기(바이트)를 나타내는 <see langword="FileOpen" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2553">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-2554"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="LOF" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2554">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2555">사용 하 여는 `FileLen` 열려 있지 않은 파일의 길이 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2555">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2556">사용 하 여이 예제는 `LOF` 열려 있는 파일의 크기를 결정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2556">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="26db1-2557">이 예에서는 가정 하는 `TestFile` 은 샘플 데이터를 포함 하는 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2557">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2558">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2558">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="26db1-2559">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2559">Required.</span></span> <span data-ttu-id="26db1-2560">만들어질 디렉터리를 식별하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2560"><see langword="String" /> expression that identifies the directory to be created.</span></span> <span data-ttu-id="26db1-2561"><c>Path</c>에는 드라이브가 포함될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2561">The <c>Path</c> may include the drive.</span></span> <span data-ttu-id="26db1-2562">드라이브를 지정하지 않은 경우 <see langword="MkDir" />을 사용하면 현재 드라이브에서 새 디렉터리를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2562">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="26db1-2563">새 디렉터리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2563">Creates a new directory.</span></span> <span data-ttu-id="26db1-2564"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="MkDir" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2564">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span></span> <span data-ttu-id="26db1-2565">자세한 내용은 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2565">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2566">이 함수는 새 디렉터리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2566">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2567">사용 하 여이 예제는 `MkDir` 디렉터리를 만들 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2567">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="26db1-2568">드라이브 지정 되지 않은 경우에 현재 드라이브에 새 디렉터리가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2568">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-2569"><paramref name="Path" />가 지정되지 않았거나 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2569"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="26db1-2570">사용 권한이 거부되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2570">Permission denied.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2571">디렉터리가 이미 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2571">Directory already exists.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2572">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2572">Required.</span></span> <span data-ttu-id="26db1-2573">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2573">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="26db1-2574">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2574">Optional.</span></span> <span data-ttu-id="26db1-2575">파일에 쓸 쉼표로 구분된 0개 이상의 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2575">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
 <span data-ttu-id="26db1-2576"><c>Output</c> 인수 설정은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2576">The <c>Output</c> argument settings are:</span></span>  
  
 <span data-ttu-id="26db1-2577"><see langword="T:System.IO.IOException" />: 파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2577"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="26db1-2578"><see langword="T:System.IO.IOException" />: <c>FileNumber</c>가 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2578"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span></span></param>
        <summary><span data-ttu-id="26db1-2579">표시 형식 데이터를 순차 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2579">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2580">`Print` 및 `PrintLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2580">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2581">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2581">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2582">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2582">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2583">`Print` 줄 바꿈으로 줄의 끝에 포함 되지 않습니다. 그러나 `PrintLine` 줄 바꿈에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2583">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="26db1-2584">로 작성 된 데이터 `Print` 일반적으로 사용 하 여 파일에서 읽은 `LineInput` 또는 `Input`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2584">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="26db1-2585">생략 하면 `Output` 에 대 한 `PrintLine`, 빈 줄에 대 한; 파일에 출력은 `Print`, 아무것도 출력 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2585">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="26db1-2586">쉼표로 구분 된 여러 개의 식을 혼합 쉼표 탭 경계에 맞춰집니다 및 `TAB` 일관 되지 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2586">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="26db1-2587">에 대 한 `Boolean` 데이터를 `True` 또는 `False` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2587">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="26db1-2588">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2588">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="26db1-2589">날짜 데이터는 시스템에서 인식 표준 짧은 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2589">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="26db1-2590">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2590">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="26db1-2591">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2591">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="26db1-2592">그러나 경우 `Output` 목록 데이터는 `DBNull`, `Null` 파일에 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2592">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="26db1-2593">에 대 한 `Error` 데이터를 출력으로 표시 `Error errorcode`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2593">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="26db1-2594">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2594">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="26db1-2595">모든 데이터를 사용 하 여 파일에 기록 `Print` 국제적으로 인식 됩니다; 즉, 데이터의 형식이 올바르게 적절 한 소수 구분 기호를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2595">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="26db1-2596">여러 로캘에서 사용할 데이터를 출력 하려는 경우 `Write` 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2596">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="26db1-2597">사용 하 여 파일에 쓰기는 `Print` 또는 `PrintLine` 함수 필요 `Write` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2597">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2598">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-2598">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2599">사용 하 여이 예제는 `Print` 및 `PrintLine` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2599">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2600">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2600">Required.</span></span> <span data-ttu-id="26db1-2601">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2601">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="26db1-2602">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2602">Optional.</span></span> <span data-ttu-id="26db1-2603">파일에 쓸 쉼표로 구분된 0개 이상의 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2603">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
 <span data-ttu-id="26db1-2604"><c>Output</c> 인수 설정은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2604">The <c>Output</c> argument settings are:</span></span>  
  
 <span data-ttu-id="26db1-2605"><see langword="T:System.IO.IOException" />: 파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2605"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="26db1-2606"><see langword="T:System.IO.IOException" />: <c>FileNumber</c>가 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2606"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span></span></param>
        <summary><span data-ttu-id="26db1-2607">표시 형식 데이터를 순차 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2607">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2608">`Print` 및 `PrintLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2608">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2609">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2609">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2610">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2610">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2611">`Print` 줄 바꿈으로 줄의 끝에 포함 되지 않습니다. 그러나`PrintLine` 줄 바꿈에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2611">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="26db1-2612">로 작성 된 데이터 `Print` 일반적으로 사용 하 여 파일에서 읽은 `LineInput` 또는 `Input`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2612">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="26db1-2613">생략 하면 `Output` 에 대 한 `PrintLine`, 빈 줄에 대 한; 파일에 출력은 `Print`, 아무것도 출력 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2613">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="26db1-2614">쉼표로 구분 된 여러 개의 식을 혼합 쉼표 탭 경계에 맞춰집니다 및 `TAB` 일관 되지 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2614">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="26db1-2615">에 대 한 `Boolean` 데이터를 `True` 또는 `False` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2615">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="26db1-2616">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2616">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="26db1-2617">날짜 데이터는 시스템에서 인식 하는 표준의 간단한 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2617">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="26db1-2618">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2618">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="26db1-2619">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2619">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="26db1-2620">그러나 경우 `Output` 목록 데이터는 `DBNull`, `Null` 파일에 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2620">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="26db1-2621">에 대 한 `Error` 데이터를 출력으로 표시 `Error errorcode`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2621">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="26db1-2622">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2622">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="26db1-2623">모든 데이터를 사용 하 여 파일에 기록 `Print` 국제적으로 인식 됩니다; 즉, 데이터의 형식이 올바르게 적절 한 소수 구분 기호를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2623">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="26db1-2624">여러 로캘에서 사용할 데이터를 출력 하려는 경우 `Write` 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2624">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="26db1-2625">사용 하 여 파일에 쓰기는 `Print` 또는 `PrintLine` 함수 필요 `Write` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2625">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2626">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-2626">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2627">사용 하 여이 예제는 `Print` 및 `PrintLine` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2627">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath"><span data-ttu-id="26db1-2628">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2628">Required.</span></span> <span data-ttu-id="26db1-2629">기존 파일 이름과 위치를 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2629"><see langword="String" /> expression that specifies the existing file name and location.</span></span> <span data-ttu-id="26db1-2630"><c>OldPath</c>에는 파일의 디렉터리와 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2630"><c>OldPath</c> may include the directory, and drive, of the file.</span></span></param>
        <param name="NewPath"><span data-ttu-id="26db1-2631">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2631">Required.</span></span> <span data-ttu-id="26db1-2632">새 파일 이름과 위치를 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2632"><see langword="String" /> expression that specifies the new file name and location.</span></span> <span data-ttu-id="26db1-2633"><c>NewPath</c>에는 대상 위치의 디렉터리와 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2633"><c>NewPath</c> may include directory and drive of the destination location.</span></span> <span data-ttu-id="26db1-2634"><c>NewPath</c>에는 이미 있는 파일 이름을 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2634">The file name specified by <c>NewPath</c> cannot already exist.</span></span></param>
        <summary><span data-ttu-id="26db1-2635">디스크 파일 또는 디렉터리의 이름을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2635">Renames a disk file or directory.</span></span> <span data-ttu-id="26db1-2636"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="Rename" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2636">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span></span> <span data-ttu-id="26db1-2637">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2637">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2638">`Rename` 함수는 파일 이름을 바꾸고 필요한 경우 다른 디렉터리로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2638">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="26db1-2639">`Rename` 함수는 드라이브에 파일을 이동할 수 있지만 기존 디렉터리의 이름만 바꿀 수 때 둘 다 `NewPath` 및 `OldPath` 는 동일한 드라이브에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2639">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="26db1-2640">`Rename` 새 파일 또는 디렉터리를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2640">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="26db1-2641">사용 하는 `Rename` 열려 있는 파일에 대해 함수에서 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2641">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="26db1-2642">이름을 바꾸기 전에 열려 있는 파일을 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2642">You must close an open file before renaming it.</span></span> <span data-ttu-id="26db1-2643">`Rename` 다중 문자 (\*) 및 (?) 단일 문자 와일드 카드 인수 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2643">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26db1-2644">사용 하는 경우 `Rename` 파일에 덜 제한적인된 권한이 보호 된 위치를 보호 되지 않는 위치에서 파일을 복사를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2644">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="26db1-2645">보안상 위험을 도입 하지는 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2645">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2646">사용 하 여이 예제는 `Rename` 파일 이름을 바꾸는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2646">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="26db1-2647">이 예제에서 이미 지정 된 디렉터리에 존재 하는지 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2647">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="26db1-2648">경로가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2648">Path is invalid.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="26db1-2649"><paramref name="OldPath" /> 파일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2649"><paramref name="OldPath" /> file does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2650">다른 장치로 이름을 바꿀 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2650">Cannot rename to different device.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26db1-2651"><see langword="FileOpen" /> 함수를 사용하여 연 디스크 파일을 모두 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2651">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-2652"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="Reset" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2652">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span></span> <span data-ttu-id="26db1-2653">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2653">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2654">`Reset` 함수에 의해 열린 모든 활성 파일 닫습니다는 `FileOpen` 작동 하 고 동일한 기능을 `FileClose()` 매개 변수 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2654">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2655">사용 하 여이 예제는 `Reset` 함수를 열려 있는 모든 파일을 닫고 모든 파일 버퍼의 내용이 디스크에 쓰여집니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2655">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="26db1-2656">사용 하 여는 `Object` 변수 `FileNumber` 문자열과 숫자를 모두로 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2656">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="26db1-2657">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2657">Required.</span></span> <span data-ttu-id="26db1-2658">제거할 디렉터리나 폴더를 식별하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2658"><see langword="String" /> expression that identifies the directory or folder to be removed.</span></span> <span data-ttu-id="26db1-2659"><c>Path</c>에는 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2659"><c>Path</c> can include the drive.</span></span> <span data-ttu-id="26db1-2660">드라이브를 지정하지 않은 경우 <see langword="RmDir" />을 사용하면 현재 드라이브에서 디렉터리를 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2660">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="26db1-2661">기존 디렉터리를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2661">Removes an existing directory.</span></span> <span data-ttu-id="26db1-2662"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="RmDir" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2662">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span></span> <span data-ttu-id="26db1-2663">자세한 내용은 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2663">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2664">사용 하려고 하면 오류가 발생 `RmDir` 파일이 포함 된 디렉터리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2664">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="26db1-2665">사용 된 `Kill` 디렉터리를 제거 하기 전에 모든 파일을 삭제 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2665">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2666">사용 하 여이 예제는 `RmDir` 함수 기존 디렉터리를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2666">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-2667"><paramref name="Path" />가 지정되지 않았거나 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2667"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2668">대상 디렉터리에 파일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2668">Target directory contains files.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="26db1-2669">디렉터리가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2669">Directory does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-2670"><see langword="Long" /> 함수를 사용하여 연 파일에서 현재 읽기/쓰기 위치를 지정하는 <see langword="FileOpen" />을 반환하거나, <see langword="FileOpen" /> 함수를 사용하여 연 파일에서 다음 읽기/쓰기 작업 위치를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2670">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-2671"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="Seek" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2671">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="26db1-2672">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2672">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2673">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2673">Required.</span></span> <span data-ttu-id="26db1-2674">유효한 파일 번호가 포함된 <see langword="Integer" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2674">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="26db1-2675"><see langword="Long" /> 함수를 사용하여 연 파일에서 현재 읽기/쓰기 위치를 지정하는 <see langword="FileOpen" />을 반환하거나, <see langword="FileOpen" /> 함수를 사용하여 연 파일에서 다음 읽기/쓰기 작업 위치를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2675">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-2676"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="Seek" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2676">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="26db1-2677">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2677">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="26db1-2678"><see langword="Long" /> 함수를 사용하여 연 파일에서 현재 읽기/쓰기 위치를 지정하는 <see langword="FileOpen" />을 반환하거나, <see langword="FileOpen" /> 함수를 사용하여 연 파일에서 다음 읽기/쓰기 작업 위치를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2678">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2679">`Seek` 1에서 2,147,483,647 사이의 값을 반환 합니다. (2 ^31-1).</span><span class="sxs-lookup"><span data-stu-id="26db1-2679">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="26db1-2680">다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2680">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="26db1-2681">모드</span><span class="sxs-lookup"><span data-stu-id="26db1-2681">Mode</span></span>|<span data-ttu-id="26db1-2682">반환 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2682">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="26db1-2683">읽거나 쓴 다음 레코드의 수</span><span class="sxs-lookup"><span data-stu-id="26db1-2683">Number of the next record read or written</span></span>|  
|<span data-ttu-id="26db1-2684">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="26db1-2684">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="26db1-2685">다음 작업이 발생 하는 바이트 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2685">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="26db1-2686">파일의 첫 번째 바이트 위치 1에 있고, 두 번째 바이트는 2, 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2686">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2687">사용 하 여이 예제는 `Seek` 함수는 현재 파일 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2687">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="26db1-2688">이 예에서는 가정 `TestFile` 구조체의 레코드를 포함 하는 파일은 `Record`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2688">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="26db1-2689">연 파일에 `Random` 모드 `Seek` 다음 레코드의 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2689">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="26db1-2690">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2690">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="26db1-2691">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2691">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="26db1-2692">사용 하 여이 예제는 `Seek` 함수 또는 파일에 쓰기 다음 읽기에 대 한 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2692">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="26db1-2693">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2693">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="26db1-2694">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2694">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2695">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2695">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2696">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2696">Required.</span></span> <span data-ttu-id="26db1-2697">유효한 파일 번호가 포함된 <see langword="Integer" />입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2697">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <param name="Position"><span data-ttu-id="26db1-2698">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2698">Required.</span></span> <span data-ttu-id="26db1-2699">1에서 2,147,483,647 사이의 수로, 다음 읽기/쓰기 작업이 발생할 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2699">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span></span></param>
        <summary><span data-ttu-id="26db1-2700"><see langword="Long" /> 함수를 사용하여 연 파일에서 현재 읽기/쓰기 위치를 지정하는 <see langword="FileOpen" />을 반환하거나, <see langword="FileOpen" /> 함수를 사용하여 연 파일에서 다음 읽기/쓰기 작업 위치를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2700">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="26db1-2701"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="Seek" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2701">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="26db1-2702">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2702">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2703">`Seek` 1에서 2,147,483,647 사이의 값을 반환 합니다. (2 ^31-1).</span><span class="sxs-lookup"><span data-stu-id="26db1-2703">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="26db1-2704">다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2704">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="26db1-2705">모드</span><span class="sxs-lookup"><span data-stu-id="26db1-2705">Mode</span></span>|<span data-ttu-id="26db1-2706">반환 값</span><span class="sxs-lookup"><span data-stu-id="26db1-2706">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="26db1-2707">읽거나 쓴 다음 레코드의 수</span><span class="sxs-lookup"><span data-stu-id="26db1-2707">Number of the next record read or written</span></span>|  
|<span data-ttu-id="26db1-2708">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="26db1-2708">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="26db1-2709">다음 작업이 발생 하는 바이트 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2709">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="26db1-2710">파일의 첫 번째 바이트 위치 1에 있고, 두 번째 바이트는 2, 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2710">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2711">사용 하 여이 예제는 `Seek` 함수는 현재 파일 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2711">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="26db1-2712">이 예에서는 가정 `TestFile` 구조체의 레코드를 포함 하는 파일은 `Record`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2712">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="26db1-2713">연 파일에 `Random` 모드 `Seek` 다음 레코드의 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2713">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="26db1-2714">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2714">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="26db1-2715">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2715">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="26db1-2716">사용 하 여이 예제는 `Seek` 함수 또는 파일에 쓰기 다음 읽기에 대 한 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2716">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="26db1-2717">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2717">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="26db1-2718">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2718">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2719">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2719">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="26db1-2720">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2720">Required.</span></span> <span data-ttu-id="26db1-2721">파일 이름을 지정하는 <see langword="String" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2721"><see langword="String" /> expression that specifies a file name.</span></span> <span data-ttu-id="26db1-2722"><c>PathName</c>에는 디렉터리나 폴더 및 드라이브가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2722"><c>PathName</c> can include directory or folder, and drive.</span></span></param>
        <param name="Attributes"><span data-ttu-id="26db1-2723">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2723">Required.</span></span> <span data-ttu-id="26db1-2724">파일 특성을 지정하는 합계를 가진 상수 또는 숫자 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2724">Constant or numeric expression, whose sum specifies file attributes.</span></span></param>
        <summary><span data-ttu-id="26db1-2725">파일의 특성 정보를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2725">Sets attribute information for a file.</span></span> <span data-ttu-id="26db1-2726"><see langword="My" /> 기능은 파일 I/O 작업에서 <see langword="SetAttr" />보다 더 나은 생산성 및 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2726">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span></span> <span data-ttu-id="26db1-2727">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2727">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2728">열려 있는 파일의 특성을 설정 하려고 하면 런타임 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2728">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="26db1-2729">`Attributes` 인수 열거형 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2729">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="26db1-2730">값</span><span class="sxs-lookup"><span data-stu-id="26db1-2730">Value</span></span>|<span data-ttu-id="26db1-2731">상수</span><span class="sxs-lookup"><span data-stu-id="26db1-2731">Constant</span></span>|<span data-ttu-id="26db1-2732">설명</span><span class="sxs-lookup"><span data-stu-id="26db1-2732">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="26db1-2733">보통 (기본값)입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2733">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="26db1-2734">읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2734">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="26db1-2735">숨겨져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2735">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="26db1-2736">시스템 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2736">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="26db1-2737">볼륨 레이블</span><span class="sxs-lookup"><span data-stu-id="26db1-2737">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="26db1-2738">디렉터리 또는 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2738">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="26db1-2739">마지막 백업 이후에 파일이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2739">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="26db1-2740">파일에 다른 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2740">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2741">이러한 열거형은 Visual Basic 언어로 지정되며</span><span class="sxs-lookup"><span data-stu-id="26db1-2741">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="26db1-2742">이름은 실제 값 대신 코드에서 아무 곳 이나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2742">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2743">사용 하 여이 예제는 `SetAttr` 파일의 특성을 설정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2743">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26db1-2744"><paramref name="Attribute" /> 형식이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2744"><paramref name="Attribute" /> type is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count"><span data-ttu-id="26db1-2745">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2745">Required.</span></span> <span data-ttu-id="26db1-2746">목록에서 다음 식을 표시하거나 출력하기 전에 삽입할 공백의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2746">The number of spaces to insert before displaying or printing the next expression in a list.</span></span></param>
        <summary><span data-ttu-id="26db1-2747"><see langword="Print" /> 또는 <see langword="PrintLine" /> 함수와 함께 사용되어 출력의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2747">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></summary>
        <returns><span data-ttu-id="26db1-2748"><see langword="Print" /> 또는 <see langword="PrintLine" /> 함수와 함께 사용되어 출력의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2748">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2749">경우 `Count` 출력 선 두께 다음 출력 위치를 즉시 인쇄 되는 공백 수 뒤에 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2749">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="26db1-2750">경우`Count` 출력 선 두께 보다 크면 `SPC` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2750">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="26db1-2751">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="26db1-2751">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="26db1-2752">예를 들어 현재 출력 위치 24 이면 출력 줄 너비는 80 이며, 지정한 `SPC(90)`, 다음 출력 34 (출력 위치를 현재 + 90/80의 나머지) 위치에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2752">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="26db1-2753">현재 출력 위치와 출력 선 두께 간에 차이가 있는 경우 보다 작은 `Count` (또는 `Count` `Mod` *너비*), `SPC` 다음 줄의 시작 부분에 건너뛰고 생성 함수 같은 공간 `Count` – (*너비* – *currentprintposition*).</span><span class="sxs-lookup"><span data-stu-id="26db1-2753">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2754">테이블 열이 와이드 문자를 허용 하도록 충분히 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2754">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2755">사용 하 여이 예제는 `SPC` 파일 및 출력의 위치는 함수는 **출력** 창.</span><span class="sxs-lookup"><span data-stu-id="26db1-2755">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-2756"><see langword="Print" /> 또는 <see langword="PrintLine" /> 함수와 함께 사용되어 출력의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2756">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26db1-2757"><see langword="Print" /> 또는 <see langword="PrintLine" /> 함수와 함께 사용되어 출력의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2757">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="26db1-2758"><see langword="Print" /> 또는 <see langword="PrintLine" /> 함수와 함께 사용되어 출력의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2758">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2759">현재 줄에 현재 출력 위치 보다 큰 경우 `Column`, `TAB` 해당 하는 열 값으로 건너뜁니다 `Column` 다음 출력 줄.</span><span class="sxs-lookup"><span data-stu-id="26db1-2759">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="26db1-2760">경우 `Column` 1 보다 작으면 `TAB` 수식을 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2760">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="26db1-2761">경우 `Column` 출력 줄 너비 보다 큰 `TAB` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2761">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="26db1-2762">Mod 열 너비</span><span class="sxs-lookup"><span data-stu-id="26db1-2762">Column Mod width</span></span>  
  
 <span data-ttu-id="26db1-2763">예를 들어 경우 *너비* 80이 고 지정한 경우 `TAB(90)`, 다음 출력 열 (90/80의 나머지) 10에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2763">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="26db1-2764">경우 `Column` 현재 출력 위치 계산 된 출력 위치에 다음 줄에 출력이 시작 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2764">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="26db1-2765">계산 된 출력 위치 현재 출력 위치 보다 큰 경우의 계산 된 출력이 시작 출력 같은 줄에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2765">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="26db1-2766">출력 줄에서 맨 왼쪽 출력 위치는 항상 1입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2766">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="26db1-2767">사용 하는 경우는 `Print` 또는 `PrintLine` 파일을 인쇄 하는 함수의 가장 오른쪽 출력 위치를 사용 하 여 설정할 수 있는 출력 파일의 현재 너비는는 `FileWidth` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2767">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="26db1-2768">`TAB` 함수를 사용할 수도 있습니다는 `WriteLine` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2768">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="26db1-2769">함께 사용할 수 없습니다 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2769">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2770">테이블 열이 충분히 넓은 문자를 포함 하 고 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2770">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2771">사용 하 여이 예제는 `TAB` 파일 및 출력의 위치는 함수는 **출력** 창.</span><span class="sxs-lookup"><span data-stu-id="26db1-2771">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column"><span data-ttu-id="26db1-2772">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2772">Optional.</span></span> <span data-ttu-id="26db1-2773">목록에서 다음 식을 표시하거나 출력하기 전에 이동하는 열 수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2773">The column number moved to before displaying or printing the next expression in a list.</span></span> <span data-ttu-id="26db1-2774">생략할 경우 <see langword="TAB" />은 다음 출력 영역의 시작 부분으로 삽입 지점을 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2774">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span></span></param>
        <summary><span data-ttu-id="26db1-2775"><see langword="Print" /> 또는 <see langword="PrintLine" /> 함수와 함께 사용되어 출력의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2775">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="26db1-2776"><see langword="Print" /> 또는 <see langword="PrintLine" /> 함수와 함께 사용되어 출력의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2776">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2777">현재 줄에 현재 출력 위치 보다 크면 `Column`, `TAB` 해당 하는 열 값으로 건너뜁니다 `Column` 다음 출력 줄.</span><span class="sxs-lookup"><span data-stu-id="26db1-2777">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="26db1-2778">경우 `Column` 1 보다 작으면 `TAB` 수식을 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2778">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="26db1-2779">경우 `Column` 출력 선 두께 보다 크면 `TAB` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2779">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="26db1-2780">Mod 열 너비</span><span class="sxs-lookup"><span data-stu-id="26db1-2780">Column Mod width</span></span>  
  
 <span data-ttu-id="26db1-2781">예를 들어 경우 *너비* 80이 고 지정한 경우 `TAB(90)`, 다음 출력 열 (90/80의 나머지) 10에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2781">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="26db1-2782">경우 `Column` 현재 출력 위치 계산 된 출력 위치에 다음 줄에 출력이 시작 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2782">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="26db1-2783">계산 된 출력 위치 현재 출력 위치 보다 큰 경우의 계산 된 출력이 시작 출력 같은 줄에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2783">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="26db1-2784">출력 줄에서 맨 왼쪽 출력 위치는 항상 1입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2784">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="26db1-2785">사용 하는 경우는 `Print` 또는 `PrintLine` 파일을 인쇄 하는 함수의 가장 오른쪽 출력 위치를 사용 하 여 설정할 수 있는 출력 파일의 현재 너비는는 `FileWidth` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2785">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="26db1-2786">`TAB` 함수를 사용할 수도 있습니다는 `WriteLine` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2786">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="26db1-2787">함께 사용할 수 없습니다 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2787">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26db1-2788">테이블 열이 충분히 넓은 문자를 포함 하 고 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2788">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2789">사용 하 여이 예제는 `TAB` 파일 및 출력의 위치는 함수는 **출력** 창.</span><span class="sxs-lookup"><span data-stu-id="26db1-2789">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26db1-2790"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2790">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2791"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2791">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2792">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2792">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2793">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2793">Required.</span></span> <span data-ttu-id="26db1-2794">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2794">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="26db1-2795"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2795">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2796"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2796">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2797">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2797">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2798">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2798">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="26db1-2799">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2799">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="26db1-2800">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2800">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="26db1-2801">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2801">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="26db1-2802">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2802">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="26db1-2803">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2803">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2804">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2804">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="26db1-2805">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2805">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2806">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2806">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2807">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2807">Required.</span></span> <span data-ttu-id="26db1-2808">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2808">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="26db1-2809">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2809">Optional.</span></span> <span data-ttu-id="26db1-2810">잠그거나 잠금을 해제할 레코드 또는 바이트 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2810">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="26db1-2811"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2811">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2812"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2812">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2813">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2813">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2814">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2814">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="26db1-2815">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2815">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="26db1-2816">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2816">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="26db1-2817">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2817">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="26db1-2818">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2818">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="26db1-2819">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2819">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2820">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2820">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="26db1-2821">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2821">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2822">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2822">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2823">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2823">Required.</span></span> <span data-ttu-id="26db1-2824">유효한 파일 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2824">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="26db1-2825">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2825">Optional.</span></span> <span data-ttu-id="26db1-2826">잠그거나 잠금을 해제할 첫째 레코드 또는 바이트 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2826">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="26db1-2827">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2827">Optional.</span></span> <span data-ttu-id="26db1-2828">잠그거나 잠금을 해제할 마지막 레코드 또는 바이트 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2828">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="26db1-2829"><see langword="Open" /> 함수를 사용하여 연 파일의 일부 또는 전부에 대한 다른 프로세스의 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2829">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="26db1-2830"><see langword="My" /> 기능을 사용하면 <see langword="Lock" /> 및 <see langword="Unlock" />을 사용할 때보다 파일 I/O 작업의 생산성 및 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2830">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="26db1-2831">자세한 내용은 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26db1-2831">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2832">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2832">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="26db1-2833">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2833">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="26db1-2834">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2834">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="26db1-2835">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2835">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="26db1-2836">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2836">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="26db1-2837">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2837">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2838">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2838">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="26db1-2839">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2839">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2840">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2840">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2841">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2841">Required.</span></span> <span data-ttu-id="26db1-2842">유효한 파일 번호가 포함된 <see langword="Integer" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2842">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="26db1-2843">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2843">Optional.</span></span> <span data-ttu-id="26db1-2844">파일에 쓸 쉼표로 구분된 하나 이상의 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2844">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="26db1-2845">순차 파일에 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2845">Writes data to a sequential file.</span></span> <span data-ttu-id="26db1-2846"><see langword="Write" />로 작성된 데이터는 일반적으로 <see langword="Input" />을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2846">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2847">`Write` 및 `WriteLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2847">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2848">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2848">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2849">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2849">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2850">생략 하면 `Output`, 빈 줄은 파일에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2850">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="26db1-2851">여러 개의 식은 쉼표로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2851">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="26db1-2852">와 달리는 `Print` 함수는 `Write` 파일에 기록 된 대로 함수 항목 및 문자열 주위에 따옴표 사이 쉼표를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2852">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="26db1-2853">구분 기호 목록에 배치 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2853">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="26db1-2854">때 `Write` 숫자, 파일에 데이터를 쓰는 데 사용 되 `Boolean`, 날짜, null, 및 `Error` 데이터 형식이 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2854">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="26db1-2855">다음과 같은 유니버설 가정 하므로 데이터는 항상 읽을 수 있습니다 하 고 사용 하 여 올바르게 해석 뒤 `Input`로캘에 관계 없이:</span><span class="sxs-lookup"><span data-stu-id="26db1-2855">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="26db1-2856">숫자 데이터는 항상 소수 구분 기호로 마침표를 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2856">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="26db1-2857">에 대 한 `Boolean` 데이터를 `#TRUE#` 또는 `#FALSE#` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2857">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="26db1-2858">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2858">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="26db1-2859">날짜 데이터는 범용 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2859">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="26db1-2860">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2860">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="26db1-2861">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2861">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="26db1-2862">그러나 null 데이터에 대 한 `#NULL#` 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2862">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="26db1-2863">에 대 한 `Error` 데이터를 출력으로 표시 `#ERROR errorcode#`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2863">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="26db1-2864">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2864">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="26db1-2865">`WriteLine` 줄 바꿈 문자를 삽입 합니다 (즉, 캐리지 리턴/줄 바꿈 또는 `Chr(13) + Chr(10)`) 마지막 문자 입력 된 후, `Output` 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2865">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="26db1-2866">큰따옴표를 사용 하 여 문자열에 따옴표를 포함할 수 있습니다 또는 ""입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2866">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="26db1-2867">예를 들어 개체에 적용된</span><span class="sxs-lookup"><span data-stu-id="26db1-2867">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="26db1-2868">문자열의 값을 반환 `Double quotation marks aren't "difficult" to handle`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2868">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="26db1-2869">사용 하 여 파일에 쓰기는 `Write` 또는 `WriteLine` 함수 필요 `Append` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2869">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2870">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-2870">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2871">사용 하 여이 예제는 `Write` 함수를 원시 데이터는 순차적 파일을 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2871">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="26db1-2872">파일 모드가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="26db1-2872">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="26db1-2873">필수.</span><span class="sxs-lookup"><span data-stu-id="26db1-2873">Required.</span></span> <span data-ttu-id="26db1-2874">유효한 파일 번호가 포함된 <see langword="Integer" /> 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2874">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="26db1-2875">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2875">Optional.</span></span> <span data-ttu-id="26db1-2876">파일에 쓸 쉼표로 구분된 하나 이상의 식입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2876">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="26db1-2877">순차 파일에 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2877">Writes data to a sequential file.</span></span> <span data-ttu-id="26db1-2878"><see langword="Write" />로 작성된 데이터는 일반적으로 <see langword="Input" />을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2878">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26db1-2879">`Write` 및 `WriteLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2879">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="26db1-2880">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2880">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="26db1-2881">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2881">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="26db1-2882">생략 하면 `Output`, 빈 줄은 파일에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2882">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="26db1-2883">여러 개의 식은 쉼표로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2883">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="26db1-2884">와 달리는 `Print` 함수는 `Write` 파일에 기록 된 대로 함수 항목 및 문자열 주위에 따옴표 사이 쉼표를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2884">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="26db1-2885">구분 기호 목록에 배치 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2885">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="26db1-2886">때 `Write` 숫자, 파일에 데이터를 쓰는 데 사용 되 `Boolean`, 날짜, null, 및 `Error` 데이터 형식이 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2886">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="26db1-2887">다음과 같은 유니버설 가정 하므로 데이터는 항상 읽을 수 있습니다 하 고 사용 하 여 올바르게 해석 뒤 `Input`로캘에 관계 없이:</span><span class="sxs-lookup"><span data-stu-id="26db1-2887">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="26db1-2888">숫자 데이터는 항상 소수 구분 기호로 마침표를 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2888">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="26db1-2889">에 대 한 `Boolean` 데이터를 `#TRUE#` 또는 `#FALSE#` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2889">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="26db1-2890">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2890">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="26db1-2891">날짜 데이터는 범용 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2891">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="26db1-2892">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2892">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="26db1-2893">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2893">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="26db1-2894">그러나 null 데이터에 대 한 `#NULL#` 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2894">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="26db1-2895">에 대 한 `Error` 데이터를 출력으로 표시 `#ERROR errorcode#`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2895">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="26db1-2896">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2896">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="26db1-2897">`WriteLine` 줄 바꿈 문자를 삽입 합니다 (즉, 캐리지 리턴/줄 바꿈 또는 `Chr(13) + Chr(10)`) 마지막 문자 입력 된 후, `Output` 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2897">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="26db1-2898">큰따옴표를 사용 하 여 문자열에 따옴표를 포함할 수 있습니다 또는 ""입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2898">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="26db1-2899">예를 들어 개체에 적용된</span><span class="sxs-lookup"><span data-stu-id="26db1-2899">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="26db1-2900">문자열의 값을 반환 `Double quotation marks aren't "difficult" to handle`합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2900">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="26db1-2901">사용 하 여 파일에 쓰기는 `Write` 또는 `WriteLine` 함수 필요 `Append` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2901">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="26db1-2902">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26db1-2902">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26db1-2903">사용 하 여이 예제는 `Write` 함수를 원시 데이터는 순차적 파일을 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="26db1-2903">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>