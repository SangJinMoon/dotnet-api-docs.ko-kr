<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="757b138ad08a57ad8a16b1f7210ead2e45005193" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36728098" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 모듈은 Visual Basic 언어 키워드 및 파일 및 폴더에 액세스 하는 런타임 라이브러리 멤버를 지원 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `GetAttr` 파일 및 디렉터리 또는 폴더의 특성을 결정 하는 함수입니다.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder. <c>Path</c> may include the drive. If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</param>
        <summary>Changes the current directory or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` 함수는 기본 드라이브는 기본 디렉터리를 변경 합니다. 예를 들어 기본 드라이브는 C, 다음 문은 D 드라이브의 기본 디렉터리 변경 C 기본 드라이브는 그대로:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 상대를 만들 수 있습니다 디렉터리 변경 하는 두 개의 마침표를 다음과 같이 입력 합니다.  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` 함수 비관리 코드 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `ChDir` 함수는 현재 디렉터리 또는 폴더를 변경 합니다.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is empty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Changes the current drive.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` 함수 비관리 코드 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `ChDrive` 함수 현재 드라이브를 변경 합니다. 함수는 드라이브 존재 하지 않는 경우 예외가 throw 됩니다.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` 함수 비관리 코드 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `ChDrive` 함수 현재 드라이브를 변경 합니다. 함수는 드라이브 존재 하지 않는 경우 예외가 throw 됩니다.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 사용 하 여이 예제는 `CurDir` 함수는 현재 경로를 반환 합니다.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optional. <see langword="Char" /> expression that specifies an existing drive. If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</param>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 사용 하 여이 예제는 `CurDir` 함수는 현재 경로를 반환 합니다.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` 함수 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.  
  
 `VbVolume` 특정 파일 이름 대신 드라이브 볼륨 레이블을 반환합니다.  
  
 제공 해야 합니다는 `PathName` 처음으로 호출 하는 `Dir` 함수입니다. 다음 항목을 검색 하려면에 대 한 후속 호출을 만들 수 있습니다는 `Dir` 매개 변수 없이 함수입니다.  
  
> [!IMPORTANT]
>  제대로 실행 하려면는 `Dir` 함수에 필요는 <xref:System.Security.Permissions.FileIOPermissionAccess.Read> 및 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> 의 플래그를 지정 <xref:System.Security.Permissions.FileIOPermission> 를 실행 중인 코드에 부여 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
 `Attributes` 인수 열거형 값은 다음과 같습니다.  
  
|값|상수|설명|  
|-|-|-|  
|`Normal`|`vbnormal`|기본. 특성이 없는 파일을 지정합니다.|  
|`ReadOnly`|`vbReadOnly`|읽기 전용 파일 및 파일 특성 없이 지정합니다.|  
|`Hidden`|`vbHidden`|숨겨진된 파일 및 파일 특성 없이 지정합니다.|  
|`System`|`vbSystem`|시스템 파일 및 특성이 없는 파일을 지정합니다.|  
|`Volume`|`vbVolume`|볼륨 레이블;를 지정합니다. 다른 특성을 지정 하는 경우 `vbVolume` 는 무시 됩니다.|  
|`Directory`|`vbDirectory`|디렉터리 또는 폴더 및 특성이 없는 파일을 지정합니다.|  
|`Archive`|`vbArchive`|파일은 마지막 백업 이후 변경 되었습니다.|  
|`Alias`|`vbAlias`|파일 이름이 다릅니다.|  
  
> [!NOTE]
>  이 열거형은 Visual Basic 언어에 의해 지정 되며 실제 값 대신 코드에서 어디서 나 사용할 수 있습니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Dir` 을 특정 파일 및 디렉터리가 있는지 확인 합니다.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Optional. <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</param>
        <param name="Attributes">Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</param>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` 함수 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.  
  
 `VbVolume` 특정 파일 이름 대신 드라이브 볼륨 레이블을 반환합니다.  
  
 제공 해야 합니다는 `PathName` 처음으로 호출 하는 `Dir` 함수입니다. 다음 항목을 검색 하려면에 대 한 후속 호출을 만들 수 있습니다는 `Dir` 매개 변수가 없는 함수입니다.  
  
> [!IMPORTANT]
>  제대로 실행 하려면는 `Dir` 함수에 필요는 <xref:System.Security.Permissions.FileIOPermissionAccess.Read> 및 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> 의 플래그를 지정 <xref:System.Security.Permissions.FileIOPermission> 를 실행 중인 코드에 부여 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
 `Attributes` 인수 열거형 값은 다음과 같습니다.  
  
|값|상수|설명|  
|-|-|-|  
|`Normal`|`vbnormal`|기본. 특성이 없는 파일을 지정 합니다.|  
|`ReadOnly`|`vbReadOnly`|특성이 없는 파일 외에도 읽기 전용 파일을 지정 합니다.|  
|`Hidden`|`vbHidden`|특성이 없는 파일 뿐만 아니라 숨겨진된 파일을 지정 합니다.|  
|`System`|`vbSystem`|특성이 없는 파일 외에도 시스템 파일을 지정 합니다.|  
|`Volume`|`vbVolume`|볼륨 레이블;를 지정합니다. 다른 특성을 지정 하는 경우 `vbVolume` 는 무시 됩니다.|  
|`Directory`|`vbDirectory`|디렉터리나 파일 특성이 없는 뿐만 아니라 폴더를 지정 합니다.|  
|`Archive`|`vbArchive`|파일은 마지막 백업 이후 변경 되었습니다.|  
|`Alias`|`vbAlias`|파일 이름이 다릅니다.|  
  
> [!NOTE]
>  이 열거형은 Visual Basic 언어에 의해 지정 되며 실제 값 대신 코드에서 어디서 나 사용할 수 있습니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Dir` 을 특정 파일 및 디렉터리가 있는지 확인 합니다.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains any valid file number.</param>
        <summary>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</summary>
        <returns>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 `EOF` 입력을 가져올 파일의 끝을 지나서에 의해 생성 된 오류를 방지할 수 있습니다.  
  
 `EOF` 함수에서 반환 `False` 파일의 끝에 도달할 때까지 합니다. 연 파일 `Random` 또는 `Binary` 액세스 `EOF` 반환 `False` 는 마지막으로 실행 될 때까지 `FileGet` 함수는 전체 레코드를 읽을 수 없습니다.  
  
 연 파일 `Binary` 액세스를 사용 하 여 파일을 통해 읽지는 `Input` 될 때까지 작동 `EOF` 반환 `True` 오류가 발생 합니다. 사용 하 여는 `LOF` 및 `Loc` 대신 함수 `EOF` 때 이진 파일을 읽는 `Input`, 사용 또는 `Get` 사용 하는 경우는 `EOF` 함수입니다. 연 파일 `Output`, `EOF` 항상 반환 `True`합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `EOF` 함수는 파일의 끝을 검색 합니다. 이 예에서는 가정 하는 `Testfile` 은 여러 줄의 텍스트를 포함 하는 텍스트 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. <see langword="Integer" />. Any valid file number.</param>
        <summary>Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</summary>
        <returns>The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 연 파일에 대 한 파일 모드를 나타내는 열거형을 반환 하는이 함수는 `FileOpen` 함수입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FileAttr` 함수 열려 있는 파일의 파일 모드를 반환 합니다.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optional. Parameter array of 0 or more channels to be closed.</param>
        <summary>Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function. <see langword="My" /> gives you better productivity and performance in file I/O operations. See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [하는 방법: StreamReader 사용 하 여 파일에서 텍스트 읽기](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[하는 방법: StreamWriter 사용 하 여 파일에 텍스트 쓰기](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), 및 [연습: 조작 파일 및 디렉터리에서 Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)합니다.  
  
 생략 하면 `FileNumbers`, 모든 활성 파일에서 연는 `FileOpen` 함수 닫힙니다.  
  
 에 대 한 연 파일을 닫을 때 `Output` 또는 `Append`, 출력의 마지막 버퍼 해당 파일에 대 한 운영 체제 버퍼에 기록 됩니다. 모든 버퍼 공간 닫힌와 연결 된 파일을 배포 합니다.  
  
 경우는 `FileClose` 함수 실행 되 고, 해당 파일이 있는 파일의 연결 끝 번호입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FileClose` 파일을 닫으려면 함수에 대 한 열린 `Input`합니다.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Required. <see langword="String" /> expression that specifies the name of the file to be copied. <c>Source</c> may include the directory or folder, and drive, of the source file.</param>
        <param name="Destination">Required. <see langword="String" /> expression that specifies the destination file name. <c>Destination</c> may include the directory or folder, and drive, of the destination file.</param>
        <summary>Copies a file. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하려는 경우는 `FileCopy` 함수 현재 열려 있는 파일에 오류가 발생 합니다.  
  
 `FileCopy` 로컬 드라이브에서 작동 하도록 완전 신뢰가 필요 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FileCopy` 하나의 파일 간에 복사 하는 함수입니다. 이 예제에서는 한다고 가정 `SrcFile` 는 데이터가 포함 된 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</exception>
        <exception cref="T:System.IO.IOException">File is already open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Date" /> value that indicates the date and time a file was written to. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>
          <see langword="Date" /> value that indicates the date and time a file was created or last modified.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 사용 하 여이 예제는 `FileDateTime` 함수는 날짜를 파일 시간을 만들거나 마지막으로 수정 합니다. 날짜 및 시간 표시의 형식은 시스템의 로캘 설정을 기반으로 합니다.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는`FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자 사용 하지 않는 경우입니다. 에 전달 된 크기와 배열 범위 다음 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수`FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는`FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 하나의 레코드의 끝와 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.  
  
-   기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다. 설명자와 작성 된 경우 설명자를 읽을 해야 합니다. 설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.  
  
     설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 바이트는 다음과 같이 배포 됩니다.  
  
    -   설명자에 대해 18 바이트: (2 * 2 + 8)  
  
    -   데이터에 대 한 200 바이트: (4 * 5 * 10).  
  
-   로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 모든 배열 및 설명자가 포함 됩니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
-   `FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
    > [!IMPORTANT]
    >  사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject` 함수 대신 사용 됩니다 `FileGet` 경우 컴파일 타임에 모호성을 피할 수 형식 `Object` 와 같은 다른 형식 대신 반환 `Integer`, `Long`, `Short`, 등입니다.  
  
 작성 하려는 경우는 `Variant` 형식 `FileGetObject` 가 필요 합니다. 확실 하지 않은, 두 번째 매개 변수에 대 한 개체 사용 중인 경우, 항상 좋습니다를 사용 하는 `FilePutObject` 및 `FileGetObject`합니다.  
  
 `FileGetObject` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 데이터를 읽을 `FileGetObject` 일반적으로 작성 된 `FilePutObject`합니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, `FileGetObject` 마지막 뒤 레코드 또는 바이트를 읽고 `FileGetObject` 또는 `FilePutObject` 함수 (또는 마지막에서 가리키는 `Seek` 함수).  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGetObject` 레코드 길이 경계에 있는 후속 레코드를 읽습니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 채워지는 데이터의 양은 정확 하 게 확인할 수 없습니다, 되므로 레코드 길이 읽을 데이터의 길이 일치 하는 것이 좋습니다.  
  
-   읽을 변수가 기본적으로는 문자열이 `FileGetObject` 문자열 길이 포함 하는 2 바이트 설명자를 읽고 다음 변수에 전달 되는 데이터를 읽습니다. 지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다. Visual Basic 6.0 및 이전 버전에서는 고정 길이 문자열을 파일을 읽을 때 길이 설명자는 기록 되지 않습니다. 전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   으로 읽고 배열에 되 면 변수로 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: 2 + 8 * 더한 것입니다.  
  
     배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 바이트가 다음과 같이 배포 됩니다: (2 + 8 * 2) 설명자에 대 한 18 바이트 및 (4 * 5 * 10) 데이터에 대 한 100 바이트입니다.  
  
-   `FileGetObject` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다. 동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePutObject`)는 설명자가 2 더하기 8 시간 차원 수가 옵니다: 2 + 8 * 더한 것입니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 모든 배열과 그 설명자를 포함 하 여 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. <xref:Microsoft.VisualBasic.VBFixedStringAttribute> 클래스를 쓸 때 문자열의 크기를 나타내는 구조체의 string 필드에 적용할 수 디스크에 있습니다.  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드의 모든는 `Random` 경우를이 제외 규칙이 적용 됩니다.  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FileGetObject` 변수를 읽습니다 모든 디스크에서 연속적으로 즉, 레코드 간에 데이터가 채워지지 않습니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FileGetObject` 만 데이터를 읽습니다. 설명자는 읽지 않습니다.  
  
 `FileGetObject` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다. 읽은 바이트 수를는 문자열의 문자 수를 같습니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 파일이 Visual Basic 소스 파일 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 레코드를 읽고 테스트 파일에 다음이 검색 합니다.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the length of a file in bytes. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          <see langword="Long" /> value that specifies the length of a file in bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 파일은 열려 있는 경우는 `FileLen` 함수 호출 되 면 반환 된 값으로 열었을 때 파일의 크기를 나타냅니다.  
  
> [!NOTE]
>  열려 있는 파일의 현재 길이 가져오려면는 `LOF` 함수입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FileLen` 함수를 파일의 길이 바이트 단위로 반환 합니다. 이 예제에서는 한다고 가정 `TestFile` 은 일부 데이터를 포함 하는 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number. Use the <see langword="FreeFile" /> function to obtain the next available file number.</param>
        <param name="FileName">Required. <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</param>
        <param name="Mode">Required. Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Optional. Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />. Defaults to <see langword="ReadWrite" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Optional. Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />. Defaults to <see langword="Lock Read Write" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.</param>
        <summary>Opens a file for input or output. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 I/O 작업을 수행 하려면 먼저 파일을 열어야 합니다. `FileOpen` 파일 I/O에 대 한 버퍼를 할당 하 고 버퍼와 함께 사용할 액세스 모드를 결정 합니다.  
  
> [!IMPORTANT]
>  파일에 쓸 때 응용 프로그램 만들어야 할 수 파일을 작성 하려는 파일이 존재 하지 않는 경우. 이렇게 하려면 해당 파일이 만들어질 된 디렉터리에 대 한 권한이 있어야 합니다. 그러나 하 여 지정한 파일이 있으면 `FileName` 존재 않는 응용 프로그램 요구 `Write` 파일 자체에 사용 권한입니다. 보안을 강화 하려면 가능한, 배포 및 부여 하는 동안 파일을 만들고 하는 아무 곳에 나 `Write` 해당 파일에 대 한 전체 디렉터리 대신만 합니다. 보안 향상을 위해 대신 사용자 디렉터리의 루트 디렉터리 또는 Program Files 디렉터리에 데이터를 씁니다.  
  
 사용 하 여 열려는 채널을 찾을 수 있습니다는 `FreeFile()` 함수입니다.  
  
> [!IMPORTANT]
>  `FileOpen` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다. 자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거 합니다.  
  
   
  
## Examples  
 다양 한 용도 보여 주는이 예제는 `FileOpen` 함수를 입력 및 출력 파일을 사용 합니다.  
  
 다음 코드 파일을 열고 `TestFile` 에 `Input` 모드입니다.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 이 예제에서 파일을 열고 `Binary` 쓰기 작업용 모드입니다.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 다음 예제에서는의 파일을 엽니다 `Random` 모드입니다. 해당 파일의 구조는 레코드가 포함 `Person`합니다.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 이 코드 예제에서 파일을 열고 `Output` 모드; 읽거나 파일에 쓸 모든 프로세스 수 있습니다.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 이 코드 예제에서 파일을 열고 `Binary` 읽기에 대 한 모드 다른 프로세스가 파일을 읽을 수 없습니다.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Record length is negative (and not equal to -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는`VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는`RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.  
  
-   쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다. 따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다. Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다. Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다. 설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다. 읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것). 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다. 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.  
  
-   `FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다. `VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.  
  
    > [!NOTE]
    >  문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다. 열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
-   구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다. 설명자를 쓰지 않았습니다.  
  
-   `FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다. 쓴 바이트 수를는 문자열의 문자 수를 같습니다. 예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다. 구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject` 함수 대신 사용 됩니다 `FilePut` 경우 컴파일 타임에 모호성을 방지 하려면 형식 `Object` 와 같은 다른 형식 대신 전달 됩니다 `Integer`, `Long`, `Short`, 등입니다.  
  
 `FilePutObject` 작성 하 고 개체를 설명 하는 설명자를 읽습니다. 작성 하려는 경우는 `Variant` 형식 `FilePutObject` 가 필요 합니다. 확실 하지 않은, 두 번째 매개 변수에 대 한 개체 사용 중인 경우, 항상 사용 하는 권장 `FilePutObject` 및 `FileGetObject`합니다.  
  
 `FilePutObject` 에서만 유효 `Random` 및 `Binary` 모드입니다.  
  
 `FilePutObject`로 작성된 데이터는 일반적으로 `FileGetObject`을 사용하여 파일에서 읽습니다.  
  
 첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등. 생략 하면 `RecordNumber`, `FilePutObject` 지난 후 다음 레코드 또는 바이트를 쓰기 `FileGetObject` 또는 `FilePutObject` 함수 (또는 마지막에서 가리키는 레코드 또는 바이트 `Seek` 함수).  
  
 `StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다. `FilePutObject` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다. 사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePutObject`와 동일한 작업을 수행 해야 `FileGetObject`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.  
  
## <a name="random-mode"></a>임의 모드  
 연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.  
  
-   쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePutObject` 레코드 길이 경계에 다음 레코드를 씁니다. 한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다. 채워지는 데이터의 양은 정확 하 게 확인할 수 없습니다, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다. 기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수, 예외가 throw 됩니다.  
  
-   숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePutObject` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다. 예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePutObject` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.  
  
-   쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePutObject` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다. 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다. 전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.  
  
-   쓰고 배열 되 면 변수로 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다. 설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다. 길이 2 + 8 시간 차원 수가: (2 + 8 * 더한 것).  
  
## <a name="binary-mode"></a>이진 모드  
 연 파일에 `Binary` 모드에서는 모든는 `Random` 모드 규칙 적용을 제외 하 고:  
  
-   `RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다. `FilePutObject` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FilePutObject` 문자열 파일에 기록 하는 함수입니다.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="RecordWidth">Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <c>RecordWidth</c> equals 0, there is no limit to the length of a line. The default value for <c>RecordWidth</c> is 0.</param>
        <summary>Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 사용 하 여이 예제는 `FileWidth` 파일에 대 한 출력 선 두께 설정 하는 함수입니다.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</summary>
        <returns>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 `FreeFile` 을 이미 사용 되지 않는 파일 번호를 제공 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `FreeFile` 다음 사용 가능한 파일 수를 반환 하는 함수입니다. 5 개의 파일 출력 루프 내에 열리고 몇 가지 샘플 데이터에 각각 기록 됩니다.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">More than 255 files are in use.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file, directory, or folder name. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 설정 된 특성을 확인 하려면는 `And` 연산자에서 반환 값의 비트 비교를 수행 하는 `GetAttr` 함수와 원하는 개별 파일 특성의 값입니다. 결과 0이 아니면 해당 특성은 명명된 된 파일에 설정 됩니다. 예를 들어, 다음의 반환 값 `And` 식은 경우에는 0는 `Archive` 특성이 설정 되지 않았습니다.  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 0이 아닌 값을 반환 된 `Archive` 특성이 설정 되어 있습니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `GetAttr` 파일 및 디렉터리 또는 폴더의 특성을 결정 하는 함수입니다.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 은 파일을 사용 하 여 기록 된 데이터의 일부 줄입니다는 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 은 파일을 사용 하 여 기록 된 데이터의 일부 줄입니다는 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전에서 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문입니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.  
  
 읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다. 다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.  
  
|데이터|변수에 할당 된 값|  
|-|-|  
|쉼표 또는 빈 줄을 구분합니다.|Empty|  
|#NULL#|`DBNull`|  
|# # TRUE 또는 FALSE # #|`True` 또는 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|날짜 및/또는 식으로 표시 된 시간이|  
|#ERROR `errornumber`#|`errornumber` (변수가 오류 태그가 지정 된 개체)|  
  
 데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.  
  
> [!NOTE]
>  `Input` 함수 지역화 되지 않습니다. 예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다. 이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="CharCount">Required. Any valid numeric expression specifying the number of characters to read.</param>
        <summary>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 사용 하 여 읽은 데이터는 `InputString` 함수는 일반적으로 사용 하 여 파일에 기록 됩니다 `Print` 또는 `FilePut`합니다. 열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.  
  
 와 달리는 `Input` 함수는 `InputString` 읽어 온 모든 문자가 반환 됩니다. 여기에 쉼표, 캐리지 리턴, 줄 바꿈, 인용 부호 및 선행 공백을 포함 됩니다.  
  
 연 파일 `Binary` 액세스를 사용 하 여 파일을 통해 읽지는 `InputString` 될 때까지 작동 `EOF` 반환 `True` 오류가 발생 합니다. 사용 하 여는 `LOF` 및 `Loc` 대신 함수 `EOF` 를 사용 하 여 이진 파일을 읽을 때 `InputString`, 사용 또는 `FileGet` 사용 하는 경우는 `EOF` 함수입니다.  
  
> [!NOTE]
>  파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대해 보안 판단 하면 안 됩니다. 예를 들어 Form1.vb 파일이 Visual Basic 소스 파일 수 없습니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `InputString` 파일에서 한 번에 한 문자를 읽고 인쇄 하는 함수는 `Output` 창. 이 예에서는 가정 하는 `MyFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 or &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies one or more file names to be deleted. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Deletes files from a disk. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.  
  
 **보안 정보** 을 실행 하려면는 `Kill` 함수 필요 `Read` 및 `PathDiscovery` 의 플래그 지정 <xref:System.Security.Permissions.FileIOPermission> 코드 실행에 부여할 합니다. 자세한 내용은 참조 <xref:System.Security.SecurityException> [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 사용 하 여이 예제는 `Kill` 함수를 디스크에서 파일을 삭제 합니다.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Target file(s) open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file(s) not found.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</summary>
        <returns>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 데이터를 읽을 `LineInput` 를 사용 하 여 일반적으로 파일에 기록 `Print`합니다.  
  
> [!IMPORTANT]
>  파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다. 예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.  
  
 `LineInput` 캐리지 리턴에 도달할 때까지 한 번에 파일 1 자에서 함수를 읽습니다 (`Chr(13)`) 또는 캐리지 리턴/줄 바꿈 (`Chr(13) + Chr(10)`) 시퀀스입니다. 캐리지 리턴/줄 바꿈된 시퀀스 문자 문자열에 추가 하는 대신 생략 됩니다.  
  
> [!IMPORTANT]
>  사용 하 여 파일에서 읽기는 `LineInput` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `LineInput` 함수 순차 파일에서 줄을 읽고을 변수에 할당 합니다. 이 예에서는 가정 하는 `TestFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">End of file reached.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid <see langword="Integer" /> file number.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</summary>
        <returns>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` 함수는 0부터 시작; 파일의 첫 번째 바이트를 검색 하는 데 사용 하는 0을 반환 합니다.  
  
 `Loc` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.  
  
|모드|반환 값|  
|-|-|  
|`Random`|읽거나 파일에 쓴 마지막 레코드의 수입니다.|  
|`Sequential`|128로 구분해 서 파일의 현재 바이트 위치입니다. 그러나 정보를 반환할 `Loc` 순차적 파일 사용 아니고 필요한에 대 한 합니다.|  
|`Binary`|마지막 바이트 읽기 또는 쓰기의 위치입니다.|  
  
   
  
## Examples  
 사용 하 여이 예제는 `Loc` 열려 있는 파일의 현재 읽기/쓰기 위치를 반환 하는 함수입니다. 이 예에서는 가정 하는 `MyFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.  
  
 `Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다. 에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.  
  
 경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다. 경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.  
  
 파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.  
  
   
  
## Examples  
 이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다. 이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.  
  
 `Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다. 에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.  
  
 경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다. 경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.  
  
 파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.  
  
   
  
## Examples  
 이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다. 이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.  
  
 `Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다. 에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.  
  
 경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다. 경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.  
  
 파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.  
  
   
  
## Examples  
 이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다. 이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 `FileLen` 열려 있지 않은 파일의 길이 함수입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `LOF` 열려 있는 파일의 크기를 결정 하는 함수입니다. 이 예에서는 가정 하는 `TestFile` 은 샘플 데이터를 포함 하는 텍스트 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory to be created. The <c>Path</c> may include the drive. If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</param>
        <summary>Creates a new directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 함수는 새 디렉터리를 만듭니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `MkDir` 디렉터리를 만들 함수입니다. 드라이브 지정 되지 않은 경우에 현재 드라이브에 새 디렉터리가 만들어집니다.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <exception cref="T:System.IO.IOException">Directory already exists.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` 및 `PrintLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 `Print` 줄 바꿈으로 줄의 끝에 포함 되지 않습니다. 그러나 `PrintLine` 줄 바꿈에 포함 되어 있습니다.  
  
 로 작성 된 데이터 `Print` 일반적으로 사용 하 여 파일에서 읽은 `LineInput` 또는 `Input`합니다.  
  
 생략 하면 `Output` 에 대 한 `PrintLine`, 빈 줄에 대 한; 파일에 출력은 `Print`, 아무것도 출력 되지 않습니다. 쉼표로 구분 된 여러 개의 식을 혼합 쉼표 탭 경계에 맞춰집니다 및 `TAB` 일관 되지 않은 결과가 발생할 수 있습니다.  
  
 에 대 한 `Boolean` 데이터를 `True` 또는 `False` 인쇄 됩니다. `True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
 날짜 데이터는 시스템에서 인식 표준 짧은 날짜 형식을 사용 하 여 파일에 기록 됩니다. 날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.  
  
 있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다. 그러나 경우 `Output` 목록 데이터는 `DBNull`, `Null` 파일에 기록 합니다.  
  
 에 대 한 `Error` 데이터를 출력으로 표시 `Error errorcode`합니다. `Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
 모든 데이터를 사용 하 여 파일에 기록 `Print` 국제적으로 인식 됩니다; 즉, 데이터의 형식이 올바르게 적절 한 소수 구분 기호를 사용 하 여 합니다. 여러 로캘에서 사용할 데이터를 출력 하려는 경우 `Write` 사용 해야 합니다.  
  
 사용 하 여 파일에 쓰기는 `Print` 또는 `PrintLine` 함수 필요 `Write` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Print` 및 `PrintLine` 함수는 파일에 데이터를 쓸 수 있습니다.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` 및 `PrintLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 `Print` 줄 바꿈으로 줄의 끝에 포함 되지 않습니다. 그러나`PrintLine` 줄 바꿈에 포함 되어 있습니다.  
  
 로 작성 된 데이터 `Print` 일반적으로 사용 하 여 파일에서 읽은 `LineInput` 또는 `Input`합니다.  
  
 생략 하면 `Output` 에 대 한 `PrintLine`, 빈 줄에 대 한; 파일에 출력은 `Print`, 아무것도 출력 되지 않습니다. 쉼표로 구분 된 여러 개의 식을 혼합 쉼표 탭 경계에 맞춰집니다 및 `TAB` 일관 되지 않은 결과가 발생할 수 있습니다.  
  
 에 대 한 `Boolean` 데이터를 `True` 또는 `False` 인쇄 됩니다. `True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
 날짜 데이터는 시스템에서 인식 하는 표준의 간단한 날짜 형식을 사용 하 여 파일에 기록 됩니다. 날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.  
  
 있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다. 그러나 경우 `Output` 목록 데이터는 `DBNull`, `Null` 파일에 기록 합니다.  
  
 에 대 한 `Error` 데이터를 출력으로 표시 `Error errorcode`합니다. `Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
 모든 데이터를 사용 하 여 파일에 기록 `Print` 국제적으로 인식 됩니다; 즉, 데이터의 형식이 올바르게 적절 한 소수 구분 기호를 사용 하 여 합니다. 여러 로캘에서 사용할 데이터를 출력 하려는 경우 `Write` 사용 해야 합니다.  
  
 사용 하 여 파일에 쓰기는 `Print` 또는 `PrintLine` 함수 필요 `Write` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Print` 및 `PrintLine` 함수는 파일에 데이터를 쓸 수 있습니다.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Required. <see langword="String" /> expression that specifies the existing file name and location. <c>OldPath</c> may include the directory, and drive, of the file.</param>
        <param name="NewPath">Required. <see langword="String" /> expression that specifies the new file name and location. <c>NewPath</c> may include directory and drive of the destination location. The file name specified by <c>NewPath</c> cannot already exist.</param>
        <summary>Renames a disk file or directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` 함수는 파일 이름을 바꾸고 필요한 경우 다른 디렉터리로 이동 합니다. `Rename` 함수는 드라이브에 파일을 이동할 수 있지만 기존 디렉터리의 이름만 바꿀 수 때 둘 다 `NewPath` 및 `OldPath` 는 동일한 드라이브에 있습니다. `Rename` 새 파일 또는 디렉터리를 만들 수 없습니다.  
  
 사용 하는 `Rename` 열려 있는 파일에 대해 함수에서 오류가 발생 합니다. 이름을 바꾸기 전에 열려 있는 파일을 닫아야 합니다. `Rename` 다중 문자 (*) 및 (?) 단일 문자 와일드 카드 인수 포함할 수 없습니다.  
  
> [!IMPORTANT]
>  사용 하는 경우 `Rename` 파일에 덜 제한적인된 권한이 보호 된 위치를 보호 되지 않는 위치에서 파일을 복사를 유지 합니다. 보안상 위험을 도입 하지는 있는지 확인 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Rename` 파일 이름을 바꾸는 함수입니다. 이 예제에서 이미 지정 된 디렉터리에 존재 하는지 가정 합니다.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Path is invalid.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> file does not exist.</exception>
        <exception cref="T:System.IO.IOException">Cannot rename to different device.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes all disk files opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset` 함수에 의해 열린 모든 활성 파일 닫습니다는 `FileOpen` 작동 하 고 동일한 기능을 `FileClose()` 매개 변수 없이 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Reset` 함수를 열려 있는 모든 파일을 닫고 모든 파일 버퍼의 내용이 디스크에 쓰여집니다. 사용 하 여는 `Object` 변수 `FileNumber` 문자열과 숫자를 모두로 합니다.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory or folder to be removed. <c>Path</c> can include the drive. If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</param>
        <summary>Removes an existing directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />. For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하려고 하면 오류가 발생 `RmDir` 파일이 포함 된 디렉터리에 있습니다. 사용 된 `Kill` 디렉터리를 제거 하기 전에 모든 파일을 삭제 하는 함수입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `RmDir` 함수 기존 디렉터리를 제거 합니다.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.IO.IOException">Target directory contains files.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Directory does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 1에서 2,147,483,647 사이의 값을 반환 합니다. (2 ^31-1).  
  
 다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.  
  
|모드|반환 값|  
|-|-|  
|`Random`|읽거나 쓴 다음 레코드의 수|  
|`Binary`, `Input`, `Output`, `Append`|다음 작업이 발생 하는 바이트 위치입니다. 파일의 첫 번째 바이트 위치 1에 있고, 두 번째 바이트는 2, 위치입니다.|  
  
   
  
## Examples  
 사용 하 여이 예제는 `Seek` 함수는 현재 파일 위치를 반환 합니다. 이 예에서는 가정 `TestFile` 구조체의 레코드를 포함 하는 파일은 `Record`합니다.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 연 파일에 `Random` 모드 `Seek` 다음 레코드의 수를 반환 합니다.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 반환 합니다. 가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 사용 하 여이 예제는 `Seek` 함수 또는 파일에 쓰기 다음 읽기에 대 한 위치를 설정 합니다.  
  
 이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 설정 합니다. 가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <param name="Position">Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 1에서 2,147,483,647 사이의 값을 반환 합니다. (2 ^31-1).  
  
 다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.  
  
|모드|반환 값|  
|-|-|  
|`Random`|읽거나 쓴 다음 레코드의 수|  
|`Binary`, `Input`, `Output`, `Append`|다음 작업이 발생 하는 바이트 위치입니다. 파일의 첫 번째 바이트 위치 1에 있고, 두 번째 바이트는 2, 위치입니다.|  
  
   
  
## Examples  
 사용 하 여이 예제는 `Seek` 함수는 현재 파일 위치를 반환 합니다. 이 예에서는 가정 `TestFile` 구조체의 레코드를 포함 하는 파일은 `Record`합니다.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 연 파일에 `Random` 모드 `Seek` 다음 레코드의 수를 반환 합니다.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 반환 합니다. 가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 사용 하 여이 예제는 `Seek` 함수 또는 파일에 쓰기 다음 읽기에 대 한 위치를 설정 합니다.  
  
 이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 설정 합니다. 가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> can include directory or folder, and drive.</param>
        <param name="Attributes">Required. Constant or numeric expression, whose sum specifies file attributes.</param>
        <summary>Sets attribute information for a file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 열려 있는 파일의 특성을 설정 하려고 하면 런타임 오류가 발생 합니다.  
  
 `Attributes` 인수 열거형 값은 다음과 같습니다.  
  
|값|상수|설명|  
|-|-|-|  
|`Normal`|`vbNormal`|보통 (기본값)입니다.|  
|`ReadOnly`|`vbReadOnly`|읽기 전용입니다.|  
|`Hidden`|`vbHidden`|숨겨집니다.|  
|`System`|`vbSystem`|시스템 파일입니다.|  
|`Volume`|`vbVolume`|볼륨 레이블|  
|`Directory`|`vbDirectory`|디렉터리 또는 폴더입니다.|  
|`Archive`|`vbArchive`|파일은 마지막 백업 이후 변경 되었습니다.|  
|`Alias`|`vbAlias`|파일 이름이 다릅니다.|  
  
> [!NOTE]
>  이러한 열거형 Visual Basic 언어에 의해 지정 됩니다. 이름은 실제 값 대신 코드에서 아무 곳 이나 사용할 수 있습니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `SetAttr` 파일의 특성을 설정 하는 함수입니다.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> type is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Required. The number of spaces to insert before displaying or printing the next expression in a list.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `Count` 출력 선 두께 다음 출력 위치를 즉시 인쇄 되는 공백 수 뒤에 보다 작습니다. 경우`Count` 출력 선 두께 보다 크면 `SPC` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 예를 들어 현재 출력 위치 24 이면 출력 줄 너비는 80 이며, 지정한 `SPC(90)`, 다음 출력 34 (출력 위치를 현재 + 90/80의 나머지) 위치에서 시작 됩니다. 현재 출력 위치와 출력 선 두께 간에 차이가 있는 경우 보다 작은 `Count` (또는 `Count` `Mod` *너비*), `SPC` 다음 줄의 시작 부분에 건너뛰고 생성 함수 같은 공간 `Count` – (*너비* – *currentprintposition*).  
  
> [!NOTE]
>  테이블 열이 와이드 문자를 허용 하도록 충분히 있는지 확인 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `SPC` 파일 및 출력의 위치는 함수는 **출력** 창.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 줄에 현재 출력 위치 보다 큰 경우 `Column`, `TAB` 해당 하는 열 값으로 건너뜁니다 `Column` 다음 출력 줄. 경우 `Column` 1 보다 작으면 `TAB` 수식을 출력 위치를 계산 합니다. 경우 `Column` 출력 줄 너비 보다 큰 `TAB` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.  
  
 Mod 열 너비  
  
 예를 들어 경우 *너비* 80이 고 지정한 경우 `TAB(90)`, 다음 출력 열 (90/80의 나머지) 10에서 시작 됩니다. 경우 `Column` 현재 출력 위치 계산 된 출력 위치에 다음 줄에 출력이 시작 보다 작습니다. 계산 된 출력 위치 현재 출력 위치 보다 큰 경우의 계산 된 출력이 시작 출력 같은 줄에 위치 합니다.  
  
 출력 줄에서 맨 왼쪽 출력 위치는 항상 1입니다. 사용 하는 경우는 `Print` 또는 `PrintLine` 파일을 인쇄 하는 함수의 가장 오른쪽 출력 위치를 사용 하 여 설정할 수 있는 출력 파일의 현재 너비는는 `FileWidth` 함수입니다.  
  
 `TAB` 함수를 사용할 수도 있습니다는 `WriteLine` 함수입니다. 함께 사용할 수 없습니다 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  테이블 열이 충분히 넓은 문자를 포함 하 고 있는지 확인 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `TAB` 파일 및 출력의 위치는 함수는 **출력** 창.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 줄에 현재 출력 위치 보다 크면 `Column`, `TAB` 해당 하는 열 값으로 건너뜁니다 `Column` 다음 출력 줄. 경우 `Column` 1 보다 작으면 `TAB` 수식을 출력 위치를 계산 합니다. 경우 `Column` 출력 선 두께 보다 크면 `TAB` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.  
  
 Mod 열 너비  
  
 예를 들어 경우 *너비* 80이 고 지정한 경우 `TAB(90)`, 다음 출력 열 (90/80의 나머지) 10에서 시작 됩니다. 경우 `Column` 현재 출력 위치 계산 된 출력 위치에 다음 줄에 출력이 시작 보다 작습니다. 계산 된 출력 위치 현재 출력 위치 보다 큰 경우의 계산 된 출력이 시작 출력 같은 줄에 위치 합니다.  
  
 출력 줄에서 맨 왼쪽 출력 위치는 항상 1입니다. 사용 하는 경우는 `Print` 또는 `PrintLine` 파일을 인쇄 하는 함수의 가장 오른쪽 출력 위치를 사용 하 여 설정할 수 있는 출력 파일의 현재 너비는는 `FileWidth` 함수입니다.  
  
 `TAB` 함수를 사용할 수도 있습니다는 `WriteLine` 함수입니다. 함께 사용할 수 없습니다 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  테이블 열이 충분히 넓은 문자를 포함 하 고 있는지 확인 합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `TAB` 파일 및 출력의 위치는 함수는 **출력** 창.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.  
  
 `Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다. 에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.  
  
 경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다. 경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.  
  
 파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.  
  
   
  
## Examples  
 이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다. 이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.  
  
 `Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다. 에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.  
  
 경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다. 경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.  
  
 파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.  
  
   
  
## Examples  
 이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다. 이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.  
  
 `Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다. 에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.  
  
 경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다. 경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.  
  
 파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.  
  
   
  
## Examples  
 이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다. 이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` 및 `WriteLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 생략 하면 `Output`, 빈 줄은 파일에 출력 합니다. 여러 개의 식은 쉼표로 구분할 수 있습니다.  
  
 와 달리는 `Print` 함수는 `Write` 파일에 기록 된 대로 함수 항목 및 문자열 주위에 따옴표 사이 쉼표를 삽입 합니다. 구분 기호 목록에 배치 필요가 없습니다. 때 `Write` 숫자, 파일에 데이터를 쓰는 데 사용 되 `Boolean`, 날짜, null, 및 `Error` 데이터 형식이 지원 됩니다. 다음과 같은 유니버설 가정 하므로 데이터는 항상 읽을 수 있습니다 하 고 사용 하 여 올바르게 해석 뒤 `Input`로캘에 관계 없이:  
  
-   숫자 데이터는 항상 소수 구분 기호로 마침표를 사용 하 여 기록 됩니다.  
  
-   에 대 한 `Boolean` 데이터를 `#TRUE#` 또는 `#FALSE#` 인쇄 됩니다. `True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
-   날짜 데이터는 범용 날짜 형식을 사용 하 여 파일에 기록 됩니다. 날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.  
  
-   있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다. 그러나 null 데이터에 대 한 `#NULL#` 기록 됩니다.  
  
-   에 대 한 `Error` 데이터를 출력으로 표시 `#ERROR errorcode#`합니다. `Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
 `WriteLine` 줄 바꿈 문자를 삽입 합니다 (즉, 캐리지 리턴/줄 바꿈 또는 `Chr(13) + Chr(10)`) 마지막 문자 입력 된 후, `Output` 파일에 있습니다.  
  
 큰따옴표를 사용 하 여 문자열에 따옴표를 포함할 수 있습니다 또는 ""입니다. 예를 들어 개체에 적용된  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 문자열의 값을 반환 `Double quotation marks aren't "difficult" to handle`합니다.  
  
 사용 하 여 파일에 쓰기는 `Write` 또는 `WriteLine` 함수 필요 `Append` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Write` 함수를 원시 데이터는 순차적 파일을 기록 합니다.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` 및 `WriteLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다. 이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다. 자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.  
  
 생략 하면 `Output`, 빈 줄은 파일에 출력 합니다. 여러 개의 식은 쉼표로 구분할 수 있습니다.  
  
 와 달리는 `Print` 함수는 `Write` 파일에 기록 된 대로 함수 항목 및 문자열 주위에 따옴표 사이 쉼표를 삽입 합니다. 구분 기호 목록에 배치 필요가 없습니다. 때 `Write` 숫자, 파일에 데이터를 쓰는 데 사용 되 `Boolean`, 날짜, null, 및 `Error` 데이터 형식이 지원 됩니다. 다음과 같은 유니버설 가정 하므로 데이터는 항상 읽을 수 있습니다 하 고 사용 하 여 올바르게 해석 뒤 `Input`로캘에 관계 없이:  
  
-   숫자 데이터는 항상 소수 구분 기호로 마침표를 사용 하 여 기록 됩니다.  
  
-   에 대 한 `Boolean` 데이터를 `#TRUE#` 또는 `#FALSE#` 인쇄 됩니다. `True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
-   날짜 데이터는 범용 날짜 형식을 사용 하 여 파일에 기록 됩니다. 날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.  
  
-   있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다. 그러나 null 데이터에 대 한 `#NULL#` 기록 됩니다.  
  
-   에 대 한 `Error` 데이터를 출력으로 표시 `#ERROR errorcode#`합니다. `Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.  
  
 `WriteLine` 줄 바꿈 문자를 삽입 합니다 (즉, 캐리지 리턴/줄 바꿈 또는 `Chr(13) + Chr(10)`) 마지막 문자 입력 된 후, `Output` 파일에 있습니다.  
  
 큰따옴표를 사용 하 여 문자열에 따옴표를 포함할 수 있습니다 또는 ""입니다. 예를 들어 개체에 적용된  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 문자열의 값을 반환 `Double quotation marks aren't "difficult" to handle`합니다.  
  
 사용 하 여 파일에 쓰기는 `Write` 또는 `WriteLine` 함수 필요 `Append` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다. 자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Write` 함수를 원시 데이터는 순차적 파일을 기록 합니다.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>