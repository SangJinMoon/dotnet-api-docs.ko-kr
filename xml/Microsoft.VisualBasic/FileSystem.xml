<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="757b138ad08a57ad8a16b1f7210ead2e45005193" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36728098" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="620ed-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span>
      <span class="sxs-lookup">
        <span data-stu-id="620ed-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span>
      </span>
      <span data-ttu-id="620ed-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span>
      <span class="sxs-lookup">
        <span data-stu-id="620ed-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span>
      </span>
      <span data-ttu-id="620ed-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="620ed-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-104">이 모듈은 Visual Basic 언어 키워드 및 파일 및 폴더에 액세스 하는 런타임 라이브러리 멤버를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-105">사용 하 여이 예제는 `GetAttr` 파일 및 디렉터리 또는 폴더의 특성을 결정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="620ed-106">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-106">Required.</span>
          </span>
          <span data-ttu-id="620ed-107">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-107">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span>
          </span>
          <span data-ttu-id="620ed-108">
            <c>Path</c> may include the drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-108">
              <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="620ed-109">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-109">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-110">Changes the current directory or folder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-110">Changes the current directory or folder.</span>
          </span>
          <span data-ttu-id="620ed-111">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-111">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span>
          </span>
          <span data-ttu-id="620ed-112">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-112">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-113">`ChDir` 함수는 기본 드라이브는 기본 디렉터리를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-113">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="620ed-114">예를 들어 기본 드라이브는 C, 다음 문은 D 드라이브의 기본 디렉터리 변경 C 기본 드라이브는 그대로:</span><span class="sxs-lookup"><span data-stu-id="620ed-114">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="620ed-115">상대를 만들 수 있습니다 디렉터리 변경 하는 두 개의 마침표를 다음과 같이 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-115">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-116">`ChDir` 함수 비관리 코드 권한이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-116">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="620ed-117">자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-117">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-118">사용 하 여이 예제는 `ChDir` 함수는 현재 디렉터리 또는 폴더를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-118">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-119">
            <paramref name="Path" /> is empty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-119">
              <paramref name="Path" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-120">Invalid drive is specified, or drive is unavailable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-120">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-121">Changes the current drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-121">Changes the current drive.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="620ed-122">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-122">Required.</span>
          </span>
          <span data-ttu-id="620ed-123">String expression that specifies an existing drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-123">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="620ed-124">If you supply a zero-length string (""), the current drive does not change.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-124">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="620ed-125">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-125">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-126">Changes the current drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-126">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-127">`ChDrive` 함수 비관리 코드 권한이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-127">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="620ed-128">자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-128">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-129">사용 하 여이 예제는 `ChDrive` 함수 현재 드라이브를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-129">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="620ed-130">함수는 드라이브 존재 하지 않는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-130">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-131">Invalid drive is specified, or drive is unavailable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-131">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="620ed-132">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-132">Required.</span>
          </span>
          <span data-ttu-id="620ed-133">String expression that specifies an existing drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-133">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="620ed-134">If you supply a zero-length string (""), the current drive does not change.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-134">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="620ed-135">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-135">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-136">Changes the current drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-136">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-137">`ChDrive` 함수 비관리 코드 권한이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-137">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="620ed-138">자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-138">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-139">사용 하 여이 예제는 `ChDrive` 함수 현재 드라이브를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-139">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="620ed-140">함수는 드라이브 존재 하지 않는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-140">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-141">Invalid drive is specified, or drive is unavailable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-141">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-142">Returns a string representing the current path.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-142">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="620ed-143">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-143">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="620ed-144">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-144">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="620ed-145">Returns a string representing the current path.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-145">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="620ed-146">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-146">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="620ed-147">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-147">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-148">A string representing the current path.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-148">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="620ed-149">사용 하 여이 예제는 `CurDir` 함수는 현재 경로를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-149">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="620ed-150">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-150">Optional.</span>
          </span>
          <span data-ttu-id="620ed-151">
            <see langword="Char" /> expression that specifies an existing drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-151">
              <see langword="Char" /> expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="620ed-152">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-152">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-153">Returns a string representing the current path.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-153">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="620ed-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="620ed-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-156">A string representing the current path.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-156">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="620ed-157">사용 하 여이 예제는 `CurDir` 함수는 현재 경로를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-158">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-158">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="620ed-159">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-159">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="620ed-160">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-160">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="620ed-161">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-161">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="620ed-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="620ed-163">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-163">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-164">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-164">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-165">`Dir` 함수 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-165">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="620ed-166">`VbVolume` 특정 파일 이름 대신 드라이브 볼륨 레이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-166">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="620ed-167">제공 해야 합니다는 `PathName` 처음으로 호출 하는 `Dir` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-167">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="620ed-168">다음 항목을 검색 하려면에 대 한 후속 호출을 만들 수 있습니다는 `Dir` 매개 변수 없이 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-168">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-169">제대로 실행 하려면는 `Dir` 함수에 필요는 <xref:System.Security.Permissions.FileIOPermissionAccess.Read> 및 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> 의 플래그를 지정 <xref:System.Security.Permissions.FileIOPermission> 를 실행 중인 코드에 부여 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-169">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="620ed-170">자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-170">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="620ed-171">`Attributes` 인수 열거형 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-171">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="620ed-172">값</span><span class="sxs-lookup"><span data-stu-id="620ed-172">Value</span></span>|<span data-ttu-id="620ed-173">상수</span><span class="sxs-lookup"><span data-stu-id="620ed-173">Constant</span></span>|<span data-ttu-id="620ed-174">설명</span><span class="sxs-lookup"><span data-stu-id="620ed-174">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="620ed-175">기본.</span><span class="sxs-lookup"><span data-stu-id="620ed-175">Default.</span></span> <span data-ttu-id="620ed-176">특성이 없는 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-176">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="620ed-177">읽기 전용 파일 및 파일 특성 없이 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-177">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="620ed-178">숨겨진된 파일 및 파일 특성 없이 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-178">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="620ed-179">시스템 파일 및 특성이 없는 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-179">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="620ed-180">볼륨 레이블;를 지정합니다. 다른 특성을 지정 하는 경우 `vbVolume` 는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-180">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="620ed-181">디렉터리 또는 폴더 및 특성이 없는 파일을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-181">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="620ed-182">파일은 마지막 백업 이후 변경 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-182">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="620ed-183">파일 이름이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-183">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="620ed-184">이 열거형은 Visual Basic 언어에 의해 지정 되며 실제 값 대신 코드에서 어디서 나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-184">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-185">사용 하 여이 예제는 `Dir` 을 특정 파일 및 디렉터리가 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-185">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="620ed-186">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-186">Optional.</span>
          </span>
          <span data-ttu-id="620ed-187">
            <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-187">
              <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span>
          </span>
          <span data-ttu-id="620ed-188">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-188">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span>
          </span>
        </param>
        <param name="Attributes">
          <span data-ttu-id="620ed-189">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-189">Optional.</span>
          </span>
          <span data-ttu-id="620ed-190">Enumeration or numeric expression whose value specifies file attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-190">Enumeration or numeric expression whose value specifies file attributes.</span>
          </span>
          <span data-ttu-id="620ed-191">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-191">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-192">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-192">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="620ed-193">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-193">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="620ed-194">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-194">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-195">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-195">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-196">`Dir` 함수 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-196">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="620ed-197">`VbVolume` 특정 파일 이름 대신 드라이브 볼륨 레이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-197">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="620ed-198">제공 해야 합니다는 `PathName` 처음으로 호출 하는 `Dir` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-198">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="620ed-199">다음 항목을 검색 하려면에 대 한 후속 호출을 만들 수 있습니다는 `Dir` 매개 변수가 없는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-199">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-200">제대로 실행 하려면는 `Dir` 함수에 필요는 <xref:System.Security.Permissions.FileIOPermissionAccess.Read> 및 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> 의 플래그를 지정 <xref:System.Security.Permissions.FileIOPermission> 를 실행 중인 코드에 부여 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-200">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="620ed-201">자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-201">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="620ed-202">`Attributes` 인수 열거형 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-202">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="620ed-203">값</span><span class="sxs-lookup"><span data-stu-id="620ed-203">Value</span></span>|<span data-ttu-id="620ed-204">상수</span><span class="sxs-lookup"><span data-stu-id="620ed-204">Constant</span></span>|<span data-ttu-id="620ed-205">설명</span><span class="sxs-lookup"><span data-stu-id="620ed-205">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="620ed-206">기본.</span><span class="sxs-lookup"><span data-stu-id="620ed-206">Default.</span></span> <span data-ttu-id="620ed-207">특성이 없는 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-207">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="620ed-208">특성이 없는 파일 외에도 읽기 전용 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-208">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="620ed-209">특성이 없는 파일 뿐만 아니라 숨겨진된 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-209">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="620ed-210">특성이 없는 파일 외에도 시스템 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-210">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="620ed-211">볼륨 레이블;를 지정합니다. 다른 특성을 지정 하는 경우 `vbVolume` 는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-211">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="620ed-212">디렉터리나 파일 특성이 없는 뿐만 아니라 폴더를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-212">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="620ed-213">파일은 마지막 백업 이후 변경 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-213">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="620ed-214">파일 이름이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-214">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="620ed-215">이 열거형은 Visual Basic 언어에 의해 지정 되며 실제 값 대신 코드에서 어디서 나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-215">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-216">사용 하 여이 예제는 `Dir` 을 특정 파일 및 디렉터리가 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-216">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-217">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-217">Required.</span>
          </span>
          <span data-ttu-id="620ed-218">An <see langword="Integer" /> that contains any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-218">An <see langword="Integer" /> that contains any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-219">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-219">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-220">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-220">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-221">사용 하 여 `EOF` 입력을 가져올 파일의 끝을 지나서에 의해 생성 된 오류를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-221">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="620ed-222">`EOF` 함수에서 반환 `False` 파일의 끝에 도달할 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-222">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="620ed-223">연 파일 `Random` 또는 `Binary` 액세스 `EOF` 반환 `False` 는 마지막으로 실행 될 때까지 `FileGet` 함수는 전체 레코드를 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-223">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="620ed-224">연 파일 `Binary` 액세스를 사용 하 여 파일을 통해 읽지는 `Input` 될 때까지 작동 `EOF` 반환 `True` 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-224">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="620ed-225">사용 하 여는 `LOF` 및 `Loc` 대신 함수 `EOF` 때 이진 파일을 읽는 `Input`, 사용 또는 `Get` 사용 하는 경우는 `EOF` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-225">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="620ed-226">연 파일 `Output`, `EOF` 항상 반환 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-226">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-227">사용 하 여이 예제는 `EOF` 함수는 파일의 끝을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-227">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="620ed-228">이 예에서는 가정 하는 `Testfile` 은 여러 줄의 텍스트를 포함 하는 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-228">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-229">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-229">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-230">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-230">Required.</span>
          </span>
          <span data-ttu-id="620ed-231">
            <see langword="Integer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-231">
              <see langword="Integer" />.</span>
          </span>
          <span data-ttu-id="620ed-232">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-232">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-233">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-233">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-234">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-234">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span>
          </span>
          <span data-ttu-id="620ed-235">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-235">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-236">The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-236">The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-237">사용 하 여 연 파일에 대 한 파일 모드를 나타내는 열거형을 반환 하는이 함수는 `FileOpen` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-237">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-238">사용 하 여이 예제는 `FileAttr` 함수 열려 있는 파일의 파일 모드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-238">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">
          <span data-ttu-id="620ed-239">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-239">Optional.</span>
          </span>
          <span data-ttu-id="620ed-240">Parameter array of 0 or more channels to be closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-240">Parameter array of 0 or more channels to be closed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-241">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-241">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-242">
            <see langword="My" /> gives you better productivity and performance in file I/O operations.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-242">
              <see langword="My" /> gives you better productivity and performance in file I/O operations.</span>
          </span>
          <span data-ttu-id="620ed-243">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-243">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-244">`FileClose` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-244">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-245">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-245">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-246">자세한 내용은 참조 [하는 방법: StreamReader 사용 하 여 파일에서 텍스트 읽기](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[하는 방법: StreamWriter 사용 하 여 파일에 텍스트 쓰기](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), 및 [연습: 조작 파일 및 디렉터리에서 Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-246">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="620ed-247">생략 하면 `FileNumbers`, 모든 활성 파일에서 연는 `FileOpen` 함수 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-247">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="620ed-248">에 대 한 연 파일을 닫을 때 `Output` 또는 `Append`, 출력의 마지막 버퍼 해당 파일에 대 한 운영 체제 버퍼에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-248">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="620ed-249">모든 버퍼 공간 닫힌와 연결 된 파일을 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-249">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="620ed-250">경우는 `FileClose` 함수 실행 되 고, 해당 파일이 있는 파일의 연결 끝 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-250">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-251">사용 하 여이 예제는 `FileClose` 파일을 닫으려면 함수에 대 한 열린 `Input`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-251">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-252">
            <paramref name="FileNumber" /> does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-252">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">
          <span data-ttu-id="620ed-253">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-253">Required.</span>
          </span>
          <span data-ttu-id="620ed-254">
            <see langword="String" /> expression that specifies the name of the file to be copied.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-254">
              <see langword="String" /> expression that specifies the name of the file to be copied.</span>
          </span>
          <span data-ttu-id="620ed-255">
            <c>Source</c> may include the directory or folder, and drive, of the source file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-255">
              <c>Source</c> may include the directory or folder, and drive, of the source file.</span>
          </span>
        </param>
        <param name="Destination">
          <span data-ttu-id="620ed-256">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-256">Required.</span>
          </span>
          <span data-ttu-id="620ed-257">
            <see langword="String" /> expression that specifies the destination file name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-257">
              <see langword="String" /> expression that specifies the destination file name.</span>
          </span>
          <span data-ttu-id="620ed-258">
            <c>Destination</c> may include the directory or folder, and drive, of the destination file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-258">
              <c>Destination</c> may include the directory or folder, and drive, of the destination file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-259">Copies a file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-259">Copies a file.</span>
          </span>
          <span data-ttu-id="620ed-260">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-260">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span>
          </span>
          <span data-ttu-id="620ed-261">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-261">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-262">사용 하려는 경우는 `FileCopy` 함수 현재 열려 있는 파일에 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-262">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="620ed-263">`FileCopy` 로컬 드라이브에서 작동 하도록 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-263">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-264">사용 하 여이 예제는 `FileCopy` 하나의 파일 간에 복사 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-264">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="620ed-265">이 예제에서는 한다고 가정 `SrcFile` 는 데이터가 포함 된 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-265">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-266">
            <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-266">
              <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-267">File is already open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-267">File is already open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-268">File does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-268">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="620ed-269">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-269">Required.</span>
          </span>
          <span data-ttu-id="620ed-270">
            <see langword="String" /> expression that specifies a file name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-270">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="620ed-271">
            <c>PathName</c> may include the directory or folder, and the drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-271">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-272">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-272">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span>
          </span>
          <span data-ttu-id="620ed-273">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-273">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span>
          </span>
          <span data-ttu-id="620ed-274">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-274">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-275">
            <see langword="Date" /> value that indicates the date and time a file was created or last modified.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-275">
              <see langword="Date" /> value that indicates the date and time a file was created or last modified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="620ed-276">사용 하 여이 예제는 `FileDateTime` 함수는 날짜를 파일 시간을 만들거나 마지막으로 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-276">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="620ed-277">날짜 및 시간 표시의 형식은 시스템의 로캘 설정을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-277">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-278">
            <paramref name="PathName" /> is invalid or contains wildcards.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-278">
              <paramref name="PathName" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-279">Target file does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-279">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-280">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-280">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-281">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-281">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-282">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-282">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-283">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-283">Required.</span>
          </span>
          <span data-ttu-id="620ed-284">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-284">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-285">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-285">Required.</span>
          </span>
          <span data-ttu-id="620ed-286">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-286">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-287">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-287">Optional.</span>
          </span>
          <span data-ttu-id="620ed-288">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-288">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-289">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-289">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-290">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-290">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-291">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-291">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-292">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-292">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-293">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-293">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-294">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-294">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-295">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-295">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-296">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-296">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-297">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-297">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-298">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-298">Random Mode</span></span>  
 <span data-ttu-id="620ed-299">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-299">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-300">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-300">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-301">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-301">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-302">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-302">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-303">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-303">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-304">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-304">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-305">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-305">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-306">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-306">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-307">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-307">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-308">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-308">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-309">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-309">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-310">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-310">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-311">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-311">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-312">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-312">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-313">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-313">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-314">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-314">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-315">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-315">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-316">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-316">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-317">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-317">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-318">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-318">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-319">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-319">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-320">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-320">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-321">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-321">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-322">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-322">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-323">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-323">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-324">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-324">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-325">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-325">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-326">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-326">Binary Mode</span></span>  
 <span data-ttu-id="620ed-327">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-327">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-328">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-328">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-329">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-329">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-330">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-330">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-331">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-331">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-332">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-332">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-333">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-333">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-334">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-334">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-335">사용 하 여 파일에서 읽기는`FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-335">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-336">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-336">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-337">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-337">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-338">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-338">Required.</span>
          </span>
          <span data-ttu-id="620ed-339">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-339">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-340">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-340">Required.</span>
          </span>
          <span data-ttu-id="620ed-341">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-341">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-342">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-342">Optional.</span>
          </span>
          <span data-ttu-id="620ed-343">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-343">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-344">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-344">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-345">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-345">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-346">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-346">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-347">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-347">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-348">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-348">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-349">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-349">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-350">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-350">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-351">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-351">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-352">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-352">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-353">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-353">Random Mode</span></span>  
 <span data-ttu-id="620ed-354">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-354">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-355">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-355">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-356">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-356">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-357">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-357">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-358">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-358">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-359">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-359">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-360">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-360">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-361">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-361">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-362">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-362">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-363">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-363">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-364">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-364">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-365">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-365">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-366">설명자 사용 하지 않는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-366">If the descriptor is not used.</span></span> <span data-ttu-id="620ed-367">에 전달 된 크기와 배열 범위 다음 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-367">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-368">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-368">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-369">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-369">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-370">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-370">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-371">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-371">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-372">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-372">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-373">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-373">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-374">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-374">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-375">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-375">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-376">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-376">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-377">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-377">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-378">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-378">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-379">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-379">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-380">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-380">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-381">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-381">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-382">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-382">Binary Mode</span></span>  
 <span data-ttu-id="620ed-383">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-383">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-384">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-384">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-385">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-385">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-386">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-386">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-387">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-387">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-388">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-388">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-389">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-389">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-390">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-390">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-391">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-391">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-392">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-392">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-393">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-393">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-394">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-394">Required.</span>
          </span>
          <span data-ttu-id="620ed-395">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-395">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-396">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-396">Required.</span>
          </span>
          <span data-ttu-id="620ed-397">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-397">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-398">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-398">Optional.</span>
          </span>
          <span data-ttu-id="620ed-399">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-399">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-400">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-400">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-401">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-401">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-402">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-402">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-403">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-403">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-404">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-404">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-405">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-405">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-406">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-406">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-407">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-407">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-408">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-408">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-409">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-409">Random Mode</span></span>  
 <span data-ttu-id="620ed-410">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-410">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-411">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-411">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-412">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-412">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-413">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-413">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-414">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-414">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-415">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-415">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-416">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-416">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-417">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-417">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-418">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-418">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-419">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-419">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-420">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-420">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-421">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-421">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-422">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-422">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-423">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-423">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-424">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-424">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-425">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-425">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-426">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-426">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-427">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-427">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-428">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-428">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-429">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-429">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-430">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-430">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-431">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-431">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-432">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-432">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-433">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-433">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-434">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-434">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-435">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-435">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-436">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-436">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-437">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-437">Binary Mode</span></span>  
 <span data-ttu-id="620ed-438">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-438">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-439">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-439">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-440">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-440">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-441">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-441">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-442">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-442">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-443">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-443">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-444">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-444">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-445">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-445">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-446">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-446">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-447">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-447">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-448">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-448">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-449">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-449">Required.</span>
          </span>
          <span data-ttu-id="620ed-450">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-450">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-451">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-451">Required.</span>
          </span>
          <span data-ttu-id="620ed-452">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-452">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-453">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-453">Optional.</span>
          </span>
          <span data-ttu-id="620ed-454">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-454">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-455">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-455">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-456">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-456">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-457">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-457">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-458">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-458">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-459">데이터를 읽을 `FileGet` 일반적으로 사용 하 여 파일 쓰여집니다 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-459">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-460">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-460">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-461">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-461">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-462">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-462">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-463">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-463">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-464">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-464">Random Mode</span></span>  
 <span data-ttu-id="620ed-465">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-465">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-466">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수`FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-466">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-467">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-467">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-468">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-468">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-469">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-469">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-470">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-470">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-471">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-471">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-472">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-472">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-473">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-473">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-474">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-474">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-475">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-475">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-476">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-476">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-477">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-477">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-478">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-478">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-479">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-479">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-480">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-480">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-481">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-481">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-482">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-482">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-483">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-483">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-484">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-484">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-485">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-485">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-486">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-486">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-487">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-487">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-488">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-488">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-489">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-489">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-490">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-490">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-491">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-491">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-492">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-492">Binary Mode</span></span>  
 <span data-ttu-id="620ed-493">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-493">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-494">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-494">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-495">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-495">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-496">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-496">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-497">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-497">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-498">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-498">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-499">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-499">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-500">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-500">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-501">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-501">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-502">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-502">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-503">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-503">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-504">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-504">Required.</span>
          </span>
          <span data-ttu-id="620ed-505">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-505">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-506">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-506">Required.</span>
          </span>
          <span data-ttu-id="620ed-507">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-507">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-508">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-508">Optional.</span>
          </span>
          <span data-ttu-id="620ed-509">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-509">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-510">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-510">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-511">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-511">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-512">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-512">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-513">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-513">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-514">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-514">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-515">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-515">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-516">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-516">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-517">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-517">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-518">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-518">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-519">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-519">Random Mode</span></span>  
 <span data-ttu-id="620ed-520">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-520">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-521">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-521">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-522">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-522">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-523">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-523">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-524">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-524">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-525">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-525">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-526">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-526">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-527">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-527">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-528">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-528">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-529">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-529">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-530">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-530">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-531">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-531">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-532">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-532">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-533">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-533">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-534">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-534">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-535">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-535">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-536">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-536">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-537">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-537">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-538">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-538">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-539">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-539">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-540">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-540">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-541">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-541">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-542">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-542">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-543">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-543">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-544">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-544">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-545">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-545">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-546">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-546">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-547">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-547">Binary Mode</span></span>  
 <span data-ttu-id="620ed-548">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-548">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-549">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-549">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-550">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-550">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-551">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-551">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-552">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-552">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-553">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-553">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-554">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-554">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-555">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-555">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-556">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-556">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-557">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-557">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-558">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-558">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-559">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-559">Required.</span>
          </span>
          <span data-ttu-id="620ed-560">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-560">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-561">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-561">Required.</span>
          </span>
          <span data-ttu-id="620ed-562">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-562">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-563">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-563">Optional.</span>
          </span>
          <span data-ttu-id="620ed-564">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-564">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-565">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-565">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-566">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-566">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-567">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-567">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-568">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-568">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-569">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-569">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-570">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-570">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-571">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-571">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-572">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-572">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-573">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-573">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-574">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-574">Random Mode</span></span>  
 <span data-ttu-id="620ed-575">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-575">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-576">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-576">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-577">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-577">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-578">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-578">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-579">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-579">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-580">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-580">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-581">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-581">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-582">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-582">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-583">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-583">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-584">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-584">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-585">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-585">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-586">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-586">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-587">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-587">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-588">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-588">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-589">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-589">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-590">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-590">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-591">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-591">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-592">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-592">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-593">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-593">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-594">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-594">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-595">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-595">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-596">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-596">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-597">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-597">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-598">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-598">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-599">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-599">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-600">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-600">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-601">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-601">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-602">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-602">Binary Mode</span></span>  
 <span data-ttu-id="620ed-603">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-603">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-604">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-604">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-605">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-605">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-606">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-606">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-607">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-607">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-608">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-608">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-609">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-609">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-610">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-610">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-611">사용 하 여 파일에서 읽기는`FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-611">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-612">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-612">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-613">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-613">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-614">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-614">Required.</span>
          </span>
          <span data-ttu-id="620ed-615">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-615">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-616">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-616">Required.</span>
          </span>
          <span data-ttu-id="620ed-617">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-617">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-618">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-618">Optional.</span>
          </span>
          <span data-ttu-id="620ed-619">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-619">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-620">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-620">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-621">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-621">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-622">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-622">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-623">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-623">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-624">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-624">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-625">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-625">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-626">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-626">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-627">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-627">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-628">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-628">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-629">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-629">Random Mode</span></span>  
 <span data-ttu-id="620ed-630">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-630">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-631">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-631">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-632">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-632">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-633">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-633">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-634">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-634">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-635">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-635">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-636">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-636">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-637">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-637">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-638">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-638">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-639">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-639">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-640">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-640">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-641">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-641">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-642">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-642">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-643">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-643">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-644">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-644">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-645">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-645">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-646">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-646">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-647">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-647">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-648">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-648">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-649">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-649">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-650">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-650">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-651">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-651">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-652">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-652">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-653">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-653">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-654">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-654">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-655">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-655">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-656">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-656">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-657">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-657">Binary Mode</span></span>  
 <span data-ttu-id="620ed-658">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-658">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-659">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-659">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-660">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-660">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-661">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-661">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-662">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-662">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-663">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-663">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-664">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-664">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-665">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-665">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-666">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-666">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-667">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-667">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-668">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-668">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-669">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-669">Required.</span>
          </span>
          <span data-ttu-id="620ed-670">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-670">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-671">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-671">Required.</span>
          </span>
          <span data-ttu-id="620ed-672">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-672">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-673">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-673">Optional.</span>
          </span>
          <span data-ttu-id="620ed-674">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-674">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-675">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-675">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-676">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-676">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-677">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-677">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-678">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-678">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-679">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-679">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-680">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-680">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-681">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-681">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-682">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-682">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-683">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-683">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-684">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-684">Random Mode</span></span>  
 <span data-ttu-id="620ed-685">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-685">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-686">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-686">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-687">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-687">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-688">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-688">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-689">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-689">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-690">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-690">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-691">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-691">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-692">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-692">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-693">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-693">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-694">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-694">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-695">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-695">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-696">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-696">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-697">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-697">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-698">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-698">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-699">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-699">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-700">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-700">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-701">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-701">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-702">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-702">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-703">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-703">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-704">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-704">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-705">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-705">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-706">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-706">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-707">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-707">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-708">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-708">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-709">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-709">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-710">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-710">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-711">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-711">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-712">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-712">Binary Mode</span></span>  
 <span data-ttu-id="620ed-713">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-713">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-714">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-714">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-715">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-715">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-716">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-716">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-717">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-717">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-718">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-718">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-719">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-719">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-720">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-720">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-721">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-721">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-722">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-722">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-723">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-723">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-724">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-724">Required.</span>
          </span>
          <span data-ttu-id="620ed-725">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-725">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-726">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-726">Required.</span>
          </span>
          <span data-ttu-id="620ed-727">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-727">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-728">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-728">Optional.</span>
          </span>
          <span data-ttu-id="620ed-729">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-729">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-730">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-730">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-731">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-731">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-732">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-732">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-733">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-733">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-734">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-734">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-735">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-735">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-736">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-736">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-737">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-737">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-738">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-738">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-739">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-739">Random Mode</span></span>  
 <span data-ttu-id="620ed-740">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-740">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-741">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-741">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-742">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-742">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-743">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-743">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-744">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-744">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-745">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-745">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-746">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-746">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-747">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-747">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-748">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-748">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-749">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-749">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-750">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-750">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-751">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-751">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-752">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-752">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-753">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-753">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-754">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-754">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-755">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-755">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-756">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-756">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-757">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-757">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-758">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-758">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-759">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-759">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-760">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-760">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-761">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-761">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-762">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-762">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-763">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-763">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-764">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-764">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-765">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-765">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-766">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-766">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-767">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-767">Binary Mode</span></span>  
 <span data-ttu-id="620ed-768">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-768">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-769">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-769">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-770">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-770">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-771">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-771">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-772">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-772">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-773">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-773">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-774">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-774">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-775">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-775">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-776">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-776">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-777">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-777">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-778">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-778">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-779">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-779">Required.</span>
          </span>
          <span data-ttu-id="620ed-780">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-780">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-781">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-781">Required.</span>
          </span>
          <span data-ttu-id="620ed-782">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-782">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-783">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-783">Optional.</span>
          </span>
          <span data-ttu-id="620ed-784">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-784">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-785">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-785">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-786">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-786">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-787">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-787">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-788">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-788">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-789">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-789">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-790">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-790">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-791">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-791">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-792">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-792">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-793">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-793">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-794">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-794">Random Mode</span></span>  
 <span data-ttu-id="620ed-795">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-795">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-796">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-796">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-797">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-797">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-798">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-798">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-799">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-799">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-800">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-800">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-801">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-801">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-802">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-802">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-803">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-803">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-804">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-804">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-805">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-805">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-806">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-806">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-807">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-807">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-808">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-808">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-809">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-809">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-810">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-810">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-811">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-811">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-812">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-812">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-813">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-813">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-814">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-814">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-815">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-815">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-816">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-816">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-817">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-817">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-818">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-818">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-819">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-819">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-820">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-820">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-821">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-821">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-822">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-822">Binary Mode</span></span>  
 <span data-ttu-id="620ed-823">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-823">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-824">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-824">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-825">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-825">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-826">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-826">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-827">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-827">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-828">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-828">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-829">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-829">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-830">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-830">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-831">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-831">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-832">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-832">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-833">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-833">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-834">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-834">Required.</span>
          </span>
          <span data-ttu-id="620ed-835">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-835">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-836">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-836">Required.</span>
          </span>
          <span data-ttu-id="620ed-837">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-837">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-838">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-838">Optional.</span>
          </span>
          <span data-ttu-id="620ed-839">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-839">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-840">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-840">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-841">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-841">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-842">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-842">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-843">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-843">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-844">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-844">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-845">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-845">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-846">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-846">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-847">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-847">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-848">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-848">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-849">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-849">Random Mode</span></span>  
 <span data-ttu-id="620ed-850">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-850">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-851">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-851">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-852">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-852">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-853">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-853">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-854">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-854">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-855">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-855">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-856">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-856">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-857">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-857">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-858">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-858">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-859">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-859">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-860">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-860">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-861">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-861">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-862">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-862">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-863">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-863">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-864">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-864">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-865">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-865">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-866">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-866">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-867">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-867">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-868">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-868">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-869">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-869">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-870">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-870">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-871">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-871">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-872">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-872">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-873">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-873">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-874">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-874">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-875">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-875">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-876">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-876">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-877">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-877">Binary Mode</span></span>  
 <span data-ttu-id="620ed-878">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-878">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-879">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-879">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-880">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-880">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-881">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-881">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-882">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-882">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-883">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-883">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-884">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-884">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-885">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-885">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-886">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-886">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-887">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-887">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-888">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-888">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-889">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-889">Required.</span>
          </span>
          <span data-ttu-id="620ed-890">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-890">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-891">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-891">Required.</span>
          </span>
          <span data-ttu-id="620ed-892">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-892">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-893">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-893">Optional.</span>
          </span>
          <span data-ttu-id="620ed-894">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-894">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="620ed-895">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-895">Optional.</span>
          </span>
          <span data-ttu-id="620ed-896">Applies only when writing a string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-896">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="620ed-897">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-897">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="620ed-898">The default is <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-898">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-899">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-899">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-900">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-900">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-901">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-901">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-902">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-902">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-903">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-903">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-904">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-904">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-905">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-905">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-906">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-906">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-907">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-907">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-908">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-908">Random Mode</span></span>  
 <span data-ttu-id="620ed-909">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-909">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-910">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-910">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-911">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-911">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-912">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-912">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-913">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-913">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-914">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-914">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-915">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-915">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-916">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-916">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-917">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-917">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-918">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-918">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-919">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-919">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-920">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-920">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-921">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-921">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-922">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-922">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-923">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-923">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-924">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-924">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-925">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-925">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-926">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-926">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-927">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-927">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-928">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-928">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-929">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-929">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-930">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-930">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-931">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-931">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-932">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-932">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-933">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-933">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-934">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-934">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-935">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-935">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-936">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-936">Binary Mode</span></span>  
 <span data-ttu-id="620ed-937">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-937">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-938">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-938">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-939">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-939">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-940">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-940">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-941">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-941">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-942">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-942">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-943">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-943">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-944">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-944">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-945">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-945">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-946">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-946">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-947">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-947">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-948">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-948">Required.</span>
          </span>
          <span data-ttu-id="620ed-949">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-949">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-950">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-950">Required.</span>
          </span>
          <span data-ttu-id="620ed-951">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-951">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-952">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-952">Optional.</span>
          </span>
          <span data-ttu-id="620ed-953">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-953">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="620ed-954">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-954">Optional.</span>
          </span>
          <span data-ttu-id="620ed-955">Applies only when writing an array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-955">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="620ed-956">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-956">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="620ed-957">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-957">Optional.</span>
          </span>
          <span data-ttu-id="620ed-958">Applies only when writing a string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-958">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="620ed-959">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-959">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="620ed-960">The default is <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-960">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-961">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-961">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-962">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-962">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="620ed-963">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-963">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-964">`FileGet` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-964">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-965">데이터를 읽을 `FileGet` 를 사용 하 여 일반적으로 파일에 기록 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-965">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="620ed-966">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-966">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-967">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 (또는 마지막에서 가리키는 `Seek` 함수)는 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-967">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-968">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-968">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-969">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-969">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-970">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-970">Random Mode</span></span>  
 <span data-ttu-id="620ed-971">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-971">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-972">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGet` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-972">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-973">하나의 레코드의 끝와 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-973">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-974">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 읽을 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-974">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-975">기본적으로 읽을 변수가 문자열인 경우 `FileGet` 문자열 길이가 포함 된 변수로 전달 되는 데이터를 읽고 다음 2 바이트 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-975">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-976">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-976">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-977">Visual Basic 6.0 및 이전 버전을 고정 길이 문자열; 지원 파일에 쓸 때, 길이 설명자 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-977">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-978">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-978">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-979">로 읽어 변수가 배열 크기와 배열 차원에 대 한 설명자를 읽을 것인지 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-979">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="620ed-980">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-980">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-981">배열을 읽을 때 배열 쓰여진 방식을 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-981">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="620ed-982">설명자와 작성 된 경우 설명자를 읽을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-982">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="620ed-983">설명자를 사용 하지 않으면 크기와 배열 범위에 전달 된 `FileGet` 읽기 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-983">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="620ed-984">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-984">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-985">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-985">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-986">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-986">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-987">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-987">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="620ed-988">218 바이트는 다음과 같이 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-988">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="620ed-989">설명자에 대해 18 바이트: (2 \* 2 + 8)</span><span class="sxs-lookup"><span data-stu-id="620ed-989">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="620ed-990">데이터에 대 한 200 바이트: (4 * 5 * 10).</span><span class="sxs-lookup"><span data-stu-id="620ed-990">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="620ed-991">로 읽어 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FileGet` 만 변수 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-991">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="620ed-992">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 읽을 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-992">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-993">`FileGet` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-993">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-994">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePut`)는 설명자가 2 더하기 8 시간 차원 수가 접두사로 적용 됩니다: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-994">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-995">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-995">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="620ed-996">모든 배열 및 설명자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-996">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-997">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-997">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-998">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-998">Binary Mode</span></span>  
 <span data-ttu-id="620ed-999">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-999">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1000">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1000">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1001">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1001">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1002">`FileGet` 연속적으로; 디스크에서 모든 변수를 읽으십시오 즉, 없이 사이의 안쪽 여백 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1002">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1003">구조에 포함 되지 않은 모든 배열에 대 한 `FileGet` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1003">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="620ed-1004">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1004">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="620ed-1005">`FileGet` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1005">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1006">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1006">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="620ed-1007">사용 하 여 파일에서 읽기는 `FileGet` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1007">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1008">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1008">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1009">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1009">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1010">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1010">Required.</span>
          </span>
          <span data-ttu-id="620ed-1011">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1011">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1012">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1012">Required.</span>
          </span>
          <span data-ttu-id="620ed-1013">Valid variable name into which data is read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1013">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1014">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1014">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1015">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1015">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1016">Reads data from an open disk file into a variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1016">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="620ed-1017">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1017">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span>
          </span>
          <span data-ttu-id="620ed-1018">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1018">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1019">`FileGetObject` 함수 대신 사용 됩니다 `FileGet` 경우 컴파일 타임에 모호성을 피할 수 형식 `Object` 와 같은 다른 형식 대신 반환 `Integer`, `Long`, `Short`, 등입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1019">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="620ed-1020">작성 하려는 경우는 `Variant` 형식 `FileGetObject` 가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1020">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="620ed-1021">확실 하지 않은, 두 번째 매개 변수에 대 한 개체 사용 중인 경우, 항상 좋습니다를 사용 하는 `FilePutObject` 및 `FileGetObject`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1021">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="620ed-1022">`FileGetObject` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1022">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1023">데이터를 읽을 `FileGetObject` 일반적으로 작성 된 `FilePutObject`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1023">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="620ed-1024">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1024">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1025">생략 하면 `RecordNumber`, `FileGetObject` 마지막 뒤 레코드 또는 바이트를 읽고 `FileGetObject` 또는 `FilePutObject` 함수 (또는 마지막에서 가리키는 `Seek` 함수).</span><span class="sxs-lookup"><span data-stu-id="620ed-1025">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1026">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1026">Random Mode</span></span>  
 <span data-ttu-id="620ed-1027">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1027">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1028">읽고 있는 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FileGetObject` 레코드 길이 경계에 있는 후속 레코드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1028">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1029">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1029">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1030">채워지는 데이터의 양은 정확 하 게 확인할 수 없습니다, 되므로 레코드 길이 읽을 데이터의 길이 일치 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1030">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="620ed-1031">읽을 변수가 기본적으로는 문자열이 `FileGetObject` 문자열 길이 포함 하는 2 바이트 설명자를 읽고 다음 변수에 전달 되는 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1031">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1032">지정한 레코드 길이 따라서는 `RecordLength` 절은 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1032">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1033">Visual Basic 6.0 및 이전 버전에서는 고정 길이 문자열을 파일을 읽을 때 길이 설명자는 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1033">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="620ed-1034">전달 해야 설명자 없이 문자열을 읽도록 하려면 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1034">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1035">으로 읽고 배열에 되 면 변수로 지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1035">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1036">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1036">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1037">길이 2 + 8 시간 차원 수가: 2 + 8 \* 더한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1037">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="620ed-1038">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에:</span><span class="sxs-lookup"><span data-stu-id="620ed-1038">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="620ed-1039">218 바이트가 다음과 같이 배포 됩니다: (2 + 8 \* 2) 설명자에 대 한 18 바이트 및 (4 \* 5 \* 10) 데이터에 대 한 100 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1039">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="620ed-1040">`FileGetObject` 구조체의 요소가으로 각각 개별적으로 읽는 것를 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1040">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="620ed-1041">동적 디스크에는 사용자 정의 형식에 배열 (로 작성 된 `FilePutObject`)는 설명자가 2 더하기 8 시간 차원 수가 옵니다: 2 + 8 \* 더한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1041">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="620ed-1042">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 모든 배열과 그 설명자를 포함 하 여 개별 요소를 읽는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1042">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="620ed-1043"><xref:Microsoft.VisualBasic.VBFixedStringAttribute> 클래스를 쓸 때 문자열의 크기를 나타내는 구조체의 string 필드에 적용할 수 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1043">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1044">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1044">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1045">연 파일에 `Binary` 모드의 모든는 `Random` 경우를이 제외 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1045">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="620ed-1046">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1046">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1047">`FileGetObject` 변수를 읽습니다 모든 디스크에서 연속적으로 즉, 레코드 간에 데이터가 채워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1047">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1048">구조에 포함 되지 않은 모든 배열에 대 한 `FileGetObject` 만 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1048">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="620ed-1049">설명자는 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1049">No descriptor is read.</span></span>  
  
 <span data-ttu-id="620ed-1050">`FileGetObject` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1050">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1051">읽은 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1051">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-1052">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1052">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-1053">예를 들어 Form1.vb 파일이 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1053">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1054">다음 예제에서는 레코드를 읽고 테스트 파일에 다음이 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1054">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="620ed-1055">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1055">Required.</span>
          </span>
          <span data-ttu-id="620ed-1056">
            <see langword="String" /> expression that specifies a file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1056">
              <see langword="String" /> expression that specifies a file.</span>
          </span>
          <span data-ttu-id="620ed-1057">
            <c>PathName</c> may include the directory or folder, and the drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1057">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1058">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1058">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
          <span data-ttu-id="620ed-1059">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1059">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span>
          </span>
          <span data-ttu-id="620ed-1060">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1060">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-1061">
            <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1061">
              <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1062">지정 된 파일은 열려 있는 경우는 `FileLen` 함수 호출 되 면 반환 된 값으로 열었을 때 파일의 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1062">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-1063">열려 있는 파일의 현재 길이 가져오려면는 `LOF` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1063">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1064">사용 하 여이 예제는 `FileLen` 함수를 파일의 길이 바이트 단위로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1064">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="620ed-1065">이 예제에서는 한다고 가정 `TestFile` 은 일부 데이터를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1065">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-1066">File does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1066">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1067">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1067">Required.</span>
          </span>
          <span data-ttu-id="620ed-1068">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1068">Any valid file number.</span>
          </span>
          <span data-ttu-id="620ed-1069">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1069">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span>
          </span>
        </param>
        <param name="FileName">
          <span data-ttu-id="620ed-1070">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1070">Required.</span>
          </span>
          <span data-ttu-id="620ed-1071">
            <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1071">
              <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Mode">
          <span data-ttu-id="620ed-1072">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1072">Required.</span>
          </span>
          <span data-ttu-id="620ed-1073">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1073">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span>
          </span>
          <span data-ttu-id="620ed-1074">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1074">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span>
          </span>
        </param>
        <param name="Access">
          <span data-ttu-id="620ed-1075">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1075">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1076">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1076">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="620ed-1077">Defaults to <see langword="ReadWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1077">Defaults to <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="620ed-1078">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1078">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span>
          </span>
        </param>
        <param name="Share">
          <span data-ttu-id="620ed-1079">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1079">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1080">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1080">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="620ed-1081">Defaults to <see langword="Lock Read Write" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1081">Defaults to <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="620ed-1082">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1082">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span>
          </span>
        </param>
        <param name="RecordLength">
          <span data-ttu-id="620ed-1083">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1083">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1084">Number less than or equal to 32,767 (bytes).</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1084">Number less than or equal to 32,767 (bytes).</span>
          </span>
          <span data-ttu-id="620ed-1085">For files opened for random access, this value is the record length.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1085">For files opened for random access, this value is the record length.</span>
          </span>
          <span data-ttu-id="620ed-1086">For sequential files, this value is the number of characters buffered.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1086">For sequential files, this value is the number of characters buffered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1087">Opens a file for input or output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1087">Opens a file for input or output.</span>
          </span>
          <span data-ttu-id="620ed-1088">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1088">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span>
          </span>
          <span data-ttu-id="620ed-1089">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1089">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1090">`FileOpen` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1090">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-1091">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1091">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-1092">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1092">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-1093">I/O 작업을 수행 하려면 먼저 파일을 열어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1093">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="620ed-1094">`FileOpen` 파일 I/O에 대 한 버퍼를 할당 하 고 버퍼와 함께 사용할 액세스 모드를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1094">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-1095">파일에 쓸 때 응용 프로그램 만들어야 할 수 파일을 작성 하려는 파일이 존재 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="620ed-1095">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="620ed-1096">이렇게 하려면 해당 파일이 만들어질 된 디렉터리에 대 한 권한이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1096">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="620ed-1097">그러나 하 여 지정한 파일이 있으면 `FileName` 존재 않는 응용 프로그램 요구 `Write` 파일 자체에 사용 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1097">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="620ed-1098">보안을 강화 하려면 가능한, 배포 및 부여 하는 동안 파일을 만들고 하는 아무 곳에 나 `Write` 해당 파일에 대 한 전체 디렉터리 대신만 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1098">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="620ed-1099">보안 향상을 위해 대신 사용자 디렉터리의 루트 디렉터리 또는 Program Files 디렉터리에 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1099">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="620ed-1100">사용 하 여 열려는 채널을 찾을 수 있습니다는 `FreeFile()` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1100">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-1101">`FileOpen` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1101">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="620ed-1102">자세한 내용은 참조 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1102">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1103">다양 한 용도 보여 주는이 예제는 `FileOpen` 함수를 입력 및 출력 파일을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1103">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="620ed-1104">다음 코드 파일을 열고 `TestFile` 에 `Input` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1104">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="620ed-1105">이 예제에서 파일을 열고 `Binary` 쓰기 작업용 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1105">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="620ed-1106">다음 예제에서는의 파일을 엽니다 `Random` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1106">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="620ed-1107">해당 파일의 구조는 레코드가 포함 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1107">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="620ed-1108">이 코드 예제에서 파일을 열고 `Output` 모드; 읽거나 파일에 쓸 모든 프로세스 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1108">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="620ed-1109">이 코드 예제에서 파일을 열고 `Binary` 읽기에 대 한 모드 다른 프로세스가 파일을 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1109">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1110">Record length is negative (and not equal to -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1110">Record length is negative (and not equal to -1).</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1111">
            <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1111">
              <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-1112">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1112">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1113">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1113">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1114">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1114">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1115">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1115">Required.</span>
          </span>
          <span data-ttu-id="620ed-1116">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1116">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1117">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1117">Required.</span>
          </span>
          <span data-ttu-id="620ed-1118">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1118">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1119">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1119">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1120">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1120">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1121">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1121">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1122">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1122">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1123">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1123">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1124">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1124">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1125">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1125">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1126">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1126">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1127">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1127">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1128">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1128">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1129">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1129">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1130">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1130">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1131">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1131">Random Mode</span></span>  
 <span data-ttu-id="620ed-1132">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1132">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1133">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1133">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1134">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1134">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1135">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1135">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1136">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1136">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1137">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1137">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1138">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1138">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1139">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1139">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1140">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1140">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1141">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1141">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1142">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1142">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1143">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1143">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1144">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1144">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1145">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1145">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1146">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1146">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1147">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1147">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1148">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1148">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1149">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1149">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1150">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1150">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1151">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1151">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1152">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1152">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1153">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1153">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1154">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1154">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1155">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1155">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1156">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1156">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1157">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1157">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1158">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1158">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1159">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1159">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1160">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1160">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1161">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1161">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1162">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1162">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1163">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1163">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1164">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1164">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1165">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1165">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1166">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1166">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1167">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1167">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1168">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1168">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1169">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1169">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1170">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1170">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1171">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1171">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1172">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1172">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1173">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1173">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1174">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1174">Required.</span>
          </span>
          <span data-ttu-id="620ed-1175">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1175">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1176">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1176">Required.</span>
          </span>
          <span data-ttu-id="620ed-1177">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1177">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1178">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1178">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1179">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1179">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1180">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1180">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1181">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1181">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1182">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1182">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1183">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1183">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1184">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1184">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1185">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1185">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1186">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1186">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1187">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1187">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1188">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1188">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1189">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1189">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1190">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1190">Random Mode</span></span>  
 <span data-ttu-id="620ed-1191">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1191">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1192">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1192">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1193">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1193">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1194">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1194">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1195">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1195">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1196">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1196">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1197">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1197">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1198">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1198">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1199">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1199">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1200">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1200">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1201">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1201">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1202">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1202">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1203">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1203">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1204">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1204">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1205">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1205">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1206">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1206">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1207">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1207">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1208">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1208">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1209">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1209">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1210">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1210">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1211">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1211">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1212">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1212">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1213">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1213">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1214">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1214">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1215">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1215">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1216">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1216">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1217">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1217">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1218">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1218">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1219">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1219">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1220">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1220">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1221">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1221">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1222">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1222">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1223">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1223">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1224">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1224">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1225">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1225">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1226">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1226">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1227">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1227">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1228">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1228">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1229">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1229">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1230">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1230">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1231">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1231">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1232">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1232">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1233">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1233">Required.</span>
          </span>
          <span data-ttu-id="620ed-1234">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1234">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1235">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1235">Required.</span>
          </span>
          <span data-ttu-id="620ed-1236">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1236">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1237">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1237">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1238">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1238">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1239">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1239">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1240">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1240">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1241">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1241">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1242">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1242">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1243">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1243">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1244">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1244">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1245">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1245">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1246">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1246">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1247">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1247">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1248">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1248">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1249">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1249">Random Mode</span></span>  
 <span data-ttu-id="620ed-1250">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1250">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1251">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1251">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1252">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1252">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1253">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1253">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1254">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1254">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1255">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1255">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1256">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1256">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1257">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1257">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1258">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1258">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1259">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1259">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1260">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1260">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1261">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1261">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1262">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1262">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1263">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1263">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1264">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1264">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1265">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1265">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1266">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1266">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1267">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1267">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1268">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1268">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1269">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1269">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1270">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1270">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1271">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1271">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1272">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1272">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1273">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1273">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1274">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1274">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1275">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1275">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1276">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1276">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1277">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1277">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1278">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1278">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1279">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1279">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1280">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1280">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1281">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1281">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1282">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1282">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1283">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1283">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1284">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1284">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1285">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1285">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1286">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1286">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1287">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1287">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1288">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1288">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1289">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1289">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1290">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1290">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1291">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1291">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1292">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1292">Required.</span>
          </span>
          <span data-ttu-id="620ed-1293">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1293">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1294">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1294">Required.</span>
          </span>
          <span data-ttu-id="620ed-1295">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1295">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1296">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1296">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1297">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1297">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1298">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1298">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1299">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1299">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1300">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1300">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1301">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1301">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1302">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1302">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1303">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1303">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1304">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1304">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1305">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1305">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1306">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1306">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1307">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1307">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1308">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1308">Random Mode</span></span>  
 <span data-ttu-id="620ed-1309">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1309">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1310">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1310">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1311">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1311">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1312">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1312">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1313">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1313">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1314">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1314">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1315">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1315">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1316">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1316">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1317">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1317">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1318">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1318">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1319">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1319">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1320">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1320">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1321">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1321">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1322">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1322">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1323">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1323">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1324">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1324">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1325">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1325">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1326">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1326">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1327">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1327">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1328">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1328">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1329">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1329">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1330">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1330">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1331">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1331">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1332">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1332">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1333">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1333">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1334">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1334">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1335">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1335">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1336">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1336">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1337">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1337">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1338">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1338">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1339">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1339">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1340">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1340">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1341">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1341">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1342">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1342">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1343">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1343">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1344">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1344">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1345">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1345">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1346">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1346">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1347">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1347">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1348">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1348">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1349">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1349">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1350">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1350">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1351">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1351">Required.</span>
          </span>
          <span data-ttu-id="620ed-1352">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1352">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1353">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1353">Required.</span>
          </span>
          <span data-ttu-id="620ed-1354">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1354">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1355">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1355">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1356">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1356">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1357">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1357">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1358">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1358">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1359">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1359">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1360">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1360">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1361">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1361">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1362">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1362">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1363">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1363">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1364">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1364">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1365">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1365">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1366">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1366">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1367">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1367">Random Mode</span></span>  
 <span data-ttu-id="620ed-1368">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1368">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1369">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1369">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1370">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1370">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1371">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1371">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1372">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1372">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1373">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1373">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1374">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1374">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1375">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1375">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1376">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1376">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1377">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1377">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1378">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1378">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1379">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1379">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1380">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1380">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1381">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1381">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1382">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1382">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1383">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1383">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1384">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1384">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1385">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1385">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1386">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1386">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1387">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1387">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1388">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1388">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1389">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1389">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1390">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1390">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1391">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1391">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1392">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1392">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1393">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1393">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1394">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1394">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1395">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1395">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1396">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1396">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1397">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1397">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1398">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1398">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1399">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1399">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1400">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1400">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1401">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1401">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1402">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1402">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1403">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1403">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1404">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1404">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1405">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1405">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1406">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1406">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1407">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1407">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1408">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1408">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1409">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1409">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1410">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1410">Required.</span>
          </span>
          <span data-ttu-id="620ed-1411">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1411">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1412">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1412">Required.</span>
          </span>
          <span data-ttu-id="620ed-1413">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1413">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1414">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1414">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1415">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1415">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1416">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1416">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1417">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1417">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1418">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1418">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1419">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1419">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1420">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1420">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1421">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1421">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1422">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1422">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1423">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1423">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1424">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1424">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1425">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1425">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1426">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1426">Random Mode</span></span>  
 <span data-ttu-id="620ed-1427">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1427">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1428">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1428">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1429">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1429">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1430">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1430">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1431">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1431">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1432">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1432">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1433">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1433">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1434">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1434">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1435">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1435">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1436">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1436">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1437">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1437">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1438">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1438">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1439">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1439">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1440">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1440">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1441">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1441">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1442">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1442">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1443">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1443">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1444">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1444">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1445">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1445">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1446">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1446">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1447">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1447">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1448">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1448">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1449">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1449">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1450">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1450">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1451">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1451">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1452">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1452">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1453">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1453">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1454">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1454">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1455">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1455">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1456">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1456">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1457">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1457">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1458">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1458">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1459">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1459">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1460">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1460">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1461">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1461">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1462">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1462">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1463">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1463">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1464">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1464">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1465">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1465">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1466">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1466">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1467">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1467">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1468">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1468">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1469">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1469">Required.</span>
          </span>
          <span data-ttu-id="620ed-1470">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1470">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1471">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1471">Required.</span>
          </span>
          <span data-ttu-id="620ed-1472">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1472">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1473">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1473">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1474">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1474">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1475">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1475">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1476">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1476">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1477">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1477">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1478">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1478">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1479">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1479">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1480">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1480">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1481">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1481">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1482">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1482">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1483">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1483">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1484">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1484">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1485">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1485">Random Mode</span></span>  
 <span data-ttu-id="620ed-1486">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1486">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1487">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1487">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1488">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1488">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1489">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1489">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1490">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1490">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1491">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1491">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1492">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1492">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1493">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1493">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1494">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1494">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1495">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1495">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1496">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는`VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1496">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1497">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1497">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1498">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1498">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1499">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1499">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1500">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1500">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1501">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1501">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1502">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1502">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1503">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1503">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1504">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1504">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1505">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1505">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1506">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1506">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1507">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1507">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1508">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1508">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1509">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1509">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1510">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1510">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1511">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1511">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1512">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1512">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1513">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1513">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1514">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1514">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1515">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1515">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1516">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1516">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1517">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1517">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1518">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1518">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1519">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1519">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1520">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1520">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1521">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1521">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1522">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1522">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1523">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1523">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1524">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1524">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1525">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1525">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1526">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1526">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1527">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1527">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1528">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1528">Required.</span>
          </span>
          <span data-ttu-id="620ed-1529">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1529">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1530">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1530">Required.</span>
          </span>
          <span data-ttu-id="620ed-1531">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1531">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1532">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1532">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1533">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1533">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1534">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1534">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1535">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1535">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1536">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1536">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1537">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1537">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1538">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1538">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1539">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1539">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1540">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1540">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1541">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1541">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1542">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1542">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1543">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1543">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1544">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1544">Random Mode</span></span>  
 <span data-ttu-id="620ed-1545">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1545">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1546">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1546">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1547">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1547">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1548">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1548">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1549">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1549">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1550">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1550">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1551">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1551">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1552">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1552">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1553">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1553">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1554">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1554">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1555">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1555">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1556">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1556">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1557">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1557">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1558">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1558">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1559">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1559">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1560">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1560">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1561">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1561">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1562">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1562">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1563">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1563">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1564">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1564">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1565">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1565">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1566">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1566">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1567">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1567">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1568">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1568">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1569">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1569">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1570">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1570">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1571">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1571">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1572">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1572">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1573">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1573">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1574">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1574">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1575">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1575">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1576">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1576">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1577">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1577">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1578">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1578">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1579">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1579">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1580">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1580">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1581">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1581">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1582">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1582">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1583">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1583">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1584">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1584">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1585">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1585">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1586">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1586">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1587">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1587">Required.</span>
          </span>
          <span data-ttu-id="620ed-1588">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1588">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1589">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1589">Required.</span>
          </span>
          <span data-ttu-id="620ed-1590">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1590">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1591">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1591">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1592">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1592">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1593">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1593">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1594">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1594">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1595">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1595">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1596">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1596">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1597">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1597">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1598">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1598">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1599">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1599">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1600">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1600">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1601">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1601">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1602">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1602">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1603">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1603">Random Mode</span></span>  
 <span data-ttu-id="620ed-1604">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1604">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1605">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1605">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1606">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1606">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1607">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1607">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1608">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1608">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1609">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1609">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1610">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1610">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1611">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1611">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1612">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1612">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1613">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1613">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1614">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1614">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1615">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1615">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1616">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1616">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1617">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1617">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1618">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1618">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1619">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1619">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1620">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1620">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1621">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1621">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1622">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1622">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1623">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1623">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1624">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1624">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1625">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1625">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1626">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1626">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1627">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1627">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1628">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1628">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1629">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1629">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1630">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1630">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1631">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1631">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1632">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1632">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1633">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1633">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1634">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1634">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1635">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1635">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1636">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1636">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1637">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1637">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1638">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1638">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1639">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1639">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1640">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1640">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1641">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1641">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1642">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1642">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1643">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1643">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1644">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1644">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1645">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1645">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1646">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1646">Required.</span>
          </span>
          <span data-ttu-id="620ed-1647">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1647">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1648">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1648">Required.</span>
          </span>
          <span data-ttu-id="620ed-1649">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1649">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1650">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1650">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1651">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1651">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1652">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1652">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1653">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1653">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1654">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1654">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1655">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1655">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1656">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1656">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1657">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1657">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1658">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1658">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1659">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1659">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1660">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1660">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1661">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1661">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1662">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1662">Random Mode</span></span>  
 <span data-ttu-id="620ed-1663">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1663">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1664">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1664">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1665">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1665">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1666">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1666">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1667">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1667">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1668">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1668">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1669">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1669">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1670">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1670">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1671">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1671">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1672">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1672">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1673">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1673">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1674">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1674">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1675">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1675">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1676">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1676">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1677">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1677">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1678">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1678">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1679">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1679">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1680">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1680">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1681">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1681">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1682">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1682">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1683">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1683">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1684">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1684">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1685">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1685">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1686">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1686">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1687">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1687">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1688">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1688">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1689">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1689">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1690">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1690">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1691">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1691">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1692">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1692">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1693">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1693">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1694">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1694">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1695">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1695">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1696">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1696">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1697">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1697">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1698">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1698">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1699">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1699">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1700">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1700">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1701">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1701">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1702">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1702">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1703">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1703">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1704">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1704">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1705">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1705">Required.</span>
          </span>
          <span data-ttu-id="620ed-1706">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1706">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1707">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1707">Required.</span>
          </span>
          <span data-ttu-id="620ed-1708">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1708">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1709">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1709">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1710">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1710">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1711">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1711">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1712">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1712">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1713">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1713">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1714">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1714">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1715">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1715">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1716">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1716">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1717">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1717">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1718">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1718">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1719">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1719">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1720">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1720">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1721">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1721">Random Mode</span></span>  
 <span data-ttu-id="620ed-1722">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1722">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1723">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는`RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1723">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1724">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1724">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1725">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1725">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1726">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1726">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1727">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1727">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1728">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1728">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1729">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1729">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1730">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1730">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1731">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1731">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1732">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1732">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1733">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1733">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1734">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1734">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1735">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1735">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1736">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1736">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1737">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1737">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1738">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1738">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1739">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1739">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1740">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1740">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1741">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1741">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1742">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1742">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1743">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1743">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1744">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1744">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1745">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1745">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1746">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1746">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1747">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1747">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1748">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1748">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1749">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1749">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1750">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1750">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1751">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1751">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1752">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1752">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1753">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1753">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1754">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1754">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1755">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1755">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1756">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1756">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1757">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1757">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1758">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1758">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1759">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1759">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1760">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1760">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1761">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1761">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1762">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1762">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1763">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1763">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1764">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1764">Required.</span>
          </span>
          <span data-ttu-id="620ed-1765">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1765">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1766">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1766">Required.</span>
          </span>
          <span data-ttu-id="620ed-1767">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1767">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1768">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1768">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1769">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1769">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1770">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1770">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1771">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1771">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1772">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1772">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1773">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1773">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1774">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1774">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1775">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1775">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1776">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1776">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1777">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1777">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1778">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1778">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1779">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1779">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1780">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1780">Random Mode</span></span>  
 <span data-ttu-id="620ed-1781">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1781">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1782">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1782">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1783">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1783">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1784">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1784">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1785">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1785">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1786">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1786">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1787">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1787">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1788">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1788">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1789">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1789">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1790">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1790">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1791">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1791">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1792">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1792">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1793">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1793">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1794">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1794">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1795">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1795">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1796">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1796">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1797">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1797">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1798">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1798">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1799">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1799">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1800">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1800">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1801">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1801">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1802">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1802">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1803">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1803">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1804">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1804">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1805">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1805">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1806">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1806">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1807">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1807">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1808">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1808">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1809">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1809">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1810">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1810">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1811">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1811">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1812">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1812">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1813">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1813">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1814">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1814">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1815">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1815">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1816">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1816">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1817">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1817">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1818">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1818">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1819">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1819">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1820">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1820">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1821">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1821">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1822">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1822">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1823">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1823">Required.</span>
          </span>
          <span data-ttu-id="620ed-1824">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1824">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1825">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1825">Required.</span>
          </span>
          <span data-ttu-id="620ed-1826">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1826">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1827">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1827">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1828">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1828">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="620ed-1829">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1829">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1830">Applies only when writing a string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1830">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="620ed-1831">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1831">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="620ed-1832">The default is <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1832">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1833">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1833">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1834">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1834">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1835">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1835">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1836">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1836">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1837">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1837">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1838">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1838">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1839">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1839">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1840">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1840">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1841">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1841">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1842">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1842">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1843">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1843">Random Mode</span></span>  
 <span data-ttu-id="620ed-1844">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1844">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1845">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1845">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1846">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1846">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1847">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1847">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1848">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1848">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1849">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1849">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1850">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1850">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1851">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1851">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1852">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1852">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1853">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1853">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1854">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1854">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1855">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1855">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1856">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1856">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1857">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1857">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1858">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1858">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1859">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1859">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1860">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1860">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1861">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1861">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1862">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1862">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1863">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1863">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1864">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1864">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1865">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1865">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1866">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1866">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1867">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1867">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1868">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1868">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1869">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1869">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1870">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1870">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1871">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1871">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1872">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1872">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1873">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1873">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1874">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1874">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1875">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1875">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1876">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1876">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1877">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1877">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1878">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1878">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1879">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1879">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1880">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1880">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1881">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1881">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1882">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1882">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1883">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1883">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1884">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1884">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1885">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1885">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1886">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1886">Required.</span>
          </span>
          <span data-ttu-id="620ed-1887">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1887">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1888">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1888">Required.</span>
          </span>
          <span data-ttu-id="620ed-1889">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1889">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1890">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1890">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1891">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1891">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="620ed-1892">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1892">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1893">Applies only when writing an array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1893">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="620ed-1894">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1894">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="620ed-1895">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1895">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1896">Applies only when writing a string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1896">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="620ed-1897">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1897">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="620ed-1898">The default is <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1898">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1899">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1899">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1900">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1900">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="620ed-1901">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1901">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1902">`FilePut` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1902">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1903">`FilePut`로 작성된 데이터는 일반적으로 `FileGet`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1903">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="620ed-1904">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1904">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1905">생략 하면 `RecordNumber`, 다음 레코드 또는 마지막 바이트 `FileGet` 또는 `FilePut` 함수 또는 마지막에서 가리키는 `Seek` 함수를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1905">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="620ed-1906">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1906">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1907">`FilePut` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1907">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1908">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePut`와 동일한 작업을 수행 해야 `FileGet`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1908">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1909">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1909">Random Mode</span></span>  
 <span data-ttu-id="620ed-1910">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1910">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1911">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePut` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1911">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1912">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1912">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1913">정확히 패딩 데이터의 양을 결정할 수 없으므로, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1913">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1914">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수에서 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1914">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1915">쓰고, 문자열인 경우 `FilePut` 문자열 길이 포함 한 후 변수로 전달 되는 데이터를 작성 하는 2 바이트 설명자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1915">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="620ed-1916">따라서 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1916">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="620ed-1917">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePut` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1917">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1918">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePut` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1918">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1919">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1919">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1920">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePut` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1920">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1921">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1921">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1922">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1922">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1923">쓰고 배열이 면 크기와 배열 차원에 대 한 설명자를 쓸 것인지 여부를 선택할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1923">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="620ed-1924">Visual Basic 6.0 및 이전 버전에서는 동적 배열의 있지만 고정 크기 배열 대 한 파일 설명자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1924">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="620ed-1925">Visual Basic 2005 설명자를 쓰지 않습니다. 기본값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1925">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="620ed-1926">설명자에 설정 된 `ArrayIsDynamic` 매개 변수를 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1926">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="620ed-1927">읽은 배열; 방식과 일치 해야 하는 배열을 작성할 때는 설명자와 읽을 수는 경우 설명자를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1927">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="620ed-1928">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1928">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1929">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1929">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="620ed-1930">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1930">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1931">배열에 기록 되는 경우 다음과 같이 배열을 선언 218 바이트가 필요 예를 들어 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1931">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="620ed-1932">쓰고 있는 변수가 (하지 가변 길이 문자열 또는 개체), 다른 유형의 경우 `FilePut` 변수 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1932">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="620ed-1933">지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 기록 데이터의 길이 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1933">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="620ed-1934">`FilePut` 구조체의 요소가으로 기록 개별적으로 작성 된 각 요소 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1934">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="620ed-1935">`VBFixedString` 특성을 쓸 때 문자열의 크기를 나타내는 구조체에서 문자열 필드에 적용할 수 있습니다 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1935">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="620ed-1936">문자열에 지정한 것 보다 더 많은 바이트에 있는 필드는 `VBFixedString` 특성 기록 될 때 잘립니다를 디스크에</span><span class="sxs-lookup"><span data-stu-id="620ed-1936">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1937">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1937">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1938">연 파일에 `Binary` 모드에서는 대부분의는 `Random` 모드 규칙이 몇 가지 예외가 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1938">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="620ed-1939">열린 파일에 대 한 다음 규칙 `Binary` 모드에 대 한 규칙에서 다른 `Random` 모드:</span><span class="sxs-lookup"><span data-stu-id="620ed-1939">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="620ed-1940">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1940">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1941">`FilePut` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1941">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="620ed-1942">구조에 포함 되지 않은 모든 배열에 대 한 `FilePut` 데이터만 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1942">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="620ed-1943">설명자를 쓰지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1943">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="620ed-1944">`FilePut` 2 바이트 길이 설명자 없이 구조체의 요소가 없는 가변 길이 문자열을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1944">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="620ed-1945">쓴 바이트 수를는 문자열의 문자 수를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1945">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="620ed-1946">예를 들어 다음 문은 파일 번호 1 11 바이트를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1946">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="620ed-1947">사용 하 여 파일에 쓰기는 `FilePut` 함수 필요 `Write` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1947">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1948">사용 하 여이 예제는 `FilePut` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1948">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="620ed-1949">구조체의 5 개 레코드가 `Person` 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1949">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-1950">
            <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1950">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-1951">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1951">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1952">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1952">Required.</span>
          </span>
          <span data-ttu-id="620ed-1953">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1953">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-1954">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1954">Required.</span>
          </span>
          <span data-ttu-id="620ed-1955">Valid variable name that contains data written to disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1955">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="620ed-1956">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1956">Optional.</span>
          </span>
          <span data-ttu-id="620ed-1957">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1957">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1958">Writes data from a variable to a disk file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1958">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="620ed-1959">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1959">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span>
          </span>
          <span data-ttu-id="620ed-1960">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1960">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-1961">`FilePutObject` 함수 대신 사용 됩니다 `FilePut` 경우 컴파일 타임에 모호성을 방지 하려면 형식 `Object` 와 같은 다른 형식 대신 전달 됩니다 `Integer`, `Long`, `Short`, 등입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1961">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="620ed-1962">`FilePutObject` 작성 하 고 개체를 설명 하는 설명자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1962">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="620ed-1963">작성 하려는 경우는 `Variant` 형식 `FilePutObject` 가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1963">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="620ed-1964">확실 하지 않은, 두 번째 매개 변수에 대 한 개체 사용 중인 경우, 항상 사용 하는 권장 `FilePutObject` 및 `FileGetObject`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1964">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="620ed-1965">`FilePutObject` 에서만 유효 `Random` 및 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1965">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-1966">`FilePutObject`로 작성된 데이터는 일반적으로 `FileGetObject`을 사용하여 파일에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1966">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="620ed-1967">첫 번째 레코드 또는 파일의 바이트 위치 1에 있고, 두 번째 레코드와 바이트는 2, 위치 및 기타 등등.</span><span class="sxs-lookup"><span data-stu-id="620ed-1967">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="620ed-1968">생략 하면 `RecordNumber`, `FilePutObject` 지난 후 다음 레코드 또는 바이트를 쓰기 `FileGetObject` 또는 `FilePutObject` 함수 (또는 마지막에서 가리키는 레코드 또는 바이트 `Seek` 함수).</span><span class="sxs-lookup"><span data-stu-id="620ed-1968">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="620ed-1969">`StringIsFixedLength` 인수는 함수는으로 변수 또는 고정 길이 문자열을 해석 하는 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1969">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="620ed-1970">`FilePutObject` 인수가 길이 설명자를 쓰지 않습니다 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1970">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="620ed-1971">사용 하는 경우 `StringIsFixedLength`  =  `True` 와 `FilePutObject`와 동일한 작업을 수행 해야 `FileGetObject`, 예상 길이 문자열 초기화 되는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1971">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="620ed-1972">임의 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1972">Random Mode</span></span>  
 <span data-ttu-id="620ed-1973">연 파일에 `Random` 모드는 다음 규칙이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1973">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="620ed-1974">쓸 데이터의 길이에 지정 된 길이 보다 작은 경우는 `RecordLength` 절은 `FileOpen` 함수 `FilePutObject` 레코드 길이 경계에 다음 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1974">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="620ed-1975">한 레코드의 끝과 다음 레코드의 시작 사이의 간격을 하면 파일 버퍼의 기존 내용을 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1975">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="620ed-1976">채워지는 데이터의 양은 정확 하 게 확인할 수 없습니다, 일반적으로 레코드 길이 쓰고 있는 데이터의 길이 일치 시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1976">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="620ed-1977">기록 데이터의 길이에 지정 된 길이 보다 큰 경우는 `RecordLength` 절은 `FileOpen` 함수, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1977">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="620ed-1978">숫자 형식을 포함 하는 개체 변수를 쓰는 경우 `FilePutObject` 식별 하는 2 바이트를 쓴는 `VarType` 개체의 다음 변수를 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1978">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="620ed-1979">예를 들어 개체를 작성할 때는 포함 하는 정수 `FilePutObject` 6 바이트를 씁니다:으로 개체를 식별 하는 2 바이트 `VarType(3)` (`Integer`) 및 데이터를 포함 하는 4 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1979">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="620ed-1980">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수에 변수를 저장 하는 데 필요한 바이트의 실제 숫자 보다 큰 2 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1980">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="620ed-1981">쓰고 있는 변수는 문자열을 포함 하는 개체 이면 `FilePutObject` 식별 하는 2 바이트 설명자는 `VarType(8)` 문자열 및 다음 쓰기 문자열 데이터의 길이 나타내는 2 바이트 설명자 개체의 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1981">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="620ed-1982">지정한 레코드 길이 `RecordLength` 에서 매개 변수는 `FileOpen` 함수는 문자열의 실제 길이 보다 큰 4 바이트 이상 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1982">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="620ed-1983">전달 해야 설명자 없이 문자열이 저장 하려는 경우 `True` 에 `StringIsFixedLength` 매개 변수를 읽어 들이는 정확한 길이 해야 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1983">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="620ed-1984">쓰고 배열 되 면 변수로 지정한 레코드 길이 `RecordLength` 절에는 `FileOpen` 배열 데이터 및 배열 설명자를 작성 하는 데 필요한 모든 바이트 보다 크거나 함수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1984">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="620ed-1985">설명자는 배열, 크기 및 각 순위 하 한의 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1985">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="620ed-1986">길이 2 + 8 시간 차원 수가: (2 + 8 \* 더한 것).</span><span class="sxs-lookup"><span data-stu-id="620ed-1986">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="620ed-1987">이진 모드</span><span class="sxs-lookup"><span data-stu-id="620ed-1987">Binary Mode</span></span>  
 <span data-ttu-id="620ed-1988">연 파일에 `Binary` 모드에서는 모든는 `Random` 모드 규칙 적용을 제외 하 고:</span><span class="sxs-lookup"><span data-stu-id="620ed-1988">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="620ed-1989">`RecordLength` 절에는 `FileOpen` 함수에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1989">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="620ed-1990">`FilePutObject` 모든 변수를 연속적으로 레코드 사이의 안쪽 여백 없이 즉, 디스크를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1990">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-1991">사용 하 여이 예제는 `FilePutObject` 문자열 파일에 기록 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1991">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-1992">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1992">Required.</span>
          </span>
          <span data-ttu-id="620ed-1993">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1993">Any valid file number.</span>
          </span>
        </param>
        <param name="RecordWidth">
          <span data-ttu-id="620ed-1994">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1994">Required.</span>
          </span>
          <span data-ttu-id="620ed-1995">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1995">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span>
          </span>
          <span data-ttu-id="620ed-1996">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1996">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span>
          </span>
          <span data-ttu-id="620ed-1997">The default value for <c>RecordWidth</c> is 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1997">The default value for <c>RecordWidth</c> is 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-1998">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-1998">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="620ed-1999">사용 하 여이 예제는 `FileWidth` 파일에 대 한 출력 선 두께 설정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-1999">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2000">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2000">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2001">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2001">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2002">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2002">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2003">사용 하 여 `FreeFile` 을 이미 사용 되지 않는 파일 번호를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2003">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2004">사용 하 여이 예제는 `FreeFile` 다음 사용 가능한 파일 수를 반환 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2004">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="620ed-2005">5 개의 파일 출력 루프 내에 열리고 몇 가지 샘플 데이터에 각각 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2005">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2006">More than 255 files are in use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2006">More than 255 files are in use.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="620ed-2007">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2007">Required.</span>
          </span>
          <span data-ttu-id="620ed-2008">
            <see langword="String" /> expression that specifies a file, directory, or folder name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2008">
              <see langword="String" /> expression that specifies a file, directory, or folder name.</span>
          </span>
          <span data-ttu-id="620ed-2009">
            <c>PathName</c> can include the directory or folder, and the drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2009">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2010">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2010">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span>
          </span>
          <span data-ttu-id="620ed-2011">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2011">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span>
          </span>
          <span data-ttu-id="620ed-2012">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2012">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2013">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2013">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2014">사용 하 여 설정 된 특성을 확인 하려면는 `And` 연산자에서 반환 값의 비트 비교를 수행 하는 `GetAttr` 함수와 원하는 개별 파일 특성의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2014">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="620ed-2015">결과 0이 아니면 해당 특성은 명명된 된 파일에 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2015">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="620ed-2016">예를 들어, 다음의 반환 값 `And` 식은 경우에는 0는 `Archive` 특성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2016">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="620ed-2017">0이 아닌 값을 반환 된 `Archive` 특성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2017">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2018">사용 하 여이 예제는 `GetAttr` 파일 및 디렉터리 또는 폴더의 특성을 결정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2018">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2019">
            <paramref name="Pathname" /> is invalid or contains wildcards.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2019">
              <paramref name="Pathname" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-2020">Target file does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2020">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2021">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2021">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2022">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2022">Required.</span>
          </span>
          <span data-ttu-id="620ed-2023">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2023">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2024">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2024">Required.</span>
          </span>
          <span data-ttu-id="620ed-2025">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2025">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2026">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2026">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2027">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2027">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2028">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2028">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2029">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2029">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2030">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2030">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2031">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2031">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2032">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2032">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2033">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2033">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2034">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2034">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2035">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2035">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2036">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2036">Data</span></span>|<span data-ttu-id="620ed-2037">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2037">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2038">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2038">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2039">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2039">Empty</span></span>|  
|<span data-ttu-id="620ed-2040">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2040">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2041"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2041">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2042">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2042">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2043">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2043">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2044">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2044">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2045">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2045">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2046">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2046">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2047">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2047">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2048">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2048">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2049">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2049">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2050">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2050">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2051">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2051">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2052">이 예에서는 가정 하는 `TestFile` 은 파일을 사용 하 여 기록 된 데이터의 일부 줄입니다는 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2052">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2053">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2053">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2054">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2054">Required.</span>
          </span>
          <span data-ttu-id="620ed-2055">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2055">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2056">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2056">Required.</span>
          </span>
          <span data-ttu-id="620ed-2057">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2057">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2058">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2058">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2059">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2059">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2060">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2060">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2061">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2061">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2062">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2062">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2063">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2063">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2064">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2064">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2065">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2065">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2066">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2066">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2067">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2067">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2068">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2068">Data</span></span>|<span data-ttu-id="620ed-2069">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2069">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2070">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2070">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2071">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2071">Empty</span></span>|  
|<span data-ttu-id="620ed-2072">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2072">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2073"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2073">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2074">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2074">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2075">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2075">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2076">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2076">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2077">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2077">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2078">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2078">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2079">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2079">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2080">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2080">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2081">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2081">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2082">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2082">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2083">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2083">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2084">이 예에서는 가정 하는 `TestFile` 은 파일을 사용 하 여 기록 된 데이터의 일부 줄입니다는 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2084">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2085">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2085">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2086">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2086">Required.</span>
          </span>
          <span data-ttu-id="620ed-2087">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2087">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2088">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2088">Required.</span>
          </span>
          <span data-ttu-id="620ed-2089">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2089">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2090">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2090">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2091">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2091">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2092">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2092">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2093">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2093">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2094">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2094">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2095">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2095">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2096">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2096">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2097">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2097">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2098">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2098">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2099">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2099">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2100">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2100">Data</span></span>|<span data-ttu-id="620ed-2101">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2101">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2102">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2102">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2103">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2103">Empty</span></span>|  
|<span data-ttu-id="620ed-2104">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2104">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2105"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2105">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2106">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2106">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2107">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2107">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2108">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2108">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2109">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2109">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2110">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2110">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2111">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2111">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2112">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2112">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2113">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2113">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2114">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2114">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2115">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2115">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2116">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2116">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2117">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2117">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2118">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2118">Required.</span>
          </span>
          <span data-ttu-id="620ed-2119">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2119">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2120">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2120">Required.</span>
          </span>
          <span data-ttu-id="620ed-2121">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2121">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2122">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2122">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2123">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2123">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2124">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2124">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2125">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2125">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2126">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2126">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2127">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2127">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2128">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2128">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2129">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2129">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2130">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2130">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2131">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2131">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2132">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2132">Data</span></span>|<span data-ttu-id="620ed-2133">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2133">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2134">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2134">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2135">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2135">Empty</span></span>|  
|<span data-ttu-id="620ed-2136">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2136">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2137"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2137">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2138">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2138">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2139">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2139">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2140">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2140">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2141">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2141">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2142">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2142">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2143">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2143">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2144">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2144">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2145">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2145">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2146">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2146">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2147">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2147">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2148">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2148">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2149">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2149">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2150">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2150">Required.</span>
          </span>
          <span data-ttu-id="620ed-2151">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2151">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2152">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2152">Required.</span>
          </span>
          <span data-ttu-id="620ed-2153">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2153">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2154">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2154">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2155">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2155">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2156">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2156">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2157">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2157">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2158">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2158">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2159">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2159">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2160">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2160">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2161">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2161">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2162">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2162">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2163">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2163">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2164">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2164">Data</span></span>|<span data-ttu-id="620ed-2165">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2165">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2166">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2166">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2167">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2167">Empty</span></span>|  
|<span data-ttu-id="620ed-2168">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2168">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2169"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2169">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2170">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2170">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2171">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2171">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2172">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2172">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2173">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2173">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2174">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2174">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2175">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2175">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2176">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2176">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2177">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2177">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2178">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2178">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2179">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2179">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2180">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2180">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2181">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2181">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2182">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2182">Required.</span>
          </span>
          <span data-ttu-id="620ed-2183">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2183">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2184">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2184">Required.</span>
          </span>
          <span data-ttu-id="620ed-2185">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2185">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2186">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2186">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2187">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2187">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2188">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2188">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2189">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2189">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2190">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2190">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2191">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2191">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2192">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2192">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2193">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2193">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2194">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2194">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2195">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2195">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2196">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2196">Data</span></span>|<span data-ttu-id="620ed-2197">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2197">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2198">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2198">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2199">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2199">Empty</span></span>|  
|<span data-ttu-id="620ed-2200">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2200">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2201"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2201">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2202">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2202">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2203">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2203">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2204">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2204">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2205">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2205">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2206">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2206">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2207">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2207">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2208">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2208">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2209">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2209">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2210">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2210">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2211">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2211">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2212">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2212">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2213">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2213">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2214">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2214">Required.</span>
          </span>
          <span data-ttu-id="620ed-2215">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2215">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2216">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2216">Required.</span>
          </span>
          <span data-ttu-id="620ed-2217">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2217">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2218">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2218">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2219">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2219">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2220">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2220">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2221">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2221">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2222">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2222">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2223">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2223">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2224">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2224">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2225">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2225">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2226">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2226">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2227">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2227">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2228">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2228">Data</span></span>|<span data-ttu-id="620ed-2229">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2229">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2230">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2230">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2231">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2231">Empty</span></span>|  
|<span data-ttu-id="620ed-2232">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2232">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2233"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2233">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2234">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2234">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2235">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2235">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2236">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2236">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2237">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2237">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2238">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2238">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2239">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2239">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2240">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2240">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2241">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2241">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2242">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2242">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2243">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2243">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2244">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2244">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2245">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2245">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2246">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2246">Required.</span>
          </span>
          <span data-ttu-id="620ed-2247">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2247">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2248">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2248">Required.</span>
          </span>
          <span data-ttu-id="620ed-2249">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2249">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2250">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2250">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2251">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2251">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2252">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2252">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2253">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2253">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2254">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2254">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2255">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2255">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2256">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2256">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2257">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2257">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2258">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2258">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2259">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2259">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2260">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2260">Data</span></span>|<span data-ttu-id="620ed-2261">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2261">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2262">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2262">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2263">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2263">Empty</span></span>|  
|<span data-ttu-id="620ed-2264">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2264">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2265"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2265">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2266">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2266">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2267">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2267">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2268">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2268">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2269">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2269">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2270">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2270">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2271">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2271">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2272">예를 들어 독일어 버전에서 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2272">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2273">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2273">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2274">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2274">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2275">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2275">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2276">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2276">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2277">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2277">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2278">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2278">Required.</span>
          </span>
          <span data-ttu-id="620ed-2279">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2279">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2280">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2280">Required.</span>
          </span>
          <span data-ttu-id="620ed-2281">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2281">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2282">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2282">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2283">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2283">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2284">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2284">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2285">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2285">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2286">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2286">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2287">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2287">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2288">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2288">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2289">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2289">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2290">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2290">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2291">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2291">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2292">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2292">Data</span></span>|<span data-ttu-id="620ed-2293">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2293">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2294">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2294">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2295">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2295">Empty</span></span>|  
|<span data-ttu-id="620ed-2296">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2296">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2297"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2297">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2298">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2298">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2299">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2299">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2300">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2300">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2301">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2301">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2302">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2302">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2303">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2303">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2304">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2304">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2305">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2305">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2306">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2306">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2307">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2307">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2308">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2308">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2309">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2309">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2310">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2310">Required.</span>
          </span>
          <span data-ttu-id="620ed-2311">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2311">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2312">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2312">Required.</span>
          </span>
          <span data-ttu-id="620ed-2313">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2313">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2314">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2314">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2315">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2315">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2316">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2316">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2317">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2317">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2318">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2318">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2319">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2319">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2320">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2320">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2321">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2321">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2322">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2322">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2323">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2323">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2324">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2324">Data</span></span>|<span data-ttu-id="620ed-2325">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2325">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2326">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2326">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2327">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2327">Empty</span></span>|  
|<span data-ttu-id="620ed-2328">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2328">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2329"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2329">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2330">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2330">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2331">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2331">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2332">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2332">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2333">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2333">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2334">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2334">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2335">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2335">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2336">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2336">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2337">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2337">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2338">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2338">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2339">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2339">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2340">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2340">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2341">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2341">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2342">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2342">Required.</span>
          </span>
          <span data-ttu-id="620ed-2343">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2343">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2344">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2344">Required.</span>
          </span>
          <span data-ttu-id="620ed-2345">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2345">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2346">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2346">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2347">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2347">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2348">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2348">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2349">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2349">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2350">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2350">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2351">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2351">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2352">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2352">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2353">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2353">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2354">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2354">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2355">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2355">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2356">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2356">Data</span></span>|<span data-ttu-id="620ed-2357">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2357">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2358">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2358">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2359">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2359">Empty</span></span>|  
|<span data-ttu-id="620ed-2360">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2360">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2361"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2361">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2362">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2362">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2363">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2363">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2364">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2364">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2365">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2365">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2366">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2366">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2367">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2367">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2368">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2368">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2369">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2369">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2370">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2370">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2371">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2371">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2372">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2372">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2373">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2373">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2374">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2374">Required.</span>
          </span>
          <span data-ttu-id="620ed-2375">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2375">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="620ed-2376">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2376">Required.</span>
          </span>
          <span data-ttu-id="620ed-2377">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2377">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2378">Reads data from an open sequential file and assigns the data to variables.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2378">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2379">`Input` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2379">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2380">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2380">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2381">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2381">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2382">데이터를 읽을 `Input` 를 사용 하 여 일반적으로 파일에 기록 `Write`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2382">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="620ed-2383">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2383">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2384">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2384">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2385">예를 들어 Form1.vb 라는 파일은 Visual Basic 2005 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2385">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="620ed-2386">읽을 때 표준 문자열 또는 숫자 데이터를 수정 하지 않고 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2386">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="620ed-2387">다음 표에서 다른 입력된 데이터를 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2387">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="620ed-2388">데이터</span><span class="sxs-lookup"><span data-stu-id="620ed-2388">Data</span></span>|<span data-ttu-id="620ed-2389">변수에 할당 된 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2389">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="620ed-2390">쉼표 또는 빈 줄을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2390">Delimiting comma or blank line</span></span>|<span data-ttu-id="620ed-2391">Empty</span><span class="sxs-lookup"><span data-stu-id="620ed-2391">Empty</span></span>|  
|<span data-ttu-id="620ed-2392">#NULL#</span><span class="sxs-lookup"><span data-stu-id="620ed-2392">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="620ed-2393"># # TRUE 또는 FALSE # #</span><span class="sxs-lookup"><span data-stu-id="620ed-2393">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="620ed-2394">`True` 또는 `False`</span><span class="sxs-lookup"><span data-stu-id="620ed-2394">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="620ed-2395">날짜 및/또는 식으로 표시 된 시간이</span><span class="sxs-lookup"><span data-stu-id="620ed-2395">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="620ed-2396">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="620ed-2396">#ERROR `errornumber`#</span></span>|<span data-ttu-id="620ed-2397">`errornumber` (변수가 오류 태그가 지정 된 개체)</span><span class="sxs-lookup"><span data-stu-id="620ed-2397">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="620ed-2398">데이터 항목을 입력 하는 동안 파일의 끝에 도달 하면, 입력이 중지 되 고 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2398">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2399">`Input` 함수 지역화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2399">The `Input` function is not localized.</span></span> <span data-ttu-id="620ed-2400">예를 들어 독일어 버전 3,14159를 입력 하는 경우 반환 3만 쉼표가 소수점으로 대신 변수 구분 기호로 처리 되기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2400">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2401">사용 하 여 파일에서 읽기는 `Input` 함수 필요 `Read` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2401">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2402">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="620ed-2402">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2403">사용 하 여이 예제는 `Input` 함수 두 변수로 파일에서 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2403">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="620ed-2404">이 예에서는 가정 하는 `TestFile` 이 여러 줄을 사용 하 여 기록 된 데이터의 파일이 `Write` 함수를 견적 및 예를 들어, 쉼표로 구분 된 숫자의 문자열을 포함 하는 각 줄: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="620ed-2404">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2405">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2405">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2406">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2406">Required.</span>
          </span>
          <span data-ttu-id="620ed-2407">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2407">Any valid file number.</span>
          </span>
        </param>
        <param name="CharCount">
          <span data-ttu-id="620ed-2408">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2408">Required.</span>
          </span>
          <span data-ttu-id="620ed-2409">Any valid numeric expression specifying the number of characters to read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2409">Any valid numeric expression specifying the number of characters to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2410">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2410">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="620ed-2411">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2411">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
          <span data-ttu-id="620ed-2412">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2412">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2413">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2413">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="620ed-2414">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2414">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2415">`InputString` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2415">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2416">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2416">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2417">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2417">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2418">사용 하 여 읽은 데이터는 `InputString` 함수는 일반적으로 사용 하 여 파일에 기록 됩니다 `Print` 또는 `FilePut`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2418">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="620ed-2419">열린 파일에만이 함수를 사용 하 여 `Input` 또는 `Binary` 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2419">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="620ed-2420">와 달리는 `Input` 함수는 `InputString` 읽어 온 모든 문자가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2420">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="620ed-2421">여기에 쉼표, 캐리지 리턴, 줄 바꿈, 인용 부호 및 선행 공백을 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2421">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="620ed-2422">연 파일 `Binary` 액세스를 사용 하 여 파일을 통해 읽지는 `InputString` 될 때까지 작동 `EOF` 반환 `True` 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2422">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="620ed-2423">사용 하 여는 `LOF` 및 `Loc` 대신 함수 `EOF` 를 사용 하 여 이진 파일을 읽을 때 `InputString`, 사용 또는 `FileGet` 사용 하는 경우는 `EOF` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2423">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2424">파일을 읽을 때 파일 이름 확장명에 근거 하 여 파일의 내용에 대해 보안 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2424">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="620ed-2425">예를 들어 Form1.vb 파일이 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2425">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2426">사용 하 여이 예제는 `InputString` 파일에서 한 번에 한 문자를 읽고 인쇄 하는 함수는 `Output` 창.</span><span class="sxs-lookup"><span data-stu-id="620ed-2426">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="620ed-2427">이 예에서는 가정 하는 `MyFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2427">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2428">
            <paramref name="FileNumber" /> does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2428">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-2429">
            <paramref name="CharCount" /> &lt; 0 or &gt; 214.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2429">
              <paramref name="CharCount" /> &lt; 0 or &gt; 214.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="620ed-2430">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2430">Required.</span>
          </span>
          <span data-ttu-id="620ed-2431">
            <see langword="String" /> expression that specifies one or more file names to be deleted.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2431">
              <see langword="String" /> expression that specifies one or more file names to be deleted.</span>
          </span>
          <span data-ttu-id="620ed-2432">
            <c>PathName</c> can include the directory or folder, and the drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2432">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2433">Deletes files from a disk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2433">Deletes files from a disk.</span>
          </span>
          <span data-ttu-id="620ed-2434">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2434">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span>
          </span>
          <span data-ttu-id="620ed-2435">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2435">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2436">`Kill` 다중 문자 사용을 지원 (`*`) 및 단일 문자 (`?`) 와일드 카드 여러 파일을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2436">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="620ed-2437">**보안 정보** 을 실행 하려면는 `Kill` 함수 필요 `Read` 및 `PathDiscovery` 의 플래그 지정 <xref:System.Security.Permissions.FileIOPermission> 코드 실행에 부여할 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2437">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="620ed-2438">자세한 내용은 참조 <xref:System.Security.SecurityException> [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="620ed-2438">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2439">사용 하 여이 예제는 `Kill` 함수를 디스크에서 파일을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2439">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2440">Target file(s) open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2440">Target file(s) open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-2441">Target file(s) not found.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2441">Target file(s) not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="620ed-2442">Permission denied.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2442">Permission denied.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2443">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2443">Required.</span>
          </span>
          <span data-ttu-id="620ed-2444">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2444">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2445">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2445">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2446">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2446">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2447">`LineInput` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2447">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2448">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2448">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2449">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2449">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2450">데이터를 읽을 `LineInput` 를 사용 하 여 일반적으로 파일에 기록 `Print`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2450">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2451">파일을 읽을 때 파일 이름 확장명에 따라 파일의 내용에 대 한 판단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2451">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="620ed-2452">예를 들어 Form1.vb 라는 파일은 Visual Basic 소스 파일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2452">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="620ed-2453">`LineInput` 캐리지 리턴에 도달할 때까지 한 번에 파일 1 자에서 함수를 읽습니다 (`Chr(13)`) 또는 캐리지 리턴/줄 바꿈 (`Chr(13) + Chr(10)`) 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2453">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="620ed-2454">캐리지 리턴/줄 바꿈된 시퀀스 문자 문자열에 추가 하는 대신 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2454">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2455">사용 하 여 파일에서 읽기는 `LineInput` 함수 필요 `Read` 에서 액세스는 <xref:System.Security.Permissions.FileIOPermissionAccess> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2455">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2456">사용 하 여이 예제는 `LineInput` 함수 순차 파일에서 줄을 읽고을 변수에 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2456">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="620ed-2457">이 예에서는 가정 하는 `TestFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2457">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">
          <span data-ttu-id="620ed-2458">End of file reached.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2458">End of file reached.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2459">
            <paramref name="FileNumber" /> does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2459">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2460">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2460">Required.</span>
          </span>
          <span data-ttu-id="620ed-2461">Any valid <see langword="Integer" /> file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2461">Any valid <see langword="Integer" /> file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2462">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2462">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2463">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2463">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2464">`Loc` 함수는 0부터 시작; 파일의 첫 번째 바이트를 검색 하는 데 사용 하는 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2464">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="620ed-2465">`Loc` 함수는 이전 버전과 호환성을 위해 제공 되며 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2465">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2466">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2466">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2467">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2467">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2468">다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2468">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="620ed-2469">모드</span><span class="sxs-lookup"><span data-stu-id="620ed-2469">Mode</span></span>|<span data-ttu-id="620ed-2470">반환 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2470">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="620ed-2471">읽거나 파일에 쓴 마지막 레코드의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2471">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="620ed-2472">128로 구분해 서 파일의 현재 바이트 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2472">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="620ed-2473">그러나 정보를 반환할 `Loc` 순차적 파일 사용 아니고 필요한에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2473">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="620ed-2474">마지막 바이트 읽기 또는 쓰기의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2474">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2475">사용 하 여이 예제는 `Loc` 열려 있는 파일의 현재 읽기/쓰기 위치를 반환 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2475">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="620ed-2476">이 예에서는 가정 하는 `MyFile` 은 샘플 데이터의 여러 줄 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2476">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2477">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2477">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2478">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2478">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2479">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2479">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2480">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2480">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2481">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2481">Required.</span>
          </span>
          <span data-ttu-id="620ed-2482">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2482">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2483">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2483">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2484">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2484">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2485">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2485">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2486">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2486">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="620ed-2487">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2487">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="620ed-2488">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2488">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="620ed-2489">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2489">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="620ed-2490">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2490">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="620ed-2491">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2491">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2492">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2492">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="620ed-2493">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2493">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2494">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2494">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2495">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2495">Required.</span>
          </span>
          <span data-ttu-id="620ed-2496">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2496">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="620ed-2497">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2497">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2498">Number of the only record or byte to lock or unlock</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2498">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2499">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2499">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2500">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2500">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2501">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2501">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2502">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2502">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="620ed-2503">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2503">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="620ed-2504">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2504">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="620ed-2505">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2505">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="620ed-2506">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2506">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="620ed-2507">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2507">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2508">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2508">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="620ed-2509">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2509">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2510">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2510">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2511">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2511">Required.</span>
          </span>
          <span data-ttu-id="620ed-2512">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2512">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="620ed-2513">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2513">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2514">Number of the first record or byte to lock or unlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2514">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="620ed-2515">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2515">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2516">Number of the last record or byte to lock or unlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2516">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2517">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2517">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2518">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2518">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2519">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2519">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2520">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2520">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="620ed-2521">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2521">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="620ed-2522">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2522">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="620ed-2523">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2523">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="620ed-2524">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2524">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="620ed-2525">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2525">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2526">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2526">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="620ed-2527">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2527">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2528">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2528">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2529">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2529">Required.</span>
          </span>
          <span data-ttu-id="620ed-2530">An <see langword="Integer" /> that contains a valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2530">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2531">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2531">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2532">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2532">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
          <span data-ttu-id="620ed-2533">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2533">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2534">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2534">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2535">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2535">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2536">사용 하 여는 `FileLen` 열려 있지 않은 파일의 길이 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2536">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2537">사용 하 여이 예제는 `LOF` 열려 있는 파일의 크기를 결정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2537">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="620ed-2538">이 예에서는 가정 하는 `TestFile` 은 샘플 데이터를 포함 하는 텍스트 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2538">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2539">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2539">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="620ed-2540">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2540">Required.</span>
          </span>
          <span data-ttu-id="620ed-2541">
            <see langword="String" /> expression that identifies the directory to be created.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2541">
              <see langword="String" /> expression that identifies the directory to be created.</span>
          </span>
          <span data-ttu-id="620ed-2542">The <c>Path</c> may include the drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2542">The <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="620ed-2543">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2543">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2544">Creates a new directory.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2544">Creates a new directory.</span>
          </span>
          <span data-ttu-id="620ed-2545">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2545">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span>
          </span>
          <span data-ttu-id="620ed-2546">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2546">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2547">이 함수는 새 디렉터리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2547">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2548">사용 하 여이 예제는 `MkDir` 디렉터리를 만들 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2548">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="620ed-2549">드라이브 지정 되지 않은 경우에 현재 드라이브에 새 디렉터리가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2549">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-2550">
            <paramref name="Path" /> is not specified or is empty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2550">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="620ed-2551">Permission denied.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2551">Permission denied.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2552">Directory already exists.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2552">Directory already exists.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2553">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2553">Required.</span>
          </span>
          <span data-ttu-id="620ed-2554">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2554">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="620ed-2555">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2555">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2556">Zero or more comma-delimited expressions to write to a file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2556">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="620ed-2557">The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2557">The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="620ed-2558">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2558">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2559">Writes display-formatted data to a sequential file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2559">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2560">`Print` 및 `PrintLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2560">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2561">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2561">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2562">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2562">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2563">`Print` 줄 바꿈으로 줄의 끝에 포함 되지 않습니다. 그러나 `PrintLine` 줄 바꿈에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2563">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="620ed-2564">로 작성 된 데이터 `Print` 일반적으로 사용 하 여 파일에서 읽은 `LineInput` 또는 `Input`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2564">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="620ed-2565">생략 하면 `Output` 에 대 한 `PrintLine`, 빈 줄에 대 한; 파일에 출력은 `Print`, 아무것도 출력 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2565">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="620ed-2566">쉼표로 구분 된 여러 개의 식을 혼합 쉼표 탭 경계에 맞춰집니다 및 `TAB` 일관 되지 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2566">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="620ed-2567">에 대 한 `Boolean` 데이터를 `True` 또는 `False` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2567">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="620ed-2568">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2568">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="620ed-2569">날짜 데이터는 시스템에서 인식 표준 짧은 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2569">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="620ed-2570">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2570">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="620ed-2571">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2571">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="620ed-2572">그러나 경우 `Output` 목록 데이터는 `DBNull`, `Null` 파일에 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2572">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="620ed-2573">에 대 한 `Error` 데이터를 출력으로 표시 `Error errorcode`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2573">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="620ed-2574">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2574">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="620ed-2575">모든 데이터를 사용 하 여 파일에 기록 `Print` 국제적으로 인식 됩니다; 즉, 데이터의 형식이 올바르게 적절 한 소수 구분 기호를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2575">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="620ed-2576">여러 로캘에서 사용할 데이터를 출력 하려는 경우 `Write` 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2576">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="620ed-2577">사용 하 여 파일에 쓰기는 `Print` 또는 `PrintLine` 함수 필요 `Write` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2577">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2578">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="620ed-2578">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2579">사용 하 여이 예제는 `Print` 및 `PrintLine` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2579">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2580">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2580">Required.</span>
          </span>
          <span data-ttu-id="620ed-2581">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2581">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="620ed-2582">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2582">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2583">Zero or more comma-delimited expressions to write to a file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2583">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="620ed-2584">The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2584">The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="620ed-2585">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2585">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2586">Writes display-formatted data to a sequential file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2586">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2587">`Print` 및 `PrintLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2587">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2588">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2588">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2589">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2589">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2590">`Print` 줄 바꿈으로 줄의 끝에 포함 되지 않습니다. 그러나`PrintLine` 줄 바꿈에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2590">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="620ed-2591">로 작성 된 데이터 `Print` 일반적으로 사용 하 여 파일에서 읽은 `LineInput` 또는 `Input`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2591">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="620ed-2592">생략 하면 `Output` 에 대 한 `PrintLine`, 빈 줄에 대 한; 파일에 출력은 `Print`, 아무것도 출력 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2592">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="620ed-2593">쉼표로 구분 된 여러 개의 식을 혼합 쉼표 탭 경계에 맞춰집니다 및 `TAB` 일관 되지 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2593">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="620ed-2594">에 대 한 `Boolean` 데이터를 `True` 또는 `False` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2594">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="620ed-2595">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2595">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="620ed-2596">날짜 데이터는 시스템에서 인식 하는 표준의 간단한 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2596">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="620ed-2597">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2597">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="620ed-2598">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2598">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="620ed-2599">그러나 경우 `Output` 목록 데이터는 `DBNull`, `Null` 파일에 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2599">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="620ed-2600">에 대 한 `Error` 데이터를 출력으로 표시 `Error errorcode`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2600">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="620ed-2601">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2601">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="620ed-2602">모든 데이터를 사용 하 여 파일에 기록 `Print` 국제적으로 인식 됩니다; 즉, 데이터의 형식이 올바르게 적절 한 소수 구분 기호를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2602">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="620ed-2603">여러 로캘에서 사용할 데이터를 출력 하려는 경우 `Write` 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2603">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="620ed-2604">사용 하 여 파일에 쓰기는 `Print` 또는 `PrintLine` 함수 필요 `Write` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2604">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2605">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="620ed-2605">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2606">사용 하 여이 예제는 `Print` 및 `PrintLine` 함수는 파일에 데이터를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2606">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">
          <span data-ttu-id="620ed-2607">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2607">Required.</span>
          </span>
          <span data-ttu-id="620ed-2608">
            <see langword="String" /> expression that specifies the existing file name and location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2608">
              <see langword="String" /> expression that specifies the existing file name and location.</span>
          </span>
          <span data-ttu-id="620ed-2609">
            <c>OldPath</c> may include the directory, and drive, of the file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2609">
              <c>OldPath</c> may include the directory, and drive, of the file.</span>
          </span>
        </param>
        <param name="NewPath">
          <span data-ttu-id="620ed-2610">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2610">Required.</span>
          </span>
          <span data-ttu-id="620ed-2611">
            <see langword="String" /> expression that specifies the new file name and location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2611">
              <see langword="String" /> expression that specifies the new file name and location.</span>
          </span>
          <span data-ttu-id="620ed-2612">
            <c>NewPath</c> may include directory and drive of the destination location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2612">
              <c>NewPath</c> may include directory and drive of the destination location.</span>
          </span>
          <span data-ttu-id="620ed-2613">The file name specified by <c>NewPath</c> cannot already exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2613">The file name specified by <c>NewPath</c> cannot already exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2614">Renames a disk file or directory.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2614">Renames a disk file or directory.</span>
          </span>
          <span data-ttu-id="620ed-2615">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2615">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span>
          </span>
          <span data-ttu-id="620ed-2616">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2616">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2617">`Rename` 함수는 파일 이름을 바꾸고 필요한 경우 다른 디렉터리로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2617">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="620ed-2618">`Rename` 함수는 드라이브에 파일을 이동할 수 있지만 기존 디렉터리의 이름만 바꿀 수 때 둘 다 `NewPath` 및 `OldPath` 는 동일한 드라이브에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2618">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="620ed-2619">`Rename` 새 파일 또는 디렉터리를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2619">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="620ed-2620">사용 하는 `Rename` 열려 있는 파일에 대해 함수에서 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2620">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="620ed-2621">이름을 바꾸기 전에 열려 있는 파일을 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2621">You must close an open file before renaming it.</span></span> <span data-ttu-id="620ed-2622">`Rename` 다중 문자 (\*) 및 (?) 단일 문자 와일드 카드 인수 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2622">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="620ed-2623">사용 하는 경우 `Rename` 파일에 덜 제한적인된 권한이 보호 된 위치를 보호 되지 않는 위치에서 파일을 복사를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2623">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="620ed-2624">보안상 위험을 도입 하지는 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2624">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2625">사용 하 여이 예제는 `Rename` 파일 이름을 바꾸는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2625">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="620ed-2626">이 예제에서 이미 지정 된 디렉터리에 존재 하는지 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2626">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-2627">Path is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2627">Path is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-2628">
            <paramref name="OldPath" /> file does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2628">
              <paramref name="OldPath" /> file does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2629">Cannot rename to different device.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2629">Cannot rename to different device.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2630">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2630">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2631">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2631">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span>
          </span>
          <span data-ttu-id="620ed-2632">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2632">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2633">`Reset` 함수에 의해 열린 모든 활성 파일 닫습니다는 `FileOpen` 작동 하 고 동일한 기능을 `FileClose()` 매개 변수 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2633">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2634">사용 하 여이 예제는 `Reset` 함수를 열려 있는 모든 파일을 닫고 모든 파일 버퍼의 내용이 디스크에 쓰여집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2634">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="620ed-2635">사용 하 여는 `Object` 변수 `FileNumber` 문자열과 숫자를 모두로 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2635">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="620ed-2636">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2636">Required.</span>
          </span>
          <span data-ttu-id="620ed-2637">
            <see langword="String" /> expression that identifies the directory or folder to be removed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2637">
              <see langword="String" /> expression that identifies the directory or folder to be removed.</span>
          </span>
          <span data-ttu-id="620ed-2638">
            <c>Path</c> can include the drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2638">
              <c>Path</c> can include the drive.</span>
          </span>
          <span data-ttu-id="620ed-2639">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2639">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2640">Removes an existing directory.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2640">Removes an existing directory.</span>
          </span>
          <span data-ttu-id="620ed-2641">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2641">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span>
          </span>
          <span data-ttu-id="620ed-2642">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2642">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2643">사용 하려고 하면 오류가 발생 `RmDir` 파일이 포함 된 디렉터리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2643">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="620ed-2644">사용 된 `Kill` 디렉터리를 제거 하기 전에 모든 파일을 삭제 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2644">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2645">사용 하 여이 예제는 `RmDir` 함수 기존 디렉터리를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2645">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-2646">
            <paramref name="Path" /> is not specified or is empty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2646">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2647">Target directory contains files.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2647">Target directory contains files.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="620ed-2648">Directory does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2648">Directory does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2649">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2649">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2650">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2650">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="620ed-2651">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2651">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2652">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2652">Required.</span>
          </span>
          <span data-ttu-id="620ed-2653">An <see langword="Integer" /> that contains a valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2653">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2654">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2654">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2655">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2655">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="620ed-2656">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2656">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2657">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2657">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2658">`Seek` 1에서 2,147,483,647 사이의 값을 반환 합니다. (2 ^31-1).</span><span class="sxs-lookup"><span data-stu-id="620ed-2658">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="620ed-2659">다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2659">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="620ed-2660">모드</span><span class="sxs-lookup"><span data-stu-id="620ed-2660">Mode</span></span>|<span data-ttu-id="620ed-2661">반환 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2661">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="620ed-2662">읽거나 쓴 다음 레코드의 수</span><span class="sxs-lookup"><span data-stu-id="620ed-2662">Number of the next record read or written</span></span>|  
|<span data-ttu-id="620ed-2663">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="620ed-2663">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="620ed-2664">다음 작업이 발생 하는 바이트 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2664">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="620ed-2665">파일의 첫 번째 바이트 위치 1에 있고, 두 번째 바이트는 2, 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2665">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2666">사용 하 여이 예제는 `Seek` 함수는 현재 파일 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2666">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="620ed-2667">이 예에서는 가정 `TestFile` 구조체의 레코드를 포함 하는 파일은 `Record`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2667">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="620ed-2668">연 파일에 `Random` 모드 `Seek` 다음 레코드의 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2668">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="620ed-2669">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2669">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="620ed-2670">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2670">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="620ed-2671">사용 하 여이 예제는 `Seek` 함수 또는 파일에 쓰기 다음 읽기에 대 한 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2671">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="620ed-2672">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2672">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="620ed-2673">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2673">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2674">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2674">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2675">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2675">Required.</span>
          </span>
          <span data-ttu-id="620ed-2676">An <see langword="Integer" /> that contains a valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2676">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <param name="Position">
          <span data-ttu-id="620ed-2677">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2677">Required.</span>
          </span>
          <span data-ttu-id="620ed-2678">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2678">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2679">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2679">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2680">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2680">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="620ed-2681">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2681">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2682">`Seek` 1에서 2,147,483,647 사이의 값을 반환 합니다. (2 ^31-1).</span><span class="sxs-lookup"><span data-stu-id="620ed-2682">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="620ed-2683">다음은 각 파일 액세스 모드에 대 한 반환 값에 대 한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2683">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="620ed-2684">모드</span><span class="sxs-lookup"><span data-stu-id="620ed-2684">Mode</span></span>|<span data-ttu-id="620ed-2685">반환 값</span><span class="sxs-lookup"><span data-stu-id="620ed-2685">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="620ed-2686">읽거나 쓴 다음 레코드의 수</span><span class="sxs-lookup"><span data-stu-id="620ed-2686">Number of the next record read or written</span></span>|  
|<span data-ttu-id="620ed-2687">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="620ed-2687">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="620ed-2688">다음 작업이 발생 하는 바이트 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2688">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="620ed-2689">파일의 첫 번째 바이트 위치 1에 있고, 두 번째 바이트는 2, 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2689">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2690">사용 하 여이 예제는 `Seek` 함수는 현재 파일 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2690">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="620ed-2691">이 예에서는 가정 `TestFile` 구조체의 레코드를 포함 하는 파일은 `Record`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2691">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="620ed-2692">연 파일에 `Random` 모드 `Seek` 다음 레코드의 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2692">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="620ed-2693">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2693">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="620ed-2694">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2694">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="620ed-2695">사용 하 여이 예제는 `Seek` 함수 또는 파일에 쓰기 다음 읽기에 대 한 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2695">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="620ed-2696">이외의 모드에서 연 파일에 대 한 `Random` 모드 `Seek` 에서 다음 작업을 실시 바이트 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2696">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="620ed-2697">가정 `TestFile` 은 여러 줄의 텍스트를 포함 하는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2697">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2698">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2698">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="620ed-2699">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2699">Required.</span>
          </span>
          <span data-ttu-id="620ed-2700">
            <see langword="String" /> expression that specifies a file name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2700">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="620ed-2701">
            <c>PathName</c> can include directory or folder, and drive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2701">
              <c>PathName</c> can include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Attributes">
          <span data-ttu-id="620ed-2702">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2702">Required.</span>
          </span>
          <span data-ttu-id="620ed-2703">Constant or numeric expression, whose sum specifies file attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2703">Constant or numeric expression, whose sum specifies file attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2704">Sets attribute information for a file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2704">Sets attribute information for a file.</span>
          </span>
          <span data-ttu-id="620ed-2705">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2705">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span>
          </span>
          <span data-ttu-id="620ed-2706">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2706">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2707">열려 있는 파일의 특성을 설정 하려고 하면 런타임 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2707">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="620ed-2708">`Attributes` 인수 열거형 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2708">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="620ed-2709">값</span><span class="sxs-lookup"><span data-stu-id="620ed-2709">Value</span></span>|<span data-ttu-id="620ed-2710">상수</span><span class="sxs-lookup"><span data-stu-id="620ed-2710">Constant</span></span>|<span data-ttu-id="620ed-2711">설명</span><span class="sxs-lookup"><span data-stu-id="620ed-2711">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="620ed-2712">보통 (기본값)입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2712">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="620ed-2713">읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2713">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="620ed-2714">숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2714">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="620ed-2715">시스템 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2715">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="620ed-2716">볼륨 레이블</span><span class="sxs-lookup"><span data-stu-id="620ed-2716">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="620ed-2717">디렉터리 또는 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2717">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="620ed-2718">파일은 마지막 백업 이후 변경 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2718">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="620ed-2719">파일 이름이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2719">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2720">이러한 열거형 Visual Basic 언어에 의해 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2720">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="620ed-2721">이름은 실제 값 대신 코드에서 아무 곳 이나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2721">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2722">사용 하 여이 예제는 `SetAttr` 파일의 특성을 설정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2722">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="620ed-2723">
            <paramref name="Attribute" /> type is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2723">
              <paramref name="Attribute" /> type is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">
          <span data-ttu-id="620ed-2724">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2724">Required.</span>
          </span>
          <span data-ttu-id="620ed-2725">The number of spaces to insert before displaying or printing the next expression in a list.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2725">The number of spaces to insert before displaying or printing the next expression in a list.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2726">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2726">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2727">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2727">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2728">경우 `Count` 출력 선 두께 다음 출력 위치를 즉시 인쇄 되는 공백 수 뒤에 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2728">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="620ed-2729">경우`Count` 출력 선 두께 보다 크면 `SPC` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2729">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="620ed-2730">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="620ed-2730">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="620ed-2731">예를 들어 현재 출력 위치 24 이면 출력 줄 너비는 80 이며, 지정한 `SPC(90)`, 다음 출력 34 (출력 위치를 현재 + 90/80의 나머지) 위치에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2731">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="620ed-2732">현재 출력 위치와 출력 선 두께 간에 차이가 있는 경우 보다 작은 `Count` (또는 `Count` `Mod` *너비*), `SPC` 다음 줄의 시작 부분에 건너뛰고 생성 함수 같은 공간 `Count` – (*너비* – *currentprintposition*).</span><span class="sxs-lookup"><span data-stu-id="620ed-2732">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2733">테이블 열이 와이드 문자를 허용 하도록 충분히 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2733">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2734">사용 하 여이 예제는 `SPC` 파일 및 출력의 위치는 함수는 **출력** 창.</span><span class="sxs-lookup"><span data-stu-id="620ed-2734">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2735">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2735">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2736">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2736">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2737">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2737">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2738">현재 줄에 현재 출력 위치 보다 큰 경우 `Column`, `TAB` 해당 하는 열 값으로 건너뜁니다 `Column` 다음 출력 줄.</span><span class="sxs-lookup"><span data-stu-id="620ed-2738">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="620ed-2739">경우 `Column` 1 보다 작으면 `TAB` 수식을 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2739">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="620ed-2740">경우 `Column` 출력 줄 너비 보다 큰 `TAB` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2740">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="620ed-2741">Mod 열 너비</span><span class="sxs-lookup"><span data-stu-id="620ed-2741">Column Mod width</span></span>  
  
 <span data-ttu-id="620ed-2742">예를 들어 경우 *너비* 80이 고 지정한 경우 `TAB(90)`, 다음 출력 열 (90/80의 나머지) 10에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2742">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="620ed-2743">경우 `Column` 현재 출력 위치 계산 된 출력 위치에 다음 줄에 출력이 시작 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2743">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="620ed-2744">계산 된 출력 위치 현재 출력 위치 보다 큰 경우의 계산 된 출력이 시작 출력 같은 줄에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2744">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="620ed-2745">출력 줄에서 맨 왼쪽 출력 위치는 항상 1입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2745">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="620ed-2746">사용 하는 경우는 `Print` 또는 `PrintLine` 파일을 인쇄 하는 함수의 가장 오른쪽 출력 위치를 사용 하 여 설정할 수 있는 출력 파일의 현재 너비는는 `FileWidth` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2746">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="620ed-2747">`TAB` 함수를 사용할 수도 있습니다는 `WriteLine` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2747">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="620ed-2748">함께 사용할 수 없습니다 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2748">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2749">테이블 열이 충분히 넓은 문자를 포함 하 고 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2749">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2750">사용 하 여이 예제는 `TAB` 파일 및 출력의 위치는 함수는 **출력** 창.</span><span class="sxs-lookup"><span data-stu-id="620ed-2750">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">
          <span data-ttu-id="620ed-2751">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2751">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2752">The column number moved to before displaying or printing the next expression in a list.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2752">The column number moved to before displaying or printing the next expression in a list.</span>
          </span>
          <span data-ttu-id="620ed-2753">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2753">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2754">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2754">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="620ed-2755">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2755">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2756">현재 줄에 현재 출력 위치 보다 크면 `Column`, `TAB` 해당 하는 열 값으로 건너뜁니다 `Column` 다음 출력 줄.</span><span class="sxs-lookup"><span data-stu-id="620ed-2756">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="620ed-2757">경우 `Column` 1 보다 작으면 `TAB` 수식을 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2757">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="620ed-2758">경우 `Column` 출력 선 두께 보다 크면 `TAB` 는 수식을 사용 하 여 다음 출력 위치를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2758">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="620ed-2759">Mod 열 너비</span><span class="sxs-lookup"><span data-stu-id="620ed-2759">Column Mod width</span></span>  
  
 <span data-ttu-id="620ed-2760">예를 들어 경우 *너비* 80이 고 지정한 경우 `TAB(90)`, 다음 출력 열 (90/80의 나머지) 10에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2760">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="620ed-2761">경우 `Column` 현재 출력 위치 계산 된 출력 위치에 다음 줄에 출력이 시작 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2761">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="620ed-2762">계산 된 출력 위치 현재 출력 위치 보다 큰 경우의 계산 된 출력이 시작 출력 같은 줄에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2762">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="620ed-2763">출력 줄에서 맨 왼쪽 출력 위치는 항상 1입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2763">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="620ed-2764">사용 하는 경우는 `Print` 또는 `PrintLine` 파일을 인쇄 하는 함수의 가장 오른쪽 출력 위치를 사용 하 여 설정할 수 있는 출력 파일의 현재 너비는는 `FileWidth` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2764">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="620ed-2765">`TAB` 함수를 사용할 수도 있습니다는 `WriteLine` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2765">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="620ed-2766">함께 사용할 수 없습니다 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2766">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="620ed-2767">테이블 열이 충분히 넓은 문자를 포함 하 고 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2767">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2768">사용 하 여이 예제는 `TAB` 파일 및 출력의 위치는 함수는 **출력** 창.</span><span class="sxs-lookup"><span data-stu-id="620ed-2768">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="620ed-2769">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2769">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2770">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2770">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2771">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2771">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2772">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2772">Required.</span>
          </span>
          <span data-ttu-id="620ed-2773">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2773">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2774">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2774">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2775">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2775">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2776">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2776">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2777">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2777">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="620ed-2778">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2778">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="620ed-2779">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2779">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="620ed-2780">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2780">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="620ed-2781">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2781">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="620ed-2782">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2782">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2783">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2783">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="620ed-2784">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2784">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2785">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2785">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2786">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2786">Required.</span>
          </span>
          <span data-ttu-id="620ed-2787">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2787">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="620ed-2788">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2788">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2789">Number of the only record or byte to lock or unlock</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2789">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2790">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2790">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2791">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2791">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2792">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2792">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2793">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2793">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="620ed-2794">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2794">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="620ed-2795">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2795">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="620ed-2796">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2796">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="620ed-2797">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2797">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="620ed-2798">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2798">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2799">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2799">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="620ed-2800">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2800">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2801">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2801">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2802">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2802">Required.</span>
          </span>
          <span data-ttu-id="620ed-2803">Any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2803">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="620ed-2804">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2804">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2805">Number of the first record or byte to lock or unlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2805">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="620ed-2806">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2806">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2807">Number of the last record or byte to lock or unlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2807">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2808">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2808">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="620ed-2809">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2809">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="620ed-2810">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2810">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2811">`Lock` 및 `Unlock` 함수 환경에서 사용 되는 여러 프로세스에서 동일한 파일에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2811">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="620ed-2812">`Lock` 및 `Unlock` 함수 쌍에서 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2812">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="620ed-2813">에 대 한 인수 `Lock` 및 `Unlock` 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2813">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="620ed-2814">경우 `Record`, 또는 `FromRecord` 및 `ToRecord` 는 제공 되지 않으면 전체 파일에 대 한 잠금 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2814">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="620ed-2815">경우 `Record` 만 지정 하면 단일 레코드를 잠그거나 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2815">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="620ed-2816">파일을 열어 순차적 입력 또는 출력으로 경우 `Lock` 및 `Unlock` 에 지정한 범위에 관계 없이 전체 파일에 영향을 `FromRecord` 및`ToRecord`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2816">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2817">이 예제에서는 사용 된 `Lock` 및 `Unlock` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2817">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="620ed-2818">이 예에서는 가정 하는 `People.txt` 구조체의 레코드를 포함 하는 파일은 `Person`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2818">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2819">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2819">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2820">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2820">Required.</span>
          </span>
          <span data-ttu-id="620ed-2821">An <see langword="Integer" /> expression that contains any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2821">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="620ed-2822">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2822">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2823">One or more comma-delimited expressions to write to a file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2823">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2824">Writes data to a sequential file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2824">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="620ed-2825">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2825">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2826">`Write` 및 `WriteLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2826">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2827">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2827">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2828">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2828">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2829">생략 하면 `Output`, 빈 줄은 파일에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2829">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="620ed-2830">여러 개의 식은 쉼표로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2830">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="620ed-2831">와 달리는 `Print` 함수는 `Write` 파일에 기록 된 대로 함수 항목 및 문자열 주위에 따옴표 사이 쉼표를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2831">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="620ed-2832">구분 기호 목록에 배치 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2832">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="620ed-2833">때 `Write` 숫자, 파일에 데이터를 쓰는 데 사용 되 `Boolean`, 날짜, null, 및 `Error` 데이터 형식이 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2833">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="620ed-2834">다음과 같은 유니버설 가정 하므로 데이터는 항상 읽을 수 있습니다 하 고 사용 하 여 올바르게 해석 뒤 `Input`로캘에 관계 없이:</span><span class="sxs-lookup"><span data-stu-id="620ed-2834">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="620ed-2835">숫자 데이터는 항상 소수 구분 기호로 마침표를 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2835">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="620ed-2836">에 대 한 `Boolean` 데이터를 `#TRUE#` 또는 `#FALSE#` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2836">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="620ed-2837">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2837">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="620ed-2838">날짜 데이터는 범용 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2838">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="620ed-2839">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2839">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="620ed-2840">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2840">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="620ed-2841">그러나 null 데이터에 대 한 `#NULL#` 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2841">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="620ed-2842">에 대 한 `Error` 데이터를 출력으로 표시 `#ERROR errorcode#`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2842">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="620ed-2843">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2843">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="620ed-2844">`WriteLine` 줄 바꿈 문자를 삽입 합니다 (즉, 캐리지 리턴/줄 바꿈 또는 `Chr(13) + Chr(10)`) 마지막 문자 입력 된 후, `Output` 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2844">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="620ed-2845">큰따옴표를 사용 하 여 문자열에 따옴표를 포함할 수 있습니다 또는 ""입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2845">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="620ed-2846">예를 들어 개체에 적용된</span><span class="sxs-lookup"><span data-stu-id="620ed-2846">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="620ed-2847">문자열의 값을 반환 `Double quotation marks aren't "difficult" to handle`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2847">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="620ed-2848">사용 하 여 파일에 쓰기는 `Write` 또는 `WriteLine` 함수 필요 `Append` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2848">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2849">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="620ed-2849">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2850">사용 하 여이 예제는 `Write` 함수를 원시 데이터는 순차적 파일을 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2850">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="620ed-2851">File mode is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2851">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="620ed-2852">Required.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2852">Required.</span>
          </span>
          <span data-ttu-id="620ed-2853">An <see langword="Integer" /> expression that contains any valid file number.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2853">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="620ed-2854">Optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2854">Optional.</span>
          </span>
          <span data-ttu-id="620ed-2855">One or more comma-delimited expressions to write to a file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2855">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="620ed-2856">Writes data to a sequential file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2856">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="620ed-2857">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="620ed-2857">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="620ed-2858">`Write` 및 `WriteLine` 함수는 이전 버전과 호환성을 위해 제공 되 고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2858">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="620ed-2859">이전 응용 프로그램의 경우는 `My.Computer.FileSystem` 개체 더 나은 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2859">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="620ed-2860">자세한 내용은 참조 [Visual Basic을 사용한 파일 액세스](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2860">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="620ed-2861">생략 하면 `Output`, 빈 줄은 파일에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2861">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="620ed-2862">여러 개의 식은 쉼표로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2862">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="620ed-2863">와 달리는 `Print` 함수는 `Write` 파일에 기록 된 대로 함수 항목 및 문자열 주위에 따옴표 사이 쉼표를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2863">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="620ed-2864">구분 기호 목록에 배치 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2864">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="620ed-2865">때 `Write` 숫자, 파일에 데이터를 쓰는 데 사용 되 `Boolean`, 날짜, null, 및 `Error` 데이터 형식이 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2865">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="620ed-2866">다음과 같은 유니버설 가정 하므로 데이터는 항상 읽을 수 있습니다 하 고 사용 하 여 올바르게 해석 뒤 `Input`로캘에 관계 없이:</span><span class="sxs-lookup"><span data-stu-id="620ed-2866">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="620ed-2867">숫자 데이터는 항상 소수 구분 기호로 마침표를 사용 하 여 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2867">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="620ed-2868">에 대 한 `Boolean` 데이터를 `#TRUE#` 또는 `#FALSE#` 인쇄 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2868">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="620ed-2869">`True` 및 `False` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2869">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="620ed-2870">날짜 데이터는 범용 날짜 형식을 사용 하 여 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2870">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="620ed-2871">날짜 또는 시간 구성 요소가 누락 이거나 0 부분만 제공 된 경우 파일에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2871">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="620ed-2872">있으면 파일에 쓰여지지 `Output` 데이터가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2872">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="620ed-2873">그러나 null 데이터에 대 한 `#NULL#` 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2873">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="620ed-2874">에 대 한 `Error` 데이터를 출력으로 표시 `#ERROR errorcode#`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2874">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="620ed-2875">`Error` 로캘에 관계 없이 키워드는 번역 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2875">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="620ed-2876">`WriteLine` 줄 바꿈 문자를 삽입 합니다 (즉, 캐리지 리턴/줄 바꿈 또는 `Chr(13) + Chr(10)`) 마지막 문자 입력 된 후, `Output` 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2876">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="620ed-2877">큰따옴표를 사용 하 여 문자열에 따옴표를 포함할 수 있습니다 또는 ""입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2877">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="620ed-2878">예를 들어 개체에 적용된</span><span class="sxs-lookup"><span data-stu-id="620ed-2878">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="620ed-2879">문자열의 값을 반환 `Double quotation marks aren't "difficult" to handle`합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2879">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="620ed-2880">사용 하 여 파일에 쓰기는 `Write` 또는 `WriteLine` 함수 필요 `Append` 에서 액세스는 `FileIOPermissionAccess` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2880">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="620ed-2881">자세한 내용은 <xref:System.Security.Permissions.FileIOPermissionAccess>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="620ed-2881">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="620ed-2882">사용 하 여이 예제는 `Write` 함수를 원시 데이터는 순차적 파일을 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="620ed-2882">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>