<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="066f5d18bb6954443ddf00f4507b470f32e1e4c6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36658808" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="Interaction" /> 모듈에는 개체, 응용 프로그램 및 시스템과 상호 작용하는 데 사용되는 프로시저가 포함되어 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 모듈은 Visual Basic 언어 키워드 및 다른 프로그램 실행, 메서드 또는 속성이 호출, 컴퓨터에서 경고음, 명령줄 문자열을 제공, COM 개체, 조작 및 대화 상자를 제어 하는 런타임 라이브러리 멤버를 지원 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `Shell` 사용자가 지정 된 응용 프로그램을 실행할 함수입니다. 지정 <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> 를 두 번째 인수는 응용 프로그램에서 보통 크기로 열리고의 포커스를 제공 합니다.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이미 실행 중인 응용 프로그램을 활성화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">이 프로세스에 할당되는 Win32 프로세스 ID 번호를 지정하는 <see langword="Integer" />입니다. <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />에서 반환된 ID가 0이 아닐 경우 이 ID를 사용할 수 있습니다.</param>
        <summary>이미 실행 중인 응용 프로그램을 활성화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하면 `AppActivate` 응용 프로그램의 활성 창에 포커스를 맞출입니다. 있습니다 수 하지 대 한 핸들 또는 활성 창에 대 한 참조 나, 심지어 알고 창을 지정한 순간에 활성화 됩니다. 이 경우 사용할 수 없습니다는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드.  
  
 `AppActivate` 함수 이름의 응용 프로그램이 또는 창으로 포커스를 변경 하지만 최대화 또는 최소화은 영향을 주지 않습니다. 사용자가을 포커스를 변경 하거나 창을 닫으면 일부 외의 다른 활성화 된 응용 프로그램 창을 포커스가 이동 합니다. 사용할 수는 `Shell` 창 스타일을 설정 및 응용 프로그램을 시작 하 게 작동 합니다.  
  
 사용 하는 경우는 `Title` 매개 변수를 `AppActivate` 대/소문자 구분 비교를 사용 하지만 그렇지 않은 경우 제목 표시줄의 내용으로 정확 하 게 일치 해야 합니다. 먼저 한 다음 자식 창을 최상위 창을 찾습니다. 일치 하는 항목을 찾을 수 없으면 throw는 <xref:System.ArgumentException>합니다.  
  
 사용할 수 있습니다 `AppActivate` 창을 소유 하는 프로세스에 대해서만 합니다. 대부분의 콘솔 응용 프로그램 목록에 나타나지 않는 의미를 처리 하는 windows를 소유 하지 않은 `AppActivate` 검색 합니다. 콘솔 응용 프로그램을 실행 하는 경우 시스템 응용 프로그램을 실행 하는 별도 프로세스를 생성 하 고 콘솔 프로세스에는 출력을 반환 합니다. 따라서, 현재 프로세스 ID를 요청 하는 경우 얻게 콘솔 응용 프로그램의 프로세스 id입니다. 대신이 프로세스의 프로세스 ID  
  
 런타임에 `AppActivate` 제목이 일치 하는 실행 중인 응용 프로그램을 활성화 하는 함수 `Title` 또는 일치 하는 프로세스 ID와 `ProcessId`합니다. 정확히 일치 하는 제목 문자열이로 끝나는 모든 응용 프로그램을 활성화 `Title`합니다. 명명 된 둘 이상의 응용 프로그램이 없는 경우 `Title`, `AppActivate` 하나를 활성화 하는 함수 임의로 선택 합니다.  
  
> [!NOTE]
>  `AppActivate` 함수 필요 `UIPermission` 에 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 수준 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다. 자세한 내용은 <xref:System.Security.Permissions.UIPermission>을 참조하십시오.  
  
   
  
## Examples  
 다양 한 용도 보여 주는이 예제는 `AppActivate` 함수를 응용 프로그램 창을 활성화 합니다. 이 예제에서는 throw 메모장 프로세스를 실행 하지 않는 경우는 <xref:System.ArgumentException>합니다. `Shell` 프로시저 응용 프로그램은 지정 된 경로 있는 것으로 가정 합니다.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">활성화할 응용 프로그램의 제목 표시줄에 표시되는 제목을 지정하는 <see langword="String" /> 식입니다. 응용 프로그램이 시작될 때 응용 프로그램에 할당된 제목을 사용할 수 있습니다.</param>
        <summary>이미 실행 중인 응용 프로그램을 활성화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하면 `AppActivate` 응용 프로그램의 활성 창에 포커스를 맞출입니다. 있습니다 수 하지 대 한 핸들 또는 활성 창에 대 한 참조 나, 심지어 알고 창을 지정한 순간에 활성화 됩니다. 이 경우 사용할 수 없습니다는 <xref:System.Windows.Forms.Control.Focus%2A> 메서드.  
  
 `AppActivate` 함수 이름의 응용 프로그램이 또는 창으로 포커스를 변경 하지만 최대화 또는 최소화은 영향을 주지 않습니다. 사용자가을 포커스를 변경 하거나 창을 닫으면 일부 외의 다른 활성화 된 응용 프로그램 창을 포커스가 이동 합니다. 사용할 수는 `Shell` 창 스타일을 설정 및 응용 프로그램을 시작 하 게 작동 합니다.  
  
 사용 하는 경우는 `Title` 매개 변수를 `AppActivate` 대/소문자 구분 비교를 사용 하지만 그렇지 않은 경우 제목 표시줄의 내용으로 정확 하 게 일치 해야 합니다. 먼저 한 다음 자식 창을 최상위 창을 찾습니다. 일치 하는 항목을 찾을 수 없으면 throw는 <xref:System.ArgumentException>합니다.  
  
 사용할 수 있습니다 `AppActivate` 창을 소유 하는 프로세스에 대해서만 합니다. 대부분의 콘솔 응용 프로그램 목록에 나타나지 않는 의미를 처리 하는 windows를 소유 하지 않은 `AppActivate` 검색 합니다. 콘솔 응용 프로그램을 실행 하는 경우 시스템 응용 프로그램을 실행 하는 별도 프로세스를 생성 하 고 콘솔 프로세스에는 출력을 반환 합니다. 따라서, 현재 프로세스 ID를 요청 하는 경우 얻게 콘솔 응용 프로그램의 프로세스 id입니다. 대신이 프로세스의 프로세스 ID  
  
 런타임에 `AppActivate` 제목이 일치 하는 실행 중인 응용 프로그램을 활성화 하는 함수 `Title` 또는 일치 하는 프로세스 ID와 `ProcessId`합니다. 정확히 일치 하는 제목 문자열이로 끝나는 모든 응용 프로그램을 활성화 `Title`합니다. 명명 된 둘 이상의 응용 프로그램이 없는 경우 `Title`, `AppActivate` 하나를 활성화 하는 함수 임의로 선택 합니다.  
  
> [!NOTE]
>  `AppActivate` 함수 필요 `UIPermission` 에 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 수준 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다. 자세한 내용은 <xref:System.Security.Permissions.UIPermission>을 참조하십시오.  
  
   
  
## Examples  
 다양 한 용도 보여 주는이 예제는 `AppActivate` 함수를 응용 프로그램 창을 활성화 합니다. 이 예제에서는 throw 메모장 프로세스를 실행 하지 않는 경우는 <xref:System.ArgumentException>합니다. `Shell` 프로시저 응용 프로그램은 지정 된 경로 있는 것으로 가정 합니다.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컴퓨터 스피커를 통해 소리를 냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 피치 및 경고음의 지속 하드웨어 및 시스템 소프트웨어에 따라 다르며 컴퓨터입니다.  
  
> [!NOTE]
>  `Beep` 함수 필요 `UIPermission` 에 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 수준 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다. 자세한 내용은 <xref:System.Security.Permissions.UIPermission>을 참조하세요.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Beep` 함수를 통해 컴퓨터의 스피커 소리를 냅니다.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">필수. <see langword="Object" />. 형식이며 속성이나 메서드를 노출하는 개체에 대한 포인터입니다.</param>
        <param name="ProcName">필수. <see langword="String" />. 형식이며 개체의 속성이나 메서드 이름이 포함된 문자열 식입니다.</param>
        <param name="UseCallType">필수. 호출되는 프로시저 형식을 나타내는 <see cref="T:Microsoft.VisualBasic.CallType" /> 형식의 열거형 멤버입니다. <see langword="CallType" /> 값은 <see langword="Method" />, <see langword="Get" /> 또는 <see langword="Set" />이 될 수 있습니다.</param>
        <param name="Args">선택 사항입니다. <see langword="ParamArray" />. 형식이며 호출되는 속성이나 메서드에 전달될 인수가 포함된 매개 변수 배열입니다.</param>
        <summary>개체의 메서드를 실행하거나 개체의 속성을 설정 또는 반환합니다.</summary>
        <returns>개체의 메서드를 실행하거나 개체의 속성을 설정 또는 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CallByName` 함수는 런타임 시 속성 가져오기, 속성을 설정 하거나 메서드를 호출 하는 데 사용 됩니다.  
  
   
  
## Examples  
 첫 번째 줄은 다음 예에서 사용 하 여 `CallByName` 설정 하는 `Text` 입력란의 속성을 두 번째 줄의 값을 검색 하는 `Text` 속성 및 세 번째 줄에서 호출는 `Move` 입력란을 이동 하는 메서드.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 사용 하 여 다음 예제는 `CallByName` 함수를 호출 하는 `Add` 및 `Item` 컬렉션 개체의 메서드.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="UseCallType" /> 값이 잘못되었습니다. <see langword="Method" />, <see langword="Get" /> 또는 <see langword="Set" />이어야 합니다.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">필수. <see langword="Double" />. 1과 <c>Choice</c> 인수에 전달된 요소 수 사이의 값을 반환하는 숫자 식입니다.</param>
        <param name="Choice">필수. <see langword="Object" /> 매개 변수 배열입니다. <see langword="Object" /> 데이터 형식, 쉼표로 구분된 <see langword="Object" /> 변수나 식의 목록 또는 <see langword="Object" /> 요소의 1차원 배열로 계산되는 단일 변수나 식을 사용할 수 있습니다.</param>
        <summary>인수 목록에서 값을 선택하고 반환합니다.</summary>
        <returns>인수 목록에서 값을 선택하고 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Choose` 함수에 전달 된 목록의 구성원을 반환 `Choice()`의 값에 따라 `Index`합니다. 목록의 첫 번째 멤버를 선택할 때 `Index` 는 1입니다. 목록의 마지막 멤버를 선택할 때 `Index` 은 `UBound`(`Choice()`). 경우 `Index` 이 범위를 벗어나면은 `Choose` 반환 `Nothing`합니다.  
  
 경우 `Index` 전체 숫자가 아니거나 계산 되기 전에 가장 가까운 정수로 반올림 됩니다.  
  
 사용할 수 있습니다 `Choose` 가능한 항목 목록에서 값을 조회 하 합니다.  
  
> [!NOTE]
>  인수 목록의 식은 함수 호출을 포함할 수 있습니다. 인수 목록에 대 한 호출에 대 한 준비의 일부로 `Choose`, Visual Basic 컴파일러는 모든 식에서 모든 함수를 호출 합니다. 즉, 다른 식의 선택 하 여 호출 되지 않는 특정 함수를 사용할 수 없게 `Index`합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Choose` 프로시저에 전달 되는 인덱스에 대 한 응답에는 이름을 표시 하는 함수는 `Ind` 매개 변수입니다.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Visual Basic으로 작성한 실행 가능한 프로그램 또는 Visual Basic을 시작하는 데 사용되는 명령줄의 인수 부분을 반환합니다. <see langword="My" /> 기능을 사용하면 <see langword="Command" /> 함수보다 생산성 및 성능이 향상됩니다. 자세한 내용은 <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />을 참조하세요.</summary>
        <returns>Visual Basic으로 작성한 실행 가능한 프로그램 또는 Visual Basic을 시작하는 데 사용되는 명령줄의 인수 부분을 반환합니다.  <see langword="My" /> 기능을 사용하면 <see langword="Command" /> 함수보다 생산성 및 성능이 향상됩니다. 자세한 내용은 <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인수를 반환한 후에 공백, 슬래시나, 하이픈 또는 개별 매개 변수에 대 한 문자열을 검색 하거나 인용 부호와 같은 일반 구분 기호에 대 한 검색할 수 있습니다.  
  
 Visual Basic로 개발 및.exe 파일로 컴파일된 응용 프로그램에 대 한는 `Command` 함수 반환이 양식에서 명령줄에 응용 프로그램의 이름 다음에 표시 되는 인수: `MyApp(cmdlineargs)`합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `Command` 함수 배열을 포함 하는 개체에 명령줄 인수를 반환 합니다.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">필수. <see langword="String" />. 만들 개체의 프로그램 ID입니다.</param>
        <param name="ServerName">선택 사항입니다. <see langword="String" />. 개체가 만들어질 네트워크 서버의 이름입니다. <c>ServerName</c>이 빈 문자열("")이면 로컬 컴퓨터가 사용됩니다.</param>
        <summary>COM 개체를 만들고 만든 개체에 대한 참조를 반환합니다. 클래스가 명시적으로 COM 구성 요소로 노출되지 않는 경우 Visual Basic에서 <see langword="CreateObject" />를 사용하여 해당 클래스의 인스턴스를 만들 수 없습니다.</summary>
        <returns>COM 개체를 만들고 만든 개체에 대한 참조를 반환합니다. 클래스가 명시적으로 COM 구성 요소로 노출되지 않는 경우 Visual Basic에서 <see langword="CreateObject" />를 사용하여 해당 클래스의 인스턴스를 만들 수 없습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM 구성 요소의 인스턴스를 만들려면 반환 되는 개체를 할당 `CreateObject` 개체 변수에:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 개체 변수를 사용 하면 반환된 된 개체를 저장할 응용 프로그램의 성능에 영향을 줄 수 있습니다. 사용 하는 개체 변수 선언에서 `As Object` 절 모든 종류의 개체에 대 한 참조를 포함할 수 있는 변수를 만듭니다. 그러나 해당 변수를 통해 개체에 대 한 액세스는 *런타임에 바인딩된*, 즉, 바인딩이 발생 프로그램이 실행 되 면입니다. 런타임에 바인딩, 응용 프로그램 성능 저하를 포함 하지 않아야 하는 여러 가지 이유가 있습니다.  
  
 초기 바인딩 발생 하는 개체 변수를 만들 수 있습니다-즉, 프로그램 컴파일될 때 바인딩. 개체에 대 한 형식 라이브러리에 대 한 참조를 추가 **COM** 탭은 **참조 추가** 대화 상자에는 **프로젝트** 메뉴. 개체의 특정 유형의 개체 변수를 선언 합니다. 대부분의 경우에서 것이 더 효율적 사용 하는 `Dim` 문과를 사용 하는 것 보다 개체를 만들려면 주 interop 어셈블리는 `CreateObject` 함수입니다.  
  
## <a name="interacting-with-unmanaged-code"></a>비관리 코드와의 상호 작용  
 또 다른 문제는 COM 개체 비관리 코드를 사용-공용 언어 런타임 활용 하지 않고 코드입니다. COM에서 비관리 코드와 관리 되는 Visual Basic 코드를 혼합 하는에 참여는 상당수의 복잡성 COM 개체, 해당 라이브러리;에 대 한 주 interop 어셈블리 (PIA)에 대 한 Visual Basic 검색에 대 한 참조를 추가 하는 경우 를 찾은 다음 해당 사용 합니다. PIA를 찾지 못하면 COM 라이브러리의 각 클래스에 대 한 로컬 상호 운용성 클래스를 포함 하는 상호 운용성 어셈블리를 만듭니다 것입니다. 자세한 내용은 참조 [.NET Framework 응용 프로그램의 COM 상호 운용성](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md)합니다.  
  
 일반적으로 강력 하 게 바인딩된 개체와 가능 하면 주 interop 어셈블리 사용 해야 합니다. 사용 하 여 아래 예제는 `CreateObject` 함수 데모에 대 한 Microsoft Office 개체와의 목적 으로만 사용 합니다. 그러나 이러한 개체는 사용 하기 쉽고 적절 한 주 interop 어셈블리와 함께 사용할 경우 신뢰할 수 있는 합니다.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>원격 컴퓨터에서 개체를 만들려면  
 컴퓨터의 이름을 전달 하 여 원격 네트워크에 연결 된 컴퓨터에서 개체를 만들 수는 `ServerName` 의 인수는 `CreateObject` 함수입니다. 해당 이름은 컴퓨터 이름 부분 공유 이름의 동일: 공유 이름의 "\\\MyServer\Public," `ServerName` "MyServer"는  
  
> [!NOTE]
>  COM 설명서를 참조 (Microsoft Developer Network 참조) 응용 프로그램 네트워크에 연결 된 원격 컴퓨터에서 액세스할 수 있도록 대 한 자세한 내용은 합니다. 응용 프로그램에 대 한 레지스트리 키를 추가 해야 합니다.  
  
 다음 코드 라는 원격 컴퓨터에서 실행 중인 인스턴스의 Excel의 버전 번호 반환 `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 원격 서버 이름이 올바른지 또는 사용할 수 없는 경우 런타임 오류가 발생 합니다.  
  
> [!NOTE]
>  사용 하 여 `CreateObject` 개체의 현재 인스턴스가 없습니다. 개체의 인스턴스가 이미 실행 중인 경우 새 인스턴스를 시작 하 고 지정 된 형식의 개체가 만들어집니다. 현재 인스턴스를 사용 하거나 응용 프로그램을 시작 하 고 파일을 로드 하려면 사용 된 `GetObject` 함수입니다. 개체를 단일 인스턴스 개체로 등록 된을 경우 개체의 인스턴스가 하나만 만들어지면 관계 없이 여러 번 `CreateObject` 실행 됩니다.  
  
## <a name="creating-framework-objects"></a>프레임 워크 개체 만들기  
 사용할 수는 `CreateObject` COM 개체를 만들 때에 함수입니다. .NET Framework 개체를 만들기 위한 정확한 없는 해당 메커니즘은는 <xref:System.Activator> 에서 <xref:System> 네임 스페이스는 로컬 또는 원격 개체를 만드는 메서드를 포함 합니다. 특히는 <xref:System.Activator.CreateInstance%2A> 메서드 또는 <xref:System.Activator.CreateInstanceFrom%2A> 메서드가 유용할 수 있습니다.  
  
> [!IMPORTANT]
>  `CreateObject` 함수 비관리 코드 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
   
  
## Examples  
 다음 예제에서는 `CreateObject` 함수를 Microsoft Excel 워크시트를 만들고 파일에 워크시트를 저장 합니다. 이 예제를 사용 하려면이 프로그램 실행 되는 컴퓨터에 Excel이 설치 해야 합니다. 형식 라이브러리에 대 한 참조를 추가 해야 또한는 **COM** 탭은 **참조 추가** 대화 상자에는 **프로젝트** 메뉴. 형식 라이브러리의 이름은 사용자의 컴퓨터에 Excel이 설치의 버전에 따라 달라 집니다. 예를 들어 Microsoft Excel 2002에 대 한 형식 라이브러리 라는 **Microsoft Excel 10.0 개체 라이브러리**합니다.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">서버를 사용할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">지정된 형식의 개체가 없습니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">필수. 섹션 또는 키 설정이 적용되는 응용 프로그램이나 프로젝트의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Section">필수. 키 설정을 삭제할 섹션의 이름을 포함하는 <see langword="String" /> 식입니다. <c>AppName</c>과 <c>Section</c>만 제공할 경우 모든 관련 키 설정과 함께 지정한 섹션이 삭제됩니다.</param>
        <param name="Key">선택 사항입니다. 삭제할 키 설정의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <summary>Windows 레지스트리에 있는 응용 프로그램 엔트리에서 섹션 설정 또는 키 설정을 삭제합니다. <see langword="My" /> 기능을 사용하면 <see langword="DeleteSetting" /> 함수보다 레지스트리 작업의 생산성 및 성능이 향상됩니다. 자세한 내용은 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />을 참조하십시오.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 인수를 제공 하는 경우 지정 된 설정이 삭제 됩니다. 런타임 오류가 발생 하는 사용 하려는 경우 `DeleteSetting` 키 설정 또는 존재 하지 않는 섹션입니다.  
  
 `DeleteSetting` 아래에서 작동 하기 때문에 사용자 로그온 할 필요는 `HKEY_LOCAL_USER` 사용자가 대화형으로 로그온 할 때까지 비활성화 되어 있는 레지스트리 키입니다.  
  
 아래는 비 대화형 프로세스 (예: Mtx.exe)에서 액세스 하는 레지스트리 설정에 저장 해야는 `HKEY_LOCAL_MACHINE\Software\` 또는 `HKEY_USER\DEFAULT\Software` 레지스트리 키입니다.  
  
   
  
## Examples  
 다음 예에서는 먼저 사용 하 여는 `SaveSetting` 절차에 대 한 Windows 레지스트리에 항목에는 `MyApp` 응용 프로그램을 한 다음 사용 하는 `DeleteSetting` 제거 하는 함수입니다. 때문에 없는 `Key` 인수를 지정 하면 전체 `Startup` 섹션이 섹션 이름 및 모든 해당 키를 포함 하 여 삭제 됩니다.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">사용자가 로그인하지 않았습니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>운영 체제 환경 변수와 연결된 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">필수. 환경 변수의 이름이 포함된 문자열이나 환경 문자열 테이블에 있는 환경 문자열의 순서에 해당하는 정수를 계산하는 식입니다.</param>
        <summary>운영 체제 환경 변수와 연결된 문자열을 반환합니다.</summary>
        <returns>운영 체제 환경 변수와 연결된 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `Expression` 는 문자열이 포함 된는 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 함수는 지정 된 환경 문자열에 할당 된 텍스트를 반환 합니다.-즉, 해당 환경 변수에 대 한 환경 문자열 테이블에 등호 (=) 다음 텍스트입니다. 경우에 문자열 `Expression` 길이가 0 인 문자열 환경 문자열 테이블에서 찾을 수 없습니다 ("")이 반환 됩니다.  
  
 경우 `Expression` 환경 문자열 테이블에서 위치에 숫자 반환 되는 문자열이 정수를 포함 합니다. 이 경우 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 모든 환경 변수 이름을 포함 하 여 텍스트를 반환 합니다. 지정된 된 위치에서 환경 문자열이 없는 경우 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 길이가 0 인 문자열을 반환 합니다.  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 함수 환경 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 항목 번호와 길이를 제공 하는 함수는 `PATH` 환경 문자열 테이블에서 문의 합니다.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" />이 없습니다.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">필수. 환경 변수의 이름이 포함된 문자열이나 환경 문자열 테이블에 있는 환경 문자열의 순서에 해당하는 정수를 계산하는 식입니다.</param>
        <summary>운영 체제 환경 변수와 연결된 문자열을 반환합니다.</summary>
        <returns>운영 체제 환경 변수와 연결된 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `Expression` 는 문자열이 포함 된는 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 함수는 지정 된 환경 문자열에 할당 된 텍스트를 반환 합니다.-즉, 해당 환경 변수에 대 한 환경 문자열 테이블에 등호 (=) 다음 텍스트입니다. 경우에 문자열 `Expression` 길이가 0 인 문자열 환경 문자열 테이블에서 찾을 수 없습니다 ("")이 반환 됩니다.  
  
 경우 `Expression` 환경 문자열 테이블에서 위치에 숫자 반환 되는 문자열이 정수를 포함 합니다. 이 경우 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 모든 환경 변수 이름을 포함 하 여 텍스트를 반환 합니다. 지정된 된 위치에서 환경 문자열이 없는 경우 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 길이가 0 인 문자열을 반환 합니다.  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 함수 환경 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 항목 번호와 길이를 제공 하는 함수는 `PATH` 환경 문자열 테이블에서 문의 합니다.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" />이 없습니다.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">필수. 키 설정이 요청된 응용 프로그램이나 프로젝트의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Section">필수. 키 설정이 요청된 섹션의 이름을 포함하는 <see langword="String" /> 식입니다. <see langword="GetAllSettings" />는 2차원 문자열 배열을 포함하는 개체를 반환합니다. 이 문자열은 지정한 섹션의 모든 키 설정과 이 설정에 해당하는 값을 포함합니다.</param>
        <summary>Windows 레지스트리에 있는 응용 프로그램 엔트리에서 키 설정 및 해당 값(원래 <see langword="SaveSetting" />으로 만든 값)의 목록을 반환합니다. <see langword="My" /> 기능을 사용하면 <see langword="GetAllSettings" /> 함수보다 레지스트리 작업의 생산성 및 성능이 향상됩니다. 자세한 내용은 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />을 참조하세요.</summary>
        <returns>Windows 레지스트리에 있는 응용 프로그램 엔트리에서 키 설정 및 해당 값(원래 <see langword="SaveSetting" />으로 만든 값)의 목록을 반환합니다.  <see langword="My" /> 기능을 사용하면 <see langword="GetAllSettings" /> 함수보다 레지스트리 작업의 생산성 및 성능이 향상됩니다. 자세한 내용은 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` 초기화 되지 않은 반환 `Object` 경우 `AppName` 또는 `Section` 존재 하지 않습니다.  
  
 아래에서 작동 하기 때문에 `HKEY_LOCAL_USER` 활성화 되는 사용자가 대화형으로 로그온 할 때까지, 레지스트리 키 `GetAllSettings` 사용자 로그온 수 있어야 합니다.  
  
 아래는 비 대화형 프로세스 (예: Mtx.exe)에서 액세스 하는 레지스트리 설정에 저장 해야는 `HKEY_LOCAL_MACHINE\Software\` 또는 `HKEY_USER\DEFAULT\Software` 레지스트리 키입니다.  
  
   
  
## Examples  
 이 예에서는 먼저 사용 하 여는 `SaveSetting` 항목으로 지정 된 응용 프로그램에 대 한 Windows 레지스트리에서 해당 함수가 `AppName`, 사용 하 여는 `GetAllSettings` 함수 설정을 표시 합니다. 해당 응용 프로그램 참고 이름 및 `Section` 와 이름을 검색할 수 없습니다 `GetAllSettings`합니다. 마지막으로 `DeleteSetting` 함수 응용 프로그램의 엔트리를 제거 합니다.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">사용자가 로그인하지 않았습니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">선택 사항입니다. <see langword="String" />. 검색할 개체를 포함하는 파일의 전체 경로와 이름입니다. <c>PathName</c>이 생략된 경우 <c>Class</c>가 필요합니다.</param>
        <param name="Class">
          <c>PathName</c>이 제공되지 않을 경우 필요합니다. <see langword="String" />. 개체의 클래스를 나타내는 문자열입니다. <c>Class</c> 인수의 구문과 구성 요소는 다음과 같습니다. <c>appname</c><c>.</c><c>objecttype</c>  [1|1] 매개 변수  [1|2] 설명  [2|1] <c>appname</c>  [2|2] 필수적 요소. <see langword="String" />. 개체를 제공하는 응용 프로그램의 이름입니다.  [3|1] <c>objecttype</c>  [3|2] 필수적 요소. <see langword="String" />. 만들 개체의 형식이나 클래스입니다.</param>
        <summary>COM 구성 요소에 의해 제공된 개체에 대한 참조를 반환합니다.</summary>
        <returns>COM 구성 요소에 의해 제공된 개체에 대한 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 `GetObject` 파일에서 COM 구성 요소의 인스턴스를 로드 하는 함수입니다. 다음은 이에 대한 예입니다.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 이 코드를 실행할 때 지정 된 관련 응용 프로그램 `PathName` 시작 되는 개체가 지정한 파일에 활성화 됩니다.  
  
## <a name="default-cases"></a>기본 사례가  
 경우 `PathName` 은 빈 문자열 (`""`), `GetObject` 지정 된 클래스 형식의 새 개체 인스턴스를 반환 합니다. 경우는 `PathName` 인수를 생략 하면 `GetObject` 에 지정 된 클래스 형식의 현재 활성 개체를 반환 `Class`합니다. 지정 된 형식의 개체가 없는 경우 오류가 발생 합니다.  
  
## <a name="accessing-a-subobject"></a>하위 개체 액세스  
 일부 응용 프로그램 파일과 관련 된 하위 개체의 인증을 허용 합니다. 이 위해 느낌표 (`!`) 파일 이름 및 다음의 끝에 사용 하 여 파일의 부분을 식별 하는 문자열 활성화 하려는 합니다. 이 문자열을 만드는 방법에 대 한 자세한 내용은 개체를 만든 응용 프로그램에 대 한 설명서를 참조 하십시오.  
  
 예를 들어 그리기 응용 프로그램에서 파일에 저장 된 그림에 여러 계층이 있는 될 수 있습니다. 라는 레이어를 활성화 하려면 다음 코드를 사용할 수 있습니다 `schema.cad`합니다.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>클래스를 지정  
 개체의 지정 하지 않으면 `Class`를 자동화 하거나 응용 프로그램 시작 개체를 활성화 하려면 제공 된 파일 이름에 따라 결정 합니다. 그러나 일부 파일 개체의 클래스를 여러 개 지원할 수 있습니다. 예를 들어 드로잉 세 가지 유형의 개체를 지원할 수 있습니다:는 `Application` 개체는 `Drawing` 개체 및 `Toolbar` 개체는 모두 동일한 파일에 포함 합니다. 활성화 하려는 파일에 있는 개체를 지정 하려면 사용 하 여 선택적 `Class` 인수입니다. 다음은 이에 대한 예입니다.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 앞의 예제에서 `Figment` 그리기 응용 프로그램의 이름 및 `Drawing` 지 원하는 개체 형식 중 하나입니다.  
  
## <a name="using-the-object"></a>개체를 사용 하 여  
 개체가 활성화 되 면 참조 선언 된 개체 변수를 사용 하 여 코드에서. 개체 변수를 사용 하 여 새 개체의 속성 및 메서드에 액세스 앞의 예제에서 `drawObj`합니다. 다음은 이에 대한 예입니다.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  사용 된 `GetObject` 로드 된 파일로 개체를 만들려는 경우 나 개체의 현재 인스턴스가 있을 때 작동 합니다. 현재 인스턴스가 없음, 시작 개체 하지 않을 경우 파일 로드를 <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> 함수입니다.  
>   
>  개체는 ActiveX 단일 인스턴스 개체로 등록 된을 경우 개체의 인스턴스가 하나만 만들어지면 관계 없이 여러 번 `CreateObject` 호출 됩니다. 단일 인스턴스 개체와 `GetObject` 항상 길이가 0 인 문자열을 사용 하 여 호출 하는 경우 동일한 인스턴스를 반환 합니다 (`""`) 구문에서 오류가 발생 된 `PathName` 인수를 생략 하면 합니다. 사용할 수 없습니다 `GetObject` Visual Basic을 사용 하 여 만든 클래스에 대 한 참조를 얻으려고 합니다.  
  
> [!IMPORTANT]
>  `GetObject` 함수 비관리 코드 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
   
  
## Examples  
 다음 예제에서는 `GetObject` 함수 특정 Microsoft Excel 워크시트에 대 한 참조입니다. (`excelObj`). 워크시트의 사용 하 여 `Application` 볼 수 있도록 하려면 Excel을 닫고 하 고 다른 작업을 수행 하는 속성입니다. 두 개의 API 호출을 사용 하 여 `detectExcel` 프로시저 Excel을 찾아서 실행 되는 경우 실행 개체 테이블에 입력 합니다. 첫 번째 호출 `GetObject` Excel 아직 실행 하지 않은,이 예제에서 오류가 발생 하면는 `excelWasNotRunning` 플래그를 설정할 수 `True`합니다. 두 번째 호출으로 `GetObject` 열려는 파일을 지정 합니다. 두 번째 호출 시작 하 고 지정된 된 파일을 나타내는 워크시트에 대 한 참조를 반환 합니다. Excel 아직 실행 하지 않은 경우 `test.xls`합니다. 파일이; 지정된 된 위치에 있어야 합니다. 그렇지 않으면 Visual Basic throw 한 <xref:System.IO.FileNotFoundException>합니다. 다음으로, 예제 코드 하면 Excel과 지정된 된 워크시트가 포함 된 창이 모두 있습니다.  
  
 이 예제에서는 `Option Strict Off` 런타임에 바인딩을 사용 하기 때문에 여기서 개체에 할당 된 형식의 변수에 `Object`합니다. 지정할 수 있습니다 `Option Strict On` 에서 Excel 형식 라이브러리에 대 한 참조를 추가 하는 경우에 특정 개체 유형의 개체를 선언 하 고는 **COM** 탭은 **참조 추가** 의 대화 상자는 ** 프로젝트** Visual Studio에서 메뉴.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 호출 하는 경우는 `getExcel` 함수 검사가 수행 되는 Excel 이미 실행 되 고 있는지를 합니다. 그렇지 않은 경우 인스턴스가 만들어집니다.  
  
> [!IMPORTANT]
>  간단히 하기 위해 앞의 예제에서는 모든 창에 호출 되도록 가정 `XLMAIN` Microsoft Excel의 인스턴스에 속합니다. 불법 변조으로 된 다른 개체를 해당 이름으로 창을 만든 Excel에 대 한 대상으로 하는 모든 메시지가 받게 됩니다. 좀 더 엄격한 테스트 되었는지 확인 하려면 포함 해야 프로덕션에 사용할 응용 프로그램에서는 `XLMAIN` 실제로 Excel에 속하는지 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">지정한 클래스 형식의 개체가 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">지정한 경로와 파일 이름의 개체가 없습니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">필수. 키 설정이 요청된 응용 프로그램이나 프로젝트의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Section">필수. 키 설정이 있는 섹션의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Key">필수. 반환할 키 설정의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Default">선택 사항입니다. <c>키</c> 설정에 값이 설정되어 있지 않을 경우에 반환할 값을 포함하고 있는 식입니다. 생략할 경우 <c>Default</c>는 길이가 0인 문자열("")로 간주됩니다.</param>
        <summary>Windows 레지스트리에 있는 응용 프로그램 엔트리에서 키 설정 값을 반환합니다. <see langword="My" /> 기능을 사용하면 <see langword="GetAllSettings" />보다 레지스트리 작업의 생산성 및 성능이 향상됩니다. 자세한 내용은 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />을 참조하세요.</summary>
        <returns>Windows 레지스트리에 있는 응용 프로그램 엔트리에서 키 설정 값을 반환합니다.  <see langword="My" /> 기능을 사용하면 <see langword="GetAllSettings" />보다 레지스트리 작업의 생산성 및 성능이 향상됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 명명 된 항목 중 하나는 `GetSetting` 인수가 존재 하지 않는 `GetSetting` 의 값을 반환 `Default`합니다.  
  
 아래에서 작동 하기 때문에 `HKEY_LOCAL_USER` 활성화 되는 사용자가 대화형으로 로그온 할 때까지, 레지스트리 키 `GetSetting` 사용자 로그온 수 있어야 합니다.  
  
 아래는 비 대화형 프로세스 (예: Mtx.exe)에서 액세스 하는 레지스트리 설정에 저장 해야는 `HKEY_LOCAL_MACHINE\Software\` 또는 `HKEY_USER\DEFAULT\Software` 레지스트리 키입니다.  
  
 `GetSetting` 필요한 `Read` <xref:System.Security.Permissions.RegistryPermission> 합니다.  
  
   
  
## Examples  
 이 예에서는 먼저 사용 하 여는 `SaveSetting` 항목으로 지정 된 응용 프로그램에 대 한 Windows 레지스트리에서 해당 함수가 `AppName`, 다음 사용 하 여는 `GetSetting` 설정 중 하나를 표시 하는 함수입니다. 때문에 `Default` 인수를 지정한 경우 반드시 일부 값이 반환 됩니다. 다음에 유의 `Section` 와 이름을 검색할 수 없습니다 `GetSetting`합니다. 마지막으로 `DeleteSetting` 함수 응용 프로그램의 모든 항목을 제거 합니다.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">하나 이상의 인수가 <see langword="String" /> 식이 아니거나 사용자가 로그인하지 않았습니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">필수. <see langword="Boolean" />. 계산할 식입니다.</param>
        <param name="TruePart">필수. <see langword="Object" />. <c>식</c>이 <see langword="True" />로 평가되는 경우 반환됩니다.</param>
        <param name="FalsePart">필수. <see langword="Object" />. <c>식</c>이 <see langword="False" />로 평가되는 경우 반환됩니다.</param>
        <summary>식을 계산한 결과에 따라 두 개의 개체 중에서 하나를 반환합니다.</summary>
        <returns>식을 계산한 결과에 따라 두 개의 개체 중에서 하나를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IIf` 의 삼항 해당 하는 도구를 제공 하는 함수 [조건부 연산자:?:](http://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) Visual c + +에서입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `IIf` 평가 하는 함수는 `testMe` 의 매개 변수는 `checkIt` 절차 및 반환 단어 "대형" 경우에는 크기 보다 크면 1000 않으면 그렇지 않으면 반환 단어 "작음"입니다.  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 되는 경우 `Option Strict` 은 `On`를 사용 해야 합니다는 `CStr` 에서 반환 된 값을 명시적으로 변환 하는 키워드 `Object` 를 `String`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">필수적 요소입니다. 대화 상자에서 메시지로 표시되는 <see langword="String" /> 식입니다. <c>프롬프트</c>의 최대 길이는 대략 1024자이며 사용되는 문자의 너비에 따라 달라집니다. <c>프롬프트</c>가 두 줄 이상으로 구성되는 경우 캐리지 리턴 문자(<see langword="Chr(" />13<see langword=")" />), 줄 바꿈 문자(<see langword="Chr(" />10<see langword=")" />) 또는 각 줄 사이에 캐리지 리턴/줄 바꿈 조합(<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />)을 사용하여 줄을 구분할 수 있습니다.</param>
        <param name="Title">선택 사항입니다. 대화 상자의 제목 표시줄에 표시되는 <see langword="String" /> 식입니다. <c>Title</c>을 생략하면 응용 프로그램 이름이 제목 표시줄에 나타납니다.</param>
        <param name="DefaultResponse">선택 사항입니다. 입력한 내용이 없는 경우 텍스트 상자에 기본적으로 표시되는 <see langword="String" /> 식입니다. <c>DefaultResponse</c>를 생략하면 텍스트 상자가 빈 상태로 표시됩니다.</param>
        <param name="XPos">선택 사항입니다. 화면 왼쪽 가장자리에서 대화 상자의 왼쪽 가장자리까지의 간격을 트윕 단위로 지정하는 숫자 식입니다. <c>XPos</c>를 생략하면 대화 상자는 화면 가운데에 가로 방향으로 배치됩니다.</param>
        <param name="YPos">선택 사항입니다. 화면 맨 위에서 대화 상자의 위쪽 가장자리까지의 간격을 트윕 단위로 지정하는 숫자 식입니다. <c>YPos</c>를 생략하면 대화 상자는 화면 아래 방향으로 1/3 지점에 세로 방향으로 배치됩니다.</param>
        <summary>대화 상자에서 프롬프트를 표시하고 사용자가 텍스트를 입력하거나 단추를 클릭할 때까지 대기한 다음 텍스트 상자의 내용을 포함하는 문자열을 반환합니다.</summary>
        <returns>대화 상자에서 프롬프트를 표시하고 사용자가 텍스트를 입력하거나 단추를 클릭할 때까지 대기한 다음 텍스트 상자의 내용을 포함하는 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 클릭할 경우 **취소**, 길이가 0 인 문자열이 반환 됩니다.  
  
 첫 번째 인수 보다 더를 지정 하려면 사용 해야 합니다는 `InputBox` 식에서 함수입니다. 위치 인수를 생략 하는 경우 해당 하는 쉼표로 구분 기호를 보유 해야 합니다.  
  
> [!NOTE]
>  `InputBox` 함수 필요 `UIPermission` 에 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 수준 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다. 자세한 내용은 참조 및 <xref:System.Security.Permissions.UIPermission> 합니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는이 예제는 `InputBox` 함수 값을 입력 하 라는 메시지입니다. 경우 x 및 y 위치를 생략 하면, 대화 상자는 자동으로 각 축의 가운데에 있습니다. 변수 `MyValue` 사용자가 확인을 클릭 하거나 ENTER 키를 누른 경우 사용자가 입력 한 값을 포함 합니다.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">필수. 대화 상자에서 메시지로 표시되는 <see langword="String" /> 식입니다. <c>프롬프트</c>의 최대 길이는 대략 1024자이며 사용되는 문자의 너비에 따라 달라집니다. <c>프롬프트</c>가 두 줄 이상으로 구성되는 경우 캐리지 리턴 문자(<see langword="Chr(" />13<see langword=")" />), 줄 바꿈 문자(<see langword="Chr(" />10<see langword=")" />) 또는 각 줄 사이에 캐리지 리턴/줄 바꿈 문자 조합(<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />)을 사용하여 줄을 구분할 수 있습니다.</param>
        <param name="Buttons">선택 사항입니다. 표시할 단추의 수와 형식, 사용할 아이콘 스타일, 기본 단추의 ID 및 메시지 상자의 모달을 지정하는 값의 합을 나타내는 숫자 식입니다. <c>Buttons</c>를 생략한 경우 기본값은 0입니다.</param>
        <param name="Title">선택 사항입니다. 대화 상자의 제목 표시줄에 표시되는 <see langword="String" /> 식입니다. <c>Title</c>을 생략하면 응용 프로그램 이름이 제목 표시줄에 나타납니다.</param>
        <summary>대화 상자에 메시지를 표시하고 사용자가 단추를 클릭할 때까지 대기한 다음 클릭된 단추를 나타내는 정수를 반환합니다.</summary>
        <returns>
          <list type="table">
            <item>
              <term> 상수  </term>
              <description> 값  </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1  </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2  </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3  </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4  </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5  </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6  </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7  </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위치 인수를 생략 하는 경우 해당 하는 쉼표로 구분 기호를 보유 해야 합니다.  
  
 대화 상자 표시 되는 **취소** ESC 키를 누르면 단추를 클릭할 때와 같은 효과가 **취소**  
  
 대화 상자에는 **도움말** 단추가, 대화 상자에 대 한 상황에 맞는 도움말을 제공 됩니다. 그러나 값이 없는 다른 단추 중 하나 선택 될 때까지 반환 됩니다. Windows Form 응용 프로그램에서 선택 된 **도움말** 단추 실행는 <xref:System.Windows.Forms.Control.HelpRequested> 폼에 대 한 이벤트.  
  
> [!NOTE]
>  `MsgBox` 함수 필요 `UIPermission` 에 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> 수준 부분 신뢰 상황에서의 실행에 영향을 줄 수 있습니다. 자세한 내용은 <xref:System.Security.Permissions.UIPermission>을 참조하세요.  
  
 `MsgBoxStyle` 열거형 값은 아래에 나열 됩니다.  
  
|멤버|값|설명|  
|-|-|-|  
|멤버|값|설명|  
|`OKOnly`|0|확인 단추만 표시 합니다.|  
|`OKCancel`|1|확인 표시 및 취소 단추|  
|`AbortRetryIgnore`|2|중단, 다시 시도 및 무시 단추가 표시 됩니다.|  
|`YesNoCancel`|3|Yes를 표시, 아니요 및 취소 단추입니다.|  
|`YesNo`|4|예 및 아니요 단추를 표시합니다.|  
|`RetryCancel`|5|다시 시도 및 취소 단추를 표시합니다.|  
|`Critical`|16|중요 한 메시지 아이콘을 표시 합니다.|  
|`Question`|32|경고 쿼리 아이콘을 표시 합니다.|  
|`Exclamation`|48|경고 메시지 아이콘을 표시 합니다.|  
|`Information`|64|정보 메시지 아이콘을 표시 합니다.|  
|`DefaultButton1`|0|첫 번째 단추가 기본 단추입니다.|  
|`DefaultButton2`|256|두 번째 단추가 기본 단추입니다.|  
|`DefaultButton3`|512|세 번째 단추가 기본 단추입니다.|  
|`ApplicationModal`|0|응용 프로그램이 모달입니다. 사용자는 현재 응용 프로그램에서 작업을 계속 하기 전에 messagebox에 응답 해야 합니다.|  
|`SystemModal`|4096|시스템은 모달입니다. 모든 응용 프로그램에는 메시지 상자에 사용자가 응답할 때까지 일시 중단 됩니다.|  
|`MsgBoxSetForeground`|65536|메시지 상자 창 위에 오도록 지정합니다.|  
|`MsgBoxRight`|524288|텍스트를 오른쪽에 맞춥니다.|  
|`MsgBoxRtlReading`|1048576|텍스트가 같이 오른쪽에서 왼쪽으로 읽는 히브리어 및 아랍어 시스템에 표시 되도록 지정 합니다.|  
  
 대화 상자에 표시 되는 단추의 유형과 수 값 (0-5)의 첫 번째 그룹에 설명 합니다. 아이콘 스타일을 설명 하는 두 번째 그룹 (예: 16, 32, 48, 64). 세 번째 그룹 (0, 256, 512) 기본값 사용 되는 단추를 결정 합니다. 네 번째 그룹 (0, 4, 096) 모달 메시지 상자를 결정 하 고 다섯 번째 그룹은 메시지 상자 창 전경 창인지 여부와 함께 맞춤과 텍스트의 방향을 지정 합니다. 에 대 한 최종 값을 산출 하기 위해 숫자를 추가 하는 경우는 `Buttons` 인수를 사용 하 여 각 그룹에서 하나의 숫자입니다.  
  
   
  
## Examples  
 사용 하 여이 예제는 `MsgBox` 함수 예 및 단추가 있는 대화 상자에 중대 오류 메시지를 표시 합니다. 아니요 단추에 기본적으로 지정 됩니다. 이렇게 조합 하 여는 `MsgBox` 하나의 숫자 식으로 상수 값입니다. 이 경우 4를 추가 (는 예/아니요 단추 조합) 및 16 (의 **중대 오류 메시지** 창) 256 (기본 단추로 두 번째 단추) 276의 합계를 제공 합니다. 반환한 값은 `MsgBox` 기능은 사용자가 선택한 단추에 따라 달라 집니다: 예 6;의 값을 반환 7의 값을 반환 없습니다.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" />가 <see langword="String" /> 식이 아니거나 <paramref name="Title" />이 올바르지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">프로세스가 사용자 대화형 모드로 실행되고 있지 않습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">하나 이상의 매개 변수가 <see langword="MsgBoxResult" /> 또는 <see langword="MsgBoxStyle" /> 열거형의 멤버가 아닙니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">필수. <see langword="Long" />. 하나의 계산된 범위에서 찾을 정수입니다.</param>
        <param name="Start">필수. <see langword="Long" />. 계산된 범위 집합의 시작을 나타내는 정수입니다. <c>Start</c>는 0보다 작을 수 없습니다.</param>
        <param name="Stop">필수. <see langword="Long" />. 계산된 범위 집합의 끝을 나타내는 정수입니다. <c>Stop</c>은 <c>Start</c>보다 작거나 같을 수 없습니다.</param>
        <param name="Interval">필수. <see langword="Long" />. <c>Start</c>와 <c>Stop</c> 사이에서 계산되는 각 범위의 크기를 나타내는 정수입니다. <c>Interval</c>은 1보다 작을 수 없습니다.</param>
        <summary>숫자가 들어 있는 계산된 범위를 나타내는 문자열을 반환합니다.</summary>
        <returns>숫자가 들어 있는 계산된 범위를 나타내는 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Partition` 함수 계산 숫자 범위 집합을 통해 지정 된 값 수가 포함 된 각 `Interval`합니다. 첫 번째 범위에서 시작 `Start`, 마지막 범위에서 끝나고 `Stop`합니다. `Partition` 함수 포함 하는 범위를 식별 한 다음 `Number` 하 고 해당 범위를 설명 하는 문자열을 반환 합니다. 범위에 따라 문자열에 표시 됩니다 "*lowervalue*:*uppervalue*" 여기서 범위의 하위 끝 (*lowervalue*)은 높은 끝점에서 분리 되어 (* uppervalue*)에 콜론 (:).  
  
 필요한 경우는 `Partition` 함수 앞에 선행 공백이 삽입 *lowervalue* 및 *uppervalue* 갖도록 두 값 (의 문자열 표현으로 동일한 문자 수 `Stop` + 1). 출력을 사용 하는 경우 이렇게 하면는 `Partition` 의 여러 가지 값으로 함수 `Number`, 이후에 정렬 작업 동안 결과 텍스트를 올바르게 처리 됩니다.  
  
 다음 표에서 세 가지를 사용 하 여 계산 범위에 대 한 몇 가지 샘플 문자열 `Start`, `Stop`, 및 `Interval`합니다. "시작 범위" 및 "범위 마지막" 열에서 최저 및 최고 범위 범위 지정 된 값의 표시 `Start` 및 `Stop`합니다. 열 값에 대해 반환 된 문자열을 보여 범위"이전" 및 "마지막 범위" 호출 후 `Number` 미만 `Start` 보다 큰 `Stop`각각.  
  
|`Start`|`Stop`|`Interval`|첫 번째 범위 하기 전에|첫 번째 범위|마지막 범위|마지막 범위 이후|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"  0:  4"|" 95: 99"|"100:   "|  
|20|199|10|"   : 19"|" 20: 29"|"190:199"|"200:   "|  
|100|1010|20|"    : 99"|" 100: 119"|"1000:1010"|"1011:    "|  
  
 앞의 표에서 세 번째 줄의 결과 보여 줍니다. 때 `Start` 및 `Stop` 으로 균등 하 게 나눌 수 없는 숫자 집합의 정의 `Interval`합니다. 마지막 범위에서 끝나는 `Stop`, 있어서 11 숫자도 `Interval` 는 20 개입니다.  
  
 경우 `Interval` 1의 범위는 "`Number`:`Number`"에 관계 없이 `Start` 및 `Stop` 인수입니다. 예를 들어 경우 `Number` 가 267, `Stop` 은 1000으로 및 `Interval` 1 이면 `Partition` "267: 267"를 반환 합니다.  
  
 `Partition` 데이터베이스 쿼리를 구성할 때 유용할 수 있습니다. 주문 수 2000 1001를 1에서 1000, 송장 값이 있는 예를 들어 다양 한 값의 범위 내에서 발생 하 고 표시 하는 SELECT 쿼리를 만들 수 있습니다.  
  
   
  
## Examples  
 다음 예에서는 일련의 범위를 1950-2049 년 설정 합니다. 값을 찾고 `year` 하며 적절 한 범위 내에서 `String` 값 범위를 표시 합니다. 경우 `year` 1984 년 값을 예를 들어이 `Partition` "1980:1989"를 반환 합니다.  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" /> 또는 <paramref name="Interval" /> &lt; 1입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">필수. 설정이 적용되는 응용 프로그램이나 프로젝트의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Section">필수. 키 설정을 저장할 섹션의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Key">필수. 저장할 키 설정의 이름을 포함하는 <see langword="String" /> 식입니다.</param>
        <param name="Setting">필수. 설정할 <c>키</c> 값을 포함하는 식입니다.</param>
        <summary>Windows 레지스트리에 응용 프로그램 엔트리를 저장하거나 만듭니다. <see langword="My" /> 기능을 사용하면 <see langword="SaveSetting" />보다 레지스트리 작업의 생산성 및 성능이 향상됩니다. 자세한 내용은 <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />을 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `SaveSetting` 키를 추가 하는 함수 `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`합니다.  
  
 어떤 이유로 든 키 설정을 저장할 수 없습니다, 오류가 발생 합니다.  
  
 `SaveSetting` 아래에서 작동 하기 때문에 사용자 로그온 할 필요는 `HKEY_LOCAL_USER` 사용자가 대화형으로 로그온 할 때까지 비활성화 되어 있는 레지스트리 키입니다.  
  
 아래는 비 대화형 프로세스 (예: Mtx.exe)에서 액세스 하는 레지스트리 설정에 저장 해야는 `HKEY_LOCAL_MACHINE\Software\` 또는 `HKEY_USER\DEFAULT\Software` 레지스트리 키입니다.  
  
 `SaveSetting` 필요한 `Write` 및 `Create` <xref:System.Security.Permissions.RegistryPermission> 합니다.  
  
   
  
## Examples  
 다음 예에서는 먼저 사용 하 여는 `SaveSetting` 함수를 Windows 레지스트리에 항목을 만듭니다는 `MyApp` 응용 프로그램을 한 다음 사용 하는 `DeleteSetting` 함수를 제거 합니다.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">키 레지스트리를 만들 수 없거나 사용자가 로그인하지 않았습니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" />
        <Parameter Name="Wait" Type="System.Boolean" />
        <Parameter Name="Timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="PathName">필수. <see langword="String" />. 필수적 요소인 모든 인수 및 명령줄 스위치와 함께 실행할 프로그램의 이름입니다. 또한 <c>PathName</c>에는 드라이브와 디렉터리 경로 또는 폴더가 포함될 수 있습니다.  프로그램의 경로를 모를 경우 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />를 사용하여 찾을 수 있습니다. 예를 들어, <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>를 호출할 수 있으며, 드라이브 C:\\의 모든 위치에서 이름이 <c>testFile.txt</c>인 모든 파일의 전체 경로가 반환됩니다.</param>
        <param name="Style">선택 사항입니다. <see langword="AppWinStyle" />. 프로그램이 실행될 창의 스타일을 지정하는 <see cref="T:Microsoft.VisualBasic.AppWinStyle" />에서 선택된 값입니다. <c>Style</c>이 생략되면 <see langword="Shell" />은 최소화되고 포커스가 있는 상태로 프로그램을 시작하는 <see langword="AppWinStyle.MinimizedFocus" />를 사용합니다.</param>
        <param name="Wait">선택 사항입니다. <see langword="Boolean" />. 프로그램이 완료될 때까지 <see langword="Shell" /> 함수가 대기할지 여부를 나타내는 값입니다. <c>Wait</c>가 생략되면 <see langword="Shell" />은 <see langword="False" />를 사용합니다.</param>
        <param name="Timeout">선택 사항입니다. <see langword="Integer" />. <c>Wait</c>가 <see langword="True" />인 경우 완료될 때까지 대기하는 시간(밀리초)입니다. <c>Timeout</c>이 생략되면 <see langword="Shell" />은 -1을 사용합니다. 이 값은 시간 제한이 없고 프로그램이 완료될 때까지 <see langword="Shell" />이 반환되지 않음을 나타냅니다. 따라서 <c>Timeout</c>을 생략하거나 -1로 설정하면 <see langword="Shell" />에서 프로그램에 제어를 반환하지 않게 됩니다.</param>
        <summary>실행 프로그램을 실행하고 실행 중인 프로그램의 프로세스 ID가 포함된 정수를 반환합니다.</summary>
        <returns>실행 프로그램을 실행하고 실행 중인 프로그램의 프로세스 ID가 포함된 정수를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값은 `Shell` 함수에서 프로그램 이름이 있는지 여부에 따라 달라 집니다 `PathName` 시기를 아직 실행 되 `Shell` 반환 합니다. 설정한 경우 `Wait` 를 `True` 프로그램 제한 시간이 만료 되기 전에 완료 및 `Shell` 0을 반환 합니다. 생략 하는 경우 또는 제한 시간이 만료 `Wait` 로 설정 하거나 `False`, `Shell` 프로그램의 프로세스 ID를 반환 합니다. 프로세스 ID는 실행 중인 프로그램을 식별 하는 고유 번호입니다.  
  
## <a name="failure-to-start"></a>시작 실패  
 경우는 `Shell` 함수는 명명된 된 프로그램을 시작할 수 없으면는 <xref:System.IO.FileNotFoundException> 오류가 발생 합니다. 이 발생할 수 있습니다, 예를 들어 16 비트 프로그램와 같은 실행 하려고 하면 `command.com`를 사용 하 여 응용 프로그램에서 <xref:System.Windows.Forms?displayProperty=nameWithType>합니다. 이 문제를 해결 하려면 원하는 16 비트 프로그램을 호출 하는 32 비트 프로그램을 실행할 수 있습니다. 경우 `command.com`를 실행할 수 있습니다 `cmd.exe` 대신 합니다.  
  
## <a name="waiting-for-completion"></a>완료 대기 중  
 기본적으로는 `Shell` 함수는 프로그램을 비동기적으로 실행 합니다. 즉, 시작 된 프로그램의 `Shell` 함수 문 다음 하기 전에 실행을 종료 되지 않습니다는 `Shell` 함수가 실행 됩니다. 대기 하려면 계속 하기 전에 완료 하는 데 프로그램에 대 한 설정, `Wait` 를 `True`합니다.  
  
## <a name="determining-the-exit-code"></a>종료 코드 확인  
 프로세스를 반환할 수 있습니다는 *종료 코드* 종료 될 때입니다. 그러나 사용할 수 없습니다 `Shell` 있기 때문에이 종료 코드를 검색할 `Shell` 종료를 때까지 대기 하는 경우 0을 반환 그리고 프로세스에서 다른 개체에서 실행 되기 때문에 `Shell`합니다.  
  
 프로세스의 종료 코드를 검색 하려면 프로세스를 시작 하 고 종료 될 때까지 기다리는 사용자 고유의 코드를 작성 해야 합니다. 다음 예제에서는 프로세스를 시작, 종료 될 때까지 기다렸다가 및 종료 코드를 검색 하는 방법을 보여 줍니다.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>보호 파일 지정  
 항상 묶어야 전체 경로 및 파일 사양은 인용 부호로 다음 예제와 같이 합니다.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 인접 한 개의 큰따옴표의 각 쌍 (`" "`) 문자열에서 리터럴 문자열에 하나의 큰따옴표 문자로 해석 됩니다. 앞의 예제에 다음 문자열을 제공 하는 따라서는 `Shell` 함수:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 경로에서 따옴표로 묶이지 없는 경우 Windows 라는 파일을 찾을 것 `Program.exe` C:\ 디렉터리에 대신 `display.exe` C:\Program Files 디렉터리에 있습니다.  
  
> [!IMPORTANT]
>  경로 파일 사양 인용 부호로 묶지 않습니다 경우 파일 이름이 나 경로 노드에 공백이 있으면 보안상 위험 합니다. 위의 예제에서는 경로 노드 `\Program Files` 공백이 포함 합니다. 경우 사양을 묶여 있지 않고 인용 부호 및 명명 된 프로그램 `Program.exe` c: \에 설치 되어 있던\\, 예를 들어 불법 변조 하 여 Windows가 실행 대신 `display.exe`합니다.  
  
> [!IMPORTANT]
>  `Shell` 함수 비관리 코드 권한이 필요 합니다. 자세한 내용은 참조 <xref:System.Security.Permissions.SecurityPermission> 및 [코드 액세스 권한](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)합니다.  
  
   
  
## Examples  
 다음 예제에서는 `Shell` 사용자가 지정 된 응용 프로그램을 실행할 함수입니다. 지정 <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> 를 두 번째 인수는 응용 프로그램에서 보통 크기로 열리고의 포커스를 제공 합니다.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" />의 범위는 0-9(포함)가 아니어야 합니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" />이 <paramref name="PathName" /> 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" />가 <see langword="Nothing" />인 경우</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">필수. <see langword="Object" /> 매개 변수 배열입니다. 요소의 수는 짝수여야 합니다. 쉼표로 구분된 <see langword="Object" /> 변수나 식의 목록 또는 1차원 배열의 <see langword="Object" /> 요소를 사용할 수 있습니다.</param>
        <summary>식 목록을 계산하고 목록에서 <see langword="Object" />인 첫 번째 식에 해당하는 <see langword="True" /> 값을 반환합니다.</summary>
        <returns>식 목록을 계산하고 목록에서 <see langword="Object" />인 첫 번째 식에 해당하는 <see langword="True" /> 값을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 제공 된 인수는 `VarExpr` 쌍을 이루는 식 및 값으로 구성 합니다. `Switch` 함수 홀수 번호의 식을 계산에서 가장 낮은의 가장 큰 인덱스 `VarExpr`, 계산 되는 첫 번째 식과 관련 된 짝수 값을 반환 하 고 `True`합니다. 예를 들어 경우 `VarExpr(0)` 은 `True`, `Switch` 반환 `VarExpr(1)`, 쓰고 `VarExpr(0)` 은 `False` 하지만 `VarExpr(2)` 은 `True`, `Switch` 반환 `VarExpr(3)`등입니다.  
  
 지정 하지 않으면는 `VarExpr` 인수 `Switch` 반환 `Nothing`합니다.  
  
> [!NOTE]
>  인수 목록의 식은 함수 호출을 포함할 수 있습니다. 인수 목록에 대 한 호출에 대 한 준비의 일부로 `Switch`, Visual Basic 컴파일러는 모든 식에서 모든 함수를 호출 합니다. 즉, 식이 인수 목록이 앞부분에 나오는 경우에 호출 되지 않는 특정 함수를 사용할 수 없게 `True`합니다.  
  
   
  
## Examples  
 다음 예제에서는 `Switch` 도시 이름을 일치 하는 언어의 이름을 반환 하는 함수입니다. `Option Strict` 수 `Off`합니다.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 때문에 <xref:System.Diagnostics> 네임 스페이스에 라는 클래스도 포함 되어 <xref:System.Diagnostics.Switch>에 대 한 호출에서 `Switch` 함수도 한정 되어야 합니다는 <xref:Microsoft.VisualBasic> 네임 스페이스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">인수 개수가 홀수 개입니다.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>