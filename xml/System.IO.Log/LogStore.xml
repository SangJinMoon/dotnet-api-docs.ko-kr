<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e09c8f57cbb65b4338595c8c78cf1de13180ff3f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37759115" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a log-structured storage.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> 클래스는 CLFS(Common Log File System) 로그 위에 레코드 시퀀스 인터페이스의 구현을 제공합니다. 이 클래스는 CLFS 로그 파일을 직접 조작하고 관리하는 데 필요한 인터페이스를 제공하는 <xref:System.IO.Log.LogStore> 클래스와 함께 작동합니다. 로그 저장소는 일련의 디스크 범위에서 추가 전용 저장소를 제공합니다. <xref:System.IO.Log.LogStore> 클래스는 이 저장소를 나타내며 컨테이너 추가 및 제거, 정책 설정 및 아카이브 생성을 위한 메서드를 제공합니다. 하지만 저장소에서 읽고 저장소에 쓰기 위한 메서드는 제공하지 않습니다. 이러한 메서드는 <xref:System.IO.Log.LogRecordSequence> 클래스에서 제공합니다.  
  
 <xref:System.IO.Log.LogStore> 클래스와 <xref:System.IO.Log.LogRecordSequence> 클래스의 관계는 디스크 파일과 <xref:System.IO.FileStream> 개체의 관계와 유사합니다. 디스크 파일은 실제 저장소를 제공하고 길이 및 마지막 액세스 시간과 같은 특성을 갖고 있으며, <xref:System.IO.FileStream> 개체는 파일에서 읽고 파일에 쓰는 데 사용할 수 있는 파일에 대한 뷰를 제공합니다. 이와 마찬가지로 <xref:System.IO.Log.LogStore> 클래스에는 디스크 범위의 컬렉션 및 정책과 같은 특성이 있으며, <xref:System.IO.Log.LogRecordSequence> 클래스는 데이터를 읽고 쓰기 위한 레코드 기반의 메커니즘을 제공합니다.  
  
 <xref:System.IO.Log.FileRecordSequence> 클래스가 나타내는 파일 레코드 시퀀스와 달리, <xref:System.IO.Log.LogStore> 인스턴스는 <xref:System.IO.Log.LogExtent> 인스턴스가 나타내는 디스크 범위의 컬렉션에 데이터를 저장합니다. 지정된 <xref:System.IO.Log.LogStore> 인스턴스의 범위는 크기가 모두 동일하며 범위가 증가하면 <xref:System.IO.Log.LogStore> 인스턴스에서 공간이 추가되고 제거됩니다. 로그 범위를 추가하고 제거하려면 <xref:System.IO.Log.LogExtentCollection.Add%2A> 속성에서 반환할 수 있는 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 개체의 <xref:System.IO.Log.LogExtentCollection> 및 <xref:System.IO.Log.LogStore.Extents%2A> 메서드를 사용합니다.  
  
 <xref:System.IO.Log.LogStore> 인스턴스에는 정책이 연결되어 있을 수 있습니다. 이러한 정책은 <xref:System.IO.Log.LogPolicy> 속성에서 반환할 수 있는 <xref:System.IO.Log.LogStore.Policy%2A> 인스턴스로 나타냅니다. 정책에서는 로그에서 따라야 할 최대 범위 수 및 최소 크기, 특정 조건에서 <xref:System.IO.Log.LogStore>를 늘리거나 줄이는 지침 등의 규칙을 규정합니다. 또한 <xref:System.IO.Log.LogStore> 인스턴스를 보관할 수 있는지 여부를 지정할 수 있습니다. 정책은 로그별로 설정되고 일시적입니다. 즉, 로그에 대한 각 핸들이 닫히면 정책이 더 이상 존재하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">A file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> object encapsulates.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class for the specified handle.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The log handle could not be bound to the thread pool.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path and mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용하여 지정된 경로와 모드로 로그 저장소를 엽니다. 저장소는 읽기/쓰기 권한으로 열리고 읽기 권한을 공유합니다.  
  
 `path` 매개 변수는 다음 구문을 사용해야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path, mode, and access.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용하여 지정된 경로, 모드 및 액세스 권한으로 새 로그 저장소를 엽니다. 저장소는 읽기 권한을 공유하여 열립니다.  
  
 `path` 매개 변수는 다음 구문을 사용해야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.  -or  <paramref name="access" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 지정된 경로, 모드 및 액세스 권한을 사용하여 여는 새 <xref:System.IO.Log.LogStore> 개체를 초기화합니다. 저장소는 지정된 액세스 권한을 공유하여 열립니다.  
  
 `path` 매개 변수는 다음 구문을 사용해야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.  -or  <paramref name="access" /> contains an invalid value.  -or-  <paramref name="share" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</param>
        <param name="fileSecurity">One of the <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 지정된 경로, 모드 및 액세스 권한을 사용하여 여는 새 <xref:System.IO.Log.LogStore> 개체를 초기화합니다. 저장소는 지정된 액세스 권한을 공유하여 열립니다. `path` 매개 변수는 다음 구문을 따라야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The log store file name specified by <paramref name="path" /> is not valid.  -or-  <paramref name="Mode" /> is <see langword="CreateNew" />, which cannot be used without write access.  -or-  <paramref name="Mode" /> is <see langword="OpenOrCreate" />, which cannot be used without write access.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.  -or  <paramref name="access" /> contains an invalid value.  -or-  <paramref name="share" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.  The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.  -or-  The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.  -or-  The log handle could not be bound to the thread pool.  -or-  The specified log file format or version is invalid.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this <see cref="T:System.IO.Log.LogStore" /> instance can be archived.</summary>
        <value>이 <see langword="true" /> 인스턴스를 보관할 수 있으면 <see cref="T:System.IO.Log.LogStore" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogStore>를 보관할 수 없는 경우 <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> 및 <xref:System.IO.Log.LogStore.SetArchiveTail%2A> 메서드를 호출하면 <xref:System.NotSupportedException>이 throw됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the lowest sequence number that corresponds to a valid record in this <see cref="T:System.IO.Log.LogStore" /> instance.</summary>
        <value>이 <see cref="T:System.IO.Log.LogStore" /> 인스턴스에서 유효한 레코드에 해당하는 가장 작은 시퀀스 번호입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유효한 시퀀스 번호는 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>보다 작습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Takes a snapshot of the log store state necessary to make a backup.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Takes a snapshot of the log store state for making a backup.</summary>
        <returns>A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The log store is not archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when creating the archive snapshot.</exception>
        <exception cref="T:System.ArgumentException">An argument is not valid.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation has been executed.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">The starting sequence number in the range to archive.</param>
        <param name="last">The ending sequence number in the range to archive.</param>
        <summary>Takes a snapshot of the log store state between the specified sequence numbers for making a backup.</summary>
        <returns>A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환된 아카이브 스냅숏은 기준 시퀀스 번호나 아카이브 시퀀스 번호 중 작은 번호부터 마지막 시퀀스 번호 사이의 정보를 포함합니다. 여기에서 마지막 시퀀스 번호는 포함되지 않습니다. 즉, 마지막 시퀀스 번호를 제외하고 그 이전 번호까지의 레코드만 아카이브에 포함됩니다. 또한 이 메서드를 사용할 때 아카이브가 일관성을 유지하려면 시작 SequenceNumber가 BaseSequenceNumber와 같아야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="first" /> or <paramref name="last" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="first" /> is larger than <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation has been executed.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when creating the archive snapshot.</exception>
        <exception cref="T:System.NotSupportedException">The log store is not archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to remove.</param>
        <summary>Removes the log store.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogStore.Dispose%2A>를 사용한 후에 <xref:System.IO.Log.LogStore>를 호출합니다. <xref:System.IO.Log.LogStore.Dispose%2A> 메서드를 사용하면 <xref:System.IO.Log.LogStore>를 사용할 수 없게 됩니다. <xref:System.IO.Log.LogStore.Dispose%2A>를 호출한 후에 가비지 수집기가 <xref:System.IO.Log.LogStore>에서 차지한 메모리를 회수할 수 있도록 <xref:System.IO.Log.LogStore>에 대한 모든 참조를 해제해야 합니다.  
  
> [!NOTE]
>  <xref:System.IO.Log.LogStore.Dispose%2A>에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.IO.Log.LogStore>를 호출하십시오. 이렇게 하지 않으면 가비지 수집기가 <xref:System.IO.Log.LogStore> 개체의 `Finalize` 메서드를 호출할 때까지 사용 중인 리소스가 해제되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of log extents that contain the data for this log store.</summary>
        <value>이 로그 저장소에 대한 데이터를 캡슐화하는 로그 범위의 컬렉션을 포함하는 <see cref="T:System.IO.Log.LogExtentCollection" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogStore> 인스턴스는 <xref:System.IO.Log.LogExtent> 인스턴스가 나타내는 디스크 범위의 컬렉션에 데이터를 저장합니다. 지정된 <xref:System.IO.Log.LogStore> 인스턴스의 범위는 크기가 모두 동일하며 범위가 증가하면 <xref:System.IO.Log.LogStore> 인스턴스에서 공간이 추가되고 제거됩니다. 로그 범위를 추가하고 제거하려면 이 속성에서 반환하는 <xref:System.IO.Log.LogExtentCollection.Add%2A> 개체의 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 및 <xref:System.IO.Log.LogExtentCollection> 메서드를 사용합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes available in the log store.</summary>
        <value>로그 저장소에서 사용 가능한 바이트의 수입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the operating system file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> instance encapsulates.</summary>
        <value>현재 <see cref="T:System.IO.Log.LogStore" /> 인스턴스가 캡슐화하는 로그 파일에 대한 운영 체제 파일 핸들입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the sequence number of the next record to be appended to the log store.</summary>
        <value>로그 저장소에 추가할 다음 레코드의 시퀀스 번호입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유효한 시퀀스 번호는 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>보다 작습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of the log store, in bytes.</summary>
        <value>로그 저장소의 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로그 저장소의 크기는 로그 범위의 크기를 합한 것입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the policy associated with this log store.</summary>
        <value>이 로그 저장소와 연결된 정책을 나타내는 <see cref="T:System.IO.Log.LogPolicy" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환하는 <xref:System.IO.Log.LogPolicy> 인스턴스를 사용하여 이 <xref:System.IO.Log.LogStore>와 연결된 로그 정책을 검사하고 조작할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">The sequence number of the archive tail.</param>
        <summary>Sets the sequence number of the archive tail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기준 시퀀스 번호와 아카이브 테일 중 작은 값으로 로그의 테일이 결정됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="archiveTail" /> is not valid for this sequence.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation has been executed.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when creating the archive snapshot.</exception>
        <exception cref="T:System.NotSupportedException">The log store is not archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of log streams in this log store.</summary>
        <value>이 로그 저장소의 로그 스트림 수입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>