<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e09c8f57cbb65b4338595c8c78cf1de13180ff3f" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="37759115" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="9ab55-101">구조적 로그 스토리지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-101">Represents a log-structured storage.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-102"><xref:System.IO.Log.LogRecordSequence> 클래스는 CLFS(Common Log File System) 로그 위에 레코드 시퀀스 인터페이스의 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-102">The <xref:System.IO.Log.LogRecordSequence> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</span></span> <span data-ttu-id="9ab55-103">이 클래스는 CLFS 로그 파일을 직접 조작하고 관리하는 데 필요한 인터페이스를 제공하는 <xref:System.IO.Log.LogStore> 클래스와 함께 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-103">It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file.</span></span> <span data-ttu-id="9ab55-104">로그 저장소는 일련의 디스크 범위에서 추가 전용 스토리지를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-104">A log store provides append-only storage across a set of disk extents.</span></span> <span data-ttu-id="9ab55-105"><xref:System.IO.Log.LogStore> 클래스는 이 저장소를 나타내며 컨테이너 추가 및 제거, 정책 설정 및 아카이브 생성을 위한 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-105">The <xref:System.IO.Log.LogStore> class represents this storage, and provides methods for adding and removing containers, setting policy, and creating archives.</span></span> <span data-ttu-id="9ab55-106">하지만 스토리지에서 읽고 스토리지에 쓰기 위한 메서드는 제공하지 않습니다. 이러한 메서드는 <xref:System.IO.Log.LogRecordSequence> 클래스에서 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-106">It does not provide methods for reading from and writing to the storage; these methods are provided by the <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
 <span data-ttu-id="9ab55-107"><xref:System.IO.Log.LogStore> 클래스와 <xref:System.IO.Log.LogRecordSequence> 클래스의 관계는 디스크 파일과 <xref:System.IO.FileStream> 개체의 관계와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-107">The relationship between the <xref:System.IO.Log.LogStore> class and the <xref:System.IO.Log.LogRecordSequence> class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="9ab55-108">디스크 파일은 실제 스토리지를 제공하고 길이 및 마지막 액세스 시간과 같은 특성을 갖고 있으며, <xref:System.IO.FileStream> 개체는 파일에서 읽고 파일에 쓰는 데 사용할 수 있는 파일에 대한 보기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-108">The disk file provides the actual storage and has attributes such as length and last access time, while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it.</span></span> <span data-ttu-id="9ab55-109">이와 마찬가지로 <xref:System.IO.Log.LogStore> 클래스에는 디스크 범위의 컬렉션 및 정책과 같은 특성이 있으며, <xref:System.IO.Log.LogRecordSequence> 클래스는 데이터를 읽고 쓰기 위한 레코드 기반의 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-109">Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents, and the <xref:System.IO.Log.LogRecordSequence> class provides a record-oriented mechanism for reading and writing data.</span></span>  
  
 <span data-ttu-id="9ab55-110"><xref:System.IO.Log.FileRecordSequence> 클래스가 나타내는 파일 레코드 시퀀스와 달리, <xref:System.IO.Log.LogStore> 인스턴스는 <xref:System.IO.Log.LogExtent> 인스턴스가 나타내는 디스크 범위의 컬렉션에 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-110">Unlike the file record sequence represented by the <xref:System.IO.Log.FileRecordSequence> class, a <xref:System.IO.Log.LogStore> instance stores its data in a collection of disk extents, represented by <xref:System.IO.Log.LogExtent> instances.</span></span> <span data-ttu-id="9ab55-111">지정된 <xref:System.IO.Log.LogStore> 인스턴스의 범위는 크기가 모두 동일하며 범위가 증가하면 <xref:System.IO.Log.LogStore> 인스턴스에서 공간이 추가되고 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-111">The extents in a given <xref:System.IO.Log.LogStore> instance are all of uniform size, and space is added to and removed from a <xref:System.IO.Log.LogStore> instance in extent increments.</span></span> <span data-ttu-id="9ab55-112">로그 범위를 추가하고 제거하려면 <xref:System.IO.Log.LogExtentCollection.Add%2A> 속성에서 반환할 수 있는 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 개체의 <xref:System.IO.Log.LogExtentCollection> 및 <xref:System.IO.Log.LogStore.Extents%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-112">To add and remove log extents, use the <xref:System.IO.Log.LogExtentCollection.Add%2A> and <xref:System.IO.Log.LogExtentCollection.Remove%2A> methods of the <xref:System.IO.Log.LogExtentCollection> object, which can be returned by the <xref:System.IO.Log.LogStore.Extents%2A> property.</span></span>  
  
 <span data-ttu-id="9ab55-113"><xref:System.IO.Log.LogStore> 인스턴스에는 정책이 연결되어 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-113">A <xref:System.IO.Log.LogStore> instance can have policies associated with it.</span></span> <span data-ttu-id="9ab55-114">이러한 정책은 <xref:System.IO.Log.LogPolicy> 속성에서 반환할 수 있는 <xref:System.IO.Log.LogStore.Policy%2A> 인스턴스로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-114">These are represented by <xref:System.IO.Log.LogPolicy> instances that can be returned by the <xref:System.IO.Log.LogStore.Policy%2A> property.</span></span> <span data-ttu-id="9ab55-115">정책에서는 로그에서 따라야 할 최대 범위 수 및 최소 크기, 특정 조건에서 <xref:System.IO.Log.LogStore>를 늘리거나 줄이는 지침 등의 규칙을 규정합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-115">A policy dictates rules that the log will attempt to follow, such as maximum number of extents and minimum size, and instructions on growing or shrinking the <xref:System.IO.Log.LogStore> under certain conditions.</span></span> <span data-ttu-id="9ab55-116">또한 <xref:System.IO.Log.LogStore> 인스턴스를 보관할 수 있는지 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-116">In addition, you can specify whether a <xref:System.IO.Log.LogStore> instance can be archived.</span></span> <span data-ttu-id="9ab55-117">정책은 로그별로 설정되고 일시적입니다. 즉, 로그에 대한 각 핸들이 닫히면 정책이 더 이상 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-117">Policies are set per log and are volatile, which means that once every handle to the log is closed, the policy no longer exists.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ab55-118">다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-118">The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.</span></span>  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9ab55-119"><see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-119">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="9ab55-120">현재 <see cref="T:System.IO.Log.LogStore" /> 개체가 캡슐화하는 로그 파일에 대한 파일 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-120">A file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> object encapsulates.</span></span></param>
        <summary><span data-ttu-id="9ab55-121">지정된 핸들에 대한 <see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-121">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class for the specified handle.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9ab55-122"><paramref name="handle" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-122"><paramref name="handle" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-123">로그 핸들을 스레드 풀에 바인딩할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-123">The log handle could not be bound to the thread pool.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-124">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-124">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-125">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-125">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-126">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-126">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9ab55-127">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-127">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="9ab55-128">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-128">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <summary><span data-ttu-id="9ab55-129">지정된 경로 및 모드를 사용하여 <see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-129">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path and mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-130">이 생성자를 사용하여 지정된 경로와 모드로 로그 저장소를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-130">Use this constructor to open a log store with the specified path and mode.</span></span> <span data-ttu-id="9ab55-131">저장소는 읽기/쓰기 권한으로 열리고 읽기 권한을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-131">The store is opened with read/write access, and shares read access.</span></span>  
  
 <span data-ttu-id="9ab55-132">`path` 매개 변수는 다음 구문을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-132">The `path` parameter should use the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="9ab55-133">여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-133">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="9ab55-134">로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-134">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="9ab55-135">로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-135">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="9ab55-136">실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고,</span><span class="sxs-lookup"><span data-stu-id="9ab55-136">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="9ab55-137">가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-137">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="9ab55-138">동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-138">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9ab55-139"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-139"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-140"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-140"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="9ab55-141">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-141">-or-</span></span> 
 <span data-ttu-id="9ab55-142"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-142"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="9ab55-143">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-143">-or-</span></span> 
 <span data-ttu-id="9ab55-144"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-144"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9ab55-145"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-145"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9ab55-146">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-146">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-147">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-147">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-148">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-148">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="9ab55-149">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="9ab55-149"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="9ab55-150">사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-150">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-151">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-151">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9ab55-152">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-152">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="9ab55-153">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-153">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="9ab55-154"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-154">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <summary><span data-ttu-id="9ab55-155">지정된 경로, 모드 및 액세스 권한을 사용하여 <see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-155">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path, mode, and access.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-156">이 생성자를 사용하여 지정된 경로, 모드 및 액세스 권한으로 새 로그 저장소를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-156">Use this constructor to open a new log store with the specified path, mode, and access.</span></span> <span data-ttu-id="9ab55-157">저장소는 읽기 권한을 공유하여 열립니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-157">The store is opened sharing read access.</span></span>  
  
 <span data-ttu-id="9ab55-158">`path` 매개 변수는 다음 구문을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-158">The `path` parameter should use the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="9ab55-159">여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-159">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="9ab55-160">로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-160">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="9ab55-161">로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-161">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="9ab55-162">실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고,</span><span class="sxs-lookup"><span data-stu-id="9ab55-162">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="9ab55-163">가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-163">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="9ab55-164">동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-164">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9ab55-165"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-165"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-166"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-166"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="9ab55-167">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-167">-or-</span></span> 
 <span data-ttu-id="9ab55-168"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-168"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="9ab55-169">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-169">-or-</span></span> 
 <span data-ttu-id="9ab55-170"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-170"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9ab55-171"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-171"><paramref name="mode" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="9ab55-172">-또는-</span><span class="sxs-lookup"><span data-stu-id="9ab55-172">-or</span></span> 
 <span data-ttu-id="9ab55-173"><paramref name="access" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-173"><paramref name="access" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9ab55-174">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-174">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-175">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-175">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-176">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-176">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="9ab55-177">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="9ab55-177"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="9ab55-178">사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-178">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-179">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-179">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9ab55-180">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-180">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="9ab55-181">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-181">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="9ab55-182"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-182">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="9ab55-183">로그 저장소가 프로세스 간에 공유되는 방법을 결정하는 <see cref="T:System.IO.FileShare" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-183">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <summary><span data-ttu-id="9ab55-184"><see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-184">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-185">이 생성자는 지정된 경로, 모드 및 액세스 권한을 사용하여 여는 새 <xref:System.IO.Log.LogStore> 개체를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-185">This constructor initializes a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="9ab55-186">저장소는 지정된 액세스 권한을 공유하여 열립니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-186">The store is opened sharing the specified access.</span></span>  
  
 <span data-ttu-id="9ab55-187">`path` 매개 변수는 다음 구문을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-187">The `path` parameter should use the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="9ab55-188">여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-188">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="9ab55-189">로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-189">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="9ab55-190">로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-190">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="9ab55-191">실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고,</span><span class="sxs-lookup"><span data-stu-id="9ab55-191">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="9ab55-192">가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-192">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="9ab55-193">동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-193">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9ab55-194"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-194"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-195"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-195"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="9ab55-196">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-196">-or-</span></span> 
 <span data-ttu-id="9ab55-197"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-197"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="9ab55-198">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-198">-or-</span></span> 
 <span data-ttu-id="9ab55-199"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-199"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9ab55-200"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-200"><paramref name="mode" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="9ab55-201">-또는-</span><span class="sxs-lookup"><span data-stu-id="9ab55-201">-or</span></span> 
 <span data-ttu-id="9ab55-202"><paramref name="access" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-202"><paramref name="access" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="9ab55-203">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-203">-or-</span></span> 
 <span data-ttu-id="9ab55-204"><paramref name="share" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-204"><paramref name="share" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9ab55-205">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-205">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-206">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-206">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-207">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-207">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="9ab55-208">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="9ab55-208"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="9ab55-209">사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-209">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-210">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-210">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9ab55-211">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-211">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="9ab55-212">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-212">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="9ab55-213"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-213">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="9ab55-214">로그 저장소가 프로세스 간에 공유되는 방법을 결정하는 <see cref="T:System.IO.FileShare" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-214">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <param name="fileSecurity"><span data-ttu-id="9ab55-215">저장소를 만들어야 하는 경우 새로 만든 저장소에서 설정할 보안을 지정하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-215">One of the <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</span></span></param>
        <summary><span data-ttu-id="9ab55-216"><see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-216">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-217">이 생성자는 지정된 경로, 모드 및 액세스 권한을 사용하여 여는 새 <xref:System.IO.Log.LogStore> 개체를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-217">This constructor initializes a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="9ab55-218">저장소는 지정된 액세스 권한을 공유하여 열립니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-218">The store is opened sharing the specified access.</span></span> <span data-ttu-id="9ab55-219">`path` 매개 변수는 다음 구문을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-219">The `path` parameter should follow the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="9ab55-220">여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-220">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="9ab55-221">로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-221">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="9ab55-222">로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-222">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="9ab55-223">실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고,</span><span class="sxs-lookup"><span data-stu-id="9ab55-223">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="9ab55-224">가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-224">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="9ab55-225">동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-225">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9ab55-226"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-226"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-227"><paramref name="path" />로 지정된 로그 저장소 파일 이름이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-227">The log store file name specified by <paramref name="path" /> is not valid.</span></span>  
  
<span data-ttu-id="9ab55-228">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-228">-or-</span></span> 
 <span data-ttu-id="9ab55-229"><paramref name="Mode" />가 쓰기 권한 없이 사용할 수 없는 <see langword="CreateNew" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-229"><paramref name="Mode" /> is <see langword="CreateNew" />, which cannot be used without write access.</span></span>  
  
<span data-ttu-id="9ab55-230">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-230">-or-</span></span> 
 <span data-ttu-id="9ab55-231"><paramref name="Mode" />가 쓰기 권한 없이 사용할 수 없는 <see langword="OpenOrCreate" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-231"><paramref name="Mode" /> is <see langword="OpenOrCreate" />, which cannot be used without write access.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9ab55-232"><paramref name="mode" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-232"><paramref name="mode" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="9ab55-233">-또는-</span><span class="sxs-lookup"><span data-stu-id="9ab55-233">-or</span></span> 
 <span data-ttu-id="9ab55-234"><paramref name="access" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-234"><paramref name="access" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="9ab55-235">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-235">-or-</span></span> 
 <span data-ttu-id="9ab55-236"><paramref name="share" />에 잘못된 값이 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-236"><paramref name="share" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9ab55-237">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-237">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-238">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-238">An I/O error occurs when opening the log store.</span></span>  
  
<span data-ttu-id="9ab55-239"><paramref name="path" />로 지정된 파일을 다른 프로세스에서 사용 중이기 때문에 액세스할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-239">The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.</span></span>  
  
<span data-ttu-id="9ab55-240">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-240">-or-</span></span> 
<span data-ttu-id="9ab55-241"><paramref name="path" />로 지정된 파일이나 디렉터리가 이미 있기 때문에 해당 파일을 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-241">The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.</span></span>  
  
<span data-ttu-id="9ab55-242">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-242">-or-</span></span> 
<span data-ttu-id="9ab55-243">로그 핸들을 스레드 풀에 바인딩할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-243">The log handle could not be bound to the thread pool.</span></span>  
  
<span data-ttu-id="9ab55-244">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-244">-or-</span></span> 
<span data-ttu-id="9ab55-245">지정된 로그 파일 형식이나 버전이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-245">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="9ab55-246">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="9ab55-246"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="9ab55-247">사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-247">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-248">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-248">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-249">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-249">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="9ab55-250">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-250">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-251">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-251">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-252">이 <see cref="T:System.IO.Log.LogStore" /> 인스턴스를 보관할 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-252">Gets a value indicating whether this <see cref="T:System.IO.Log.LogStore" /> instance can be archived.</span></span></summary>
        <value><span data-ttu-id="9ab55-253">이 <see langword="true" /> 인스턴스를 보관할 수 있으면 <see cref="T:System.IO.Log.LogStore" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-253"><see langword="true" /> if this <see cref="T:System.IO.Log.LogStore" /> instance can be archived; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-254"><xref:System.IO.Log.LogStore>를 보관할 수 없는 경우 <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> 및 <xref:System.IO.Log.LogStore.SetArchiveTail%2A> 메서드를 호출하면 <xref:System.NotSupportedException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-254">If a <xref:System.IO.Log.LogStore> is not archivable, calls to the <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> and <xref:System.IO.Log.LogStore.SetArchiveTail%2A> methods result in a <xref:System.NotSupportedException> being thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-255">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-255">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-256">이 <see cref="T:System.IO.Log.LogStore" /> 인스턴스에서 유효한 레코드에 해당하는 가장 작은 시퀀스 번호를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-256">Gets the lowest sequence number that corresponds to a valid record in this <see cref="T:System.IO.Log.LogStore" /> instance.</span></span></summary>
        <value><span data-ttu-id="9ab55-257">이 <see cref="T:System.IO.Log.LogStore" /> 인스턴스에서 유효한 레코드에 해당하는 가장 작은 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-257">The lowest sequence number that corresponds to a valid record in this <see cref="T:System.IO.Log.LogStore" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-258">유효한 시퀀스 번호는 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-258">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-259">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-259">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9ab55-260">백업을 만드는 데 필요한 로그 저장소 상태의 스냅숏을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-260">Takes a snapshot of the log store state necessary to make a backup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9ab55-261">백업을 만들기 위해 로그 저장소 상태의 스냅숏을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-261">Takes a snapshot of the log store state for making a backup.</span></span></summary>
        <returns><span data-ttu-id="9ab55-262">아카이브를 만드는 데 필요한 상태를 포함하는 <see cref="T:System.IO.Log.LogArchiveSnapshot" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-262">A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9ab55-263">다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-263">The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.</span></span>  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9ab55-264">로그 저장소를 보관할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-264">The log store is not archivable.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-265">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-265">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-266">아카이브 스냅숏을 만들 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-266">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-267">인수가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-267">An argument is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9ab55-268">잘못된 작업을 실행한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-268">An invalid operation has been executed.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-269">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-269">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="9ab55-270">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-270">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-271">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-271">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first"><span data-ttu-id="9ab55-272">보관할 범위의 시작 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-272">The starting sequence number in the range to archive.</span></span></param>
        <param name="last"><span data-ttu-id="9ab55-273">보관할 범위의 종료 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-273">The ending sequence number in the range to archive.</span></span></param>
        <summary><span data-ttu-id="9ab55-274">백업을 만들기 위해 지정된 시퀀스 번호 간의 로그 저장소 상태에 대한 스냅숏을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-274">Takes a snapshot of the log store state between the specified sequence numbers for making a backup.</span></span></summary>
        <returns><span data-ttu-id="9ab55-275">아카이브를 만드는 데 필요한 상태를 포함하는 <see cref="T:System.IO.Log.LogArchiveSnapshot" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-275">A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-276">이 메서드에서 반환된 아카이브 스냅숏은 기준 시퀀스 번호나 아카이브 시퀀스 번호 중 작은 번호부터 마지막 시퀀스 번호 사이의 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-276">The archive snapshot returned from this method encompasses information from either the base sequence number or the archive sequence number, whichever is lower, to the last sequence number.</span></span> <span data-ttu-id="9ab55-277">여기에서 마지막 시퀀스 번호는 포함되지 않습니다. 즉, 마지막 시퀀스 번호를 제외하고 그 이전 번호까지의 레코드만 아카이브에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-277">It is not inclusive for the last sequence number, which means that the archive only includes records up to but not including last.</span></span> <span data-ttu-id="9ab55-278">또한 이 메서드를 사용할 때 아카이브가 일관성을 유지하려면 시작 SequenceNumber가 BaseSequenceNumber와 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-278">In addition, when using this method, the start SequenceNumber must be equal to the BaseSequenceNumber in order for the archive to be consistent.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9ab55-279"><paramref name="first" /> 또는 <paramref name="last" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-279"><paramref name="first" /> or <paramref name="last" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-280"><paramref name="first" />가 <paramref name="last" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-280"><paramref name="first" /> is larger than <paramref name="last" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9ab55-281">잘못된 작업을 실행한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-281">An invalid operation has been executed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-282">아카이브 스냅숏을 만들 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-282">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9ab55-283">로그 저장소를 보관할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-283">The log store is not archivable.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-284">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-284">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-285">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-285">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="9ab55-286">레코드 시퀀스가 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-286">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-287">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-287">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9ab55-288">제거할 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-288">A relative or absolute path for the base file of the log store to remove.</span></span></param>
        <summary><span data-ttu-id="9ab55-289">로그 저장소를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-289">Removes the log store.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9ab55-290"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-290"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-291"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-291"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="9ab55-292">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-292">-or-</span></span> 
 <span data-ttu-id="9ab55-293"><paramref name="path" />에 공백만 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-293"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="9ab55-294">또는</span><span class="sxs-lookup"><span data-stu-id="9ab55-294">-or-</span></span> 
 <span data-ttu-id="9ab55-295"><paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-295"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9ab55-296">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-296">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-297">로그 저장소를 열 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-297">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-298">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-298">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9ab55-299"><see cref="T:System.IO.Log.LogStore" />에서 사용하는 모든 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-299">Releases all resources used by the <see cref="T:System.IO.Log.LogStore" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-300"><xref:System.IO.Log.LogStore.Dispose%2A>를 사용한 후에 <xref:System.IO.Log.LogStore>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-300">Call <xref:System.IO.Log.LogStore.Dispose%2A> when you have finished using the <xref:System.IO.Log.LogStore>.</span></span> <span data-ttu-id="9ab55-301"><xref:System.IO.Log.LogStore.Dispose%2A> 메서드를 사용하면 <xref:System.IO.Log.LogStore>를 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-301">The <xref:System.IO.Log.LogStore.Dispose%2A> method leaves the <xref:System.IO.Log.LogStore> in an unusable state.</span></span> <span data-ttu-id="9ab55-302"><xref:System.IO.Log.LogStore.Dispose%2A>를 호출한 후에 가비지 수집기가 <xref:System.IO.Log.LogStore>에서 차지한 메모리를 회수할 수 있도록 <xref:System.IO.Log.LogStore>에 대한 모든 참조를 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-302">After calling <xref:System.IO.Log.LogStore.Dispose%2A> , you must release all references to the <xref:System.IO.Log.LogStore> so the garbage collector can reclaim the memory that the <xref:System.IO.Log.LogStore> was occupying.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ab55-303"><xref:System.IO.Log.LogStore.Dispose%2A>에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.IO.Log.LogStore>를 호출하십시오.</span><span class="sxs-lookup"><span data-stu-id="9ab55-303">Always call <xref:System.IO.Log.LogStore.Dispose%2A> before you release your last reference to the <xref:System.IO.Log.LogStore>.</span></span> <span data-ttu-id="9ab55-304">이렇게 하지 않으면 가비지 수집기가 <xref:System.IO.Log.LogStore> 개체의 `Finalize` 메서드를 호출할 때까지 사용 중인 리소스가 해제되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-304">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.IO.Log.LogStore> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-305">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-305">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-306">이 로그 저장소에 대한 데이터를 포함하는 로그 범위의 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-306">Gets the collection of log extents that contain the data for this log store.</span></span></summary>
        <value><span data-ttu-id="9ab55-307">이 로그 저장소에 대한 데이터를 캡슐화하는 로그 범위의 컬렉션을 포함하는 <see cref="T:System.IO.Log.LogExtentCollection" /> 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-307">A <see cref="T:System.IO.Log.LogExtentCollection" /> instance containing the collection of log extents that encapsulates data for this log store.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-308"><xref:System.IO.Log.LogStore> 인스턴스는 <xref:System.IO.Log.LogExtent> 인스턴스가 나타내는 디스크 범위의 컬렉션에 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-308">A <xref:System.IO.Log.LogStore> instance stores its data in a collection of disk extents, represented by <xref:System.IO.Log.LogExtent> instances.</span></span> <span data-ttu-id="9ab55-309">지정된 <xref:System.IO.Log.LogStore> 인스턴스의 범위는 크기가 모두 동일하며 범위가 증가하면 <xref:System.IO.Log.LogStore> 인스턴스에서 공간이 추가되고 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-309">The extents in a given <xref:System.IO.Log.LogStore> instance are all of uniform size, and space is added to and removed from a <xref:System.IO.Log.LogStore> instance in extent increments.</span></span> <span data-ttu-id="9ab55-310">로그 범위를 추가하고 제거하려면 이 속성에서 반환하는 <xref:System.IO.Log.LogExtentCollection.Add%2A> 개체의 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 및 <xref:System.IO.Log.LogExtentCollection> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-310">To add and remove log extents, use the <xref:System.IO.Log.LogExtentCollection.Add%2A> and <xref:System.IO.Log.LogExtentCollection.Remove%2A> methods of the <xref:System.IO.Log.LogExtentCollection> object, which is returned by this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-311">로그 저장소에서 사용 가능한 바이트의 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-311">Gets the number of bytes available in the log store.</span></span></summary>
        <value><span data-ttu-id="9ab55-312">로그 저장소에서 사용 가능한 바이트의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-312">The number of bytes available in the log store.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-313">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-313">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-314">현재 <see cref="T:System.IO.Log.LogStore" /> 인스턴스가 캡슐화하는 로그 파일에 대한 운영 체제 파일 핸들을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-314">Gets the operating system file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> instance encapsulates.</span></span></summary>
        <value><span data-ttu-id="9ab55-315">현재 <see cref="T:System.IO.Log.LogStore" /> 인스턴스가 캡슐화하는 로그 파일에 대한 운영 체제 파일 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-315">The operating system file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> instance encapsulates.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-316">파생 클래스에서 재정의되는 경우 로그 저장소에 추가할 다음 레코드의 시퀀스 번호를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-316">When overridden in a derived class, gets the sequence number of the next record to be appended to the log store.</span></span></summary>
        <value><span data-ttu-id="9ab55-317">로그 저장소에 추가할 다음 레코드의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-317">The sequence number of the next record to be appended to the log store.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-318">유효한 시퀀스 번호는 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-318">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-319">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-319">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-320">로그 저장소의 크기(바이트)를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-320">Gets the size of the log store, in bytes.</span></span></summary>
        <value><span data-ttu-id="9ab55-321">로그 저장소의 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-321">The size of the log store, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-322">로그 저장소의 크기는 로그 범위의 크기를 합한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-322">The size of the log store is the sum of the sizes of the log extents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-323">시퀀스가 삭제된 후 속성에 액세스한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-323">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-324">이 로그 저장소와 연결된 정책을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-324">Gets the policy associated with this log store.</span></span></summary>
        <value><span data-ttu-id="9ab55-325">이 로그 저장소와 연결된 정책을 나타내는 <see cref="T:System.IO.Log.LogPolicy" /> 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-325">A <see cref="T:System.IO.Log.LogPolicy" /> instance representing the policy associated with this log store.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-326">이 속성에서 반환하는 <xref:System.IO.Log.LogPolicy> 인스턴스를 사용하여 이 <xref:System.IO.Log.LogStore>와 연결된 로그 정책을 검사하고 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-326">You can use the <xref:System.IO.Log.LogPolicy> instance returned by this property to examine and manipulate the log policy associated with this <xref:System.IO.Log.LogStore>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail"><span data-ttu-id="9ab55-327">아카이브 테일의 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-327">The sequence number of the archive tail.</span></span></param>
        <summary><span data-ttu-id="9ab55-328">아카이브 테일의 시퀀스 번호를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-328">Sets the sequence number of the archive tail.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ab55-329">기준 시퀀스 번호와 아카이브 테일 중 작은 값으로 로그의 테일이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-329">The smaller of the base sequence number and the archive tail determines the tail of the log.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ab55-330">다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-330">The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.</span></span>  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9ab55-331"><paramref name="archiveTail" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-331"><paramref name="archiveTail" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9ab55-332"><paramref name="archiveTail" />이 이 시퀀스에 유효하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-332"><paramref name="archiveTail" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9ab55-333">잘못된 작업을 실행한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-333">An invalid operation has been executed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9ab55-334">아카이브 스냅숏을 만들 때 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-334">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9ab55-335">로그 저장소를 보관할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-335">The log store is not archivable.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9ab55-336">시퀀스가 삭제된 후 메서드가 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-336">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="9ab55-337">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-337">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9ab55-338">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</span><span class="sxs-lookup"><span data-stu-id="9ab55-338">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9ab55-339">이 로그 저장소의 로그 스트림 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-339">Gets the number of log streams in this log store.</span></span></summary>
        <value><span data-ttu-id="9ab55-340">이 로그 저장소의 로그 스트림 수입니다.</span><span class="sxs-lookup"><span data-stu-id="9ab55-340">The number of log streams in this log store.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>